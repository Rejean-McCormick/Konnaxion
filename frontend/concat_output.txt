### services/_request.ts
'use client'

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  InternalAxiosRequestConfig,
} from 'axios'

const apiRequest: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE || '/api',
  withCredentials: true,
  xsrfCookieName: 'csrftoken',
  xsrfHeaderName: 'X-CSRFToken',
  timeout: 15000,
})

apiRequest.interceptors.request.use((cfg: InternalAxiosRequestConfig) => {
  // Exemple d’auth:
  // const t = typeof window !== 'undefined' ? localStorage.getItem('token') : null
  // if (t) cfg.headers.Authorization = `Bearer ${t}`
  return cfg
})

apiRequest.interceptors.response.use(
  (res) => (res.data ?? res),
  (err) => Promise.reject(err),
)

type Cfg = AxiosRequestConfig

export async function get<T>(url: string, config?: Cfg): Promise<T> {
  // l’intercepteur renvoie déjà le payload
  return apiRequest.get<T>(url, config) as unknown as Promise<T>
}

export async function post<T>(url: string, body?: any, config?: Cfg): Promise<T> {
  return apiRequest.post<T>(url, body, config) as unknown as Promise<T>
}

export async function put<T>(url: string, body?: any, config?: Cfg): Promise<T> {
  return apiRequest.put<T>(url, body, config) as unknown as Promise<T>
}

export async function patch<T>(url: string, body?: any, config?: Cfg): Promise<T> {
  return apiRequest.patch<T>(url, body, config) as unknown as Promise<T>
}

export async function del<T>(url: string, config?: Cfg): Promise<T> {
  return apiRequest.delete<T>(url, config) as unknown as Promise<T>
}

export default apiRequest




### services/decide.ts
import { get, post } from './_request'
import type { Ballot } from '@/types'

/** GET /decide/elite/ballots */
export async function fetchEliteBallots(): Promise<{
  ballots: (Ballot & { turnout: number })[]
}> {
  return get('decide/elite/ballots')
}

/** GET /decide/public/ballots */
export async function fetchPublicBallots(): Promise<{
  ballots: (Ballot & { options: string[]; turnout: number })[]
}> {
  return get('decide/public/ballots')
}

/** POST /decide/public/ballots/:id/vote */
export async function submitPublicVote(
  id: string,
  option: string,
): Promise<{ ok: true }> {
  return post(`decide/public/ballots/${id}/vote`, { option })
}

/** GET /decide/results */
export async function fetchDecisionResults(): Promise<{
  items: {
    id: string
    title: string
    scope: 'Elite' | 'Public'
    passed: boolean
    closesAt: string
    region: string
  }[]
}> {
  return get('decide/results')
}




### services/deliberate.ts
import { get, post } from './_request'
import type { Topic } from '@/types'

/** GET /deliberate/elite/topics */
export async function fetchEliteTopics(): Promise<{
  list: (Topic & {
    createdAt: string
    lastActivity: string
    hot: boolean
  })[]
}> {
  return get('deliberate/elite/topics')
}

/** GET /deliberate/topics/:id/preview */
export async function fetchTopicPreview(id: string): Promise<{
  id: string
  title: string
  category: string
  createdAt: string
  latest: { id: string; author: string; body: string }[]
}> {
  return get(`deliberate/topics/${id}/preview`)
}

/** POST /deliberate/elite/topics */
export async function createEliteTopic(payload: {
  title: string
  category: string
}): Promise<{ id: string }> {
  return post('deliberate/elite/topics', payload)
}

/** GET /deliberate/topics/:id */
export async function fetchTopicDetail(id: string): Promise<{
  id: string
  title: string
  statements: { id: string; author: string; body: string; createdAt: string }[]
}> {
  return get(`deliberate/topics/${id}`)
}




### services/pulse.ts
import { get } from './_request'
import type { KPI } from '@/types'

export interface KPIWithHistory extends KPI {
  history: { date: string; value: number }[]
}

/** GET /pulse/overview */
export async function fetchPulseOverview(): Promise<{
  refreshedAt: string
  kpis: KPIWithHistory[]
}> {
  return get('pulse/overview')
}

export interface LiveCounter {
  label: string
  value: number
  trend: number
  history: { ts: number; value: number }[]
}

/** GET /pulse/live */
export async function fetchPulseLiveData(): Promise<{
  counters: LiveCounter[]
}> {
  return get('pulse/live')
}

export type TrendChartType = 'line' | 'area' | 'heatmap'

export interface TrendChart {
  title: string
  type: TrendChartType
  config: Record<string, any>
}

/** GET /pulse/trends */
export async function fetchPulseTrends(): Promise<{
  charts: TrendChart[]
}> {
  return get('pulse/trends')
}

export interface HealthResponse {
  radarConfig: Record<string, any>
  pieConfig: Record<string, any>
}

/** GET /pulse/health */
export async function fetchPulseHealth(): Promise<HealthResponse> {
  return get('pulse/health')
}




### services/audit.ts
import { get } from './_request'

export interface LogRow {
  id: string
  ts: string                  // ISO timestamp
  actor: string               // utilisateur / service
  action: string              // ex: "UPDATE_TOPIC"
  entity?: string             // ex: "topic"
  entityId?: string
  ip?: string
  status?: 'ok' | 'warn' | 'error'
  meta?: Record<string, any>  // détails JSON
}

export interface AuditPayload {
  items: LogRow[]
  page: number
  pageSize: number
  total: number
}

/** GET /admin/audit/logs */
export async function fetchAuditLogs(params?: {
  page?: number
  pageSize?: number
  q?: string
  sort?: string
}): Promise<AuditPayload> {
  return get('admin/audit/logs', { params })
}




### services/index.ts
// services/index.ts
export * from './audit'
export * from './decide'
export * from './deliberate'
export * from './pulse'




### src/types/index.ts
// Alias: "@/types"
export type ID = string

export interface Ballot {
  id: ID
  title: string
  closesAt: string       // ISO
  scope?: 'Elite' | 'Public'
  region?: string
  options?: string[]     // pour Public
  turnout?: number
}

export interface Topic {
  id: ID
  title: string
  category: string
  createdAt?: string
  lastActivity?: string
  hot?: boolean
}

export interface KPI {
  key: string
  label: string
  value: number
  delta?: number
}




### components/compat/Icon.tsx
// components/compat/Icon.tsx
import React from 'react'
import {
  DeleteOutlined,
  EditOutlined,
  LikeOutlined,
  MessageOutlined,
  LoadingOutlined,
  PlusOutlined,
  InfoCircleOutlined,
  WarningOutlined,
  ArrowRightOutlined,
  ArrowLeftOutlined,
} from '@ant-design/icons'

const MAP: Record<string, React.ComponentType<any>> = {
  delete: DeleteOutlined,
  edit: EditOutlined,
  like: LikeOutlined,
  message: MessageOutlined,
  loading: LoadingOutlined,
  plus: PlusOutlined,
  'info-circle': InfoCircleOutlined,
  warning: WarningOutlined,
  'arrow-right': ArrowRightOutlined,
  'arrow-left': ArrowLeftOutlined,
}

type Props = { type: string } & React.HTMLAttributes<HTMLSpanElement>

export default function Icon({ type, ...rest }: Props) {
  const C = MAP[type] ?? InfoCircleOutlined
  return <C {...rest} />
}




### components/compat/Comment.tsx
// components/compat/Comment.tsx
import React from 'react'
import { Avatar, List, Typography } from 'antd'

type Props = {
  author?: React.ReactNode
  avatar?: React.ReactNode
  content?: React.ReactNode
  datetime?: React.ReactNode
  className?: string
  actions?: React.ReactNode[]
}

export default function Comment({ author, avatar, content, datetime, className, actions }: Props) {
  return (
    <List.Item className={className} actions={actions}>
      <List.Item.Meta
        avatar={avatar}
        title={
          <div style={{ display: 'flex', justifyContent: 'space-between' }}>
            <span>{author}</span>
            {datetime ? <Typography.Text type="secondary">{datetime}</Typography.Text> : null}
          </div>
        }
        description={content}
      />
    </List.Item>
  )
}




### components/Loading.tsx
// components/Loading.tsx
import { Spin } from 'antd'
export default function Loading() {
  return (
    <div style={{ padding: 24, textAlign: 'center' }}>
      <Spin />
    </div>
  )
}




### context/ThemeContext.tsx
// File: /context/ThemeContext.tsx
'use client'

import React, {
  createContext,
  useContext,
  useState,
  useLayoutEffect,
  useEffect,
  ReactNode,
} from 'react'
import { ConfigProvider, theme as antdTheme } from 'antd'
import themes, { ThemeType, themeKeys } from '@/theme'

type TokenBag = (typeof themes)[ThemeType]
// clés perso que vous exposez sur <html> (optionnel)
const cssVars = ['bgMain', 'bgLight', 'bgDark', 'textMain', 'accent'] as const

interface ThemeContextProps {
  token: TokenBag
  themeType: ThemeType
  setThemeType: (t: ThemeType) => void
  cycleTheme: () => void
}

const ThemeContext = createContext<ThemeContextProps | null>(null)
export const useTheme = () => {
  const ctx = useContext(ThemeContext)
  if (!ctx) throw new Error('useTheme must be used inside ThemeProvider')
  return ctx
}

export const ThemeProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [themeType, setThemeType] = useState<ThemeType>('funkyTheme')
  const defaultSeed = antdTheme.defaultSeed

  // Restore from localStorage
  useLayoutEffect(() => {
    if (typeof window === 'undefined') return
    const saved = localStorage.getItem('themeType') as ThemeType | null
    if (saved && themeKeys.includes(saved)) {
      setThemeType(saved)
    }
  }, [])

  // Raw theme or empty
  const raw: Partial<TokenBag> = themes[themeType] ?? {}

  // Expose custom CSS vars on <html>
  useLayoutEffect(() => {
    if (typeof window === 'undefined') return
    const html = document.documentElement
    themeKeys.forEach(k => html.classList.remove(k))
    html.classList.add(themeType)
    cssVars.forEach(key => {
      const name = `--${key.replace(/[A-Z]/g, m => '-' + m.toLowerCase())}`
      html.style.setProperty(name, String((raw as any)[key]))
    })
  }, [themeType, raw])

  // Persist choice
  useEffect(() => {
    if (typeof window !== 'undefined') localStorage.setItem('themeType', themeType)
  }, [themeType])

  // Cycle themes
  const cycleTheme = () => {
    const idx = themeKeys.indexOf(themeType)
    setThemeType(themeKeys[(idx + 1) % themeKeys.length])
  }

  // Merge with fallback on defaultSeed
  const mergedToken = {
    ...defaultSeed,
    ...(raw as any),

    // ** TEXT **
    colorText            : raw.colorText            ?? defaultSeed.colorText,
    colorTextBase        : raw.colorTextBase        ?? defaultSeed.colorTextBase,
    colorTextSecondary   : raw.colorTextSecondary   ?? defaultSeed.colorTextSecondary,
    colorTextTertiary    : raw.colorTextTertiary    ?? defaultSeed.colorTextTertiary,
    colorTextPlaceholder : raw.colorTextPlaceholder ?? defaultSeed.colorTextPlaceholder,
    colorTextDisabled    : raw.colorTextDisabled    ?? defaultSeed.colorTextDisabled,

    // Form labels
    colorTextLabel       : (raw as any).colorTextLabel    ?? defaultSeed.colorTextLabel,
    colorTextStrong      : (raw as any).colorTextStrong   ?? defaultSeed.colorTextStrong,

    // Seed overrides
    colorPrimary         : raw.colorPrimary         ?? defaultSeed.colorPrimary,
    colorLink            : raw.accent               ?? defaultSeed.colorLink,
    colorLinkHover       : raw.accent               ?? defaultSeed.colorLinkHover,

    // Layout & containers
    colorBgLayout        : raw.colorBgLayout        ?? defaultSeed.colorBgLayout,
    colorBgContainer     : raw.colorBgContainer     ?? defaultSeed.colorBgContainer,

    // Elevated surfaces
    colorBgElevated      : raw.colorBgElevated      ?? defaultSeed.colorBgElevated,
    colorBgMask          : raw.colorBgMask          ?? defaultSeed.colorBgMask,
    colorBgSpotlight     : raw.colorBgSpotlight     ?? defaultSeed.colorBgSpotlight,

    // Solid buttons
    colorBgSolid         : raw.colorBgSolid         ?? defaultSeed.colorBgSolid,
    colorBgSolidHover    : raw.colorBgSolidHover    ?? defaultSeed.colorBgSolidHover,

    // Menu & sidebar
    colorMenuItemHoverBg    : (raw as any).menuItemHoverBg    ?? defaultSeed.colorMenuItemHoverBg,
    colorMenuItemSelectedBg : (raw as any).menuItemSelectedBg ?? defaultSeed.colorMenuItemSelectedBg,
    colorMenuItemText       : (raw as any).menuItemTextColor  ?? defaultSeed.colorMenuItemText,

    // Dropdown & Popconfirm
    colorBgPopconfirm    : raw.colorBgPopconfirm    ?? defaultSeed.colorBgPopconfirm,

    // Borders & splits
    colorBorder          : raw.colorBorder          ?? defaultSeed.colorBorder,
    colorSplit           : raw.colorSplit           ?? defaultSeed.colorSplit,

    // Shadows
    boxShadow            : raw.boxShadow            ?? defaultSeed.boxShadow,
    boxShadowSecondary   : raw.boxShadowSecondary   ?? defaultSeed.boxShadowSecondary,

    // Typography & spacing
    fontFamily                : raw.fontFamily                ?? defaultSeed.fontFamily,
    fontSize                  : raw.fontSize                  ?? defaultSeed.fontSize,
    fontSizeLG                : raw.fontSizeLG                ?? defaultSeed.fontSizeLG,
    paddingContentHorizontalLG: raw.paddingContentHorizontalLG ?? defaultSeed.paddingContentHorizontalLG,
    paddingContentVerticalLG  : raw.paddingContentVerticalLG   ?? defaultSeed.paddingContentVerticalLG,
  }

  const algorithm = raw.algorithm ?? antdTheme.defaultAlgorithm

  return (
    <ThemeContext.Provider value={{ token: raw as TokenBag, themeType, setThemeType, cycleTheme }}>
      <ConfigProvider
        theme={{
          algorithm,
          cssVar: true,     // ← utilise le préfixe `--ant-*`
          hashed: false,
          token: mergedToken,
          components: {
            Table: {
              // background for table headers
              colorBgHeader: (raw as any).tableHeaderBg ?? mergedToken.colorBgContainer,
              // ensure header text is readable
              colorText:     mergedToken.colorTextBase,
            },
          },
        }}
      >
        {children}
      </ConfigProvider>
    </ThemeContext.Provider>
  )
}



