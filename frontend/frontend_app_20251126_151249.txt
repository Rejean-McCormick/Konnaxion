===== TOC (101 fichiers) =====
1. C:\MyCode\Konnaxionv14\frontend\app\_api\admin\moderation\route.ts
2. C:\MyCode\Konnaxionv14\frontend\app\_api\admin\stats\route.ts
3. C:\MyCode\Konnaxionv14\frontend\app\_api\health\route.ts
4. C:\MyCode\Konnaxionv14\frontend\app\_api\search\route.ts
5. C:\MyCode\Konnaxionv14\frontend\app\DOCHowtonest\keenkonnect.txt
6. C:\MyCode\Konnaxionv14\frontend\app\ekoh\achievements-badges\earned-badges-display\page.tsx
7. C:\MyCode\Konnaxionv14\frontend\app\ekoh\dashboard\page.tsx
8. C:\MyCode\Konnaxionv14\frontend\app\ekoh\EkohPageShell.tsx
9. C:\MyCode\Konnaxionv14\frontend\app\ekoh\expertise-areas\view-current-expertise\page.tsx
10. C:\MyCode\Konnaxionv14\frontend\app\ekoh\layout.tsx
11. C:\MyCode\Konnaxionv14\frontend\app\ekoh\overview-analytics\current-ekoh-score\page.tsx
12. C:\MyCode\Konnaxionv14\frontend\app\ekoh\voting-influence\current-voting-weight\page.tsx
13. C:\MyCode\Konnaxionv14\frontend\app\ethikos\admin\audit\page.tsx
14. C:\MyCode\Konnaxionv14\frontend\app\ethikos\admin\moderation\page.tsx
15. C:\MyCode\Konnaxionv14\frontend\app\ethikos\admin\roles\page.tsx
16. C:\MyCode\Konnaxionv14\frontend\app\ethikos\decide\elite\page.tsx
17. C:\MyCode\Konnaxionv14\frontend\app\ethikos\decide\methodology\page.tsx
18. C:\MyCode\Konnaxionv14\frontend\app\ethikos\decide\public\page.tsx
19. C:\MyCode\Konnaxionv14\frontend\app\ethikos\decide\results\page.tsx
20. C:\MyCode\Konnaxionv14\frontend\app\ethikos\deliberate\[topic]\page.tsx
21. C:\MyCode\Konnaxionv14\frontend\app\ethikos\deliberate\elite\page.tsx
22. C:\MyCode\Konnaxionv14\frontend\app\ethikos\deliberate\guidelines\page.tsx
23. C:\MyCode\Konnaxionv14\frontend\app\ethikos\EthikosPageShell.tsx
24. C:\MyCode\Konnaxionv14\frontend\app\ethikos\impact\feedback\page.tsx
25. C:\MyCode\Konnaxionv14\frontend\app\ethikos\impact\outcomes\page.tsx
26. C:\MyCode\Konnaxionv14\frontend\app\ethikos\impact\tracker\page.tsx
27. C:\MyCode\Konnaxionv14\frontend\app\ethikos\insights\page.tsx
28. C:\MyCode\Konnaxionv14\frontend\app\ethikos\layout.tsx
29. C:\MyCode\Konnaxionv14\frontend\app\ethikos\learn\changelog\page.tsx
30. C:\MyCode\Konnaxionv14\frontend\app\ethikos\learn\glossary\page.tsx
31. C:\MyCode\Konnaxionv14\frontend\app\ethikos\learn\guides\page.tsx
32. C:\MyCode\Konnaxionv14\frontend\app\ethikos\pulse\health\page.tsx
33. C:\MyCode\Konnaxionv14\frontend\app\ethikos\pulse\live\page.tsx
34. C:\MyCode\Konnaxionv14\frontend\app\ethikos\pulse\overview\page.tsx
35. C:\MyCode\Konnaxionv14\frontend\app\ethikos\pulse\trends\page.tsx
36. C:\MyCode\Konnaxionv14\frontend\app\ethikos\trust\badges\page.tsx
37. C:\MyCode\Konnaxionv14\frontend\app\ethikos\trust\credentials\page.tsx
38. C:\MyCode\Konnaxionv14\frontend\app\ethikos\trust\profile\page.tsx
39. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\ai-team-matching\find-teams\page.tsx
40. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\ai-team-matching\match-preferences\page.tsx
41. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\ai-team-matching\my-matches\page.tsx
42. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\dashboard\page.tsx
43. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\KeenPageShell.tsx
44. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\knowledge\browse-repository\page.tsx
45. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\knowledge\document-management\page.tsx
46. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\knowledge\search-filter-documents\page.tsx
47. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\knowledge\upload-new-document\page.tsx
48. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\layout.tsx
49. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\projects\browse-projects\page.tsx
50. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\projects\create-new-project\page.tsx
51. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\projects\my-projects\page.tsx
52. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\projects\project-workspace\page.tsx
53. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\sustainability-impact\submit-impact-reports\page.tsx
54. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\sustainability-impact\sustainability-dashboard\page.tsx
55. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\sustainability-impact\track-project-impact\page.tsx
56. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\user-reputation\account-preferences\page.tsx
57. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\user-reputation\manage-expertise-areas\page.tsx
58. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\user-reputation\view-reputation-ekoh\page.tsx
59. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\workspaces\browse-available-workspaces\page.tsx
60. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\workspaces\launch-new-workspace\page.tsx
61. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\workspaces\my-workspaces\page.tsx
62. C:\MyCode\Konnaxionv14\frontend\app\konnected\certifications\certification-programs\page.tsx
63. C:\MyCode\Konnaxionv14\frontend\app\konnected\certifications\exam-dashboard-results\page.tsx
64. C:\MyCode\Konnaxionv14\frontend\app\konnected\certifications\exam-preparation\page.tsx
65. C:\MyCode\Konnaxionv14\frontend\app\konnected\certifications\exam-registration\page.tsx
66. C:\MyCode\Konnaxionv14\frontend\app\konnected\community-discussions\active-threads\page.tsx
67. C:\MyCode\Konnaxionv14\frontend\app\konnected\community-discussions\moderation\page.tsx
68. C:\MyCode\Konnaxionv14\frontend\app\konnected\community-discussions\start-new-discussion\page.tsx
69. C:\MyCode\Konnaxionv14\frontend\app\konnected\dashboard\page.tsx
70. C:\MyCode\Konnaxionv14\frontend\app\konnected\KonnectedPageShell.tsx
71. C:\MyCode\Konnaxionv14\frontend\app\konnected\layout.tsx
72. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-library\browse-resources\page.tsx
73. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-library\offline-content\page.tsx
74. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-library\recommended-resources\page.tsx
75. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-library\search-filters\page.tsx
76. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-paths\create-learning-path\page.tsx
77. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-paths\manage-existing-paths\page.tsx
78. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-paths\my-learning-path\page.tsx
79. C:\MyCode\Konnaxionv14\frontend\app\konnected\teams-collaboration\activity-planner\page.tsx
80. C:\MyCode\Konnaxionv14\frontend\app\konnected\teams-collaboration\my-teams\page.tsx
81. C:\MyCode\Konnaxionv14\frontend\app\konnected\teams-collaboration\project-workspaces\page.tsx
82. C:\MyCode\Konnaxionv14\frontend\app\konnected\teams-collaboration\team-builder\page.tsx
83. C:\MyCode\Konnaxionv14\frontend\app\konsensus\page.tsx
84. C:\MyCode\Konnaxionv14\frontend\app\kreative\collaborative-spaces\find-spaces\page.tsx
85. C:\MyCode\Konnaxionv14\frontend\app\kreative\collaborative-spaces\my-spaces\page.tsx
86. C:\MyCode\Konnaxionv14\frontend\app\kreative\collaborative-spaces\start-new-space\page.tsx
87. C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\featured-projects\page.tsx
88. C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\submit-to-showcase\page.tsx
89. C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\top-creators\page.tsx
90. C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\explore-ideas\page.tsx
91. C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\inspiration-gallery\page.tsx
92. C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\submit-creative-work\page.tsx
93. C:\MyCode\Konnaxionv14\frontend\app\kreative\dashboard\page.tsx
94. C:\MyCode\Konnaxionv14\frontend\app\kreative\idea-incubator\collaborate-on-ideas\page.tsx
95. C:\MyCode\Konnaxionv14\frontend\app\kreative\idea-incubator\create-new-idea\page.tsx
96. C:\MyCode\Konnaxionv14\frontend\app\kreative\idea-incubator\my-ideas\page.tsx
97. C:\MyCode\Konnaxionv14\frontend\app\kreative\kreativePageShell.tsx
98. C:\MyCode\Konnaxionv14\frontend\app\kreative\layout.tsx
99. C:\MyCode\Konnaxionv14\frontend\app\layout.tsx
100. C:\MyCode\Konnaxionv14\frontend\app\page.tsx
101. C:\MyCode\Konnaxionv14\frontend\app\providers\AuthProvider.tsx
===== END TOC =====


===== BEGIN app/_api/admin/moderation/route.ts =====
import { NextResponse } from 'next/server'

type ReportType = 'Spam' | 'Harassment' | 'Misinformation'
type ReportStatus = 'Pending' | 'Resolved'

export interface Report {
  id: string
  content: string
  reporter: string
  type: ReportType
  status: ReportStatus
}

export interface ModerationPayload {
  items: Report[]
}

/**
 * Resolve the backend base URL in the same spirit as services/_request.ts.
 * In practice, NEXT_PUBLIC_API_BASE should be something like
 *   http://localhost:8000/api
 * or the public API root for your Django backend.
 */
function resolveApiBase(): string {
  const raw = process.env.NEXT_PUBLIC_API_BASE || 'http://localhost:8000'
  // Normalize to avoid trailing slash issues when concatenating paths
  return raw.replace(/\/+$/, '')
}

export async function GET() {
  const apiBase = resolveApiBase()
  const url = `${apiBase}/admin/moderation`

  try {
    const res = await fetch(url, {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
      // Ensure we always hit the live queue, not a cached copy
      cache: 'no-store',
    })

    if (res.ok) {
      const raw = await res.json()

      // Normalise shape to ModerationPayload:
      // - if backend already returns { items: [...] }, use it as‚Äëis
      // - if backend returns a bare array, wrap it
      let payload: ModerationPayload

      if (Array.isArray(raw)) {
        payload = { items: raw as Report[] }
      } else if (Array.isArray((raw as any)?.items)) {
        payload = { items: (raw as any).items as Report[] }
      } else {
        payload = { items: [] }
      }

      return NextResponse.json<ModerationPayload>(payload, {
        status: 200,
        headers: { 'Cache-Control': 'no-store' },
      })
    }

    // Backend responded but with an error status
    return NextResponse.json(
      {
        error: 'Failed to fetch moderation queue from backend.',
        statusCode: res.status,
      },
      {
        status: res.status,
        headers: { 'Cache-Control': 'no-store' },
      },
    )
  } catch (error) {
    // Fallback: deterministic stub, matching ModerationPayload
    const fallback: ModerationPayload = {
      items: [
        {
          id: 'stub-1',
          content: 'Example content flagged for potential harassment.',
          reporter: 'alice@example.com',
          type: 'Harassment',
          status: 'Pending',
        },
        {
          id: 'stub-2',
          content: 'Example spam message that has already been resolved.',
          reporter: 'moderation-bot',
          type: 'Spam',
          status: 'Resolved',
        },
      ],
    }

    return NextResponse.json<ModerationPayload>(fallback, {
      status: 200,
      headers: {
        'Cache-Control': 'no-store',
        'X-Konnaxion-Moderation-Mode': 'mock',
      },
    })
  }
}

===== END app/_api/admin/moderation/route.ts =====


===== BEGIN app/_api/admin/stats/route.ts =====
import { NextResponse } from 'next/server';

interface AdminStats {
  totalUsers: number;
  activeUsers: number;
  newUsers: number;
}

interface UsageReport {
  labels: string[];
  mau: number[];
  projects?: number[];
  docs?: number[];
}

const FALLBACK_STATS: AdminStats = {
  totalUsers: 1234,
  activeUsers: 567,
  newUsers: 89,
};

// Same default window as the Insights "Usage" report.
const USAGE_QUERY = '?range=30d&grouping=day';

// Base URL for the backend (matches how the rest of the app calls it)
const API_BASE =
  process.env.NEXT_PUBLIC_API_BASE ?? 'http://localhost:8000';

/**
 * Build the absolute URL for the usage report on the analytics backend.
 * This mirrors how the insights hooks call `/reports/usage`.
 */
function buildUsageUrl(): string {
  const base = API_BASE.endsWith('/') ? API_BASE.slice(0, -1) : API_BASE;
  return `${base}/reports/usage${USAGE_QUERY}`;
}

/**
 * Fetches the usage report from the analytics backend.
 * If anything goes wrong, returns null so the caller can fall back
 * to static placeholder values.
 */
async function fetchUsageReport(): Promise<UsageReport | null> {
  try {
    const url = buildUsageUrl();

    const res = await fetch(url, {
      headers: { Accept: 'application/json' },
      // This is an admin dashboard metric; we want fresh data.
      cache: 'no-store',
    });

    if (!res.ok) {
      return null;
    }

    const data = (await res.json()) as UsageReport;

    if (!data || !Array.isArray(data.mau)) {
      return null;
    }

    return data;
  } catch {
    return null;
  }
}

/**
 * Derives simple admin-friendly stats from the usage report:
 * - totalUsers  = max MAU over the window (rough upper bound)
 * - activeUsers = last MAU point
 * - newUsers    = positive delta between last and previous MAU point
 */
function deriveAdminStats(report: UsageReport): AdminStats {
  const series = Array.isArray(report.mau) ? report.mau : [];

  if (series.length === 0) {
    // If the report is empty, keep the previous placeholder behavior.
    return { ...FALLBACK_STATS };
  }

  let totalUsers = 0;
  for (const value of series) {
    if (typeof value === 'number' && Number.isFinite(value)) {
      if (value > totalUsers) {
        totalUsers = value;
      }
    }
  }

  const last = series[series.length - 1];
  const prev = series.length > 1 ? series[series.length - 2] : last;

  const activeUsers =
    typeof last === 'number' && Number.isFinite(last) ? last : 0;

  const prevValue =
    typeof prev === 'number' && Number.isFinite(prev) ? prev : activeUsers;

  const newUsers = Math.max(activeUsers - prevValue, 0);

  return { totalUsers, activeUsers, newUsers };
}

export async function GET() {
  const report = await fetchUsageReport();
  const stats = report ? deriveAdminStats(report) : FALLBACK_STATS;

  return NextResponse.json<AdminStats>(stats, {
    status: 200,
    headers: {
      'Cache-Control': 'no-store',
    },
  });
}

===== END app/_api/admin/stats/route.ts =====


===== BEGIN app/_api/health/route.ts =====
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.json(
    { status: 'ok', timestamp: new Date().toISOString() },
    {
      status: 200,
      headers: { 'Cache-Control': 'no-store' },
    }
  )
}

===== END app/_api/health/route.ts =====


===== BEGIN app/_api/search/route.ts =====
// app/_api/search/route.ts
import { NextRequest, NextResponse } from 'next/server'
import fs from 'fs/promises'
import path from 'path'

export const runtime = 'nodejs'

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface SearchResult {
  id: string
  title: string
  snippet: string
  path: string
}

interface RoutesJsonEntry {
  path: string
}

interface KnowledgeResource {
  id: string | number
  title: string
  description?: string | null
  subject?: string | null
  level?: string | null
  language?: string | null
  url?: string | null
  type?: string | null
  resource_type?: string | null
}

type RawKnowledgeSearchResponse =
  | KnowledgeResource[]
  | {
      results?: KnowledgeResource[]
      items?: KnowledgeResource[]
      count?: number
      total?: number
    }

interface SearchResponseBody {
  results: SearchResult[]
}

// ---------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------

const ROUTES_JSON_PATH = path.join(process.cwd(), 'routes.json')

// Keep this small ‚Äì it‚Äôs just a quick ‚Äújump‚Äù helper in the UI.
const MAX_RESULTS_PER_SECTION = 5
const MIN_QUERY_LENGTH = 2

// Preferred order for the Knowledge / KonnectED search endpoint.
// These mirror the other Knowledge-related pages in the app.
const KNOWLEDGE_SEARCH_ENDPOINTS = [
  '/api/konnected/resources/',
  '/api/knowledge-resources/',
  '/api/knowledge/resources/',
] as const

// Use the same base URL convention as services/_request.ts
const API_BASE = (process.env.NEXT_PUBLIC_API_BASE ?? '').replace(/\/+$/, '')

// ---------------------------------------------------------------------------
// Helpers ‚Äì generic
// ---------------------------------------------------------------------------

function toTitleCase(segment: string): string {
  return segment
    .split('-')
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ')
}

function pathToTitle(p: string): string {
  if (p === '/') return 'Home'
  const segments = p.split('/').filter(Boolean)
  if (!segments.length) return 'Home'
  return segments.map(toTitleCase).join(' ¬∑ ')
}

function buildBackendUrl(endpoint: string): string {
  const trimmed = endpoint.trim()
  if (/^https?:\/\//i.test(trimmed)) return trimmed
  if (!API_BASE) return trimmed
  if (trimmed.startsWith('/')) return `${API_BASE}${trimmed}`
  return `${API_BASE}/${trimmed}`
}

function normalizeKnowledgeResults(raw: RawKnowledgeSearchResponse | null | undefined): KnowledgeResource[] {
  if (!raw) return []

  if (Array.isArray(raw)) {
    return raw
  }

  const obj = raw as { results?: unknown; items?: unknown }
  if (Array.isArray(obj.results)) return obj.results as KnowledgeResource[]
  if (Array.isArray(obj.items)) return obj.items as KnowledgeResource[]
  return []
}

function buildKnowledgeSnippet(resource: KnowledgeResource): string {
  const parts: string[] = []

  if (resource.subject) parts.push(resource.subject)
  if (resource.level) parts.push(resource.level)
  if (resource.language) parts.push(resource.language)

  if (parts.length > 0) {
    return parts.join(' ¬∑ ')
  }

  const desc =
    typeof resource.description === 'string'
      ? resource.description.replace(/\s+/g, ' ').trim()
      : ''

  if (desc) {
    return desc.length > 120 ? `${desc.slice(0, 117)}‚Ä¶` : desc
  }

  return 'Learning resource'
}

// ---------------------------------------------------------------------------
// Routes.json search (navigation hints)
// ---------------------------------------------------------------------------

async function loadRoutes(): Promise<RoutesJsonEntry[]> {
  try {
    const content = await fs.readFile(ROUTES_JSON_PATH, 'utf8')
    const urls = JSON.parse(content) as string[]
    return urls.map((p) => ({ path: p }))
  } catch {
    // If routes.json is missing or invalid we simply return no route results.
    return []
  }
}

async function searchRoutes(q: string): Promise<SearchResult[]> {
  const routes = await loadRoutes()
  if (!routes.length) return []

  const needle = q.toLowerCase()
  type Scored = { entry: RoutesJsonEntry; score: number }

  const scored: Scored[] = []

  for (const entry of routes) {
    const p = entry.path
    if (!p) continue

    const title = pathToTitle(p)
    const haystack = `${p.toLowerCase()} ${title.toLowerCase()}`
    const idx = haystack.indexOf(needle)
    if (idx === -1) continue

    // Simple scoring:
    // - match at beginning is better
    // - shorter paths win for ties
    const score = (idx === 0 ? 2 : 1) + 1 / (p.length + 1)
    scored.push({ entry, score })
  }

  scored.sort((a, b) => b.score - a.score)

  return scored.slice(0, MAX_RESULTS_PER_SECTION).map(({ entry }) => {
    const p = entry.path
    const title = pathToTitle(p)

    return {
      id: `route:${p}`,
      title,
      snippet: `Navigate to ${p}`,
      path: p,
    }
  })
}

// ---------------------------------------------------------------------------
// Knowledge search (KonnectED / learning resources)
// ---------------------------------------------------------------------------

async function searchKnowledge(q: string, request: NextRequest): Promise<SearchResult[]> {
  const trimmed = q.trim()
  if (!trimmed) return []

  const params = new URLSearchParams()
  params.set('q', trimmed)
  // Keep it small ‚Äì this is just one section of global search.
  params.set('page', '1')
  params.set('page_size', String(MAX_RESULTS_PER_SECTION))

  const headers: Record<string, string> = {
    Accept: 'application/json',
  }

  const auth = request.headers.get('authorization')
  if (auth) headers['Authorization'] = auth

  const cookie = request.headers.get('cookie')
  if (cookie) headers['Cookie'] = cookie

  for (const endpoint of KNOWLEDGE_SEARCH_ENDPOINTS) {
    const baseUrl = buildBackendUrl(endpoint)
    const url = `${baseUrl}${baseUrl.includes('?') ? '&' : '?'}${params.toString()}`

    try {
      const res = await fetch(url, {
        method: 'GET',
        headers,
      })

      if (!res.ok) {
        // Try the next candidate for 404/405; ignore others silently.
        if (res.status === 404 || res.status === 405) {
          continue
        }
        continue
      }

      const raw = (await res.json()) as RawKnowledgeSearchResponse
      const resources = normalizeKnowledgeResults(raw)
      if (!resources.length) return []

      return resources.slice(0, MAX_RESULTS_PER_SECTION).map((r) => ({
        id: `knowledge:${String(r.id)}`,
        title: r.title,
        snippet: buildKnowledgeSnippet(r),
        path:
          r.url && typeof r.url === 'string'
            ? r.url
            : `/konnected/learning-library/browse-resources?resource=${encodeURIComponent(
                String(r.id),
              )}`,
      }))
    } catch {
      // Move on to the next endpoint.
      continue
    }
  }

  return []
}

// ---------------------------------------------------------------------------
// Route handler
// ---------------------------------------------------------------------------

export async function GET(request: NextRequest) {
  const q = request.nextUrl.searchParams.get('q')?.trim() ?? ''

  if (!q) {
    return NextResponse.json(
      { error: 'Missing query parameter `q`' },
      {
        status: 400,
        headers: { 'Cache-Control': 'no-store' },
      },
    )
  }

  if (q.length < MIN_QUERY_LENGTH) {
    // Too short ‚Äì avoid hammering the backend for single-character queries.
    const body: SearchResponseBody = { results: [] }
    return NextResponse.json(body, {
      status: 200,
      headers: { 'Cache-Control': 'no-store' },
    })
  }

  try {
    const [routeResults, knowledgeResults] = await Promise.all([
      searchRoutes(q),
      searchKnowledge(q, request),
    ])

    const results: SearchResult[] = [...routeResults, ...knowledgeResults]

    const body: SearchResponseBody = { results }

    return NextResponse.json(body, {
      status: 200,
      headers: { 'Cache-Control': 'no-store' },
    })
  } catch (err) {
    // In case of any unexpected failure, return a safe, empty payload.
    const body: SearchResponseBody = { results: [] }

    return NextResponse.json(body, {
      status: 500,
      headers: { 'Cache-Control': 'no-store' },
    })
  }
}

===== END app/_api/search/route.ts =====


===== BEGIN app/DOCHowtonest/keenkonnect.txt =====
Voici un mod√®le central que tu peux r√©utiliser comme **r√©f√©rence de layout KeenKonnect** et donner tel quel √† une autre IA quand tu lui demandes de refactor des pages.

Je vais d‚Äôabord te donner **le composant central**, puis **la structure de page de r√©f√©rence**, puis **les r√®gles pour corriger les autres pages**.

---

## 1. Composant central : `<KeenPage>` (√† cr√©er une fois)

> Objectif : toutes les pages KeenKonnect passent par ce wrapper, pour aligner :
>
> * largeur
> * padding
> * taille du titre
> * zone de description
> * toolbar √† droite
> * pas de breadcrumb local (on laisse le layout global le g√©rer)

**Fichier sugg√©r√©** : `components/keenkonnect/KeenPage.tsx`

```tsx
'use client';

import React from 'react';
import Head from 'next/head';
import usePageTitle from '@/hooks/usePageTitle';

type KeenPageProps = {
  /** Gros titre de la page, affich√© en <h1> */
  title: string;

  /** Sous-titre / description sous le titre */
  description?: string;

  /** Titre <title> du navigateur. Si non fourni, on g√©n√®re "KeenKonnect ¬∑ {title}" */
  metaTitle?: string;

  /** Contenu principal de la page */
  children: React.ReactNode;

  /**
   * √âl√©ment(s) √† droite du titre (boutons d‚Äôaction, filtres, etc.)
   * ex: <Button type="primary">New</Button>
   */
  toolbar?: React.ReactNode;

  /** Largeur max de la zone centrale */
  maxWidth?: number | string;
};

export default function KeenPage({
  title,
  description,
  metaTitle,
  children,
  toolbar,
  maxWidth = 1200,
}: KeenPageProps) {
  const finalMetaTitle = metaTitle ?? `KeenKonnect ¬∑ ${title}`;

  // Synchronise le titre de l‚Äôonglet (hook existant dans ton codebase)
  usePageTitle(finalMetaTitle);

  return (
    <>
      <Head>
        <title>{finalMetaTitle}</title>
      </Head>

      <div className="container mx-auto p-5" style={{ maxWidth }}>
        {/* Header de page standardis√© */}
        <div className="mb-4 flex flex-wrap items-center justify-between gap-3">
          <div>
            <h1 className="text-2xl font-bold">{title}</h1>
            {description && (
              <p className="mt-1 text-gray-500">{description}</p>
            )}
          </div>

          {toolbar && <div className="flex items-center gap-2">{toolbar}</div>}
        </div>

        {/* Contenu sp√©cifique √† la page */}
        {children}
      </div>
    </>
  );
}
```

**R√®gles associ√©es :**

* ‚úÖ **Toujours** utiliser `<KeenPage>` pour les pages KeenKonnect (sauf cas ultra-sp√©ciaux).
* ‚úÖ Titre **toujours** en `text-2xl font-bold`, pas de `Typography.Title level={1}` ou `level={2}` diff√©rents selon les pages.
* ‚úÖ Padding global **toujours** `className="container mx-auto p-5"`.
* ‚úÖ Toolbar (boutons √† droite du titre) passe par la prop `toolbar`.
* üö´ **Pas** de breadcrumb local dans les pages (le layout du haut s‚Äôen charge).
* üö´ **Pas** de `margin-top` √©norme ou de `padding` custom sur le container : tout doit se faire √† l‚Äôint√©rieur du contenu via des `Card`, `Row`, etc.

---

## 2. Page de r√©f√©rence (mod√®le √† recopier)

Ta page `search-filter-documents` est globalement le bon ¬´ look ¬ª.
Voici la version **r√©f√©renc√©e** qui l‚Äôutilise via `<KeenPage>` :

```tsx
'use client';

import React from 'react';
import { Card, Alert } from 'antd';
import type { PaginationProps } from 'antd';
import {
  ProTable,
  QueryFilter,
  ProFormText,
  ProFormSelect,
  ProFormDateRangePicker,
} from '@ant-design/pro-components';
import KeenPage from '@/components/keenkonnect/KeenPage';

// ... types + donn√©es (DocumentResource, sampleDocuments, etc.)

export default function SearchFilterDocumentsPage(): JSX.Element {
  // ... state, filtres, useMemo, columns, paginationProps, etc.

  return (
    <KeenPage
      title="Search & Filter Documents"
      description="Advanced search and filtering for knowledge documents in KeenKonnect."
    >
      {/* Bloc filtres */}
      <Card className="mb-4">
        <QueryFilter
          onFinish={handleFilterFinish}
          onReset={handleFilterReset}
          labelWidth="auto"
          defaultCollapsed={false}
          span={8}
          initialValues={{ sort: DEFAULT_SORT }}
        >
          {/* ... champs de filtre */}
        </QueryFilter>
      </Card>

      {/* R√©sum√© + table */}
      <Alert /* ...props */ className="mb-4" />

      <Card>
        <ProTable
          /* ...props */
        />
        {/* Pagination externe */}
      </Card>
    </KeenPage>
  );
}
```

üëâ **C‚Äôest cette structure qu‚Äôil faut viser partout** :
`<KeenPage>` en haut, puis `Card`, `ProTable`, `StepsForm`, `Tabs`, etc. √† l‚Äôint√©rieur.

---

## 3. Que corriger, et o√π ? (central vs par page)

### 3.1. Ce qui se corrige **de mani√®re centrale**

En cr√©ant / imposant `<KeenPage>` tu centralises :

1. **Taille & style du titre**

   * `h1.text-2xl.font-bold` partout.
   * Plus de `Typography.Title` avec des niveaux diff√©rents.

2. **Padding & largeur**

   * Tout le monde utilise `container mx-auto p-5` avec le m√™me `maxWidth`.
   * Plus de pages full-bleed sans padding.

3. **Structure de base**

   * Header de page = m√™me layout : titre + description + toolbar √† droite.
   * Plus de pages o√π un bouton important flotte dans un coin sans alignement.

4. **Fil d‚ÄôAriane (breadcrumb)**

   * **Jamais** en local dans la page.
   * Si un jour on veut ajouter un breadcrumb global, on le fait dans le layout `app/keenkonnect/layout.tsx` uniquement.

R√©sultat : 80% des diff√©rences visuelles disparaissent juste en passant par `<KeenPage>`.

---

### 3.2. Ce qui doit √™tre fait **par page** (m√©canique mais simple)

Pour chaque page existante (exemples : `my-projects`, `create-new-project`, `document-management`, `track-project-impact`, etc.) :

#### 1. Remplacer le wrapper racine

**Avant (exemples actuels) :**

```tsx
<div style={{ maxWidth: 960, margin: '0 auto', padding: 24 }}>
  {/* ... */}
</div>
```

ou

```tsx
<div className="container mx-auto p-5">
  <h1 className="text-3xl font-semibold">Big Title</h1>
  {/* ... */}
</div>
```

ou

```tsx
<PageContainer
  header={{
    title: 'My Page',
    breadcrumb: { /* ... */ },
  }}
>
  {/* ... */}
</PageContainer>
```

**Apr√®s (mod√®le unique) :**

```tsx
import KeenPage from '@/components/keenkonnect/KeenPage';

export default function SomePage() {
  return (
    <KeenPage
      title="My Page"
      description="One-line description of what this page does."
      toolbar={(
        /* optionnel : boutons d‚Äôaction √† droite du titre */
      )}
    >
      {/* Ancien contenu, sans h1, sans Head, sans breadcrumb */}
    </KeenPage>
  );
}
```

> üîÅ **Important** :
>
> * Supprimer le `h1` local, `Typography.Title` principal, et les gros marges hautes ‚Äî c‚Äôest g√©r√© par KeenPage.
> * Si la page utilisait `PageContainer`, garder le contenu mais le mettre dans des `Card` ou `ProCard` √† l‚Äôint√©rieur de `<KeenPage>`.

#### 2. Supprimer les breadcumbs locaux

Tout ce qui ressemble √† :

```tsx
<Breadcrumb /* ... */ />
```

ou

```tsx
<PageContainer
  header={{
    breadcrumb: { /* ... */ },
  }}
/>
```

‚û°Ô∏è **√Ä supprimer**.
Breadcrumb = only via layout global (la ‚Äúupper bar‚Äù).

#### 3. Unifier les titres secondaires

√Ä l‚Äôint√©rieur des pages, pour les sous-sections, tu peux :

* soit utiliser `Card` avec `title="..."`,
* soit `h2` / `h3` tailwind (`text-lg font-semibold`, etc.) mais de fa√ßon coh√©rente :

Par ex :

```tsx
<h2 className="text-lg font-semibold mb-2">Team Settings</h2>
```

ou

```tsx
<Card title="Team Settings" className="mb-4">
  {/* ... */}
</Card>
```

---

## 4. Quels types de pages & comment les aligner

Tu peux inclure ce bloc dans ta doc pour guider l‚ÄôIA selon le type de page.

### 4.1. Pages ‚Äúform wizard‚Äù (StepsForm)

Ex : `create-new-project`, `submit-impact-reports`, `match-preferences`, etc.

**Pattern recommand√© :**

```tsx
<KeenPage
  title="Create New Project"
  description="Use this guided wizard to describe your project and configure the team."
>
  <Card>
    <StepsForm
      onFinish={...}
      formProps={{ layout: 'vertical' }}
      submitter={{
        // pas de nextText/prevText custom si le type ne le supporte pas
      }}
    >
      {/* StepForm ... */}
    </StepsForm>
  </Card>
</KeenPage>
```

**Checklist :**

* Pas de marge/padding custom autour du `Card`.
* StepForm toujours dans un `Card` (ou deux si besoin).
* Titre principal g√©r√© par `<KeenPage>`.

---

### 4.2. Pages ‚Äútableau & filtres‚Äù (list, ProTable)

Ex :
`knowledge/search-filter-documents` (r√©f√©rence), `projects/my-projects`, `workspaces/my-workspaces`, `knowledge/document-management`.

**Pattern recommand√© :**

```tsx
<KeenPage
  title="My Projects"
  description="Browse and manage your KeenKonnect projects."
  toolbar={(
    <Button type="primary">New project</Button>
  )}
>
  <Card className="mb-4">
    {/* Filtres / QueryFilter / search bar */}
  </Card>

  <Card>
    <ProTable /* ... */ />
  </Card>
</KeenPage>
```

---

### 4.3. Pages ‚Äúdashboard / analytics‚Äù

Ex :
`sustainability-impact/sustainability-dashboard`, `track-project-impact`.

M√™me base, mais tu joues avec `Row`/`Col` + `Card`/`ProCard` :

```tsx
<KeenPage
  title="Sustainability Impact Dashboard"
  description="High-level dashboard aggregating sustainability impact across projects."
>
  <Row gutter={[16, 16]}>
    <Col xs={24} md={12}>
      <Card title="CO‚ÇÇ saved">
        {/* Graph / KPI */}
      </Card>
    </Col>
    {/* ... */}
  </Row>
</KeenPage>
```

---

## 5. R√©ponse directe √† tes questions

> **‚Äúwhat fix is needed for each page? is this a central fix, or a fix per page?‚Äù**

* **Central** :

  * Cr√©er `<KeenPage>` et l‚Äôadopter comme **obligatoire** pour toutes les pages KeenKonnect.
  * Imposer les r√®gles :

    * `container mx-auto p-5`
    * `h1.text-2xl.font-bold`
    * description en `text-gray-500`
    * toolbar √† droite via prop
    * **aucun breadcrumb local**.

* **Par page (mais m√©canique)** :

  * Remplacer le wrapper racine par `<KeenPage>`.
  * Supprimer les `h1` / `Title` custom.
  * Supprimer les breadcrumbs locaux.
  * Remettre les contenus dans des `Card` / `Row` / `Col` avec marges coh√©rentes (`mb-4`, etc.).
  * Pour les pages qui utilisaient `PageContainer`, migrer le header dans les props de `<KeenPage>`.

> **‚Äúwhich page are ok (like search-filter-documents)‚Äù**

√Ä partir de ce qu‚Äôon a vu ensemble :

* ‚úÖ `knowledge/search-filter-documents`
  ‚Üí d√©j√† tr√®s proche du mod√®le. Il suffit juste √©ventuellement de le faire passer par `<KeenPage>` mais visuellement tu es d√©j√† dans le bon style.

* ‚ö†Ô∏è Les autres pages qu‚Äôon a modifi√©es (projects, workspaces, sustainability, etc.)
  ‚Üí doivent √™tre **align√©es** sur ce mod√®le en les enveloppant dans `<KeenPage>` et en supprimant :

  * leurs wrappers custom (`div` avec padding/margin),
  * leurs gros `Title` Ant Design,
  * leurs breadcrumbs locaux,
  * leurs variations de padding.

---

### TL;DR √† copier dans ton repo / Notion

* Cr√©er `components/keenkonnect/KeenPage.tsx` (code ci-dessus).
* Toute nouvelle page KeenKonnect = **obligatoirement** bas√©e sur `<KeenPage>`.
* Toute page existante = refactor pour utiliser `<KeenPage>` et supprimer les layouts locaux.

Si tu veux, ensuite, tu peux me coller le code d‚Äôune page ‚Äúmoche‚Äù et on la r√©√©crit ensemble 100% align√©e sur ce template.

===== END app/DOCHowtonest/keenkonnect.txt =====


===== BEGIN app/ekoh/achievements-badges/earned-badges-display/page.tsx =====
'use client';

import React, { useState, useMemo } from 'react';
import Head from 'next/head';
import { Card, List, Modal, Select, Row, Col, Typography, Empty, Divider } from 'antd';
import EkohPageShell from '@/app/ekoh/EkohPageShell';

const { Text } = Typography;
const { Option } = Select;

interface Badge {
  id: string;
  name: string;
  icon: string;
  category: string;
  dateEarned: string;
  description: string;
}

// Temporary mock data ‚Äì to be replaced by a real Ekoh badges service
const sampleBadges: Badge[] = [
  {
    id: '1',
    name: 'Top Contributor',
    icon: '/badges/top-contributor.png',
    category: 'Expertise',
    dateEarned: '2023-08-20',
    description: 'Awarded for exceptional contributions in discussions.',
  },
  {
    id: '2',
    name: 'Community Champion',
    icon: '/badges/community-champion.png',
    category: 'Community',
    dateEarned: '2023-07-15',
    description: 'Recognizes outstanding community engagement and support.',
  },
  {
    id: '3',
    name: 'Innovator',
    icon: '/badges/innovator.png',
    category: 'Innovation',
    dateEarned: '2023-06-10',
    description: 'Awarded for innovative ideas and solutions.',
  },
  {
    id: '4',
    name: 'Expert Reviewer',
    icon: '/badges/expert-reviewer.png',
    category: 'Expertise',
    dateEarned: '2023-05-22',
    description: 'Given to users providing insightful reviews.',
  },
  {
    id: '5',
    name: 'Active Participant',
    icon: '/badges/active-participant.png',
    category: 'Community',
    dateEarned: '2023-09-01',
    description: 'Recognizes consistent participation over time.',
  },
];

export default function EarnedBadgesDisplay(): JSX.Element {
  const [filterCategory, setFilterCategory] = useState<string>('All');
  const [sortOrder, setSortOrder] = useState<string>('Newest');
  const [selectedBadge, setSelectedBadge] = useState<Badge | null>(null);
  const [modalVisible, setModalVisible] = useState<boolean>(false);

  const totalBadges = sampleBadges.length;
  const userLevel =
    totalBadges >= 5 ? 'Gold' : totalBadges >= 3 ? 'Silver' : 'Bronze';

  const displayedBadges = useMemo(() => {
    let badges = [...sampleBadges];

    if (filterCategory !== 'All') {
      badges = badges.filter((badge) => badge.category === filterCategory);
    }

    badges.sort((a, b) => {
      const dateA = new Date(a.dateEarned).getTime();
      const dateB = new Date(b.dateEarned).getTime();
      return sortOrder === 'Newest' ? dateB - dateA : dateA - dateB;
    });

    return badges;
  }, [filterCategory, sortOrder]);

  const showBadgeDetails = (badge: Badge) => {
    setSelectedBadge(badge);
    setModalVisible(true);
  };

  const closeModal = () => {
    setModalVisible(false);
    setSelectedBadge(null);
  };

  return (
    <>
      <Head>
        <title>Achievements & Badges ‚Äì Ekoh</title>
        <meta
          name="description"
          content="View all your earned Ekoh badges and achievements with filtering and detailed views."
        />
      </Head>

      <EkohPageShell
        title="Achievements & badges"
        subtitle="View the badges you have earned in Ekoh and explore what they represent."
      >
        {/* Summary */}
        <Card className="mb-6">
          <Row gutter={16}>
            <Col xs={24} sm={12}>
              <Text strong>Total badges:&nbsp;</Text>
              <Text>{totalBadges}</Text>
            </Col>
            <Col xs={24} sm={12}>
              <Text strong>Level:&nbsp;</Text>
              <Text>{userLevel}</Text>
            </Col>
          </Row>
        </Card>

        {/* Filters */}
        <Card className="mb-6">
          <Divider orientation="left">Filters</Divider>
          <Row gutter={[16, 16]}>
            <Col xs={24} sm={12}>
              <Text>Filter by category</Text>
              <Select
                defaultValue="All"
                style={{ width: '100%', marginTop: 8 }}
                onChange={(v) => setFilterCategory(v)}
              >
                <Option value="All">All</Option>
                <Option value="Expertise">Expertise</Option>
                <Option value="Community">Community</Option>
                <Option value="Innovation">Innovation</Option>
              </Select>
            </Col>
            <Col xs={24} sm={12}>
              <Text>Sort by date earned</Text>
              <Select
                defaultValue="Newest"
                style={{ width: '100%', marginTop: 8 }}
                onChange={(v) => setSortOrder(v)}
              >
                <Option value="Newest">Newest</Option>
                <Option value="Oldest">Oldest</Option>
              </Select>
            </Col>
          </Row>
        </Card>

        {/* Badge grid */}
        <Card>
          {displayedBadges.length > 0 ? (
            <List
              grid={{ gutter: 16, xs: 1, sm: 2, md: 3, lg: 4, xl: 4 }}
              dataSource={displayedBadges}
              renderItem={(badge: Badge) => (
                <List.Item>
                  <Card
                    hoverable
                    onClick={() => showBadgeDetails(badge)}
                    cover={
                      <img
                        alt={badge.name}
                        src={badge.icon}
                        style={{
                          padding: '10px',
                          objectFit: 'contain',
                          height: 120,
                        }}
                      />
                    }
                  >
                    <Card.Meta
                      title={badge.name}
                      description={badge.category}
                    />
                  </Card>
                </List.Item>
              )}
            />
          ) : (
            <Empty description="No badges earned yet." />
          )}
        </Card>

        {/* Detail modal */}
        <Modal
          title={selectedBadge?.name}
          open={modalVisible}
          onOk={closeModal}
          onCancel={closeModal}
          footer={null}
        >
          {selectedBadge && (
            <div>
              <img
                alt={selectedBadge.name}
                src={selectedBadge.icon}
                style={{
                  width: '100%',
                  maxHeight: 150,
                  objectFit: 'contain',
                  marginBottom: 16,
                }}
              />
              <p>
                <strong>Description:</strong> {selectedBadge.description}
              </p>
              <p>
                <strong>Date earned:</strong> {selectedBadge.dateEarned}
              </p>
            </div>
          )}
        </Modal>
      </EkohPageShell>
    </>
  );
}

===== END app/ekoh/achievements-badges/earned-badges-display/page.tsx =====


===== BEGIN app/ekoh/dashboard/page.tsx =====
'use client'

// app/ekoh/dashboard/page.tsx
import React, { useState, useEffect } from 'react';
import Head from 'next/head';
import { Card, Statistic, Row, Col, Tabs } from 'antd';
import LineChart from '@/components/dashboard-components/LineChart';
import EkohPageShell from '@/app/ekoh/EkohPageShell';

const { TabPane } = Tabs;

type TrendPoint = { time: string; score: number };

const EkohDashboard = (): JSX.Element => {
  // Simulated user metrics
  const [ekohScore] = useState<number>(80);
  const [smartVoteWeight] = useState<number>(70);
  const [badgesEarned] = useState<number>(12);

  // Trend data (Ekoh score over time)
  const [trendData, setTrendData] = useState<TrendPoint[]>([
    { time: '08:00', score: 70 },
    { time: '10:00', score: 72 },
    { time: '12:00', score: 75 },
    { time: '14:00', score: 78 },
    { time: '16:00', score: 80 },
    { time: '18:00', score: 82 },
    { time: '20:00', score: 80 },
  ]);

  // Notable achievements and recent contributions (mock data)
  const notableAchievements: string[] = [
    'Reached Expert Level 5',
    'Highest vote weight: 78%',
    'Awarded "Community Champion" badge',
  ];

  const recentContributions: string[] = [
    'Voted on Economic Reform Proposal',
    'Commented on Climate Policy Debate',
    'Shared article on Smart Voting Impact',
  ];

  // Optional simulation to refresh the trend chart
  useEffect(() => {
    const interval = setInterval(() => {
      const newTime = new Date().toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit',
      });
      const newScore = 70 + Math.floor(Math.random() * 20);

      setTrendData((prev) => [...prev.slice(-6), { time: newTime, score: newScore }]);
    }, 5000);

    return () => clearInterval(interval);
  }, []);

  return (
    <>
      <Head>
        <title>Ekoh Dashboard</title>
        <meta
          name="description"
          content="Overview of your reputation and influence in the Ekoh system."
        />
      </Head>

      <EkohPageShell
        title="Ekoh dashboard"
        subtitle="Overview of your reputation, voting influence, expertise, and badges."
      >
        {/* Overview cards */}
        <Row gutter={16} className="mb-6">
          <Col xs={24} sm={8}>
            <Card>
              <Statistic title="Ekoh Score" value={ekohScore} suffix="pts" />
            </Card>
          </Col>
          <Col xs={24} sm={8}>
            <Card>
              <Statistic title="Smart Vote Weight" value={smartVoteWeight} suffix="%" />
            </Card>
          </Col>
          <Col xs={24} sm={8}>
            <Card>
              <Statistic title="Badges Earned" value={badgesEarned} />
            </Card>
          </Col>
        </Row>

        {/* Reputation trend chart */}
        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-2">Reputation Trend Over Time</h2>
          <LineChart
            data={trendData.map((item) => ({
              time: item.time,
              value: item.score,
            }))}
          />
        </Card>

        {/* Detailed views tabs */}
        <Card className="mb-6">
          <Tabs defaultActiveKey="overview">
            <TabPane tab="Overview" key="overview">
              <p>
                This section provides an overall summary of your reputation, voting influence,
                expertise, and badges.
              </p>
            </TabPane>
            <TabPane tab="Voting Influence" key="votingInfluence">
              <p>Detailed view on your Smart Vote weight and how it affects overall decisions.</p>
            </TabPane>
            <TabPane tab="Expertise" key="expertise">
              <p>Breakdown of your expertise areas and performance therein.</p>
            </TabPane>
            <TabPane tab="Badges" key="badges">
              <p>Review your earned badges and achievements in detail.</p>
            </TabPane>
          </Tabs>
        </Card>

        {/* Achievements & Recent Contributions */}
        <Row gutter={16}>
          <Col xs={24} md={12}>
            <Card title="Notable Achievements" className="mb-6">
              <ul>
                {notableAchievements.map((achievement) => (
                  <li key={achievement}>{achievement}</li>
                ))}
              </ul>
            </Card>
          </Col>
          <Col xs={24} md={12}>
            <Card title="Recent Contributions" className="mb-6">
              <ul>
                {recentContributions.map((contribution) => (
                  <li key={contribution}>{contribution}</li>
                ))}
              </ul>
            </Card>
          </Col>
        </Row>
      </EkohPageShell>
    </>
  );
};

export default EkohDashboard;

===== END app/ekoh/dashboard/page.tsx =====


===== BEGIN app/ekoh/EkohPageShell.tsx =====
// app/ekoh/EkohPageShell.tsx
'use client';

import React, { ReactNode } from 'react';
import { Typography, Space } from 'antd';

const { Title, Paragraph } = Typography;

export type EkohPageShellProps = {
  /** Main page title (big, H1-equivalent) */
  title: string;
  /** Optional subtitle / helper text under the title */
  subtitle?: ReactNode;
  /** Main CTA on the right (e.g. primary button) */
  primaryAction?: ReactNode;
  /** Secondary actions on the right (e.g. ghost buttons, filters) */
  secondaryActions?: ReactNode;
  /** Main page content */
  children: ReactNode;
};

/**
 * Central layout wrapper for Ekoh pages.
 *
 * Usage rules:
 * - No extra big <h1> / Title outside of this shell in your pages.
 * - No breadcrumb here (rely on the global layout / shell).
 * - All Ekoh pages should use this for consistent padding & header.
 */
function EkohPageShell({
  title,
  subtitle,
  primaryAction,
  secondaryActions,
  children,
}: EkohPageShellProps): JSX.Element {
  const hasActions = Boolean(primaryAction || secondaryActions);

  return (
    <div className="container mx-auto p-5">
      {/* Header: title + subtitle + actions */}
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div className="min-w-0">
          <Title level={2} className="!mb-1">
            {title}
          </Title>
          {subtitle && (
            <Paragraph type="secondary" className="!mb-0">
              {subtitle}
            </Paragraph>
          )}
        </div>

        {hasActions && (
          <Space wrap>
            {secondaryActions}
            {primaryAction}
          </Space>
        )}
      </div>

      {/* Main content */}
      {children}
    </div>
  );
}

export default EkohPageShell;

===== END app/ekoh/EkohPageShell.tsx =====


===== BEGIN app/ekoh/expertise-areas/view-current-expertise/page.tsx =====
'use client'

// app/ekoh/expertise-areas/view-current-expertise/page.tsx
import React from 'react';
import Head from 'next/head';
import { Card, List, Progress, Tag } from 'antd';
import EkohPageShell from '@/app/ekoh/EkohPageShell';

// Exemple de donn√©es simul√©es pour l'expertise de l'utilisateur
interface Expertise {
  id: string;
  domain: string;
  proficiency: number; // en pourcentage
  contributions: number;
  lastUpdated: string; // format ISO ou date format√©e
}

const expertiseData: Expertise[] = [
  {
    id: '1',
    domain: 'Economy',
    proficiency: 80,
    contributions: 45,
    lastUpdated: '2023-08-28',
  },
  {
    id: '2',
    domain: 'Politics',
    proficiency: 65,
    contributions: 30,
    lastUpdated: '2023-08-25',
  },
  {
    id: '3',
    domain: 'Technology',
    proficiency: 75,
    contributions: 38,
    lastUpdated: '2023-08-27',
  },
];

export default function ViewCurrentExpertise(): JSX.Element {
  return (
    <>
      <Head>
        <title>Expertise Areas</title>
        <meta
          name="description"
          content="View your recognized expertise areas along with proficiency levels and contribution details."
        />
      </Head>

      <EkohPageShell
        title="Expertise Areas"
        subtitle="Overview of your recognized domains, proficiency levels, and contributions."
      >
        <Card className="mb-6">
          <List
            itemLayout="vertical"
            dataSource={expertiseData ?? []}
            renderItem={(item) => (
              <List.Item key={item.id}>
                <List.Item.Meta
                  title={
                    <span>
                      {item.domain}{' '}
                      <Tag color="blue">Proficiency: {item.proficiency}%</Tag>
                    </span>
                  }
                  description={
                    <span>
                      Contributions: {item.contributions} | Last Updated: {item.lastUpdated}
                    </span>
                  }
                />
                <Progress percent={item.proficiency} status="active" />
              </List.Item>
            )}
          />
        </Card>
      </EkohPageShell>
    </>
  );
}

===== END app/ekoh/expertise-areas/view-current-expertise/page.tsx =====


===== BEGIN app/ekoh/layout.tsx =====
import React, { Suspense } from 'react'
import MainLayout from '@/components/layout-components/MainLayout'

export default function SegmentLayout({ children }: { children: React.ReactNode }) {
  return (
    <Suspense fallback={null}>
      <MainLayout>{children}</MainLayout>
    </Suspense>
  )
}
===== END app/ekoh/layout.tsx =====


===== BEGIN app/ekoh/overview-analytics/current-ekoh-score/page.tsx =====
// app/ekoh/overview-analytics/current-ekoh-score/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import Head from 'next/head';
import { Card, Alert, Timeline, Table } from 'antd';
import EkohPageShell from '@/app/ekoh/EkohPageShell';
import {
  PieChart as RePieChart,
  Pie,
  Cell,
  Legend,
  Tooltip as ReTooltip,
  ResponsiveContainer,
  LineChart as ReLineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
} from 'recharts';

const COLORS = ['#0088FE', '#00C49F', '#FFBB28'];

type Point = { date: string; score: number };

const CurrentEkohScore = (): JSX.Element => {
  const [pieData] = useState([
    { name: 'Expertise', value: 40 },
    { name: 'Community Feedback', value: 35 },
    { name: 'Ethics', value: 25 },
  ]);

  const [trendData, setTrendData] = useState<Point[]>([
    { date: '2023-08-01', score: 60 },
    { date: '2023-08-02', score: 62 },
    { date: '2023-08-03', score: 65 },
    { date: '2023-08-04', score: 67 },
    { date: '2023-08-05', score: 70 },
    { date: '2023-08-06', score: 72 },
    { date: '2023-08-07', score: 75 },
  ]);

  const timelineData = [
    { key: '1', time: '2023-08-02', event: 'Achieved Expert Level 3' },
    { key: '2', time: '2023-08-04', event: 'Received high community feedback' },
    { key: '3', time: '2023-08-06', event: 'Ethics audit improved rating' },
  ];

  const tableColumns = [
    { title: 'Date', dataIndex: 'date', key: 'date' },
    { title: 'Contribution Detail', dataIndex: 'detail', key: 'detail' },
  ];

  const tableData = [
    { key: '1', date: '2023-08-02', detail: 'Expert review added +4 points' },
    { key: '2', date: '2023-08-04', detail: 'Community vote increased score by +3 points' },
    { key: '3', date: '2023-08-06', detail: 'Ethics audit contributed +2 points' },
  ];

  // Simple live update to simulate a moving score trend
  useEffect(() => {
    const tick = () => {
      const datePart = new Date().toLocaleDateString('en-CA'); // "YYYY-MM-DD"
      const newScore = 60 + Math.floor(Math.random() * 20);

      setTrendData((prev) => {
        const last = prev.slice(-7);
        const existingIndex = last.findIndex((p) => p.date === datePart);

        if (existingIndex >= 0) {
          return last.map((p, i) =>
            i === existingIndex ? { date: p.date, score: newScore } : p,
          );
        }

        return [...prev.slice(-6), { date: datePart, score: newScore }];
      });
    };

    tick();
    const id = setInterval(tick, 5000);
    return () => clearInterval(id);
  }, []);

  return (
    <>
      <Head>
        {/* Use the spec term ‚ÄúScore Analytics‚Äù for this Ekoh view */}
        <title>Ekoh ‚Äì Score Analytics</title>
        <meta
          name="description"
          content="Donut and trend line view of the factors contributing to your Ekoh score, plus key events and recent evaluations."
        />
      </Head>

      <EkohPageShell
        title="Score Analytics"
        subtitle="Breakdown of your Ekoh score factors over time, with key events and recent evaluations."
      >
        {/* Score breakdown donut */}
        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-4">Score Breakdown</h2>
          <div style={{ width: '100%', height: 300 }}>
            <ResponsiveContainer>
              <RePieChart>
                <ReTooltip />
                <Legend verticalAlign="bottom" height={36} />
                <Pie
                  data={pieData}
                  cx="50%"
                  cy="50%"
                  innerRadius={60}
                  outerRadius={100}
                  dataKey="value"
                  paddingAngle={5}
                >
                  {pieData.map((entry, index) => (
                    <Cell
                      key={`cell-${index}`}
                      fill={COLORS[index % COLORS.length]}
                    />
                  ))}
                </Pie>
              </RePieChart>
            </ResponsiveContainer>
          </div>
        </Card>

        {/* Historical trend line */}
        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-4">Historical Trend</h2>
          <div style={{ width: '100%', height: 250 }}>
            <ResponsiveContainer>
              <ReLineChart data={trendData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <ReTooltip />
                <Line type="monotone" dataKey="score" stroke="#82ca9d" />
              </ReLineChart>
            </ResponsiveContainer>
          </div>
        </Card>

        {/* Key events timeline */}
        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-4">
            Key Events Influencing Your Score
          </h2>
          <Timeline>
            {timelineData.map((item) => (
              <Timeline.Item key={item.key}>
                <strong>{item.time}</strong> - {item.event}
              </Timeline.Item>
            ))}
          </Timeline>
        </Card>

        {/* Calculation explanation */}
        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-4">
            How Your Score is Calculated
          </h2>
          <Alert
            message="Score Calculation Explained"
            description="Your Ekoh score is derived from a weighted combination of your expertise level, community feedback, and ethical evaluations. This transparent approach ensures that every contribution is fairly recognized."
            type="info"
            showIcon
          />
        </Card>

        {/* Recent contributing evaluations */}
        <Card>
          <h2 className="text-xl font-semibold mb-4">
            Recent Evaluations Impacting Your Score
          </h2>
          <Table columns={tableColumns} dataSource={tableData} pagination={false} />
        </Card>
      </EkohPageShell>
    </>
  );
};

export default CurrentEkohScore;

===== END app/ekoh/overview-analytics/current-ekoh-score/page.tsx =====


===== BEGIN app/ekoh/voting-influence/current-voting-weight/page.tsx =====
'use client';

import React from 'react';
import { Card, Statistic, Row, Col, Typography, List } from 'antd';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from 'recharts';

const { Title, Paragraph } = Typography;

// Simulated data for the comparison chart
const weightComparisonData: { category: string; weight: number }[] = [
  { category: 'Your Weight', weight: 70 },
  { category: 'Average Weight', weight: 50 },
  { category: 'Top Experts', weight: 90 },
];

// Simulated data for high-weight domains
const weightByDomain: { domain: string; weight: string }[] = [
  { domain: 'Economy', weight: '80%' },
  { domain: 'Politics', weight: '65%' },
  { domain: 'Technology', weight: '75%' },
];

export default function CurrentVotingWeightPage() {
  // Example: user's smart voting weight (percent)
  const smartVoteWeight = 70;

  return (
    <div className="container mx-auto p-5">
      {/* Page header */}
      <Title level={2}>Current Voting Weight</Title>

      {/* Prominent current weight */}
      <Card className="mb-6">
        <Row justify="center">
          <Col>
            <Statistic title="Smart Vote Weight" value={smartVoteWeight} suffix="%" />
          </Col>
        </Row>
      </Card>

      {/* Explanation */}
      <Card className="mb-6">
        <Paragraph>
          Your Smart Vote weight represents your relative influence in collective
          decisions based on your Ekoh reputation. A higher percentage means your
          vote carries more weight compared to the average user.
        </Paragraph>
      </Card>

      {/* Comparison chart */}
      <Card className="mb-6">
        <Title level={4}>Comparison with Others</Title>
        <div style={{ width: '100%', height: 300 }}>
          <ResponsiveContainer>
            <BarChart data={weightComparisonData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="category" />
              <YAxis domain={[0, 100]} />
              <Tooltip />
              <Bar dataKey="weight" fill="#82ca9d" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </Card>

      {/* High-weight domains */}
      <Card className="mb-6">
        <Title level={4}>Highest Weight by Domain</Title>
        <List
          dataSource={weightByDomain}
          renderItem={(item) => (
            <List.Item>
              <strong>{item.domain}:</strong>&nbsp;{item.weight}
            </List.Item>
          )}
        />
      </Card>
    </div>
  );
}

===== END app/ekoh/voting-influence/current-voting-weight/page.tsx =====


===== BEGIN app/ethikos/admin/audit/page.tsx =====
// app/ethikos/admin/audit/page.tsx
'use client';

// Enhanced Ethikos admin audit logs view using Ant Design ProComponents
// and the canonical audit services.

import React from 'react';
import type { ReactNode } from 'react';
import {
  PageContainer,
  ProCard,
  ProTable,
  StatisticCard,
  type ProColumns,
} from '@ant-design/pro-components';
import {
  Alert,
  Badge,
  Button,
  Descriptions,
  Drawer,
  Empty,
  Input,
  Segmented,
  Space,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  ClockCircleOutlined,
  EyeOutlined,
  FilterOutlined,
  InfoCircleOutlined,
  ReloadOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';

import EthikosPageShell from '@/app/ethikos/EthikosPageShell';
import {
  fetchAuditLogs,
  type AuditPayload,
  type AuditQueryParams,
  type LogRow,
} from '@/services/audit';

const { Text, Paragraph } = Typography;

type SeverityFilter = 'all' | NonNullable<LogRow['severity']>;
type TimeWindow = '24h' | '7d' | '30d' | 'all';

export default function AuditLogs(): JSX.Element {
  const [query, setQuery] = React.useState<AuditQueryParams>({
    page: 1,
    pageSize: 20,
    sort: '-ts',
  });
  const [searchValue, setSearchValue] = React.useState('');
  const [severityFilter, setSeverityFilter] =
    React.useState<SeverityFilter>('all');
  const [timeWindow, setTimeWindow] = React.useState<TimeWindow>('7d');
  const [detailRow, setDetailRow] = React.useState<LogRow | null>(null);
  const [lastRefreshedAt, setLastRefreshedAt] = React.useState<string | null>(
    null,
  );

  // ahooks v3: useRequest<Data, ParamsTuple>
  const {
    data,
    loading,
    error,
    run,
    refresh,
  } = useRequest<AuditPayload, [AuditQueryParams | undefined]>(fetchAuditLogs, {
    manual: true,
    onSuccess: () => {
      setLastRefreshedAt(new Date().toISOString());
    },
  });

  // Initial load
  React.useEffect(() => {
    run(query);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const unauthorized =
    (error as any)?.response?.status === 403 ||
    (error as any)?.status === 403;

  const logs: LogRow[] = data?.items ?? [];

  // Time-window filter applied client-side on top of server pagination
  let visibleLogs: LogRow[] = logs;
  if (timeWindow !== 'all') {
    const now = dayjs();
    const threshold =
      timeWindow === '24h'
        ? now.subtract(24, 'hour')
        : timeWindow === '7d'
        ? now.subtract(7, 'day')
        : now.subtract(30, 'day');

    visibleLogs = logs.filter((log) => {
      if (!log.ts) return false;
      const ts = dayjs(log.ts);
      return ts.isAfter(threshold);
    });
  }

  // Local stats for the KPI band
  let infoCount = 0;
  let warnCount = 0;
  let criticalCount = 0;
  let okStatus = 0;
  let warnStatus = 0;
  let errorStatus = 0;

  for (const log of visibleLogs) {
    if (log.severity === 'info') infoCount += 1;
    if (log.severity === 'warn') warnCount += 1;
    if (log.severity === 'critical') criticalCount += 1;

    if (log.status === 'ok') okStatus += 1;
    if (log.status === 'warn') warnStatus += 1;
    if (log.status === 'error') errorStatus += 1;
  }

  const totalCount = data?.total ?? logs.length;
  const pageCount = visibleLogs.length;

  const severityTag = (severity?: LogRow['severity']): ReactNode => {
    switch (severity) {
      case 'critical':
        return <Tag color="red">critical</Tag>;
      case 'warn':
        return <Tag color="orange">warn</Tag>;
      case 'info':
        return <Tag color="blue">info</Tag>;
      default:
        return <Tag>unknown</Tag>;
    }
  };

  const statusTag = (status?: LogRow['status']): ReactNode => {
    switch (status) {
      case 'ok':
        return <Tag color="green">ok</Tag>;
      case 'warn':
        return (
          <Tag color="gold">
            <InfoCircleOutlined /> warn
          </Tag>
        );
      case 'error':
        return <Tag color="red">error</Tag>;
      default:
        return null;
    }
  };

  const columns: ProColumns<LogRow>[] = [
    {
      title: 'Time',
      dataIndex: 'ts',
      valueType: 'dateTime' as const,
      width: 190,
      sorter: true,
      defaultSortOrder: 'descend',
    },
    {
      title: 'Actor & context',
      dataIndex: 'actor',
      width: 260,
      ellipsis: true,
      render: (_: ReactNode, record) => (
        <Space direction="vertical" size={2}>
          <Text>{record.actor || 'System'}</Text>
          <Space size={4} wrap>
            {record.entity && <Tag>{record.entity}</Tag>}
            {record.entityId && (
              <Tag color="purple">#{String(record.entityId)}</Tag>
            )}
            {record.ip && (
              <Tooltip title="Source IP address">
                <Tag icon={<InfoCircleOutlined />}>{record.ip}</Tag>
              </Tooltip>
            )}
          </Space>
        </Space>
      ),
    },
    {
      title: 'Event',
      dataIndex: 'action',
      width: 320,
      ellipsis: true,
      render: (_: ReactNode, record) => (
        <Space direction="vertical" size={2} style={{ width: '100%' }}>
          <Text strong>{record.action}</Text>
          {record.target && (
            <Text
              type="secondary"
              ellipsis={{ tooltip: record.target }}
              style={{ maxWidth: 280 }}
            >
              {record.target}
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'Severity',
      dataIndex: 'severity',
      width: 140,
      filters: [
        { text: 'Info', value: 'info' },
        { text: 'Warn', value: 'warn' },
        { text: 'Critical', value: 'critical' },
      ],
      onFilter: (value, record) =>
        record.severity === (String(value) as LogRow['severity']),
      render: (_dom: ReactNode, record: LogRow) => severityTag(record.severity),
    },
    {
      title: 'Outcome',
      dataIndex: 'status',
      width: 140,
      filters: [
        { text: 'OK', value: 'ok' },
        { text: 'Warn', value: 'warn' },
        { text: 'Error', value: 'error' },
      ],
      onFilter: (value, record) =>
        record.status === (String(value) as LogRow['status']),
      render: (_dom: ReactNode, record: LogRow) => statusTag(record.status),
    },
    {
      title: 'Details',
      key: 'details',
      width: 140,
      fixed: 'right',
      render: (_: ReactNode, record) => (
        <Button
          size="small"
          icon={<EyeOutlined />}
          onClick={() => setDetailRow(record)}
        >
          Inspect
        </Button>
      ),
    },
  ];

  const handleTableChange = (
    pagination: any,
    _filters: any,
    sorter: any,
  ): void => {
    setQuery((prev) => {
      const next: AuditQueryParams = {
        ...prev,
        page: pagination?.current ?? 1,
        pageSize: pagination?.pageSize ?? prev.pageSize ?? 20,
      };

      const sortItem = Array.isArray(sorter) ? sorter[0] : sorter;
      const sortField = sortItem?.field as string | undefined;
      const sortOrder = sortItem?.order as
        | 'ascend'
        | 'descend'
        | undefined;

      if (sortField && sortOrder) {
        next.sort = `${sortOrder === 'descend' ? '-' : ''}${sortField}`;
      }

      run(next);
      return next;
    });
  };

  const handleSeverityChange = (value: string | number): void => {
    const val = value as SeverityFilter;
    setSeverityFilter(val);
    setQuery((prev) => {
      const next: AuditQueryParams = {
        ...prev,
        page: 1,
        severity: val === 'all' ? undefined : (val as LogRow['severity']),
      };
      run(next);
      return next;
    });
  };

  const handleSearch = (value: string): void => {
    const trimmed = value.trim();
    setSearchValue(trimmed);
    setQuery((prev) => {
      const next: AuditQueryParams = {
        ...prev,
        page: 1,
        q: trimmed || undefined,
      };
      run(next);
      return next;
    });
  };

  const lastRefreshedLabel = lastRefreshedAt
    ? dayjs(lastRefreshedAt).format('HH:mm:ss')
    : null;

  const hasAnyData = totalCount > 0;

  const secondaryActions = (
    <Space>
      {lastRefreshedLabel && (
        <Tooltip title={`Last refreshed at ${lastRefreshedLabel}`}>
          <Badge
            count={<ClockCircleOutlined style={{ color: '#52c41a' }} />}
          />
        </Tooltip>
      )}
      <Button
        icon={<ReloadOutlined />}
        size="small"
        onClick={() => refresh()}
      />
    </Space>
  );

  return (
    <EthikosPageShell
      title="Audit logs"
      sectionLabel="Admin"
      subtitle="Immutable trail of sensitive actions across Ethikos for governance, debugging, and incident response."
      secondaryActions={secondaryActions}
    >
      <PageContainer ghost loading={loading}>
        {!hasAnyData && !loading && !error && (
          <Empty
            image={Empty.PRESENTED_IMAGE_SIMPLE}
            description="No audit events have been recorded yet."
            style={{ marginBottom: 16 }}
          />
        )}

        {unauthorized && (
          <Alert
            type="warning"
            showIcon
            style={{ marginBottom: 16 }}
            message="You do not have permission to view audit logs."
            description="Ask an administrator to grant you the ADMIN role in Ethikos to access the audit trail."
          />
        )}

        {error && !unauthorized && (
          <Alert
            type="error"
            showIcon
            style={{ marginBottom: 16 }}
            message="Unable to load audit logs."
            description="Check your connection or try again. If the problem persists, the Ethikos audit service may be temporarily unavailable."
          />
        )}

        {/* KPI band */}
        <ProCard gutter={16} wrap style={{ marginBottom: 16 }} ghost>
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 6 }}
            statistic={{
              title: 'Events (all)',
              value: totalCount,
              description: 'Total events matching current server filters',
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 6 }}
            statistic={{
              title: 'Events in view',
              value: pageCount,
              description: 'After local time window filter',
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 6 }}
            statistic={{
              title: 'Critical / Warn',
              value: criticalCount,
              suffix:
                warnCount > 0 ? ` critical ¬∑ ${warnCount} warn` : ' critical',
              description: 'On the current page',
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 6 }}
            statistic={{
              title: 'Outcome (ok / warn / error)',
              value: okStatus,
              suffix: ` / ${warnStatus} / ${errorStatus}`,
              description: 'Status of operations on this page',
            }}
          />
        </ProCard>

        {/* Filters */}
        <ProCard ghost style={{ marginBottom: 16 }}>
          <Space wrap align="center" size={[16, 12]}>
            <Space>
              <FilterOutlined />
              <Text strong>Filters</Text>
            </Space>

            <Segmented
              options={[
                { label: 'All severities', value: 'all' },
                { label: 'Info', value: 'info' },
                { label: 'Warn', value: 'warn' },
                { label: 'Critical', value: 'critical' },
              ]}
              value={severityFilter}
              onChange={handleSeverityChange}
            />

            <Segmented
              options={[
                { label: 'Last 24h', value: '24h' },
                { label: '7 days', value: '7d' },
                { label: '30 days', value: '30d' },
                { label: 'All time', value: 'all' },
              ]}
              value={timeWindow}
              onChange={(value) =>
                setTimeWindow(value as TimeWindow)
              }
            />

            <Input.Search
              allowClear
              placeholder="Search actor, action, or target"
              style={{ width: 280 }}
              value={searchValue}
              onChange={(e) => setSearchValue(e.target.value)}
              onSearch={handleSearch}
            />
          </Space>
        </ProCard>

        {/* Main table */}
        <ProTable<LogRow>
          rowKey="id"
          search={false}
          options={false}
          loading={loading}
          columns={columns}
          dataSource={visibleLogs}
          pagination={{
            current: data?.page ?? query.page ?? 1,
            pageSize: data?.pageSize ?? query.pageSize ?? 20,
            total: data?.total,
            showSizeChanger: true,
            showTotal: (total) => `${total} events`,
          }}
          onChange={handleTableChange}
          scroll={{ x: 1100 }}
          locale={{
            emptyText: unauthorized
              ? 'Access denied for audit logs.'
              : 'No audit events to display.',
          }}
        />

        {/* Detail drawer */}
        <Drawer
          title="Audit event details"
          width={520}
          open={!!detailRow}
          onClose={() => setDetailRow(null)}
          destroyOnClose
        >
          {detailRow && (
            <Space
              direction="vertical"
              size="middle"
              style={{ width: '100%' }}
            >
              <Space wrap>
                {severityTag(detailRow.severity)}
                {statusTag(detailRow.status)}
                {detailRow.entity && <Tag>{detailRow.entity}</Tag>}
                {detailRow.entityId && (
                  <Tag color="purple">#{String(detailRow.entityId)}</Tag>
                )}
              </Space>

              <Descriptions column={1} size="small" bordered>
                <Descriptions.Item label="Time">
                  {dayjs(detailRow.ts).format('YYYY-MM-DD HH:mm:ss')}
                </Descriptions.Item>
                <Descriptions.Item label="Actor">
                  {detailRow.actor || (
                    <Text type="secondary">System</Text>
                  )}
                </Descriptions.Item>
                <Descriptions.Item label="Action">
                  {detailRow.action}
                </Descriptions.Item>
                {detailRow.target && (
                  <Descriptions.Item label="Target">
                    {detailRow.target}
                  </Descriptions.Item>
                )}
                {detailRow.ip && (
                  <Descriptions.Item label="Source IP">
                    {detailRow.ip}
                  </Descriptions.Item>
                )}
                {detailRow.status && (
                  <Descriptions.Item label="Outcome">
                    {statusTag(detailRow.status)}
                  </Descriptions.Item>
                )}
              </Descriptions>

              {detailRow.meta &&
                Object.keys(detailRow.meta).length > 0 && (
                  <div>
                    <Text strong>Raw metadata</Text>
                    <Paragraph type="secondary">
                      JSON payload supplied by the backend for this
                      event.
                    </Paragraph>
                    <pre
                      style={{
                        maxHeight: 260,
                        overflow: 'auto',
                        background: '#f5f5f5',
                        padding: 12,
                        borderRadius: 4,
                        fontSize: 12,
                      }}
                    >
                      {JSON.stringify(detailRow.meta, null, 2)}
                    </pre>
                  </div>
                )}
            </Space>
          )}
        </Drawer>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/admin/audit/page.tsx =====


===== BEGIN app/ethikos/admin/moderation/page.tsx =====
// app/ethikos/admin/moderation/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import type { ReactNode } from 'react';
import {
  PageContainer,
  ProTable,
  type ProColumns,
} from '@ant-design/pro-components';
import {
  Alert,
  App as AntdApp,
  Badge,
  Button,
  Drawer,
  Popconfirm,
  Space,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  CheckCircleOutlined,
  ExclamationCircleOutlined,
  EyeOutlined,
  ReloadOutlined,
  StopOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';

import EthikosPageShell from '../../EthikosPageShell';
import {
  fetchModerationQueue,
  actOnReport,
  type ModerationPayload,
} from '@/services/admin';

const { Text, Paragraph } = Typography;

type ModerationStatus = 'Pending' | 'Resolved' | 'Escalated';
type ModerationTargetType = 'topic' | 'post' | 'user';
type Severity = 'low' | 'medium' | 'high';

interface ModerationQueueItem {
  id: string;
  /** Debate topic / argument / participant */
  targetType: ModerationTargetType;
  /** ID of the target (argumentId, topicId, userId, etc.) */
  targetId: string;
  /** Debate / consultation context (topic title) */
  contextTitle?: string;
  /** Short preview of the argument or message */
  contentPreview?: string;
  /** Who authored the offending content */
  authorName?: string;
  authorId?: string;
  /** Who reported */
  reporterName?: string;
  reporterId?: string;
  /** Primary reason label (Spam, Harassment, etc.) */
  reason?: string;
  /** Free-text notes / message from reporter */
  reporterMessage?: string;
  /** Number of merged reports for same target */
  reportCount?: number;
  /** When the first report was created (ISO) */
  createdAt?: string;
  /** When last moderation action happened (ISO) */
  lastActionAt?: string;
  /** Queue status */
  status: ModerationStatus;
  /** Heuristic severity classification */
  severity?: Severity;
}

/**
 * Normalizes whatever the backend returns from admin/moderation
 * into a richer, Ethikos‚Äëspecific moderation item.
 */
function adaptModerationItems(raw: unknown): ModerationQueueItem[] {
  if (!raw) return [];

  let items: any[] = [];
  if (Array.isArray(raw)) {
    items = raw;
  } else if ((raw as any)?.items && Array.isArray((raw as any).items)) {
    items = (raw as any).items;
  }

  return items.map((item: any): ModerationQueueItem => {
    const status: ModerationStatus =
      item.status === 'Resolved' || item.status === 'Escalated'
        ? item.status
        : 'Pending';

    const targetType: ModerationTargetType =
      (item.targetType as ModerationTargetType) ??
      (item.entityType as ModerationTargetType) ??
      'post';

    const severity: Severity =
      (item.severity as Severity) ??
      (item.priority as Severity) ??
      'medium';

    return {
      id: String(item.id),
      targetType,
      targetId: String(
        item.targetId ??
          item.argumentId ??
          item.postId ??
          item.topicId ??
          item.userId ??
          item.id,
      ),
      contextTitle:
        item.contextTitle ??
        item.threadTitle ??
        item.topicTitle ??
        item.debateTitle,
      contentPreview: item.content ?? item.contentSnippet ?? item.preview,
      authorName: item.authorName ?? item.offenderName ?? item.user,
      authorId: item.authorId ?? item.offenderId,
      reporterName: item.reporterName ?? item.reporter,
      reporterId: item.reporterId,
      reason: item.type ?? item.reason,
      reporterMessage: item.message ?? item.notes,
      reportCount: item.reportCount ?? item.count ?? 1,
      createdAt: item.createdAt ?? item.created_at ?? item.timestamp,
      lastActionAt: item.lastActionAt ?? item.updated_at,
      status,
      severity,
    };
  });
}

export default function EthikosModerationPage(): JSX.Element {
  const [selectedRowKeys, setSelectedRowKeys] = useState<React.Key[]>([]);
  const [activeStatusFilter, setActiveStatusFilter] = useState<
    ModerationStatus | 'all'
  >('Pending');
  const [detailDrawerItem, setDetailDrawerItem] =
    useState<ModerationQueueItem | null>(null);
  const [globalActionLoading, setGlobalActionLoading] = useState(false);

  const { message } = AntdApp.useApp();

  // ahooks generics: <Data, Params>
  const {
    data: rawData,
    loading,
    error,
    refresh,
  } = useRequest<ModerationPayload, []>(fetchModerationQueue);

  const items: ModerationQueueItem[] = useMemo(
    () => adaptModerationItems(rawData),
    [rawData],
  );

  const filteredItems = useMemo(() => {
    if (activeStatusFilter === 'all') return items;
    return items.filter((item) => item.status === activeStatusFilter);
  }, [items, activeStatusFilter]);

  const unauthorized =
    (error as any)?.response?.status === 403 || (error as any)?.status === 403;

  const onSingleAction = async (
    record: ModerationQueueItem,
    action: 'approve' | 'remove',
  ) => {
    try {
      setGlobalActionLoading(true);
      const remove = action === 'remove';
      await actOnReport(record.id, remove);
      message.success(
        remove
          ? 'Debate content removed and report resolved.'
          : 'Content approved and report resolved.',
      );
      await refresh();
    } catch {
      message.error('Unable to process moderation action. Please try again.');
    } finally {
      setGlobalActionLoading(false);
    }
  };

  const onBulkAction = async (action: 'approve' | 'remove') => {
    if (!selectedRowKeys.length) {
      message.info('Select at least one report to apply a bulk action.');
      return;
    }

    setGlobalActionLoading(true);
    try {
      const remove = action === 'remove';

      const promises = selectedRowKeys.map((id) =>
        actOnReport(String(id), remove).catch((err) => err),
      );

      const results = await Promise.all(promises);
      const failures = results.filter((r) => r instanceof Error);

      if (failures.length) {
        message.warning(
          `${failures.length} report(s) could not be processed. They may have been updated by another moderator.`,
        );
      } else {
        message.success('Bulk action completed successfully.');
      }

      setSelectedRowKeys([]);
      await refresh();
    } catch {
      message.error('Unable to complete bulk action. Please try again.');
    } finally {
      setGlobalActionLoading(false);
    }
  };

  const statusFilterButtons = (
    <Space>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('Pending')}
        type={activeStatusFilter === 'Pending' ? 'primary' : 'default'}
      >
        Pending
      </Button>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('Escalated')}
        type={activeStatusFilter === 'Escalated' ? 'primary' : 'default'}
      >
        Escalated
      </Button>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('Resolved')}
        type={activeStatusFilter === 'Resolved' ? 'primary' : 'default'}
      >
        Resolved
      </Button>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('all')}
        type={activeStatusFilter === 'all' ? 'primary' : 'default'}
      >
        All
      </Button>
    </Space>
  );

  const headerActions = (
    <Space>
      {statusFilterButtons}
      <Button
        icon={<ReloadOutlined />}
        onClick={() => refresh()}
        loading={loading || globalActionLoading}
        disabled={!!unauthorized}
      >
        Refresh queue
      </Button>
    </Space>
  );

  const severityTag = (severity?: Severity): ReactNode => {
    if (!severity) return null;
    const color =
      severity === 'high' ? 'red' : severity === 'medium' ? 'orange' : 'blue';
    const text =
      severity === 'high'
        ? 'High severity'
        : severity === 'medium'
        ? 'Medium'
        : 'Low';

    return (
      <Tag color={color}>
        <ExclamationCircleOutlined /> {text}
      </Tag>
    );
  };

  const targetTag = (record: ModerationQueueItem): ReactNode => {
    const label =
      record.targetType === 'topic'
        ? 'Debate topic'
        : record.targetType === 'user'
        ? 'Participant'
        : 'Argument / post';

    return <Tag>{label}</Tag>;
  };

  const statusBadge = (status: ModerationStatus): ReactNode => {
    if (status === 'Resolved') {
      return (
        <Badge
          status="success"
          text={
            <Space size={4}>
              <CheckCircleOutlined />
              Resolved
            </Space>
          }
        />
      );
    }

    if (status === 'Escalated') {
      return <Badge status="warning" text="Escalated" />;
    }

    return <Badge status="processing" text="Pending review" />;
  };

  const columns: ProColumns<ModerationQueueItem>[] = [
    {
      title: 'Content',
      dataIndex: 'contentPreview',
      ellipsis: true,
      render: (_dom: ReactNode, record: ModerationQueueItem) => (
        <Space direction="vertical" size={2}>
          {record.contextTitle && (
            <Text strong ellipsis>
              {record.contextTitle}
            </Text>
          )}
          <Text type="secondary" ellipsis>
            {record.contentPreview ?? 'No preview available.'}
          </Text>
        </Space>
      ),
    },
    {
      title: 'People',
      dataIndex: 'authorName',
      width: 200,
      render: (_dom: ReactNode, record: ModerationQueueItem) => (
        <Space direction="vertical" size={2}>
          {record.authorName && (
            <Text ellipsis>
              Author: <Text strong>{record.authorName}</Text>
            </Text>
          )}
          {record.reporterName && (
            <Text type="secondary" ellipsis>
              Reporter: {record.reporterName}
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'Reason',
      dataIndex: 'reason',
      width: 160,
      render: (_dom: ReactNode, record: ModerationQueueItem) => (
        <Space size={4}>
          {severityTag(record.severity)}
          {record.reason && <Tag>{record.reason}</Tag>}
          {typeof record.reportCount === 'number' && record.reportCount > 1 && (
            <Tag>{record.reportCount} reports</Tag>
          )}
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      width: 160,
      filters: [
        { text: 'Pending', value: 'Pending' },
        { text: 'Escalated', value: 'Escalated' },
        { text: 'Resolved', value: 'Resolved' },
      ],
      onFilter: (value, record) =>
        record.status === (String(value) as ModerationStatus),
      render: (_dom: ReactNode, record: ModerationQueueItem) =>
        statusBadge(record.status),
    },
    {
      title: 'Timeline',
      dataIndex: 'createdAt',
      width: 220,
      render: (_dom: ReactNode, record: ModerationQueueItem) => (
        <Text type="secondary">
          {record.createdAt && (
            <>
              Reported:{' '}
              {new Date(record.createdAt).toLocaleString(undefined, {
                dateStyle: 'medium',
                timeStyle: 'short',
              })}
              <br />
            </>
          )}
          {record.lastActionAt && (
            <>
              Last action:{' '}
              {new Date(record.lastActionAt).toLocaleString(undefined, {
                dateStyle: 'medium',
                timeStyle: 'short',
              })}
            </>
          )}
        </Text>
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 220,
      fixed: 'right',
      render: (_dom: ReactNode, record: ModerationQueueItem) => {
        const disabled = unauthorized || record.status === 'Resolved';

        return (
          <Space size="small">
            <Tooltip title="View details">
              <Button
                size="small"
                icon={<EyeOutlined />}
                onClick={() => setDetailDrawerItem(record)}
              />
            </Tooltip>

            <Tooltip title="Approve content and resolve report">
              <Button
                size="small"
                icon={<CheckCircleOutlined />}
                onClick={() => onSingleAction(record, 'approve')}
                disabled={disabled}
              >
                Approve
              </Button>
            </Tooltip>

            <Popconfirm
              title="Remove content?"
              description="This will remove the content for everyone and resolve all associated reports."
              okText="Remove"
              okType="danger"
              icon={<ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />}
              disabled={disabled}
              onConfirm={() => onSingleAction(record, 'remove')}
            >
              <Tooltip title="Remove content and resolve report">
                <Button
                  size="small"
                  icon={<StopOutlined />}
                  danger
                  disabled={disabled}
                >
                  Remove
                </Button>
              </Tooltip>
            </Popconfirm>
          </Space>
        );
      },
    },
  ];

  const pageBody = (
    <PageContainer ghost loading={loading}>
      <Space direction="vertical" style={{ width: '100%' }} size="large">
        {unauthorized && (
          <Alert
            type="error"
            showIcon
            message="You do not have permission to moderate Ethikos debates."
            description="If you believe this is an error, ask an administrator to grant you an Ethikos moderator or admin role."
          />
        )}

        {!unauthorized && (
          <Alert
            type="info"
            showIcon
            message="Ethikos moderation guidelines"
            description={
              <>
                Arguments that receive three or more independent reports are
                automatically hidden until a moderator reviews them. Approve
                content that fits the Ethikos charter (respect, evidence‚Äëbased
                reasoning, and inclusion), remove content that clearly violates
                it, and escalate borderline or sensitive cases.
              </>
            }
          />
        )}

        {error && !unauthorized && (
          <Alert
            type="error"
            showIcon
            message="Unable to load the moderation queue."
            description="Check your connection or try again. If the problem persists, the Ethikos moderation service may be temporarily unavailable."
          />
        )}

        {items.length === 0 && !loading && !error && !unauthorized && (
          <Alert
            type="success"
            showIcon
            message="No open reports."
            description="There are currently no unresolved reports on Ethikos debates. New reports will appear here in real time."
          />
        )}

        <ProTable<ModerationQueueItem>
          rowKey="id"
          search={false}
          options={false}
          loading={loading || globalActionLoading}
          columns={columns}
          dataSource={filteredItems}
          pagination={{
            pageSize: 10,
            showSizeChanger: true,
            showTotal: (total) => `${total} reports`,
          }}
          rowSelection={{
            selectedRowKeys,
            onChange: (keys) => setSelectedRowKeys(keys),
          }}
          tableAlertRender={({ selectedRowKeys: keys }) => (
            <Space size={8}>
              <Text strong>{keys.length}</Text>
              <Text>selected</Text>
            </Space>
          )}
          tableAlertOptionRender={() => (
            <Space>
              <Tooltip title="Content is acceptable, resolve reports and keep the debate visible.">
                <Button
                  size="small"
                  icon={<CheckCircleOutlined />}
                  onClick={() => onBulkAction('approve')}
                  disabled={!!unauthorized || !selectedRowKeys.length}
                >
                  Bulk approve
                </Button>
              </Tooltip>
              <Tooltip title="Remove content and resolve selected reports">
                <Popconfirm
                  title="Remove selected content?"
                  description="This will remove content for all selected reports and resolve them."
                  okText="Remove"
                  okType="danger"
                  icon={
                    <ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />
                  }
                  disabled={!!unauthorized || !selectedRowKeys.length}
                  onConfirm={() => onBulkAction('remove')}
                >
                  <Button
                    size="small"
                    danger
                    icon={<StopOutlined />}
                    disabled={!!unauthorized || !selectedRowKeys.length}
                  >
                    Bulk remove
                  </Button>
                </Popconfirm>
              </Tooltip>
            </Space>
          )}
          scroll={{ x: 1100 }}
        />

        <Drawer
          title="Report details"
          width={480}
          open={!!detailDrawerItem}
          onClose={() => setDetailDrawerItem(null)}
        >
          {detailDrawerItem && (
            <Space
              direction="vertical"
              style={{ width: '100%' }}
              size="middle"
            >
              <Space>
                {targetTag(detailDrawerItem)}
                {severityTag(detailDrawerItem.severity)}
                {statusBadge(detailDrawerItem.status)}
                {detailDrawerItem.reason && (
                  <Tag>{detailDrawerItem.reason}</Tag>
                )}
              </Space>

              {detailDrawerItem.contextTitle && (
                <div>
                  <Text strong>Debate / topic</Text>
                  <Paragraph>{detailDrawerItem.contextTitle}</Paragraph>
                </div>
              )}

              {detailDrawerItem.contentPreview && (
                <div>
                  <Text strong>Argument / message</Text>
                  <Paragraph>{detailDrawerItem.contentPreview}</Paragraph>
                </div>
              )}

              <div>
                <Text strong>People</Text>
                <Paragraph>
                  {detailDrawerItem.authorName && (
                    <>
                      Author:{' '}
                      <Text strong>{detailDrawerItem.authorName}</Text>
                      <br />
                    </>
                  )}
                  {detailDrawerItem.reporterName && (
                    <>
                      Reporter: <Text>{detailDrawerItem.reporterName}</Text>
                      <br />
                    </>
                  )}
                  {detailDrawerItem.reportCount && (
                    <>Reports merged: {detailDrawerItem.reportCount}</>
                  )}
                </Paragraph>
              </div>

              {detailDrawerItem.reporterMessage && (
                <div>
                  <Text strong>Reporter note</Text>
                  <Paragraph>{detailDrawerItem.reporterMessage}</Paragraph>
                </div>
              )}

              <div>
                <Text strong>Timeline</Text>
                <Paragraph type="secondary">
                  {detailDrawerItem.createdAt && (
                    <>
                      Reported:{' '}
                      {new Date(
                        detailDrawerItem.createdAt,
                      ).toLocaleString(undefined, {
                        dateStyle: 'medium',
                        timeStyle: 'short',
                      })}
                      <br />
                    </>
                  )}
                  {detailDrawerItem.lastActionAt && (
                    <>
                      Last action:{' '}
                      {new Date(
                        detailDrawerItem.lastActionAt,
                      ).toLocaleString(undefined, {
                        dateStyle: 'medium',
                        timeStyle: 'short',
                      })}
                    </>
                  )}
                </Paragraph>
              </div>

              <Alert
                type="info"
                showIcon
                message="Next steps"
                description="Use the actions in the table to approve or remove this content. For borderline arguments or repeat offenders, escalate via your internal Ethikos governance process."
              />
            </Space>
          )}
        </Drawer>
      </Space>
    </PageContainer>
  );

  return (
    <EthikosPageShell
      title="Moderation queue"
      sectionLabel="Admin"
      subtitle="Review and act on reports for debate arguments, topics, and participant behaviour."
      secondaryActions={headerActions}
    >
      {pageBody}
    </EthikosPageShell>
  );
}

===== END app/ethikos/admin/moderation/page.tsx =====


===== BEGIN app/ethikos/admin/roles/page.tsx =====
// app/ethikos/admin/roles/page.tsx
'use client';

import type { ReactNode } from 'react';
import { useMemo, useState } from 'react';
import {
  PageContainer,
  ProTable,
  type ProColumns,
} from '@ant-design/pro-components';
import {
  Alert,
  Button,
  Segmented,
  Space,
  Statistic,
  Switch,
  Tag,
  Typography,
} from 'antd';
import { ReloadOutlined } from '@ant-design/icons';
import { useRequest } from 'ahooks';

import EthikosPageShell from '@/app/ethikos/EthikosPageShell';
import {
  fetchRoles,
  toggleRole,
  type RoleRow,
  type RolePayload,
} from '@/services/admin';

const { Text } = Typography;

type StatusFilter = 'all' | 'enabled' | 'disabled';

export default function RoleManagement() {
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');

  // ahooks v3 generics: <Data, ParamsTuple>. No params ‚Üí []
  const { data, loading, refresh } = useRequest<RolePayload, []>(fetchRoles);

  const stats = useMemo(() => {
    const items = data?.items ?? [];
    const totalRoles = items.length;
    const enabledRoles = items.filter((r) => r.enabled).length;
    const totalUsers = items.reduce(
      (sum, r) => sum + (r.userCount ?? 0),
      0,
    );
    return { totalRoles, enabledRoles, totalUsers };
  }, [data]);

  const filteredItems = useMemo(() => {
    const items = data?.items ?? [];
    if (statusFilter === 'enabled') return items.filter((r) => r.enabled);
    if (statusFilter === 'disabled') return items.filter((r) => !r.enabled);
    return items;
  }, [data, statusFilter]);

  const columns: ProColumns<RoleRow>[] = [
    {
      title: 'Role',
      dataIndex: 'name',
      width: 220,
      ellipsis: true,
    },
    {
      title: 'Users',
      dataIndex: 'userCount',
      width: 120,
      align: 'right',
      render: (dom: ReactNode) => <Tag>{dom}</Tag>,
    },
    {
      title: 'Enabled',
      dataIndex: 'enabled',
      width: 140,
      valueType: 'switch',
      render: (_: ReactNode, row: RoleRow) => (
        <Switch
          checked={row.enabled}
          onChange={async (checked: boolean) => {
            await toggleRole(row.id, checked);
            refresh();
          }}
        />
      ),
    },
  ];

  return (
    <EthikosPageShell
      title="Role management"
      sectionLabel="Admin"
      subtitle="Configure who can moderate debates, manage consultations, or access sensitive impact dashboards in Ethikos."
    >
      <PageContainer ghost loading={loading}>
        <Space
          direction="vertical"
          size="middle"
          style={{ width: '100%', marginBottom: 16 }}
        >
          <Alert
            type="info"
            showIcon
            message="Role-based access for Ethikos"
            description={
              <Text type="secondary">
                Use roles to control who can moderate debates, manage
                consultations, or access sensitive impact dashboards.
                Toggling a role updates access for all users in that group.
              </Text>
            }
          />

          <Space
            align="center"
            style={{
              width: '100%',
              justifyContent: 'space-between',
              flexWrap: 'wrap',
            }}
          >
            <Space size="large" wrap>
              <Statistic title="Defined roles" value={stats.totalRoles} />
              <Statistic title="Enabled roles" value={stats.enabledRoles} />
              <Statistic title="Assigned users" value={stats.totalUsers} />
            </Space>

            <Space>
              <Segmented
                value={statusFilter}
                onChange={(value) =>
                  setStatusFilter(value as StatusFilter)
                }
                options={[
                  { label: 'All', value: 'all' },
                  { label: 'Enabled', value: 'enabled' },
                  { label: 'Disabled', value: 'disabled' },
                ]}
              />
              <Button
                icon={<ReloadOutlined />}
                onClick={() => refresh()}
                type="default"
              >
                Refresh
              </Button>
            </Space>
          </Space>
        </Space>

        <ProTable<RoleRow>
          rowKey="id"
          columns={columns}
          dataSource={filteredItems}
          pagination={false}
          search={false}
          toolBarRender={() => [
            <Text key="hint" type="secondary">
              Toggle a role to enable or disable its permissions
              platform-wide.
            </Text>,
          ]}
        />
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/admin/roles/page.tsx =====


===== BEGIN app/ethikos/decide/elite/page.tsx =====
// app/ethikos/decide/elite/page.tsx
// Updated implementation for the Elite ballots page.
// Source (original dump): app/ethikos/decide/elite/page.tsx 
// Services: fetchEliteBallots (services/decide.ts) 
// Services: fetchTopicPreview / types (services/deliberate.ts)

'use client';

import React from 'react';
import Link from 'next/link';
import {
  PageContainer,
  ProCard,
  ProTable,
  StatisticCard,
  type ProColumns,
} from '@ant-design/pro-components';
import {
  Alert,
  Button,
  Drawer,
  Empty,
  Progress,
  Segmented,
  Space,
  Statistic,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import { InfoCircleOutlined, ReloadOutlined } from '@ant-design/icons';
import { useRequest, useInterval } from 'ahooks';
import dayjs from 'dayjs';

import EthikosPageShell from '../../EthikosPageShell';
import { fetchEliteBallots } from '@/services/decide';
import { fetchTopicPreview, type TopicPreviewResponse } from '@/services/deliberate';
import type { Ballot } from '@/types';

type Row = Ballot & { turnout: number };
type ViewMode = 'all' | 'closingSoon' | 'highTurnout' | 'lowTurnout';
type Preview = TopicPreviewResponse;

const { Paragraph, Title } = Typography;

export default function EliteBallots(): JSX.Element {
  // Data: open elite ballots
  const { data, loading, refresh } = useRequest<{ ballots: Row[] }, []>(fetchEliteBallots);
  useInterval(refresh, 60_000); // auto-refresh every 60s

  const ballots = data?.ballots ?? [];

  /* ---------- local view filters ---------- */

  const [viewMode, setViewMode] = React.useState<ViewMode>('all');

  const filteredBallots = React.useMemo(() => {
    if (!ballots.length) return ballots;

    const now = dayjs();

    switch (viewMode) {
      case 'closingSoon':
        return ballots.filter((b) => dayjs(b.closesAt).diff(now, 'hour') <= 24);
      case 'highTurnout':
        return ballots.filter((b) => (b.turnout ?? 0) >= 60);
      case 'lowTurnout':
        return ballots.filter((b) => (b.turnout ?? 0) < 20);
      case 'all':
      default:
        return ballots;
    }
  }, [ballots, viewMode]);

  /* ---------- KPI header ---------- */

  const headerStats = React.useMemo(() => {
    const total = ballots.length;
    const avgTurnout =
      total > 0
        ? Math.round(ballots.reduce((sum, b) => sum + (b.turnout ?? 0), 0) / total)
        : 0;
    const closingSoon = ballots.filter((b) => dayjs(b.closesAt).diff(dayjs(), 'hour') <= 24).length;

    return [
      { label: 'Active elite ballots', value: total },
      { label: 'Avg turnout', value: avgTurnout, suffix: '%' },
      { label: 'Closing ‚â§ 24h', value: closingSoon },
    ];
  }, [ballots]);

  /* ---------- debate preview drawer ---------- */

  const [activeBallot, setActiveBallot] = React.useState<Row | null>(null);
  const {
    data: preview,
    loading: previewLoading,
    run: loadPreview,
  } = useRequest<Preview, [string]>(fetchTopicPreview, { manual: true });

  const openPreview = React.useCallback(
    (row: Row) => {
      setActiveBallot(row);
      loadPreview(row.id);
    },
    [loadPreview],
  );

  /* ---------- table columns ---------- */

  const columns: ProColumns<Row>[] = React.useMemo(
    () => [
      {
        title: 'Title',
        dataIndex: 'title',
        width: 320,
        ellipsis: true,
        render: (_dom, row) => (
          <Button type="link" onClick={() => openPreview(row)} style={{ padding: 0 }}>
            {row.title}
          </Button>
        ),
      },
      {
        title: 'Status',
        dataIndex: 'closesAt',
        width: 140,
        render: (_dom, row) => {
          const now = dayjs();
          const closes = dayjs(row.closesAt);
          const hoursLeft = closes.diff(now, 'hour');
          const isClosed = closes.isBefore(now);

          if (isClosed) return <Tag>Closed</Tag>;
          if (hoursLeft <= 24) return <Tag color="red">Closing soon</Tag>;
          return <Tag color="green">Open</Tag>;
        },
      },
      {
        title: 'Closes In',
        dataIndex: 'closesAt',
        width: 200,
        render: (_dom, row) =>
          dayjs(row.closesAt).isBefore(dayjs()) ? (
            <span>‚Äî</span>
          ) : (
            <Statistic.Countdown value={dayjs(row.closesAt).valueOf()} format="D[d] HH:mm:ss" />
          ),
      },
      {
        title: 'Turnout',
        dataIndex: 'turnout',
        width: 220,
        sorter: (a, b) => (a.turnout ?? 0) - (b.turnout ?? 0),
        render: (_dom, row) => (
          <Space>
            <Progress type="circle" percent={row.turnout} width={52} />
            <span>{row.turnout}%</span>
          </Space>
        ),
      },
      {
        title: 'Scope',
        dataIndex: 'scope',
        width: 120,
        render: (_dom, row) => <Tag color="purple">{row.scope ?? 'Elite'}</Tag>,
      },
      {
        title: 'Actions',
        dataIndex: 'actions',
        width: 240,
        render: (_dom, row) => (
          <Space>
            <Tooltip title="See the structured debate that feeds this vote">
              <Link href={`/ethikos/deliberate/${row.id}`} prefetch={false}>
                <Button size="small">View debate</Button>
              </Link>
            </Tooltip>
            <Tooltip title="View historical decisions">
              <Link href="/ethikos/decide/results" prefetch={false}>
                <Button size="small" type="default">
                  Results archive
                </Button>
              </Link>
            </Tooltip>
          </Space>
        ),
      },
    ],
    [openPreview],
  );

  /* ---------- render ---------- */

  return (
    <EthikosPageShell
      title="Decide ¬∑ Elite Ballots"
      subtitle={
        <span>
          Expert-only advisory ballots built on Korum debates, using a ‚àí3‚Ä¶+3 stance scale and
          EkoH-weighted SmartVote aggregation.
        </span>
      }
      primaryAction={
        <Link href="/ethikos/decide/methodology" prefetch={false}>
          <Button type="primary" icon={<InfoCircleOutlined />}>
            Voting methodology
          </Button>
        </Link>
      }
      secondaryActions={
        <Space>
          <Link href="/ethikos/decide/public" prefetch={false}>
            <Button>Switch to public ballots</Button>
          </Link>
        </Space>
      }
    >
      <PageContainer ghost loading={loading}>
        {/* Context banner */}
        <Alert
          type="info"
          showIcon
          style={{ marginBottom: 16 }}
          message="How elite ballots work"
          description={
            <span>
              Each elite ballot aggregates expert stances from its Korum thread, maps them onto the
              ‚àí3‚Ä¶+3 scale, and applies EkoH reputation weights before determining whether the
              proposal passes.
            </span>
          }
        />

        {/* KPI summary */}
        <ProCard gutter={16} wrap style={{ marginBottom: 16 }}>
          {headerStats.map((s) => (
            <StatisticCard
              key={s.label}
              colSpan={{ xs: 24, sm: 8 }}
              statistic={{
                title: s.label,
                value: s.value,
                suffix: s.suffix,
              }}
            />
          ))}
        </ProCard>

        {/* Main table */}
        {filteredBallots.length === 0 && !loading ? (
          <Empty description="No elite ballots are open right now." />
        ) : (
          <ProTable<Row>
            rowKey="id"
            columns={columns}
            dataSource={filteredBallots}
            pagination={{ pageSize: 8 }}
            search={false}
            options={false}
            toolBarRender={() => [
              <Segmented
                key="view"
                size="small"
                value={viewMode}
                onChange={(val) => setViewMode(val as ViewMode)}
                options={[
                  { label: 'All', value: 'all' },
                  { label: 'Closing ‚â§24h', value: 'closingSoon' },
                  { label: 'High turnout', value: 'highTurnout' },
                  { label: 'Low turnout', value: 'lowTurnout' },
                ]}
              />,
              <Button key="refresh" icon={<ReloadOutlined />} onClick={() => refresh()}>
                Refresh
              </Button>,
            ]}
          />
        )}

        {/* Debate preview drawer */}
        <Drawer
          width={520}
          open={!!activeBallot}
          onClose={() => setActiveBallot(null)}
          title={preview?.title || activeBallot?.title || 'Ballot details'}
        >
          {previewLoading ? (
            <Empty description="Loading‚Ä¶" />
          ) : preview ? (
            <>
              <Paragraph type="secondary">
                {preview.category ? `${preview.category} ¬∑ ` : ''}
                {preview.createdAt ? dayjs(preview.createdAt).format('YYYY-MM-DD HH:mm') : null}
              </Paragraph>
              <Title level={4} style={{ marginTop: 0 }}>
                Latest statements
              </Title>
              <ul style={{ paddingLeft: 16 }}>
                {preview.latest.map((s) => (
                  <li key={s.id} style={{ marginBottom: 8 }}>
                    <strong>{s.author}</strong> ‚Äî {s.body}
                  </li>
                ))}
              </ul>
              <Button
                type="primary"
                onClick={() => window.location.assign(`/ethikos/deliberate/${preview.id}`)}
              >
                Go to full thread ‚Üí
              </Button>
            </>
          ) : (
            <Empty />
          )}
        </Drawer>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/decide/elite/page.tsx =====


===== BEGIN app/ethikos/decide/methodology/page.tsx =====
// app/ethikos/decide/methodology/page.tsx
'use client';

import {
  PageContainer,
  ProCard,
  StatisticCard,
} from '@ant-design/pro-components';
import {
  Alert,
  Collapse,
  Descriptions,
  Divider,
  Steps,
  Tabs,
  Timeline,
  Typography,
  Tag,
  Space,
} from 'antd';
import {
  InfoCircleOutlined,
  SafetyCertificateOutlined,
  TeamOutlined,
} from '@ant-design/icons';

import EthikosPageShell from '../../EthikosPageShell';

const { Title, Paragraph, Text } = Typography;

export default function Methodology(): JSX.Element {
  return (
    <EthikosPageShell
      title="Voting methodology"
      sectionLabel="Decide"
      subtitle="How Ethikos turns nuanced stances, Ekoh reputation and Smart Vote into auditable decisions."
    >
      <PageContainer ghost>
        {/* ------------------------------------------------------------------ */}
        {/* Heading                                                            */}
        {/* ------------------------------------------------------------------ */}
        <Title level={3}>How Smart Voting Works</Title>
        <Paragraph type="secondary">
          This page explains how Ethikos decisions are computed from individual
          stances, how expertise (Ekoh) influences the result, and which
          safeguards and audit rules are applied before outcomes appear in the
          archive.
        </Paragraph>

        {/* ------------------------------------------------------------------ */}
        {/* Key constants / parameters                                        */}
        {/* ------------------------------------------------------------------ */}
        <ProCard
          gutter={16}
          wrap
          style={{ marginTop: 24, marginBottom: 24 }}
        >
          <StatisticCard
            colSpan={{ xs: 24, sm: 8 }}
            statistic={{
              title: 'Stance scale',
              value: '‚Äì3 ‚Ä¶ +3',
              description: 'Strongly against ‚Üí strongly for; 0 = neutral',
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 8 }}
            statistic={{
              title: 'Expert quorum',
              value: 12,
              suffix: 'experts',
              description:
                'Minimum expert votes required for expert-only results',
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 8 }}
            statistic={{
              title: 'Auto-hide threshold',
              value: 3,
              suffix: 'reports',
              description:
                'Arguments temporarily hidden after 3 independent reports',
            }}
          />
        </ProCard>

        {/* ------------------------------------------------------------------ */}
        {/* Tabs: conceptual overview                                          */}
        {/* ------------------------------------------------------------------ */}
        <Tabs
          style={{ marginBottom: 32 }}
          items={[
            {
              key: 'overview',
              label: '1 ¬∑ Pipeline overview',
              children: (
                <ProCard ghost>
                  <Paragraph>
                    Every decision in Ethikos follows the same high-level
                    pipeline:
                  </Paragraph>
                  <Timeline
                    items={[
                      {
                        color: 'blue',
                        children: (
                          <>
                            <Text strong>1. Collect nuanced stances</Text>
                            <Paragraph style={{ marginTop: 4 }}>
                              Participants express a stance on a topic on a
                              seven-point scale from{' '}
                              <Text strong>‚Äì3</Text> (strongly against) to{' '}
                              <Text strong>+3</Text> (strongly for), with{' '}
                              <Text strong>0</Text> as neutral or undecided.
                            </Paragraph>
                          </>
                        ),
                      },
                      {
                        color: 'green',
                        children: (
                          <>
                            <Text strong>2. Apply Ekoh weighting</Text>
                            <Paragraph style={{ marginTop: 4 }}>
                              Each stance is multiplied by a weight derived
                              from the voter&apos;s Ekoh reputation in the
                              relevant domain, bounded so that high expertise
                              matters but cannot dominate the entire outcome.
                            </Paragraph>
                          </>
                        ),
                      },
                      {
                        color: 'purple',
                        children: (
                          <>
                            <Text strong>3. Aggregate Smart Vote result</Text>
                            <Paragraph style={{ marginTop: 4 }}>
                              Weighted stances are aggregated by modality
                              (approval, rating, ranking, etc.) and scope (
                              <Text strong>Elite</Text> vs{' '}
                              <Text strong>Public</Text>) to produce summary
                              metrics and a consensus classification.
                            </Paragraph>
                          </>
                        ),
                      },
                      {
                        color: 'orange',
                        children: (
                          <>
                            <Text strong>
                              4. Enforce thresholds &amp; publish
                            </Text>
                            <Paragraph style={{ marginTop: 4 }}>
                              Results are only presented once minimum
                              participation and expert-quorum thresholds are
                              reached. After a cooling-off period, anonymised
                              raw data and audit logs are exposed.
                            </Paragraph>
                          </>
                        ),
                      },
                    ]}
                  />
                </ProCard>
              ),
            },
            {
              key: 'weighting',
              label: '2 ¬∑ Weighting & Ekoh',
              children: (
                <ProCard ghost>
                  <Space
                    direction="vertical"
                    size="large"
                    style={{ width: '100%' }}
                  >
                    <Paragraph>
                      Ethikos relies on the Ekoh reputation engine and Smart
                      Vote services to translate competence and ethical
                      behaviour into influence on collective decisions.
                    </Paragraph>
                    <Descriptions
                      bordered
                      size="small"
                      column={{ xs: 1, sm: 2 }}
                      labelStyle={{ width: 180 }}
                    >
                      <Descriptions.Item label="Base stance">
                        Integer in [‚Äì3, +3] chosen per topic. Negative values
                        are against, positive values are for, 0 is neutral.
                      </Descriptions.Item>
                      <Descriptions.Item label="Reputation weight">
                        A factor derived from the user&apos;s Ekoh score in the
                        topic&apos;s domain. Higher expertise ‚Üí higher weight,
                        within configured floors and caps.
                      </Descriptions.Item>
                      <Descriptions.Item label="Ethical multiplier">
                        An additional multiplier rewarding consistent ethical
                        behaviour (e.g. respectful participation, constructive
                        contributions), bounded to avoid runaway effects.
                      </Descriptions.Item>
                      <Descriptions.Item label="Final vote value">
                        The product of (stance √ó reputation weight √ó ethical
                        multiplier), normalised when aggregated at topic level.
                      </Descriptions.Item>
                    </Descriptions>
                    <Paragraph>
                      Expert-only views filter the same dataset to participants
                      whose Ekoh score is above the expert percentile threshold
                      in the relevant domain. This gives a complementary
                      reading of what the most competent contributors think,
                      without erasing the broader Krowd.
                    </Paragraph>
                  </Space>
                </ProCard>
              ),
            },
            {
              key: 'nuance',
              label: '3 ¬∑ Nuance & modalities',
              children: (
                <ProCard ghost>
                  <Space
                    direction="vertical"
                    size="large"
                    style={{ width: '100%' }}
                  >
                    <Paragraph>
                      The stance scale and voting modalities are designed to
                      balance expressiveness and simplicity:
                    </Paragraph>
                    <Descriptions
                      bordered
                      size="small"
                      column={{ xs: 1, sm: 2 }}
                      labelStyle={{ width: 220 }}
                    >
                      <Descriptions.Item label="Nuanced stance scale">
                        <Space wrap size="small">
                          <Tag color="red">‚Äì3 ¬∑ strongly against</Tag>
                          <Tag color="volcano">‚Äì2 ¬∑ against</Tag>
                          <Tag color="orange">
                            ‚Äì1 ¬∑ somewhat against
                          </Tag>
                          <Tag>0 ¬∑ neutral / unsure</Tag>
                          <Tag color="green">+1 ¬∑ somewhat for</Tag>
                          <Tag color="lime">+2 ¬∑ for</Tag>
                          <Tag color="cyan">+3 ¬∑ strongly for</Tag>
                        </Space>
                      </Descriptions.Item>
                      <Descriptions.Item label="Supported modalities">
                        Approval, rating, ranking and preferential voting are
                        supported at the engine level. The UI exposes the
                        simplest form that fits the decision (e.g. stance
                        slider for yes/no questions, ranking for alternatives).
                      </Descriptions.Item>
                      <Descriptions.Item label="Scope filters">
                        Results can be segmented by scope (Elite councils vs
                        public Krowd), and by cohort filters (experts only,
                        verified accounts, etc.) if enough data is available.
                      </Descriptions.Item>
                      <Descriptions.Item label="Time dimension">
                        For long-running debates, a timeline of stance
                        distributions is maintained so users can see how the
                        consensus evolved.
                      </Descriptions.Item>
                    </Descriptions>
                  </Space>
                </ProCard>
              ),
            },
            {
              key: 'thresholds',
              label: '4 ¬∑ Quorum & thresholds',
              children: (
                <ProCard ghost>
                  <Space
                    direction="vertical"
                    size="large"
                    style={{ width: '100%' }}
                  >
                    <Paragraph>
                      To avoid over-interpreting sparse or unbalanced
                      participation, several thresholds are enforced before a
                      result is considered stable:
                    </Paragraph>
                    <Descriptions
                      bordered
                      size="small"
                      column={{ xs: 1, sm: 2 }}
                      labelStyle={{ width: 220 }}
                    >
                      <Descriptions.Item
                        label={
                          <Space size={4}>
                            <SafetyCertificateOutlined />
                            <span>Expert quorum</span>
                          </Space>
                        }
                      >
                        Expert-only views require at least{' '}
                        <Text strong>12 distinct experts</Text> (users above
                        the expert percentile in the relevant Ekoh domain) to
                        have voted before any aggregate is displayed.
                      </Descriptions.Item>
                      <Descriptions.Item
                        label={
                          <Space size={4}>
                            <TeamOutlined />
                            <span>Participation floor</span>
                          </Space>
                        }
                      >
                        Public-facing summaries can enforce minimum
                        participation counts (configurable per deployment) to
                        avoid showing unstable distributions based on very few
                        votes.
                      </Descriptions.Item>
                      <Descriptions.Item label="Consensus classification">
                        Thresholds on weighted agreement (for instance, a
                        strong consensus band when weighted agreement exceeds a
                        high percentage) are used to label decisions as
                        &quot;divided&quot;, &quot;leaning&quot;, or
                        &quot;strong consensus&quot;.
                      </Descriptions.Item>
                      <Descriptions.Item label="Moderation linkage">
                        Content that reaches the auto-hide report threshold is
                        excluded from featured summaries until reviewed, so
                        that low-quality or abusive inputs do not skew visible
                        outcomes.
                      </Descriptions.Item>
                    </Descriptions>
                  </Space>
                </ProCard>
              ),
            },
            {
              key: 'audit',
              label: '5 ¬∑ Audit & transparency',
              children: (
                <ProCard ghost>
                  <Space
                    direction="vertical"
                    size="large"
                    style={{ width: '100%' }}
                  >
                    <Paragraph>
                      Transparency is a core requirement: stakeholders must be
                      able to verify how a decision was reached without
                      exposing individual voters.
                    </Paragraph>
                    <Collapse
                      ghost
                      items={[
                        {
                          key: 'audit-trail',
                          label: 'Audit trail',
                          children: (
                            <Paragraph>
                              For each decision, Ethikos keeps a trace of
                              configuration (topic metadata, modality, filters,
                              thresholds), stance submissions, and all
                              subsequent recalculations. Changes to weighting
                              parameters are logged so that later readers can
                              reconstruct the state that produced a given
                              outcome.
                            </Paragraph>
                          ),
                        },
                        {
                          key: 'open-data',
                          label: 'Open data export',
                          children: (
                            <Paragraph>
                              After a cooling-off period, an anonymised export
                              of stances and weights can be published.
                              Individual identifiers are removed or hashed, but
                              aggregated distributions remain verifiable by
                              third parties.
                            </Paragraph>
                          ),
                        },
                        {
                          key: 'simulation',
                          label: 'Simulation & regression tests',
                          children: (
                            <Paragraph>
                              The collective-intelligence pipeline is
                              continuously validated with synthetic data.
                              Simulation runs ensure that higher expertise
                              reliably increases influence, that the nuance
                              scale behaves as expected, and that parameter
                              changes do not introduce regressions.
                            </Paragraph>
                          ),
                        },
                      ]}
                    />
                  </Space>
                </ProCard>
              ),
            },
          ]}
        />

        {/* ------------------------------------------------------------------ */}
        {/* Deep dive: stages as collapsible sections                          */}
        {/* ------------------------------------------------------------------ */}
        <Divider orientation="left">Deep dive by stage</Divider>

        <Collapse
          style={{ marginBottom: 32 }}
          items={[
            {
              key: 'collection',
              label: 'Stage 1 ¬∑ Collecting stances',
              children: (
                <>
                  <Paragraph>
                    Participants see a clear question, any relevant background
                    material, and a stance control (slider or segmented
                    buttons). The interface encourages evidence-backed
                    participation by linking to guidelines and reference
                    material.
                  </Paragraph>
                  <Paragraph>
                    Users can revise their stance over time; the system stores
                    the latest value as the canonical position, while previous
                    stances can be kept for longitudinal analysis.
                  </Paragraph>
                </>
              ),
            },
            {
              key: 'weighting',
              label: 'Stage 2 ¬∑ Applying weights',
              children: (
                <>
                  <Paragraph>
                    For each stance, the engine fetches the voter&apos;s Ekoh
                    profile in the relevant domain and computes a weight within
                    configured bounds. An ethical multiplier rewards
                    constructive behaviour, but both factors are capped to avoid
                    extreme influence.
                  </Paragraph>
                  <Paragraph>
                    In expert-only views, only voters above the expert
                    threshold are considered, but their weights are still
                    normalised so that no single expert can dominate the
                    outcome.
                  </Paragraph>
                </>
              ),
            },
            {
              key: 'aggregation',
              label: 'Stage 3 ¬∑ Aggregation & classification',
              children: (
                <>
                  <Paragraph>
                    Weighted stances are aggregated according to the chosen
                    modality: mean or median for rating, pairwise comparisons
                    for ranking, or tallying approvals for approval voting. The
                    result is then mapped to an intuitive summary:
                    percentages, histograms, or consensus bands.
                  </Paragraph>
                  <Paragraph>
                    These summaries are computed separately for different
                    scopes and filters (public, experts-only, specific cohorts)
                    so that stakeholders can compare perspectives.
                  </Paragraph>
                </>
              ),
            },
            {
              key: 'publication',
              label: 'Stage 4 ¬∑ Publication & auditability',
              children: (
                <>
                  <Paragraph>
                    Once thresholds are met, results appear on the public
                    decision pages and in the Results Archive. A short
                    explanatory note on each decision links back to this
                    methodology page to keep the process legible.
                  </Paragraph>
                  <Paragraph>
                    For high-impact decisions, administrators can additionally
                    export an audit bundle containing configuration, weight
                    distributions, and aggregate datasets suitable for
                    independent verification.
                  </Paragraph>
                </>
              ),
            },
          ]}
        />

        {/* ------------------------------------------------------------------ */}
        {/* Visual stepper                                                     */}
        {/* ------------------------------------------------------------------ */}
        <Steps
          current={2}
          style={{ marginTop: 8, marginBottom: 24, maxWidth: 720 }}
          items={[
            {
              title: 'Propose',
              description: 'Define the question, scope, and voting modality.',
            },
            {
              title: 'Deliberate',
              description: 'Debate threads and evidence gathering in Ethikos.',
            },
            {
              title: 'Vote',
              description: 'Participants submit or update their nuanced stances.',
            },
            {
              title: 'Audit',
              description: 'Results frozen, published, and made auditable.',
            },
          ]}
        />

        {/* ------------------------------------------------------------------ */}
        {/* Final info blocks                                                  */}
        {/* ------------------------------------------------------------------ */}
        <Space
          direction="vertical"
          size="middle"
          style={{ width: '100%' }}
        >
          <Alert
            type="info"
            showIcon
            message="Open methodology"
            description={
              <>
                This methodology is stable for the current platform version and
                is designed to be understandable by non-technical stakeholders.
                If configuration parameters (thresholds, scales) change, this
                page should be updated in lockstep so that every decision can
                be traced back to the rules that produced it.
              </>
            }
          />
          <Alert
            type="warning"
            showIcon
            icon={<InfoCircleOutlined />}
            message="Interpreting results"
            description={
              <>
                Ethikos results are decision-support signals, not absolute
                truth. Administrators are encouraged to look at both public and
                expert views, examine participation levels, and read the
                underlying debates before drawing conclusions.
              </>
            }
          />
        </Space>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/decide/methodology/page.tsx =====


===== BEGIN app/ethikos/decide/public/page.tsx =====
// app/ethikos/decide/public/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import Link from 'next/link';
import {
  PageContainer,
  ProCard,
  ProTable,
  StatisticCard,
} from '@ant-design/pro-components';
import type { ProColumns } from '@ant-design/pro-components';
import {
  Alert,
  Button,
  Empty,
  Input,
  Progress,
  Radio,
  Slider,
  Space,
  Tag,
  Tooltip,
  Typography,
  message,
} from 'antd';
import type { RadioChangeEvent } from 'antd';
import {
  BarChartOutlined,
  InfoCircleOutlined,
  ThunderboltOutlined,
  SyncOutlined,
} from '@ant-design/icons';
import { useRequest, useInterval } from 'ahooks';
import dayjs from 'dayjs';

import EthikosPageShell from '../../EthikosPageShell';
import {
  fetchPublicBallots,
  submitPublicVote,
  type PublicBallot,
  type PublicBallotResponse,
} from '@/services/decide';

const { Paragraph } = Typography;

type BallotRow = PublicBallot;
type QuickFilter = 'all' | 'closing-soon' | 'high-turnout';

type SelectionMap = Record<string, string | undefined>;

const DEFAULT_SCALE_OPTIONS = [
  'Strongly disagree',
  'Disagree',
  'Neutral',
  'Agree',
  'Strongly agree',
];

const PAGE_SIZE = 8;

function resolveOptions(ballot: BallotRow): string[] {
  if (Array.isArray(ballot.options) && ballot.options.length > 0) {
    return ballot.options;
  }
  return DEFAULT_SCALE_OPTIONS;
}

export default function PublicVotingPage(): JSX.Element {
  const [searchTerm, setSearchTerm] = useState('');
  const [quickFilter, setQuickFilter] = useState<QuickFilter>('all');
  const [selectedOptions, setSelectedOptions] = useState<SelectionMap>({});
  const [submittingId, setSubmittingId] = useState<string | null>(null);

  const { data, loading, refresh } = useRequest<PublicBallotResponse, []>(
    fetchPublicBallots,
  );

  useInterval(refresh, 60_000);

  const ballots = data?.ballots ?? [];

  const headerStats = useMemo(
    () => {
      const total = ballots.length;
      const avgTurnout = total
        ? Math.round(
            ballots.reduce((sum, b) => sum + (b.turnout ?? 0), 0) / total,
          )
        : 0;

      const closingSoon = ballots.filter((ballot) => {
        const closes = dayjs(ballot.closesAt);
        if (!closes.isValid()) return false;
        return closes.diff(dayjs(), 'hour') <= 48;
      }).length;

      return [
        { label: 'Active consultations', value: total },
        { label: 'Avg participation', value: avgTurnout, suffix: '%' },
        { label: 'Closing ‚â§ 48h', value: closingSoon },
      ];
    },
    [ballots],
  );

  const filteredBallots = useMemo(() => {
    const normalizedSearch = searchTerm.trim().toLowerCase();
    const now = dayjs();

    return ballots.filter((ballot) => {
      if (
        normalizedSearch &&
        !ballot.title.toLowerCase().includes(normalizedSearch)
      ) {
        return false;
      }

      if (quickFilter === 'closing-soon') {
        const closes = dayjs(ballot.closesAt);
        if (!closes.isValid()) return false;
        return closes.diff(now, 'hour') <= 48;
      }

      if (quickFilter === 'high-turnout') {
        return (ballot.turnout ?? 0) >= 50;
      }

      return true;
    });
  }, [ballots, quickFilter, searchTerm]);

  const handleRadioChange = (id: string, e: RadioChangeEvent) => {
    const value = e.target.value as string;
    setSelectedOptions((prev) => ({ ...prev, [id]: value }));
  };

  const handleSliderChange = (
    id: string,
    value: number | [number, number],
    options: string[],
  ) => {
    const rawIndex = Array.isArray(value) ? value[0] : value;
    if (!options.length) return;

    const safeIndex = Math.min(options.length - 1, Math.max(0, rawIndex));
    const option = options[safeIndex];

    setSelectedOptions((prev) => ({ ...prev, [id]: option }));
  };

  const handleSubmitVote = async (id: string) => {
    const option = selectedOptions[id];
    if (!option) {
      message.warning('Select a stance before casting your vote.');
      return;
    }

    try {
      setSubmittingId(id);
      await submitPublicVote(id, option);
      message.success('Your vote has been recorded.');
      await refresh();
    } catch {
      message.error('Failed to submit your vote. Please try again.');
    } finally {
      setSubmittingId(null);
    }
  };

  const columns: ProColumns<BallotRow>[] = [
    {
      title: 'Question',
      dataIndex: 'title',
      width: 320,
      ellipsis: true,
    },
    {
      title: 'Your stance',
      dataIndex: 'id',
      width: 440,
      render: (_, row) => {
        const id = String(row.id);
        const options = resolveOptions(row);

        if (!options.length) {
          return <Tag color="default">No voting options configured</Tag>;
        }

        const selected = selectedOptions[id];
        const defaultIndex = Math.floor(options.length / 2);
        const currentIndex = (() => {
          if (!selected) return defaultIndex;
          const idx = options.findIndex(
            (opt) => opt.toLowerCase() === selected.toLowerCase(),
          );
          return idx >= 0 ? idx : defaultIndex;
        })();

        const marks = options.reduce<Record<number, React.ReactNode>>(
          (acc, label, idx) => {
            acc[idx] = <span style={{ fontSize: 11 }}>{label}</span>;
            return acc;
          },
          {},
        );

        return (
          <Space direction="vertical" size="small" style={{ width: '100%' }}>
            <Slider
              min={0}
              max={options.length - 1}
              value={currentIndex}
              marks={marks}
              tooltip={{ formatter: (val) => options[val ?? defaultIndex] }}
              onChange={(val) => handleSliderChange(id, val, options)}
            />

            <Radio.Group
              size="small"
              value={selected}
              onChange={(e) => handleRadioChange(id, e)}
            >
              {options.map((opt) => (
                <Radio.Button key={opt} value={opt}>
                  {opt}
                </Radio.Button>
              ))}
            </Radio.Group>

            <Space size="small">
              <Tag color={selected ? 'geekblue' : 'default'}>
                {selected ? `Selected: ${selected}` : 'No vote yet'}
              </Tag>
              <Button
                type="primary"
                size="small"
                icon={<ThunderboltOutlined />}
                loading={submittingId === id}
                disabled={!selected || submittingId === id}
                onClick={() => handleSubmitVote(id)}
              >
                Cast vote
              </Button>
            </Space>
          </Space>
        );
      },
    },
    {
      title: 'Closes',
      dataIndex: 'closesAt',
      width: 180,
      valueType: 'dateTime',
      render: (_, row) => {
        const closes = dayjs(row.closesAt);
        const now = dayjs();
        const diffHours = closes.diff(now, 'hour');
        const closingSoon = diffHours <= 48;

        return (
          <Space direction="vertical" size={2}>
            <span>{closes.format('YYYY-MM-DD HH:mm')}</span>
            {closingSoon && <Tag color="volcano">Closing soon</Tag>}
          </Space>
        );
      },
    },
    {
      title: 'Turnout',
      dataIndex: 'turnout',
      width: 160,
      render: (_, row) => {
        const turnout = Math.round(row.turnout ?? 0);
        const status = turnout >= 50 ? 'active' : 'normal';
        return (
          <Progress
            percent={turnout}
            size="small"
            status={status as any}
          />
        );
      },
    },
  ];

  return (
    <EthikosPageShell
      sectionLabel="Decide"
      title="Public consultations"
      subtitle={
        <span>
          Open consultations where any verified participant can express a nuanced stance on
          Korum debates. Votes use a ‚àí3‚Ä¶+3 stance scale and feed into the Ethikos opinion layer.
        </span>
      }
      primaryAction={
        <Link href="/ethikos/decide/results" prefetch={false}>
          <Button type="primary" icon={<BarChartOutlined />}>
            Open results archive
          </Button>
        </Link>
      }
      secondaryActions={
        <Space>
          <Link href="/ethikos/decide/elite" prefetch={false}>
            <Button>Switch to elite ballots</Button>
          </Link>
          <Link href="/ethikos/decide/methodology" prefetch={false}>
            <Button icon={<InfoCircleOutlined />}>Voting methodology</Button>
          </Link>
        </Space>
      }
    >
      <PageContainer ghost loading={loading}>
        <Space direction="vertical" size="middle" style={{ width: '100%' }}>
          <Alert
            type="info"
            showIcon
            message={
              <Space>
                <InfoCircleOutlined />
                <span>
                  You can adjust your stance at any time while a consultation is open.
                  Results feed into the Decide ¬∑ Results Archive and Ethikos ¬∑ Opinion
                  Analytics.
                </span>
              </Space>
            }
          />

          <ProCard gutter={16} wrap>
            {headerStats.map((stat) => (
              <StatisticCard
                key={stat.label}
                colSpan={{ xs: 24, sm: 8 }}
                statistic={{
                  title: stat.label,
                  value: stat.value,
                  suffix: stat.suffix,
                }}
              />
            ))}
          </ProCard>

          <ProCard
            ghost
            style={{ marginBottom: 0 }}
            title="Find an open consultation"
            extra={
              <Paragraph type="secondary" style={{ marginBottom: 0 }}>
                Search by title, or focus on consultations that are closing soon or have
                high participation.
              </Paragraph>
            }
          >
            <Space wrap>
              <Input.Search
                placeholder="Search consultations‚Ä¶"
                allowClear
                style={{ width: 280 }}
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />

              <Radio.Group
                size="small"
                value={quickFilter}
                onChange={(e) =>
                  setQuickFilter(e.target.value as QuickFilter)
                }
              >
                <Radio.Button value="all">All</Radio.Button>
                <Radio.Button value="closing-soon">Closing soon</Radio.Button>
                <Radio.Button value="high-turnout">High participation</Radio.Button>
              </Radio.Group>

              <Tooltip title="Refresh open consultations">
                <Button
                  size="small"
                  icon={<SyncOutlined />}
                  onClick={() => refresh()}
                >
                  Refresh
                </Button>
              </Tooltip>
            </Space>
          </ProCard>

          {filteredBallots.length === 0 ? (
            <Empty
              image={Empty.PRESENTED_IMAGE_SIMPLE}
              description={
                ballots.length === 0
                  ? 'No open public consultations right now.'
                  : 'No consultations match your search or filters.'
              }
            />
          ) : (
            <ProTable<BallotRow>
              rowKey="id"
              columns={columns}
              dataSource={filteredBallots}
              pagination={{ pageSize: PAGE_SIZE }}
              search={false}
              options={false}
              toolBarRender={false}
            />
          )}

          <ProCard
            ghost
            style={{ marginTop: 16 }}
            title="Where to go next"
          >
            <Space wrap>
              <Button href="/ethikos/decide/elite">
                View elite ballots
              </Button>
              <Button href="/ethikos/decide/results" icon={<BarChartOutlined />}>
                Results archive
              </Button>
              <Button href="/ethikos/insights">
                Opinion analytics
              </Button>
            </Space>
          </ProCard>
        </Space>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/decide/public/page.tsx =====


===== BEGIN app/ethikos/decide/results/page.tsx =====
// app/ethikos/decide/results/page.tsx
'use client';

import Link from 'next/link';
import { useMemo, useState } from 'react';
import {
  PageContainer,
  ProCard,
  ProTable,
  StatisticCard,
  type ProColumns,
} from '@ant-design/pro-components';
import {
  Alert,
  Button,
  DatePicker,
  Segmented,
  Select,
  Space,
  Tag,
  Typography,
} from 'antd';
import { InfoCircleOutlined, ReloadOutlined } from '@ant-design/icons';
import type { Dayjs } from 'dayjs';
import dayjs from 'dayjs';
import { useRequest } from 'ahooks';

import EthikosPageShell from '../../EthikosPageShell';
import {
  fetchDecisionResults,
  type DecisionResult,
  type DecisionResultsResponse,
  type DecisionScope,
} from '@/services/decide';

const { RangePicker } = DatePicker;
const { Text } = Typography;

type ScopeFilter = 'all' | DecisionScope;
type ResultFilter = 'all' | 'passed' | 'rejected';
type RangeValue = [Dayjs | null, Dayjs | null] | null;

export default function ResultsArchive(): JSX.Element {
  const { data, loading, refresh } = useRequest<DecisionResultsResponse, []>(
    fetchDecisionResults,
  );

  const [scopeFilter, setScopeFilter] = useState<ScopeFilter>('all');
  const [resultFilter, setResultFilter] = useState<ResultFilter>('all');
  const [regionFilter, setRegionFilter] = useState<string | 'all'>('all');
  const [range, setRange] = useState<RangeValue>(null);

  const items = data?.items ?? [];

  const allRegions = useMemo(
    () =>
      Array.from(
        new Set(
          items
            .map((d) => d.region)
            .filter((r): r is string => !!r),
        ),
      ),
    [items],
  );

  const filteredItems = useMemo(
    () =>
      items.filter((item) => {
        if (scopeFilter !== 'all' && item.scope !== scopeFilter) return false;
        if (resultFilter === 'passed' && !item.passed) return false;
        if (resultFilter === 'rejected' && item.passed) return false;
        if (regionFilter !== 'all' && item.region !== regionFilter) return false;

        if (range && range[0] && range[1]) {
          const [start, end] = range as [Dayjs, Dayjs];
          const closedTs = dayjs(item.closesAt).valueOf();
          const startTs = start.startOf('day').valueOf();
          const endTs = end.endOf('day').valueOf();
          if (closedTs < startTs || closedTs > endTs) return false;
        }

        return true;
      }),
    [items, range, regionFilter, resultFilter, scopeFilter],
  );

  const totalDecisions = items.length;
  const passedCount = items.filter((i) => i.passed).length;
  const rejectedCount = totalDecisions - passedCount;
  const passRate = totalDecisions
    ? Math.round((passedCount / totalDecisions) * 100)
    : 0;
  const coveredRegions = allRegions.length;

  const columns: ProColumns<DecisionResult>[] = [
    {
      title: 'Title',
      dataIndex: 'title',
      width: 320,
      ellipsis: true,
    },
    {
      title: 'Result',
      dataIndex: 'passed',
      width: 140,
      render: (_dom, row) => (
        <Tag color={row.passed ? 'green' : 'red'}>
          {row.passed ? 'PASSED' : 'REJECTED'}
        </Tag>
      ),
    },
    {
      title: 'Scope',
      dataIndex: 'scope',
      width: 120,
      render: (_dom, row) => <Tag>{row.scope}</Tag>,
    },
    {
      title: 'Region',
      dataIndex: 'region',
      width: 160,
      render: (_dom, row) => row.region ?? '‚Äî',
    },
    {
      title: 'Closed',
      dataIndex: 'closesAt',
      valueType: 'dateTime',
      width: 200,
      sorter: (a, b) =>
        dayjs(a.closesAt).valueOf() - dayjs(b.closesAt).valueOf(),
      defaultSortOrder: 'descend',
    },
  ];

  return (
    <EthikosPageShell
      title="Decide ¬∑ Results Archive"
      subtitle={
        <span>
          Historical record of closed Ethikos decisions across elite and public scopes. Filter by
          outcome, region and closing period, or jump to open ballots.
        </span>
      }
      primaryAction={
        <Link href="/ethikos/decide/methodology" prefetch={false}>
          <Button type="primary" icon={<InfoCircleOutlined />}>
            Voting methodology
          </Button>
        </Link>
      }
      secondaryActions={
        <Space>
          <Link href="/ethikos/decide/elite" prefetch={false}>
            <Button>Elite ballots</Button>
          </Link>
          <Link href="/ethikos/decide/public" prefetch={false}>
            <Button>Public ballots</Button>
          </Link>
          <Button
            icon={<ReloadOutlined />}
            onClick={() => refresh()}
            type="default"
            size="small"
          >
            Refresh
          </Button>
        </Space>
      }
    >
      <PageContainer ghost loading={loading}>
        <Alert
          type="info"
          showIcon
          style={{ marginBottom: 16 }}
          message="How to read this archive"
          description={
            <span>
              Each row is a closed Ethikos decision with its final outcome and scope. Pass/fail is
              derived from the aggregated stance direction at the time the vote closed. For details,
              see the voting methodology.
            </span>
          }
        />

        {/* Summary / KPIs */}
        <ProCard gutter={16} wrap style={{ marginBottom: 16 }}>
          <StatisticCard
            colSpan={{ xs: 24, sm: 8 }}
            statistic={{
              title: 'Closed decisions',
              value: totalDecisions,
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 8 }}
            statistic={{
              title: 'Pass rate',
              value: `${passRate}%`,
              description:
                totalDecisions > 0
                  ? `${passedCount} passed ¬∑ ${rejectedCount} rejected`
                  : 'No decisions yet',
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 8 }}
            statistic={{
              title: 'Regions covered',
              value: coveredRegions,
              description:
                coveredRegions > 0
                  ? 'Distinct policy domains'
                  : 'No regional data',
            }}
          />
        </ProCard>

        {/* Filters */}
        <ProCard
          ghost
          style={{ marginBottom: 16 }}
          title="Filters"
          extra={
            <Text type="secondary">
              Scope, outcome, region and closing period
            </Text>
          }
        >
          <Space wrap>
            <Segmented
              value={scopeFilter}
              onChange={(val) => setScopeFilter(val as ScopeFilter)}
              options={[
                { label: 'All scopes', value: 'all' },
                { label: 'Elite only', value: 'Elite' },
                { label: 'Public only', value: 'Public' },
              ]}
            />
            <Segmented
              value={resultFilter}
              onChange={(val) => setResultFilter(val as ResultFilter)}
              options={[
                { label: 'All outcomes', value: 'all' },
                { label: 'Passed', value: 'passed' },
                { label: 'Rejected', value: 'rejected' },
              ]}
            />
            <Select
              placeholder="Region (all)"
              style={{ minWidth: 200 }}
              allowClear
              value={regionFilter === 'all' ? undefined : regionFilter}
              onChange={(val) =>
                setRegionFilter((val as string | undefined) ?? 'all')
              }
              options={allRegions.map((r) => ({ label: r, value: r }))}
              disabled={allRegions.length === 0}
            />
            <RangePicker
              value={range}
              onChange={(value) => setRange(value as RangeValue)}
              allowEmpty={[true, true]}
            />
          </Space>
        </ProCard>

        {/* Archive table */}
        <ProTable<DecisionResult>
          rowKey="id"
          columns={columns}
          dataSource={filteredItems}
          pagination={{ pageSize: 12 }}
          search={false}
          options={false}
          toolBarRender={false}
        />
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/decide/results/page.tsx =====


===== BEGIN app/ethikos/deliberate/[topic]/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\ethikos\deliberate\[topic]\page.tsx
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { PageContainer, ProCard } from '@ant-design/pro-components';
import {
  Alert,
  Button,
  Card,
  Divider,
  Empty,
  Input,
  List,
  Progress,
  Slider,
  Space,
  Statistic,
  Tabs,
  Tag,
  Timeline,
  Typography,
  message,
} from 'antd';
import { useParams } from 'next/navigation';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';

import EthikosPageShell from '@/app/ethikos/EthikosPageShell';
import {
  fetchTopicDetail,
  fetchTopicPreview,
  type TopicDetailResponse,
  type TopicPreviewResponse,
} from '@/services/deliberate';
import { get, post } from '@/services/_request';

dayjs.extend(relativeTime);

const { Title, Paragraph, Text } = Typography;
const { TextArea } = Input;

/* ------------------------------------------------------------------ */
/*  Local types                                                        */
/* ------------------------------------------------------------------ */

type Preview = TopicPreviewResponse;
type TopicDetail = TopicDetailResponse;
type Statement = TopicDetail['statements'][number];

interface EthikosStancePoint {
  id: number;
  topic: number;
  value: number; // -3 ‚Ä¶ +3
  timestamp: string;
  user?: string;
}

interface UserMeApi {
  username: string;
  name: string | null;
  email: string;
  url: string;
}

interface StanceStats {
  total: number;
  average: number;
  positive: number;
  neutral: number;
  negative: number;
  counts: Record<number, number>;
}

/* ------------------------------------------------------------------ */
/*  Helpers                                                            */
/* ------------------------------------------------------------------ */

function computeStanceStats(stances: EthikosStancePoint[]): StanceStats {
  const counts: Record<number, number> = {
    [-3]: 0,
    [-2]: 0,
    [-1]: 0,
    0: 0,
    1: 0,
    2: 0,
    3: 0,
  };

  let total = 0;
  let sum = 0;
  let positive = 0;
  let neutral = 0;
  let negative = 0;

  for (const s of stances) {
    const v = Math.max(-3, Math.min(3, s.value));
    counts[v] = (counts[v] ?? 0) + 1;
    total += 1;
    sum += v;

    if (v > 0) positive += 1;
    else if (v < 0) negative += 1;
    else neutral += 1;
  }

  const average = total > 0 ? sum / total : 0;

  return {
    total,
    average,
    positive,
    neutral,
    negative,
    counts,
  };
}

function stanceLabel(value: number): string {
  switch (value) {
    case -3:
      return 'Strongly against';
    case -2:
      return 'Moderately against';
    case -1:
      return 'Somewhat against';
    case 0:
      return 'Neutral / undecided';
    case 1:
      return 'Somewhat for';
    case 2:
      return 'Moderately for';
    case 3:
      return 'Strongly for';
    default:
      return 'Neutral / undecided';
  }
}

async function fetchTopicStances(topicId: string): Promise<EthikosStancePoint[]> {
  const numericId = Number(topicId);
  if (!Number.isFinite(numericId)) return [];
  return get<EthikosStancePoint[]>('ethikos/stances/', {
    params: { topic: numericId },
  });
}

async function submitTopicStance(topicId: string, value: number): Promise<void> {
  const numericId = Number(topicId);
  if (!Number.isFinite(numericId)) {
    throw new Error(`Invalid topic id: ${topicId}`);
  }
  await post('ethikos/stances/', {
    topic: numericId,
    value,
  });
}

async function submitTopicArgument(topicId: string, content: string): Promise<void> {
  const numericId = Number(topicId);
  if (!Number.isFinite(numericId)) {
    throw new Error(`Invalid topic id: ${topicId}`);
  }
  await post('ethikos/arguments/', {
    topic: numericId,
    content,
  });
}

/* ------------------------------------------------------------------ */
/*  Main page                                                          */
/* ------------------------------------------------------------------ */

export default function TopicThreadPage() {
  const params = useParams<{ topic: string }>();
  const topicParam = params?.topic;
  const topicId =
    typeof topicParam === 'string'
      ? topicParam
      : Array.isArray(topicParam)
      ? topicParam[0]
      : undefined;

  // Topic meta (title, category, opened at, latest)
  const {
    data: preview,
    loading: loadingPreview,
  } = useRequest<Preview, []>(
    () => fetchTopicPreview(topicId!),
    {
      ready: !!topicId,
      refreshDeps: [topicId],
    },
  );

  // Full statements thread
  const {
    data: detail,
    loading: loadingDetail,
    refresh: refreshDetail,
  } = useRequest<TopicDetail, []>(
    () => fetchTopicDetail(topicId!),
    {
      ready: !!topicId,
      refreshDeps: [topicId],
    },
  );

  // All stances for this topic
  const {
    data: stances,
    loading: loadingStances,
    refresh: refreshStances,
  } = useRequest<EthikosStancePoint[], []>(
    () => fetchTopicStances(topicId!),
    {
      ready: !!topicId,
      refreshDeps: [topicId],
    },
  );

  // Current user (for pre-filling their stance)
  const { data: me } = useRequest<UserMeApi, []>(() => get<UserMeApi>('users/me/'));

  const [stanceValue, setStanceValue] = useState<number>(0);
  const [stanceHydrated, setStanceHydrated] = useState(false);
  const [savingStance, setSavingStance] = useState(false);

  const [newArgument, setNewArgument] = useState('');
  const [savingArgument, setSavingArgument] = useState(false);

  // Initialize slider from existing stance once
  useEffect(() => {
    if (stanceHydrated) return;
    if (!me || !stances) return;

    const my = stances.find((s) => s.user === me.username);
    if (my) {
      setStanceValue(Math.max(-3, Math.min(3, my.value)));
    }
    setStanceHydrated(true);
  }, [me, stances, stanceHydrated]);

  const stanceStats = useMemo(
    () => computeStanceStats(stances ?? []),
    [stances],
  );

  const sortedStatements = useMemo(() => {
    const items = detail?.statements ?? [];
    return [...items].sort(
      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
    );
  }, [detail?.statements]);

  const sliderMarks: Record<number, React.ReactNode> = {
    [-3]: '‚àí3',
    [-2]: '',
    [-1]: '‚àí1',
    0: '0',
    1: '+1',
    2: '',
    3: '+3',
  };

  const handleSubmitStance = async () => {
    if (!topicId) return;
    setSavingStance(true);
    try {
      await submitTopicStance(topicId, stanceValue);
      message.success('Stance saved');
      await refreshStances();
    } catch (err) {
      message.error('Could not save your stance. Please try again.');
    } finally {
      setSavingStance(false);
    }
  };

  const handleSubmitArgument = async () => {
    if (!topicId) return;
    const body = newArgument.trim();
    if (!body) return;

    setSavingArgument(true);
    try {
      await submitTopicArgument(topicId, body);
      message.success('Argument posted');
      setNewArgument('');
      await refreshDetail();
    } catch (err) {
      message.error('Could not post your argument. Please try again.');
    } finally {
      setSavingArgument(false);
    }
  };

  if (!topicId) {
    return (
      <EthikosPageShell
        title="Deliberation thread"
        sectionLabel="Deliberate"
        subtitle="Nuanced stance‚Äëtaking and structured arguments on a single question."
      >
        <PageContainer ghost>
          <Empty description="No topic specified" />
        </PageContainer>
      </EthikosPageShell>
    );
  }

  const shellTitle = preview?.title ?? 'Deliberation thread';
  const shellSubtitle = preview
    ? 'Nuanced stance‚Äëtaking and structured arguments on this topic.'
    : 'Nuanced stance‚Äëtaking and structured arguments on a single question.';

  return (
    <EthikosPageShell
      title={shellTitle}
      sectionLabel="Deliberate"
      subtitle={shellSubtitle}
    >
      <PageContainer ghost loading={loadingPreview && !preview}>
        {preview ? (
          <>
            <Title level={3} style={{ marginTop: 0 }}>
              {preview.title}
            </Title>
            <Paragraph type="secondary" style={{ marginBottom: 24 }}>
              {preview.category ? `${preview.category} ¬∑ ` : ''}
              {preview.createdAt ? dayjs(preview.createdAt).fromNow() : null}
            </Paragraph>

            <ProCard gutter={16} wrap>
              {/* Left column: stance capture + summary */}
              <ProCard colSpan={{ xs: 24, md: 8 }} bordered split="horizontal">
                <ProCard title="Your stance" bordered={false}>
                  <Paragraph type="secondary">
                    Use the scale below to register how strongly you are for or against this topic.
                    You can update your stance as the debate evolves.
                  </Paragraph>

                  <div style={{ marginTop: 16 }}>
                    <Slider
                      min={-3}
                      max={3}
                      step={1}
                      dots
                      marks={sliderMarks}
                      value={stanceValue}
                      tooltip={{
                        formatter: (v) =>
                          typeof v === 'number' ? stanceLabel(v) : '',
                      }}
                      onChange={(v) => setStanceValue(v as number)}
                    />
                    <Space
                      style={{
                        marginTop: 8,
                        justifyContent: 'space-between',
                        width: '100%',
                      }}
                    >
                      <Text type="secondary">Strongly against</Text>
                      <Text type="secondary">Neutral</Text>
                      <Text type="secondary">Strongly for</Text>
                    </Space>

                    <Paragraph style={{ marginTop: 8 }}>
                      Current selection:{' '}
                      <Text strong>{stanceLabel(stanceValue)}</Text>
                    </Paragraph>

                    <Space style={{ marginTop: 8 }}>
                      <Button
                        type="primary"
                        onClick={handleSubmitStance}
                        loading={savingStance}
                      >
                        Save stance
                      </Button>
                      <Button
                        onClick={() => setStanceValue(0)}
                        disabled={savingStance}
                      >
                        Reset to neutral
                      </Button>
                    </Space>

                    <Alert
                      style={{ marginTop: 16 }}
                      type="info"
                      showIcon
                      message="One stance per topic"
                      description="You can adjust your position at any time; only your latest stance is used in the consensus."
                    />
                  </div>
                </ProCard>

                <ProCard title="Collective stance" bordered={false}>
                  <Paragraph type="secondary">
                    Snapshot of all recorded stances on this topic.
                  </Paragraph>

                  <Space
                    size="large"
                    style={{ marginTop: 16, flexWrap: 'wrap' }}
                  >
                    <Statistic
                      title="Participants"
                      value={stanceStats.total}
                      loading={loadingStances}
                    />
                    <Statistic
                      title="Average stance"
                      value={stanceStats.average}
                      precision={2}
                      loading={loadingStances}
                    />
                    <Statistic
                      title="For / Against balance"
                      value={
                        stanceStats.total > 0
                          ? Math.round(
                              (1 -
                                Math.abs(
                                  stanceStats.positive - stanceStats.negative,
                                ) /
                                  stanceStats.total) *
                                100,
                            )
                          : 100
                      }
                      suffix="%"
                      loading={loadingStances}
                    />
                  </Space>

                  <Divider />

                  {stanceStats.total > 0 ? (
                    <Space
                      direction="vertical"
                      style={{ width: '100%' }}
                      size="small"
                    >
                      <div>
                        <Text>For</Text>
                        <Progress
                          percent={Math.round(
                            (stanceStats.positive / stanceStats.total) * 100,
                          )}
                          showInfo
                        />
                      </div>
                      <div>
                        <Text>Neutral</Text>
                        <Progress
                          percent={Math.round(
                            (stanceStats.neutral / stanceStats.total) * 100,
                          )}
                          showInfo
                        />
                      </div>
                      <div>
                        <Text>Against</Text>
                        <Progress
                          percent={Math.round(
                            (stanceStats.negative / stanceStats.total) * 100,
                          )}
                          showInfo
                        />
                      </div>

                      <Paragraph style={{ marginTop: 8 }}>
                        <Tag color="geekblue">‚àí3 ‚Ä¶ +3 scale</Tag>{' '}
                        <Text type="secondary">
                          0 = neutral; negative values = against; positive values
                          = for.
                        </Text>
                      </Paragraph>
                    </Space>
                  ) : (
                    <Empty
                      description="No stances recorded yet"
                      image={Empty.PRESENTED_IMAGE_SIMPLE}
                      style={{ marginTop: 16 }}
                    />
                  )}
                </ProCard>
              </ProCard>

              {/* Right column: debate thread + contribution form */}
              <ProCard colSpan={{ xs: 24, md: 16 }} bordered split="horizontal">
                <ProCard title="Debate thread" bordered={false}>
                  {detail?.statements?.length ? (
                    <Tabs
                      defaultActiveKey="timeline"
                      items={[
                        {
                          key: 'timeline',
                          label: 'Timeline',
                          children: (
                            <Timeline
                              items={detail.statements.map((s) => ({
                                key: s.id,
                                children: <StatementTimelineItem statement={s} />,
                              }))}
                            />
                          ),
                        },
                        {
                          key: 'list',
                          label: 'List view',
                          children: (
                            <List<Statement>
                              dataSource={sortedStatements}
                              loading={loadingDetail && !detail}
                              locale={{
                                emptyText: (
                                  <Empty description="No arguments yet" />
                                ),
                              }}
                              renderItem={(s) => (
                                <li key={s.id}>
                                  <StatementComment
                                    author={s.author}
                                    datetime={dayjs(s.createdAt).fromNow()}
                                    body={s.body}
                                  />
                                </li>
                              )}
                            />
                          ),
                        },
                      ]}
                    />
                  ) : loadingDetail ? (
                    <Card loading />
                  ) : (
                    <Empty description="No arguments yet" />
                  )}
                </ProCard>

                <ProCard title="Add an argument" bordered={false}>
                  <Paragraph type="secondary">
                    Contribute a concise, evidence-based argument. Links and
                    sources are encouraged; personal attacks are not allowed.
                  </Paragraph>

                  <TextArea
                    rows={4}
                    placeholder="Write your argument‚Ä¶"
                    value={newArgument}
                    onChange={(e) => setNewArgument(e.target.value)}
                    style={{ marginTop: 8 }}
                  />

                  <Space style={{ marginTop: 8 }}>
                    <Button
                      type="primary"
                      onClick={handleSubmitArgument}
                      loading={savingArgument}
                      disabled={!newArgument.trim()}
                    >
                      Post argument
                    </Button>
                    <Button
                      onClick={() => setNewArgument('')}
                      disabled={savingArgument || !newArgument}
                    >
                      Clear
                    </Button>
                  </Space>

                  <Paragraph style={{ marginTop: 8 }}>
                    <Text type="secondary">
                      Reminder: arguments that are off-topic or abusive may be
                      hidden after repeated reports.
                    </Text>
                  </Paragraph>
                </ProCard>
              </ProCard>
            </ProCard>

            {/* Optional quick glance at the last few statements from the preview */}
            {preview.latest?.length ? (
              <Card
                title="Latest highlights"
                style={{ marginTop: 24 }}
                bodyStyle={{ padding: 0 }}
              >
                <List
                  dataSource={preview.latest}
                  renderItem={(s) => (
                    <li key={s.id}>
                      <StatementComment
                        author={s.author}
                        body={s.body}
                      />
                    </li>
                  )}
                />
              </Card>
            ) : null}
          </>
        ) : (
          !loadingPreview && <Empty />
        )}
      </PageContainer>
    </EthikosPageShell>
  );
}

/* ------------------------------------------------------------------ */
/*  Sub‚Äëcomponents                                                     */
/* ------------------------------------------------------------------ */

function StatementTimelineItem({ statement }: { statement: Statement }) {
  return (
    <div>
      <div style={{ display: 'flex', gap: 8, alignItems: 'baseline' }}>
        <Text strong>{statement.author}</Text>
        <Text type="secondary">
          {dayjs(statement.createdAt).format('YYYY-MM-DD HH:mm')}
        </Text>
      </div>
      <Paragraph style={{ marginTop: 4, marginBottom: 0 }}>
        {statement.body}
      </Paragraph>
    </div>
  );
}

function StatementComment({
  author,
  datetime,
  body,
}: {
  author: React.ReactNode;
  datetime?: React.ReactNode;
  body: React.ReactNode;
}) {
  return (
    <div style={{ padding: '12px 0' }}>
      <div
        style={{
          display: 'flex',
          gap: 8,
          alignItems: 'baseline',
          justifyContent: 'space-between',
          marginBottom: 4,
        }}
      >
        {author && <Text strong>{author}</Text>}
        {datetime && (
          <Text type="secondary" style={{ marginLeft: 'auto' }}>
            {datetime}
          </Text>
        )}
      </div>
      <Paragraph style={{ marginBottom: 0, whiteSpace: 'pre-wrap' }}>
        {body}
      </Paragraph>
    </div>
  );
}

===== END app/ethikos/deliberate/[topic]/page.tsx =====


===== BEGIN app/ethikos/deliberate/elite/page.tsx =====
// app/ethikos/deliberate/elite/page.tsx
'use client';

import React from 'react';
import Link from 'next/link';
import {
  PageContainer,
  ProCard,
  ProTable,
  StatisticCard,
  ModalForm,
  ProFormText,
  ProFormSelect,
  type ProColumns,
} from '@ant-design/pro-components';
import {
  Alert,
  Button,
  Drawer,
  Empty,
  Space,
  Tag,
  Tooltip,
  message as antdMessage,
} from 'antd';
import { PlusOutlined, ReloadOutlined, FireOutlined, ReadOutlined } from '@ant-design/icons';
import { useRequest, useInterval } from 'ahooks';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';

import EthikosPageShell from '../../EthikosPageShell';
import { fetchEliteTopics, createEliteTopic, fetchTopicPreview } from '@/services/deliberate';
import type { Topic } from '@/types';

dayjs.extend(relativeTime);

/* ------------------------------------------------------------------ */
/*  Types                                                              */
/* ------------------------------------------------------------------ */

interface TopicRow extends Topic {
  createdAt: string;
  lastActivity: string;
  hot: boolean; // calcul√© c√¥t√© serveur
  stanceCount: number; // utilis√© par KPI et la colonne
}

type TopicPreview = {
  id: string;
  title: string;
  category: string;
  createdAt: string;
  latest: Array<{ id: string; author: string; body: string }>;
};

/* ------------------------------------------------------------------ */
/*  Service wrapper (type-safe)                                       */
/* ------------------------------------------------------------------ */
/**
 * Le service natif ne garantit pas toujours `stanceCount`.
 * On normalise ici le payload pour avoir exactement { list: TopicRow[] }.
 * Cela colle au mod√®le EliteTopic / EthikosTopicApi c√¥t√© backend v14.
 */
const useEliteService = () =>
  React.useCallback(async (): Promise<{ list: TopicRow[] }> => {
    const res = await fetchEliteTopics();
    const list = (res?.list ?? []).map((t: any) => ({
      ...t,
      stanceCount: typeof t.stanceCount === 'number' ? t.stanceCount : 0,
    })) as TopicRow[];
    return { list };
  }, []);

/* ------------------------------------------------------------------ */
/*  Composant principal                                                */
/* ------------------------------------------------------------------ */

export default function EliteAgora(): JSX.Element {
  /* ---------- data ---------- */
  const eliteService = useEliteService();
  // useRequest attend 2 g√©n√©riques <TData, TParams>. Le service n‚Äôa pas de params ‚Üí [].
  const { data, loading, refresh } = useRequest<{ list: TopicRow[] }, []>(eliteService);
  // Polling l√©ger pour rester proche du temps r√©el (sans WebSocket)
  useInterval(refresh, 60_000);

  /* ---------- drawer state ---------- */
  const [previewId, setPreviewId] = React.useState<string | null>(null);
  const {
    data: preview,
    loading: previewLoading,
    run: loadPreview,
  } = useRequest<TopicPreview, [string]>(fetchTopicPreview, { manual: true });

  /* ---------- open drawer ---------- */
  const openPreview = React.useCallback(
    (row: TopicRow) => {
      setPreviewId(row.id);
      loadPreview(row.id);
    },
    [loadPreview],
  );

  /* ---------- KPI header ---------- */
  const headerStats = React.useMemo(
    () => [
      { label: 'Open topics', value: data?.list.length ?? 0 },
      {
        label: 'Avg stances / topic',
        value: data?.list?.length
          ? Math.round(
              data!.list.reduce(
                (sum: number, t: TopicRow) => sum + (t.stanceCount ?? 0),
                0,
              ) / data!.list.length,
            )
          : 0,
      },
      {
        label: 'Hot topics',
        value: (data?.list ?? []).filter((t: TopicRow) => t.hot).length,
      },
    ],
    [data],
  );

  /* ---------- filtres cat√©gorie ---------- */
  const categoryFilters = React.useMemo(
    () =>
      Array.from(
        new Set((data?.list ?? []).map((t: TopicRow) => t.category).filter(Boolean)),
      ).map((c) => ({ text: String(c), value: String(c) })),
    [data?.list],
  );

  /* ---------- colonnes ---------- */
  const columns: ProColumns<TopicRow>[] = React.useMemo(
    () => [
      {
        title: 'Title',
        dataIndex: 'title',
        render: (_dom: React.ReactNode, row: TopicRow) => (
          <a onClick={() => openPreview(row)} style={{ cursor: 'pointer' }}>
            {row.title}
          </a>
        ),
      },
      {
        title: 'Category',
        dataIndex: 'category',
        filters: categoryFilters,
        onFilter: (value, record) =>
          String(record.category) === String(value),
        render: (_dom: React.ReactNode, row: TopicRow) => (
          <Tag color="geekblue">{row.category}</Tag>
        ),
      },
      {
        title: 'Stances',
        dataIndex: 'stanceCount',
        sorter: true,
        align: 'right',
      },
      {
        title: 'Last activity',
        dataIndex: 'lastActivity',
        // Pas de valueType non standard. On rend ‚ÄúfromNow‚Äù explicitement.
        render: (_dom: React.ReactNode, row: TopicRow) =>
          dayjs(row.lastActivity).fromNow(),
      },
      {
        title: '',
        dataIndex: 'hot',
        width: 60,
        render: (_dom: React.ReactNode, row: TopicRow) =>
          row.hot ? (
            <Tooltip title="Trending">
              <FireOutlined style={{ color: '#fa541c' }} />
            </Tooltip>
          ) : null,
      },
    ],
    [categoryFilters, openPreview],
  );

  /* ---------- rendu ---------- */
  return (
    <EthikosPageShell
      title="Deliberate ¬∑ Elite Agora"
      metaTitle="Deliberate ¬∑ Elite Agora"
      subtitle={
        <span>
          Expert‚Äëonly structured debates in Korum that use the ‚àí3‚Ä¶+3 stance scale and Ekoh expert
          quorum rules before surfacing aggregated results.
        </span>
      }
      primaryAction={
        <Link href="/ethikos/deliberate/guidelines" prefetch={false}>
          <Button icon={<ReadOutlined />}>Participation guidelines</Button>
        </Link>
      }
    >
      <PageContainer
        ghost
        loading={loading}
        extra={
          <Space>
            <Button
              icon={<ReloadOutlined />}
              onClick={refresh}
              type="text"
              title="Refresh list"
            />
            <NewTopicButton onCreated={refresh} />
          </Space>
        }
      >
        {/* Context block: align√© avec la spec v14 (√©chelle -3‚Ä¶+3, quorum 12 experts) */}
        <ProCard ghost style={{ marginBottom: 16 }}>
          <Alert
            type="info"
            showIcon
            message="Elite agora ‚Äì expert‚Äëonly debates"
            description={
              <>
                <div>
                  Stances use the seven‚Äëlevel nuance scale from ‚àí3 (‚Äústrongly against‚Äù) to +3
                  (‚Äústrongly for‚Äù), 0 = neutral.
                </div>
                <div>
                  Aggregated results are only surfaced once at least 12 distinct experts have
                  contributed on a topic (Ekoh &gt; 75th percentile in their domain).
                </div>
              </>
            }
          />
        </ProCard>

        {/* KPI summary */}
        <ProCard gutter={16} wrap style={{ marginBottom: 16 }}>
          {headerStats.map((k) => (
            <StatisticCard
              key={k.label}
              colSpan={{ xs: 24, sm: 8 }}
              statistic={{ title: k.label, value: k.value }}
            />
          ))}
        </ProCard>

        {/* Liste principale */}
        <ProTable<TopicRow>
          rowKey="id"
          columns={columns}
          dataSource={data?.list}
          search={{ labelWidth: 90, filterType: 'light' }}
          pagination={{ pageSize: 10 }}
        />

        {/* Preview drawer */}
        <Drawer
          width={520}
          open={!!previewId}
          onClose={() => setPreviewId(null)}
          title={preview?.title || 'Preview'}
        >
          {previewLoading ? (
            <Empty description="Loading‚Ä¶" />
          ) : preview ? (
            <>
              <p>
                <strong>Category:</strong> {preview.category}
              </p>
              <p>
                <strong>Opened:</strong>{' '}
                {dayjs(preview.createdAt).format('YYYY-MM-DD HH:mm')}
              </p>
              <h4>Latest statements</h4>
              <ul>
                {preview.latest.map((s) => (
                  <li key={s.id}>
                    <em>{s.author}</em> ‚Äî {s.body}
                  </li>
                ))}
              </ul>
              <Button
                type="primary"
                onClick={() =>
                  window.location.assign(`/ethikos/deliberate/${preview.id}`)
                }
              >
                Go to thread ‚Üí
              </Button>
            </>
          ) : (
            <Empty />
          )}
        </Drawer>
      </PageContainer>
    </EthikosPageShell>
  );
}

/* ------------------------------------------------------------------ */
/*  New Topic modal                                                    */
/* ------------------------------------------------------------------ */

function NewTopicButton({ onCreated }: { onCreated: () => void }) {
  const [visible, setVisible] = React.useState(false);

  // On fige les Params pour typer runAsync correctement
  const { runAsync, loading } = useRequest<unknown, [{ title: string; category: string }]>(
    createEliteTopic,
    {
      manual: true,
      onSuccess: () => {
        antdMessage.success('Topic created üéâ');
        setVisible(false);
        onCreated();
      },
    },
  );

  return (
    <>
      <Button
        icon={<PlusOutlined />}
        type="primary"
        onClick={() => setVisible(true)}
      >
        New Topic
      </Button>

      <ModalForm<{ title: string; category: string }>
        title="Create new topic"
        open={visible}
        onOpenChange={setVisible}
        onFinish={async (values) => {
          await runAsync(values);
          return true;
        }}
        submitter={{ submitButtonProps: { loading } }}
      >
        <ProFormText
          name="title"
          label="Title"
          rules={[{ required: true, min: 10 }]}
        />
        <ProFormSelect
          name="category"
          label="Category"
          options={[
            { label: 'AI Policy', value: 'AI Policy' },
            { label: 'Biotech', value: 'Biotech' },
            { label: 'Ethics', value: 'Ethics' },
          ]}
          rules={[{ required: true }]}
        />
      </ModalForm>
    </>
  );
}

===== END app/ethikos/deliberate/elite/page.tsx =====


===== BEGIN app/ethikos/deliberate/guidelines/page.tsx =====
'use client';

import { PageContainer } from '@ant-design/pro-components';
import {
  Alert,
  Anchor,
  Card,
  Col,
  Divider,
  List,
  Row,
  Space,
  Steps,
  Table,
  Tag,
  Timeline,
  Typography,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import EthikosPageShell from '@/app/ethikos/EthikosPageShell';

const { Title, Paragraph, Text } = Typography;
const { Step } = Steps;

type EvidenceRuleRow = {
  claimType: string;
  minimumEvidence: string;
  preferredSources: string;
};

const evidenceData: EvidenceRuleRow[] = [
  {
    claimType: 'Factual statement about science / policy',
    minimumEvidence: 'At least one credible, verifiable source',
    preferredSources: 'Peer‚Äëreviewed research, official statistics, institutional reports',
  },
  {
    claimType: 'Claim about personal experience or local context',
    minimumEvidence: 'Describe context and limits of your observation',
    preferredSources: 'First‚Äëhand description; optional supporting links',
  },
  {
    claimType: 'Normative / ethical argument',
    minimumEvidence: 'Explicit reasoning chain; reference to frameworks if used',
    preferredSources: 'Ethical frameworks, case law, precedent, structured argumentation',
  },
  {
    claimType: 'Prediction or scenario',
    minimumEvidence: 'Stated assumptions and method (trend, model, analogy)',
    preferredSources: 'Forecasting models, expert assessments, reputable think‚Äëtank reports',
  },
];

const evidenceColumns: ColumnsType<EvidenceRuleRow> = [
  {
    title: 'Claim type',
    dataIndex: 'claimType',
    key: 'claimType',
    width: 260,
  },
  {
    title: 'Minimum evidence',
    dataIndex: 'minimumEvidence',
    key: 'minimumEvidence',
    width: 260,
  },
  {
    title: 'Preferred sources',
    dataIndex: 'preferredSources',
    key: 'preferredSources',
  },
];

const quickChecklistItems: string[] = [
  'Is my contribution respectful and focused on the topic?',
  'Have I separated facts from opinions or values?',
  'Did I provide at least one source or explain my reasoning?',
  'Is my stance slider (‚àí3‚Ä¶+3) aligned with what I actually wrote?',
  'Would I be comfortable seeing this appear in a public archive of the debate?',
];

export default function Guidelines() {
  return (
    <EthikosPageShell
      title="Deliberation guidelines"
      subtitle="Shared rules for Korum debates and Konsultations consultations in ethiKos."
      sectionLabel="Deliberate"
    >
      <PageContainer ghost>
        <Row gutter={[24, 24]}>
          {/* Left column: navigation + quick rules */}
          <Col xs={24} md={7} lg={6}>
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              <Card size="small" title="Navigate this guide">
                <Anchor
                  affix
                  items={[
                    { key: 'overview', href: '#overview', title: 'Overview' },
                    { key: 'principles', href: '#principles', title: 'Core principles' },
                    { key: 'etiquette', href: '#etiquette', title: 'Etiquette & tone' },
                    { key: 'evidence', href: '#evidence', title: 'Evidence & sources' },
                    {
                      key: 'identity',
                      href: '#identity',
                      title: 'Identity, expertise & Ekoh',
                    },
                    { key: 'korum', href: '#korum', title: 'Korum debates' },
                    {
                      key: 'konsultations',
                      href: '#konsultations',
                      title: 'Konsultations consultations',
                    },
                    { key: 'moderation', href: '#moderation', title: 'Moderation ladder' },
                    { key: 'appeals', href: '#appeals', title: 'Appeals & transparency' },
                    { key: 'checklist', href: '#checklist', title: 'Checklist before posting' },
                  ]}
                />
              </Card>

              <Card size="small" title="Hard limits">
                <Paragraph type="secondary" style={{ marginBottom: 8 }}>
                  Content may be removed and accounts restricted for:
                </Paragraph>
                <List
                  size="small"
                  dataSource={[
                    'Harassment, threats, or targeted hate',
                    'Deliberate misinformation (knowingly false claims)',
                    'Doxxing or disclosure of private data',
                    'Incitement to violence or illegal activity',
                  ]}
                  renderItem={(item) => (
                    <List.Item style={{ paddingInline: 0 }}>{item}</List.Item>
                  )}
                />
              </Card>
            </Space>
          </Col>

          {/* Right column: full guidelines */}
          <Col xs={24} md={17} lg={18}>
            {/* Overview */}
            <section id="overview">
              <Title level={3}>What ethiKos is for</Title>
              <Paragraph>
                ethiKos is Konnaxion&apos;s environment for structured ethical debates and public
                consultations. It combines:
              </Paragraph>
              <List
                size="small"
                dataSource={[
                  'Nuanced stance‚Äëtaking on a ‚àí3‚Ä¶+3 scale (from strongly against to strongly for).',
                  'Threaded arguments (Korum) where reasoning and evidence are visible.',
                  'Time‚Äëboxed consultations (Konsultations) with transparent weighted results.',
                ]}
                renderItem={(item) => (
                  <List.Item style={{ paddingInline: 0 }}>{item}</List.Item>
                )}
              />

              <Alert
                style={{ marginTop: 16 }}
                type="info"
                showIcon
                message="Key operational rules"
                description={
                  <Space direction="vertical">
                    <Text>
                      ‚Ä¢ Stance scale is fixed at ‚àí3‚Ä¶+3; 0 = neutral. Your slider should reflect what
                      you actually argue.
                    </Text>
                    <Text>
                      ‚Ä¢ Moderation auto‚Äëhide is triggered after <strong>3 independent reports</strong>.
                    </Text>
                    <Text>
                      ‚Ä¢ &ldquo;Expert cohort&rdquo; views are only shown once at least{' '}
                      <strong>12 qualified experts</strong> have voted.
                    </Text>
                  </Space>
                }
              />
            </section>

            <Divider />

            {/* Core principles */}
            <section id="principles">
              <Title level={3}>Core principles</Title>
              <Space wrap>
                <Tag color="blue">Respect</Tag>
                <Tag color="green">Evidence</Tag>
                <Tag color="gold">Transparency</Tag>
                <Tag color="purple">Nuance</Tag>
                <Tag color="geekblue">Accountability</Tag>
              </Space>

              <Paragraph style={{ marginTop: 12 }}>
                Every contribution in ethiKos should:
              </Paragraph>
              <List
                size="small"
                dataSource={[
                  'Focus on ideas and arguments, not on people.',
                  'Separate facts (what is) from values (what ought to be).',
                  'Acknowledge uncertainty and limits of your own knowledge.',
                  'Make it possible for others to verify what you claim.',
                  'Remain readable and accessible to non‚Äëexperts where possible.',
                ]}
                renderItem={(item) => (
                  <List.Item style={{ paddingInline: 0 }}>{item}</List.Item>
                )}
              />
            </section>

            <Divider />

            {/* Etiquette & tone */}
            <section id="etiquette">
              <Title level={3}>Etiquette & tone</Title>
              <Paragraph>
                The goal is high‚Äësignal, low‚Äëtoxicity debate. The following expectations apply
                across Korum debates and Konsultations comments:
              </Paragraph>

              <List
                size="small"
                dataSource={[
                  'Be concise and stay on topic. Long posts are fine if they are structured.',
                  'Critique arguments, not identities or motives. Avoid ad hominem attacks.',
                  'No mockery, slurs, or profanity aimed at individuals or groups.',
                  'Signal disagreement explicitly (e.g. ‚ÄúI disagree because‚Ä¶‚Äù), not by sarcasm alone.',
                  'Use formatting (short paragraphs, bullet points) to make complex ideas readable.',
                ]}
                renderItem={(item) => (
                  <List.Item style={{ paddingInline: 0 }}>{item}</List.Item>
                )}
              />
            </section>

            <Divider />

            {/* Evidence & sources */}
            <section id="evidence">
              <Title level={3}>Evidence & sources</Title>
              <Paragraph>
                ethikos is not just for opinions; it is built for traceable reasoning. As a rule of
                thumb:
              </Paragraph>

              <List
                size="small"
                dataSource={[
                  'If a claim can be checked, provide enough information for others to check it.',
                  'Link to primary sources where possible (studies, datasets, official documents).',
                  'If you rely on secondary sources (media, blogs), prefer outlets with clear editorial standards.',
                  'Clearly mark personal experience as such and avoid overgeneralising from it.',
                ]}
                renderItem={(item) => (
                  <List.Item style={{ paddingInline: 0 }}>{item}</List.Item>
                )}
              />

              <Card
                size="small"
                style={{ marginTop: 16 }}
                title="Minimum evidence by claim type"
              >
                <Table<EvidenceRuleRow>
                  size="small"
                  rowKey={(row) => row.claimType}
                  columns={evidenceColumns}
                  dataSource={evidenceData}
                  pagination={false}
                />
              </Card>
            </section>

            <Divider />

            {/* Identity, expertise & Ekoh */}
            <section id="identity">
              <Title level={3}>Identity, expertise & Ekoh weighting</Title>
              <Paragraph>
                ethiKos uses the Ekoh reputation system to highlight and weight contributions from
                users with demonstrated expertise, without turning debates into popularity contests.
              </Paragraph>

              <Card size="small">
                <List
                  size="small"
                  dataSource={[
                    'Expert and verified accounts may be tagged (e.g. ‚ÄúDomain expert‚Äù, ‚ÄúVerified identity‚Äù) next to their name.',
                    'Weighted results views (e.g. ‚ÄúExperts only‚Äù) depend on Ekoh scores in the relevant field.',
                    'Reputation is descriptive, not absolute authority: arguments still stand or fall on their merits.',
                    'You may use pseudonyms where allowed, but you remain bound by all guidelines and legal obligations.',
                  ]}
                  renderItem={(item) => (
                    <List.Item style={{ paddingInline: 0, alignItems: 'flex-start' }}>
                      {item}
                    </List.Item>
                  )}
                />
              </Card>
            </section>

            <Divider />

            {/* Korum-specific rules */}
            <section id="korum">
              <Title level={3}>Korum debates: structured arguments</Title>
              <Paragraph>
                Korum is the structured debate environment under ethiKos. Topics represent a single
                question; threads capture arguments and replies.
              </Paragraph>

              <List
                size="small"
                header={<Text strong>When posting in a Korum debate, you should:</Text>}
                dataSource={[
                  'Align your stance slider (‚àí3‚Ä¶+3) with the position you defend in your argument.',
                  'Use one post per main point; avoid packing multiple unrelated arguments into a single block.',
                  'If you reply, indicate whether you are clarifying, objecting, or adding supporting detail.',
                  'Avoid repeating the same argument without engaging with counter‚Äëarguments.',
                  'Flag possible conflicts of interest when relevant to the topic.',
                ]}
                renderItem={(item) => (
                  <List.Item style={{ paddingInline: 0 }}>{item}</List.Item>
                )}
              />
            </section>

            <Divider />

            {/* Konsultations-specific rules */}
            <section id="konsultations">
              <Title level={3}>Konsultations: public consultations & feedback</Title>
              <Paragraph>
                Konsultations host time‚Äëboxed consultations and suggestion flows that may feed into
                policy or organisational decisions.
              </Paragraph>

              <Card size="small">
                <List
                  size="small"
                  header={<Text strong>For consultations and suggestions:</Text>}
                  dataSource={[
                    'Answer the specific question being asked; off‚Äëtopic comments may be hidden.',
                    'When suggesting amendments, be as concrete and implementable as possible.',
                    'Explain trade‚Äëoffs: what might be improved, and what might be lost?',
                    'Avoid campaigns to flood a consultation with near‚Äëidentical comments.',
                    'Respect any participation limits (per‚Äëday comments, max length, etc.) if configured.',
                  ]}
                  renderItem={(item) => (
                    <List.Item style={{ paddingInline: 0, alignItems: 'flex-start' }}>
                      {item}
                    </List.Item>
                  )}
                />
              </Card>
            </section>

            <Divider />

            {/* Moderation ladder */}
            <section id="moderation">
              <Title level={3}>Moderation & reporting ladder</Title>
              <Paragraph>
                Moderation in ethiKos is a mix of community signals and dedicated moderator review.
                Automated actions are transparent and bounded.
              </Paragraph>

              <Steps
                direction="vertical"
                size="small"
                current={2}
                style={{ marginTop: 8, maxWidth: 520 }}
              >
                <Step
                  title="0. Content posted"
                  description="A debate argument, comment, or suggestion is created and visible to participants."
                />
                <Step
                  title="1. Reported by users"
                  description="Other users can report content for clear guideline violations (harassment, spam, misinformation, etc.)."
                />
                <Step
                  title="2. Auto‚Äëhide at 3 independent reports"
                  description="At three distinct reports, the post is temporarily hidden and routed to the moderation queue."
                />
                <Step
                  title="3. Moderator review"
                  description="A moderator reviews the context, reports, and user history to decide on the outcome."
                />
                <Step
                  title="4. Outcome"
                  description="Content may be restored (optionally with a warning), edited/redacted, or permanently removed; account actions apply in repeated or severe cases."
                />
              </Steps>
            </section>

            <Divider />

            {/* Appeals & transparency */}
            <section id="appeals">
              <Title level={3}>Appeals & transparency</Title>
              <Paragraph>
                You can request a second look when your content is removed or your account is
                restricted. Appeals should focus on clarity and evidence.
              </Paragraph>

              <Timeline
                style={{ marginTop: 8 }}
                items={[
                  {
                    color: 'blue',
                    children: (
                      <>
                        <Text strong>1. Trigger</Text>
                        <Paragraph style={{ marginBottom: 0 }}>
                          You receive a notice that a post was removed or that your participation is
                          temporarily limited.
                        </Paragraph>
                      </>
                    ),
                  },
                  {
                    color: 'blue',
                    children: (
                      <>
                        <Text strong>2. Appeal submission</Text>
                        <Paragraph style={{ marginBottom: 0 }}>
                          Use the &ldquo;Request review&rdquo; or equivalent button (where
                          available) to explain why you think the decision was incorrect or
                          disproportionate.
                        </Paragraph>
                      </>
                    ),
                  },
                  {
                    color: 'green',
                    children: (
                      <>
                        <Text strong>3. Secondary review</Text>
                        <Paragraph style={{ marginBottom: 0 }}>
                          A moderator other than the original reviewer, where possible, examines the
                          case and may ask for clarification.
                        </Paragraph>
                      </>
                    ),
                  },
                  {
                    color: 'gray',
                    children: (
                      <>
                        <Text strong>4. Final outcome</Text>
                        <Paragraph style={{ marginBottom: 0 }}>
                          The decision may be upheld or adjusted. In all cases, a short rationale
                          should be recorded for audit and future calibration.
                        </Paragraph>
                      </>
                    ),
                  },
                ]}
              />
            </section>

            <Divider />

            {/* Checklist */}
            <section id="checklist">
              <Title level={3}>Checklist before posting</Title>
              <Paragraph>
                Use this short checklist before you submit a new stance, argument, or suggestion in
                ethiKos:
              </Paragraph>

              <List
                size="small"
                dataSource={quickChecklistItems}
                renderItem={(item) => (
                  <List.Item style={{ paddingInline: 0 }}>
                    <Text>‚Ä¢ {item}</Text>
                  </List.Item>
                )}
              />

              <Alert
                style={{ marginTop: 16 }}
                type="success"
                showIcon
                message="Signal‚Äëboost good debate"
                description={
                  <Paragraph style={{ marginBottom: 0 }}>
                    Use the available tools (up‚Äëweighting, endorsements, sharing within your
                    organisation) to promote high‚Äëquality, well‚Äëevidenced arguments‚Äîregardless of
                    whether you personally agree with them.
                  </Paragraph>
                }
              />
            </section>
          </Col>
        </Row>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/deliberate/guidelines/page.tsx =====


===== BEGIN app/ethikos/EthikosPageShell.tsx =====
// app/ethikos/EthikosPageShell.tsx
'use client';

import React, { type ReactNode } from 'react';
import Head from 'next/head';
import { usePathname } from 'next/navigation';
import { Typography, Space, Tag, Grid } from 'antd';
import usePageTitle from '@/hooks/usePageTitle';

const { Title, Paragraph, Text } = Typography;
const { useBreakpoint } = Grid;

export type EthikosPageShellProps = {
  /** Main page title (H1-equivalent) */
  title: string;
  /** Optional subtitle / helper text under the title */
  subtitle?: ReactNode;
  /**
   * Optional browser <title>.
   * If omitted, the shell generates:
   *  - "ethiKos ¬∑ {sectionLabel} ¬∑ {title}" when sectionLabel is set
   *  - "ethiKos ¬∑ {title}" otherwise
   */
  metaTitle?: string;
  /**
   * Optional section label for the header row
   * Examples: "Debate Hub", "Consultation Hub", "Opinion Analytics",
   *           "Decide", "Deliberate", "Pulse", "Trust", "Impact", "Admin", "Learn"
   *
   * If omitted, the shell will try to infer it from the current /ethikos/* route.
   */
  sectionLabel?: string;
  /** Main CTA on the right (e.g. primary button) */
  primaryAction?: ReactNode;
  /** Secondary actions on the right (e.g. ghost buttons, filters) */
  secondaryActions?: ReactNode;
  /** Main page content */
  children: ReactNode;
  /** Max width for the central content container (like KeenPageShell) */
  maxWidth?: number | string;
};

/**
 * Best-effort inference of the Ethikos section label from the current pathname.
 * This lets /ethikos/* pages get a reasonable default section label without
 * having to pass it explicitly from each page component.
 */
function inferSectionLabel(pathname: string | null | undefined): string | undefined {
  if (!pathname) return undefined;

  const segments = pathname.split('/').filter(Boolean);
  if (segments[0] !== 'ethikos') return undefined;

  const section = segments[1];

  switch (section) {
    case 'decide':
      return 'Decide';
    case 'deliberate':
      return 'Deliberate';
    case 'pulse':
      return 'Pulse';
    case 'trust':
      return 'Trust';
    case 'impact':
      return 'Impact';
    case 'learn':
      return 'Learn';
    case 'admin':
      return 'Admin';
    case 'insights':
      return 'Opinion Analytics';
    default:
      return undefined;
  }
}

/**
 * Central layout wrapper for ethiKos pages.
 *
 * Usage rules:
 * - All Ethikos suite screens (Decide, Deliberate, Pulse, Trust, Impact, Learn, Admin, Insights)
 *   should use this shell for consistent padding, heading and browser <title>.
 * - No extra big <h1> / Title outside of this shell in your pages.
 * - Do not repeat the "ethiKos" module branding in each page; the shell already handles it.
 */
function EthikosPageShell({
  title,
  subtitle,
  metaTitle,
  sectionLabel,
  primaryAction,
  secondaryActions,
  children,
  maxWidth = 1200,
}: EthikosPageShellProps): JSX.Element {
  const pathname = usePathname();
  const screens = useBreakpoint();

  const inferredSectionLabel = inferSectionLabel(pathname);
  const effectiveSectionLabel = sectionLabel ?? inferredSectionLabel;

  const hasActions = Boolean(primaryAction || secondaryActions);

  const finalMetaTitle =
    metaTitle ??
    (effectiveSectionLabel
      ? `ethiKos ¬∑ ${effectiveSectionLabel} ¬∑ ${title}`
      : `ethiKos ¬∑ ${title}`);

  // Keep browser/tab title in sync with the shell meta title
  usePageTitle(finalMetaTitle);

  const isMobile = !screens.md;

  return (
    <>
      <Head>
        <title>{finalMetaTitle}</title>
      </Head>

      <div className="container mx-auto p-5" style={{ maxWidth }}>
        {/* Header */}
        <div style={{ marginBottom: 24 }}>
          <Space
            direction={isMobile ? 'vertical' : 'horizontal'}
            align={isMobile ? 'start' : 'center'}
            size={isMobile ? 12 : 16}
            style={{ width: '100%', justifyContent: 'space-between', gap: 16 }}
          >
            <Space direction="vertical" size={4} style={{ flex: 1, minWidth: 0 }}>
              {/* Module badge + optional section label */}
              <Space align="center" size={8} wrap>
                <Tag color="purple">ethiKos</Tag>
                {effectiveSectionLabel && (
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    {effectiveSectionLabel}
                  </Text>
                )}
              </Space>

              <Title
                level={2}
                style={{
                  margin: 0,
                  fontWeight: 600,
                }}
              >
                {title}
              </Title>

              {subtitle && (
                <Paragraph
                  type="secondary"
                  style={{
                    margin: 0,
                    maxWidth: 720,
                  }}
                >
                  {subtitle}
                </Paragraph>
              )}
            </Space>

            {hasActions && (
              <Space
                align="start"
                size="middle"
                wrap
                style={{
                  justifyContent: isMobile ? 'flex-start' : 'flex-end',
                  marginLeft: isMobile ? 0 : 'auto',
                  minWidth: isMobile ? 'auto' : 0,
                }}
              >
                {secondaryActions}
                {primaryAction}
              </Space>
            )}
          </Space>
        </div>

        {/* Main content */}
        <div>{children}</div>
      </div>
    </>
  );
}

export default EthikosPageShell;

===== END app/ethikos/EthikosPageShell.tsx =====


===== BEGIN app/ethikos/impact/feedback/page.tsx =====
'use client';

import { useMemo } from 'react';
import { useRequest } from 'ahooks';

import {
  PageContainer,
  ProCard,
  ProForm,
  ProFormTextArea,
} from '@ant-design/pro-components';
import {
  Divider,
  Empty,
  Form,
  List,
  Rate,
  Space,
  Tag,
  Typography,
  message,
} from 'antd';

import EthikosPageShell from '../../EthikosPageShell';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchFeedback, submitFeedback, type FeedbackItem } from '@/services/impact';

const { Paragraph, Text } = Typography;

type FeedbackResponse = {
  items: FeedbackItem[];
};

type FeedbackFormValues = {
  body: string;
  rating?: number;
};

export default function FeedbackLoops(): JSX.Element {
  usePageTitle('Impact ¬∑ Feedback');

  const [form] = Form.useForm<FeedbackFormValues>();

  const { data, loading, refresh } = useRequest<FeedbackResponse, []>(fetchFeedback);

  const items = data?.items ?? [];

  const averageRating = useMemo(() => {
    const withRatings = items.filter(
      (f): f is FeedbackItem & { rating: number } =>
        typeof f.rating === 'number' && !Number.isNaN(f.rating),
    );
    if (!withRatings.length) return undefined;
    const total = withRatings.reduce((acc, f) => acc + f.rating, 0);
    return Number((total / withRatings.length).toFixed(1));
  }, [items]);

  const handleFinish = async (values: FeedbackFormValues): Promise<boolean> => {
    const trimmed = values.body?.trim();
    if (!trimmed) {
      message.warning('Please enter your feedback before submitting.');
      return false;
    }

    try {
      await submitFeedback({ body: trimmed, rating: values.rating || undefined });
      form.resetFields();
      await refresh();
      message.success('Thanks, your feedback has been recorded.');
      return true;
    } catch (err) {
      const rawMessage =
        err instanceof Error ? err.message : 'Unable to submit feedback. Please try again.';
      const friendly =
        typeof rawMessage === 'string' &&
        rawMessage.includes('NEXT_PUBLIC_ETHIKOS_FEEDBACK_TOPIC_ID')
          ? 'The feedback channel is not configured yet. Please contact an administrator.'
          : rawMessage;
      message.error(friendly);
      return false;
    }
  };

  return (
    <EthikosPageShell
      title="Feedback loop"
      sectionLabel="Impact"
      subtitle="Share how Ethikos works (or doesn‚Äôt) for you. Feedback is stored as anonymised arguments on a dedicated topic."
    >
      <PageContainer ghost loading={loading}>
        <ProCard title="Share your feedback" ghost>
          <Space direction="vertical" size="middle" style={{ width: '100%' }}>
            <Paragraph type="secondary" style={{ marginBottom: 0 }}>
              This channel closes the feedback loop for the Ethikos module. Tell us what worked,
              what felt confusing, or what is missing. Please avoid sharing personal or sensitive
              data.
            </Paragraph>

            <ProForm<FeedbackFormValues>
              form={form}
              layout="vertical"
              onFinish={handleFinish}
              submitter={{
                searchConfig: {
                  submitText: 'Submit feedback',
                },
                render: (_props, dom) => (
                  <Space
                    style={{
                      width: '100%',
                      justifyContent: 'space-between',
                    }}
                  >
                    <Text type="secondary">
                      Feedback becomes an anonymised argument in a dedicated Ethikos topic.
                    </Text>
                    <Space>{dom}</Space>
                  </Space>
                ),
              }}
            >
              <Form.Item label="Overall experience" name="rating" valuePropName="value">
                <Rate />
              </Form.Item>

              <ProFormTextArea
                name="body"
                label="Your feedback"
                placeholder="Share a concrete story, suggestion or pain point‚Ä¶"
                fieldProps={{ rows: 4 }}
                rules={[
                  {
                    required: true,
                    message: 'Please enter your feedback.',
                  },
                ]}
              />
            </ProForm>
          </Space>
        </ProCard>

        <ProCard
          title="Community feedback"
          ghost
          style={{ marginTop: 24 }}
          extra={
            items.length ? (
              <Space size="middle">
                <Tag>{items.length} entries</Tag>
                {typeof averageRating === 'number' && (
                  <Space size={4}>
                    <Text type="secondary">Avg. rating</Text>
                    <Rate disabled allowHalf value={averageRating} />
                    <Text type="secondary">{averageRating.toFixed(1)}/5</Text>
                  </Space>
                )}
              </Space>
            ) : null
          }
        >
          {items.length ? (
            <>
              <List
                itemLayout="vertical"
                dataSource={items}
                renderItem={(f) => (
                  <List.Item key={f.id}>
                    <List.Item.Meta
                      title={
                        <Space direction="horizontal" size="small">
                          {f.author && <Text strong>{f.author}</Text>}
                          {f.createdAt && (
                            <Text type="secondary" style={{ fontSize: 12 }}>
                              {f.createdAt}
                            </Text>
                          )}
                        </Space>
                      }
                      description={
                        <>
                          {typeof f.rating === 'number' && (
                            <div style={{ marginBottom: 4 }}>
                              <Rate disabled value={f.rating} />
                            </div>
                          )}
                          <Paragraph style={{ marginBottom: 0 }}>{f.body}</Paragraph>
                        </>
                      }
                    />
                  </List.Item>
                )}
              />
              <Divider style={{ marginTop: 16, marginBottom: 0 }} />
              <Text type="secondary">
                Older feedback is kept as part of the impact audit trail.
              </Text>
            </>
          ) : (
            <Empty description="No feedback yet. Be the first to share how Ethikos works for you." />
          )}
        </ProCard>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/impact/feedback/page.tsx =====


===== BEGIN app/ethikos/impact/outcomes/page.tsx =====
// app/ethikos/impact/outcomes/page.tsx
'use client';

import {
  PageContainer,
  ProCard,
  StatisticCard,
  ProTable,
  type ProColumns,
} from '@ant-design/pro-components';
import { Line, Bar } from '@ant-design/plots';
import { Tabs, Empty, Space, Tag, Typography, Divider } from 'antd';
import { BarChartOutlined } from '@ant-design/icons';
import dayjs from 'dayjs';
import { useRequest } from 'ahooks';

import EthikosPageShell from '../../EthikosPageShell';
import { fetchImpactOutcomes } from '@/services/impact';
import {
  fetchDecisionResults,
  type DecisionResult,
} from '@/services/decide';

const { Text } = Typography;

type OutcomesData = Awaited<ReturnType<typeof fetchImpactOutcomes>>;
type DecisionResultsData = Awaited<ReturnType<typeof fetchDecisionResults>>;

type DecisionRow = DecisionResult & { key: string };

export default function Outcomes() {
  const { data: outcomesData, loading: loadingOutcomes } =
    useRequest<OutcomesData, []>(fetchImpactOutcomes);

  const { data: decisionResults, loading: loadingDecisions } =
    useRequest<DecisionResultsData, []>(fetchDecisionResults);

  const loading = loadingOutcomes || loadingDecisions;

  const kpis = outcomesData?.kpis ?? [];
  const charts = outcomesData?.charts ?? [];

  const decisionsItems = decisionResults?.items ?? [];

  const decisionRows: DecisionRow[] = decisionsItems.map((d) => ({
    ...d,
    key: d.id,
  }));

  // Aggregate decision outcomes by region (passed vs rejected)
  const decisionRegionMap = new Map<
    string,
    { region: string; passed: number; rejected: number }
  >();

  for (const d of decisionRows) {
    const region = d.region ?? 'Unspecified';
    const bucket = decisionRegionMap.get(region) ?? {
      region,
      passed: 0,
      rejected: 0,
    };
    if (d.passed) {
      bucket.passed += 1;
    } else {
      bucket.rejected += 1;
    }
    decisionRegionMap.set(region, bucket);
  }

  const decisionOutcomeData = [
    ...Array.from(decisionRegionMap.values()).map((r) => ({
      region: r.region,
      outcome: 'Passed',
      value: r.passed,
    })),
    ...Array.from(decisionRegionMap.values()).map((r) => ({
      region: r.region,
      outcome: 'Rejected',
      value: r.rejected,
    })),
  ];

  const decisionOutcomeConfig = {
    data: decisionOutcomeData,
    isGroup: true,
    xField: 'region',
    yField: 'value',
    seriesField: 'outcome',
  };

  const decisionsColumns: ProColumns<DecisionRow>[] = [
    {
      title: 'Decision',
      dataIndex: 'title',
      key: 'title',
      ellipsis: true,
      width: 260,
    },
    {
      title: 'Result',
      dataIndex: 'passed',
      key: 'passed',
      width: 120,
      render: (_, row) => (
        <Tag color={row.passed ? 'green' : 'red'}>
          {row.passed ? 'PASSED' : 'REJECTED'}
        </Tag>
      ),
    },
    {
      title: 'Scope',
      dataIndex: 'scope',
      key: 'scope',
      width: 120,
      render: (_, row) => (
        <Tag color={row.scope === 'Elite' ? 'geekblue' : 'default'}>
          {row.scope}
        </Tag>
      ),
    },
    {
      title: 'Region',
      dataIndex: 'region',
      key: 'region',
      ellipsis: true,
      render: (_, row) =>
        row.region ?? <Text type="secondary">Unspecified</Text>,
    },
    {
      title: 'Closed at',
      dataIndex: 'closesAt',
      key: 'closesAt',
      width: 180,
      valueType: 'date',
      render: (_, row) => dayjs(row.closesAt).format('YYYY-MM-DD'),
    },
  ];

  return (
    <EthikosPageShell
      title="Impact ¬∑ Outcomes"
      subtitle="Aggregated decision outcomes, agreement levels and regional distribution across Ethikos debates."
    >
      <PageContainer ghost loading={loading}>
        <ProCard gutter={[16, 16]} wrap>
          {/* Outcome KPIs */}
          <ProCard
            colSpan={{ xs: 24, xl: 8 }}
            title={
              <Space>
                <BarChartOutlined />
                <span>Impact ¬∑ Outcomes</span>
              </Space>
            }
          >
            {kpis.length ? (
              <Space
                direction="vertical"
                style={{ width: '100%' }}
                size="large"
              >
                <Space size="large" wrap>
                  {kpis.map((kpi) => (
                    <StatisticCard
                      key={kpi.key}
                      statistic={{
                        title: kpi.label,
                        value: kpi.value,
                        suffix: kpi.key === 'agreement' ? '%' : undefined,
                        description:
                          typeof kpi.delta === 'number' ? (
                            <span
                              style={{
                                color:
                                  kpi.delta >= 0 ? '#3f8600' : '#cf1322',
                              }}
                            >
                              {kpi.delta >= 0 ? '‚ñ≤' : '‚ñº'}{' '}
                              {Math.abs(kpi.delta)}%
                            </span>
                          ) : null,
                      }}
                    />
                  ))}
                </Space>

                <Divider />

                <Space direction="vertical" size={8}>
                  <Text type="secondary">Highlights</Text>
                  <ul style={{ paddingLeft: 20, margin: 0 }}>
                    <li>
                      <Text>
                        <Text strong>
                          {kpis.find((k) => k.key === 'resolved')?.value ?? 0}
                        </Text>{' '}
                        decisions resolved overall.
                      </Text>
                    </li>
                    <li>
                      <Text>
                        Average agreement is{' '}
                        <Text strong>
                          {kpis.find((k) => k.key === 'agreement')?.value ?? 0}
                          %
                        </Text>
                        , combining stance direction and turnout.
                      </Text>
                    </li>
                    <li>
                      <Text>
                        Participation volume is{' '}
                        <Text strong>
                          {kpis.find((k) => k.key === 'participation')?.value ??
                            0}
                        </Text>{' '}
                        total stances across all debates.
                      </Text>
                    </li>
                  </ul>
                </Space>
              </Space>
            ) : (
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description="No outcome metrics available yet"
              />
            )}
          </ProCard>

          {/* Outcome charts */}
          <ProCard
            colSpan={{ xs: 24, xl: 8 }}
            title={
              <Space>
                <BarChartOutlined />
                <span>Outcome distribution</span>
              </Space>
            }
          >
            {charts.length ? (
              <Tabs
                items={charts.map((c) => ({
                  key: c.key,
                  label: c.title,
                  children: (
                    <ProCard ghost>
                      {c.type === 'line' && <Line {...c.config} />}
                      {c.type === 'bar' && <Bar {...c.config} />}
                    </ProCard>
                  ),
                }))}
              />
            ) : (
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description="No outcome charts available yet"
              />
            )}
          </ProCard>

          {/* Closed decisions summary */}
          <ProCard
            colSpan={{ xs: 24, xl: 8 }}
            title="Closed decisions ¬∑ outcomes vs engagement"
            extra={
              <Text type="secondary">
                {decisionRows.length
                  ? `${decisionRows.length} closed decisions`
                  : 'No closed decisions yet'}
              </Text>
            }
          >
            <ProCard split="horizontal" ghost>
              <ProCard title="Outcomes by region">
                {decisionOutcomeData.length === 0 ? (
                  <Empty
                    image={Empty.PRESENTED_IMAGE_SIMPLE}
                    description="No regional outcome data available"
                  />
                ) : (
                  <Bar {...decisionOutcomeConfig} />
                )}
              </ProCard>

              <ProCard title="Closed decisions">
                {decisionRows.length === 0 ? (
                  <Empty
                    image={Empty.PRESENTED_IMAGE_SIMPLE}
                    description="No closed decisions yet"
                  />
                ) : (
                  <ProTable<DecisionRow>
                    rowKey="key"
                    size="small"
                    columns={decisionsColumns}
                    dataSource={decisionRows}
                    pagination={{ pageSize: 8 }}
                    search={false}
                    options={false}
                    toolBarRender={false}
                  />
                )}
              </ProCard>
            </ProCard>
          </ProCard>
        </ProCard>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/impact/outcomes/page.tsx =====


===== BEGIN app/ethikos/impact/tracker/page.tsx =====
// app/ethikos/impact/tracker/page.tsx
'use client';

import { useMemo, useState } from 'react';
import {
  PageContainer,
  ProTable,
  type ProColumns,
} from '@ant-design/pro-components';
import {
  Alert,
  Button,
  Empty,
  Segmented,
  Select,
  Space,
  Statistic,
  Tag,
  Typography,
} from 'antd';
import { ReloadOutlined } from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';

import EthikosPageShell from '../../EthikosPageShell';
import {
  fetchImpactTracker,
  patchImpactStatus,
  type ImpactStatus,
  type TrackerItem,
} from '@/services/impact';

dayjs.extend(relativeTime);

const { Text } = Typography;

type TrackerPayload = { items: TrackerItem[] };
type StatusFilter = 'all' | 'active' | ImpactStatus;

const STATUS_LABELS: Record<ImpactStatus, string> = {
  Planned: 'Planned',
  'In-Progress': 'In progress',
  Completed: 'Completed',
  Blocked: 'Blocked',
};

const STATUS_COLORS: Record<ImpactStatus, string> = {
  Planned: 'default',
  'In-Progress': 'processing',
  Completed: 'success',
  Blocked: 'error',
};

export default function ImpactTracker(): JSX.Element {
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('active');
  const [updatingId, setUpdatingId] = useState<string | null>(null);

  const { data, loading, mutate, refresh } = useRequest<TrackerPayload, []>(
    fetchImpactTracker,
  );

  const items = data?.items ?? [];

  const stats = useMemo(() => {
    const total = items.length;
    const planned = items.filter((i) => i.status === 'Planned').length;
    const inProgress = items.filter((i) => i.status === 'In-Progress').length;
    const completed = items.filter((i) => i.status === 'Completed').length;
    const blocked = items.filter((i) => i.status === 'Blocked').length;
    const active = planned + inProgress;
    return { total, planned, inProgress, completed, blocked, active };
  }, [items]);

  const filteredItems = useMemo(() => {
    if (!items.length) return items;
    if (statusFilter === 'all') return items;
    if (statusFilter === 'active') {
      return items.filter(
        (i) => i.status === 'Planned' || i.status === 'In-Progress',
      );
    }
    return items.filter((i) => i.status === statusFilter);
  }, [items, statusFilter]);

  const statusOptions = (
    ['Planned', 'In-Progress', 'Completed', 'Blocked'] as ImpactStatus[]
  ).map((value) => ({
    value,
    label: STATUS_LABELS[value],
  }));

  const handleStatusChange = async (id: string, status: ImpactStatus) => {
    setUpdatingId(id);
    try {
      await patchImpactStatus(id, status);
      if (data) {
        const next: TrackerPayload = {
          items: data.items.map((item) =>
            item.id === id
              ? { ...item, status, updatedAt: new Date().toISOString() }
              : item,
          ),
        };
        mutate(next);
      } else {
        refresh();
      }
    } finally {
      setUpdatingId(null);
    }
  };

  const columns: ProColumns<TrackerItem>[] = [
    {
      title: 'Topic',
      dataIndex: 'title',
      width: 260,
      ellipsis: true,
    },
    {
      title: 'Owner',
      dataIndex: 'owner',
      width: 180,
    },
    {
      title: 'Status',
      dataIndex: 'status',
      width: 260,
      render: (_, row) => (
        <Space>
          <Tag color={STATUS_COLORS[row.status]}>{STATUS_LABELS[row.status]}</Tag>
          <Select<ImpactStatus>
            size="small"
            style={{ minWidth: 140 }}
            value={row.status}
            options={statusOptions}
            loading={updatingId === row.id}
            onChange={(value) => handleStatusChange(row.id, value)}
          />
        </Space>
      ),
    },
    {
      title: 'Last activity',
      dataIndex: 'updatedAt',
      width: 200,
      sorter: (a, b) =>
        dayjs(a.updatedAt).valueOf() - dayjs(b.updatedAt).valueOf(),
      render: (_, row) =>
        row.updatedAt ? (
          dayjs(row.updatedAt).fromNow()
        ) : (
          <Text type="secondary">‚Äî</Text>
        ),
    },
  ];

  return (
    <EthikosPageShell
      title="Impact tracker"
      sectionLabel="Impact"
      metaTitle="Impact ¬∑ Tracker"
      subtitle="Track the implementation status and follow‚Äëup of Ethikos debates and decisions."
    >
      <PageContainer ghost loading={loading}>
        <Space
          direction="vertical"
          size="middle"
          style={{ width: '100%', marginBottom: 16 }}
        >
          <Alert
            type="info"
            showIcon
            message="Impact tracker"
            description={
              <Text type="secondary">
                Each row represents an Ethikos decision topic. Use the status to
                indicate whether a debate is still planned, currently in progress,
                completed, or blocked awaiting follow‚Äëup.
              </Text>
            }
          />

          <Space
            align="center"
            style={{
              width: '100%',
              justifyContent: 'space-between',
              flexWrap: 'wrap',
            }}
          >
            <Space size="large" wrap>
              <Statistic title="Tracked topics" value={stats.total} />
              <Statistic
                title="Active (planned + in progress)"
                value={stats.active}
              />
              <Statistic title="Completed" value={stats.completed} />
              <Statistic title="Blocked" value={stats.blocked} />
            </Space>

            <Space>
              <Segmented
                value={statusFilter}
                onChange={(value) => setStatusFilter(value as StatusFilter)}
                options={[
                  { label: 'Active', value: 'active' },
                  { label: 'All', value: 'all' },
                  { label: 'Planned', value: 'Planned' },
                  { label: 'In progress', value: 'In-Progress' },
                  { label: 'Completed', value: 'Completed' },
                  { label: 'Blocked', value: 'Blocked' },
                ]}
              />
              <Button
                icon={<ReloadOutlined />}
                onClick={() => refresh()}
                type="default"
              >
                Refresh
              </Button>
            </Space>
          </Space>
        </Space>

        {filteredItems.length === 0 && !loading ? (
          <Empty description="No Ethikos topics found yet. Create a debate or consultation to start tracking impact." />
        ) : (
          <ProTable<TrackerItem>
            rowKey="id"
            columns={columns}
            dataSource={filteredItems}
            pagination={{ pageSize: 12 }}
            search={false}
            toolBarRender={() => [
              <Text key="hint" type="secondary">
                Adjust the status when a debate moves from planning to active work
                or when a decision is finalised.
              </Text>,
            ]}
          />
        )}
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/impact/tracker/page.tsx =====


===== BEGIN app/ethikos/insights/page.tsx =====
// app/ethikos/insights/page.tsx
'use client';

import React, { useState } from 'react';
import {
  PageContainer,
  ProCard,
  StatisticCard,
} from '@ant-design/pro-components';
import { Line, Area, Heatmap, Pie, Radar, Bar } from '@ant-design/plots';
import {
  Badge,
  Button,
  DatePicker,
  Divider,
  Empty,
  Select,
  Skeleton,
  Space,
  Tabs,
  Table,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import {
  SyncOutlined,
  ClockCircleOutlined,
  FilterOutlined,
  AreaChartOutlined,
  BarChartOutlined,
  PieChartOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs, { Dayjs } from 'dayjs';

import ChartCard from '@/components/charts/ChartCard';
import EthikosPageShell from '@/app/ethikos/EthikosPageShell';
import {
  fetchPulseOverview,
  fetchPulseTrends,
  fetchPulseHealth,
  fetchPulseLiveData,
} from '@/services/pulse';
import { fetchImpactOutcomes } from '@/services/impact';
import {
  fetchDecisionResults,
  type DecisionResult,
  type DecisionScope,
} from '@/services/decide';

const { RangePicker } = DatePicker;
const { Option } = Select;
const { Text } = Typography;

type RangeValue = [Dayjs | null, Dayjs | null] | null;

type OpinionAnalyticsData = {
  overview: Awaited<ReturnType<typeof fetchPulseOverview>>;
  trends: Awaited<ReturnType<typeof fetchPulseTrends>>;
  health: Awaited<ReturnType<typeof fetchPulseHealth>>;
  live: Awaited<ReturnType<typeof fetchPulseLiveData>>;
  outcomes: Awaited<ReturnType<typeof fetchImpactOutcomes>>;
  decisions: Awaited<ReturnType<typeof fetchDecisionResults>>;
};

type DecisionRow = DecisionResult & { key: string };

/* ------------------------------------------------------------------ */
/*  Aggregate loader                                                   */
/* ------------------------------------------------------------------ */

async function fetchOpinionAnalytics(): Promise<OpinionAnalyticsData> {
  const [overview, trends, health, live, outcomes, decisions] =
    await Promise.all([
      fetchPulseOverview(),
      fetchPulseTrends(),
      fetchPulseHealth(),
      fetchPulseLiveData(),
      fetchImpactOutcomes(),
      fetchDecisionResults(),
    ]);

  return { overview, trends, health, live, outcomes, decisions };
}

/* ------------------------------------------------------------------ */
/*  Page                                                               */
/* ------------------------------------------------------------------ */

export default function EthikosOpinionAnalytics(): JSX.Element {
  const [timeRange, setTimeRange] = useState<RangeValue>(() => [
    dayjs().subtract(30, 'day'),
    dayjs(),
  ]);
  const [scopeFilter, setScopeFilter] = useState<'all' | DecisionScope>('all');
  const [regionFilter, setRegionFilter] = useState<string | 'all'>('all');

  const { data, loading, error, refresh } =
    useRequest<OpinionAnalyticsData, []>(fetchOpinionAnalytics);

  const lastUpdated = data
    ? dayjs(
        data.overview?.refreshedAt ??
          data.health?.refreshedAt ??
          new Date().toISOString(),
      ).format('HH:mm:ss')
    : null;

  const secondaryActions = (
    <Space>
      {lastUpdated && (
        <Badge
          count={
            <Tooltip title={`Last refreshed at ${lastUpdated}`}>
              <ClockCircleOutlined style={{ color: '#52c41a' }} />
            </Tooltip>
          }
        />
      )}
      <Button
        icon={<SyncOutlined />}
        onClick={() => refresh()}
        size="small"
        type="text"
      />
    </Space>
  );

  const shellProps = {
    title: 'Opinion analytics',
    subtitle:
      'Cross-cutting analytics across debates, participation and decision outcomes in ethiKos.',
    sectionLabel: 'Insights',
    secondaryActions,
  } as const;

  /* ---------- loading skeleton ---------- */
  if (loading && !data) {
    return (
      <EthikosPageShell {...shellProps}>
        <PageContainer ghost>
          <Skeleton active />
        </PageContainer>
      </EthikosPageShell>
    );
  }

  /* ---------- error state ---------- */
  if (error) {
    return (
      <EthikosPageShell {...shellProps}>
        <PageContainer ghost>
          <Empty
            description="Failed to load opinion analytics"
            image={Empty.PRESENTED_IMAGE_SIMPLE}
          >
            <Button
              icon={<SyncOutlined />}
              onClick={refresh}
              type="primary"
            >
              Retry
            </Button>
          </Empty>
        </PageContainer>
      </EthikosPageShell>
    );
  }

  /* ---------- empty safeguard ---------- */
  if (!data) {
    return (
      <EthikosPageShell {...shellProps}>
        <PageContainer ghost>
          <Empty description="No analytics data available yet" />
        </PageContainer>
      </EthikosPageShell>
    );
  }

  const { overview, trends, health, live, outcomes, decisions } = data;

  const allRegions = Array.from(
    new Set(
      decisions.items
        .map((d) => d.region)
        .filter((r): r is string => !!r),
    ),
  );

  const [start, end] = timeRange ?? [];

  const filteredDecisions: DecisionRow[] = decisions.items
    .filter((d) => {
      if (scopeFilter !== 'all' && d.scope !== scopeFilter) return false;
      if (regionFilter !== 'all' && (d.region ?? 'Unspecified') !== regionFilter)
        return false;
      if (start && end) {
        const closedTs = new Date(d.closesAt).getTime();
        const startTs = start.toDate().getTime();
        const endTs = end.toDate().getTime();
        if (!Number.isFinite(closedTs)) return false;
        if (closedTs < startTs || closedTs > endTs) return false;
      }
      return true;
    })
    .map((d) => ({ ...d, key: d.id }));

  // Aggregate decision outcomes by region (for bar chart)
  const decisionRegionMap = new Map<
    string,
    { region: string; passed: number; rejected: number }
  >();

  for (const d of filteredDecisions) {
    const region = d.region ?? 'Unspecified';
    const bucket = decisionRegionMap.get(region) ?? {
      region,
      passed: 0,
      rejected: 0,
    };
    if (d.passed) {
      bucket.passed += 1;
    } else {
      bucket.rejected += 1;
    }
    decisionRegionMap.set(region, bucket);
  }

  const decisionOutcomeData = [
    ...Array.from(decisionRegionMap.values()).map((r) => ({
      region: r.region,
      outcome: 'Passed',
      value: r.passed,
    })),
    ...Array.from(decisionRegionMap.values()).map((r) => ({
      region: r.region,
      outcome: 'Rejected',
      value: r.rejected,
    })),
  ];

  const decisionOutcomeConfig = {
    data: decisionOutcomeData,
    isGroup: true,
    xField: 'region',
    yField: 'value',
    seriesField: 'outcome',
  };

  const decisionsColumns: ColumnsType<DecisionRow> = [
    {
      title: 'Decision',
      dataIndex: 'title',
      key: 'title',
      ellipsis: true,
      width: 260,
    },
    {
      title: 'Result',
      dataIndex: 'passed',
      key: 'passed',
      width: 120,
      render: (passed: boolean) => (
        <Tag color={passed ? 'green' : 'red'}>
          {passed ? 'PASSED' : 'REJECTED'}
        </Tag>
      ),
    },
    {
      title: 'Scope',
      dataIndex: 'scope',
      key: 'scope',
      width: 120,
      render: (scope: DecisionScope) => (
        <Tag color={scope === 'Elite' ? 'geekblue' : 'default'}>{scope}</Tag>
      ),
    },
    {
      title: 'Region',
      dataIndex: 'region',
      key: 'region',
      ellipsis: true,
      render: (region?: string) =>
        region ?? <Text type="secondary">Unspecified</Text>,
    },
    {
      title: 'Closed at',
      dataIndex: 'closesAt',
      key: 'closesAt',
      width: 180,
      render: (value: string) => dayjs(value).format('YYYY-MM-DD'),
    },
  ];

  return (
    <EthikosPageShell {...shellProps}>
      <PageContainer ghost>
        {/* ------------------------------------------------------------------ */}
        {/* Filters                                                            */}
        {/* ------------------------------------------------------------------ */}
        <ProCard ghost style={{ marginBottom: 16 }}>
          <Space wrap align="center">
            <Space>
              <FilterOutlined />
              <Text strong>Filters</Text>
            </Space>

            <Divider type="vertical" />

            <Space size="small">
              <Text type="secondary">Time window</Text>
              <RangePicker
                allowEmpty={[true, true]}
                value={timeRange ?? undefined}
                onChange={(range) => setTimeRange(range as RangeValue)}
              />
            </Space>

            <Space size="small">
              <Text type="secondary">Scope</Text>
              <Select<'all' | DecisionScope>
                style={{ minWidth: 120 }}
                value={scopeFilter}
                onChange={(val) => setScopeFilter(val)}
              >
                <Option value="all">All</Option>
                <Option value="Elite">Elite</Option>
                <Option value="Public">Public</Option>
              </Select>
            </Space>

            <Space size="small">
              <Text type="secondary">Region</Text>
              <Select<string | 'all'>
                style={{ minWidth: 160 }}
                value={regionFilter}
                onChange={(val) => setRegionFilter(val)}
              >
                <Option value="all">All regions</Option>
                {allRegions.map((region) => (
                  <Option key={region} value={region}>
                    {region}
                  </Option>
                ))}
              </Select>
            </Space>
          </Space>
        </ProCard>

        {/* ------------------------------------------------------------------ */}
        {/* Overview KPIs (Pulse overview)                                    */}
        {/* ------------------------------------------------------------------ */}
        <ProCard gutter={[16, 16]} wrap style={{ marginBottom: 16 }}>
          {overview.kpis.map((kpi) => (
            <StatisticCard
              key={kpi.label}
              colSpan={{
                xs: 24,
                sm: 12,
                md: 12,
                lg: 6,
              }}
              statistic={{
                title: kpi.label,
                value: kpi.value,
                suffix: kpi.delta !== undefined ? '%' : undefined,
                description:
                  kpi.delta !== undefined ? (
                    <span
                      style={{
                        color: kpi.delta >= 0 ? '#3f8600' : '#cf1322',
                      }}
                    >
                      {kpi.delta >= 0 ? '‚ñ≤' : '‚ñº'} {Math.abs(kpi.delta)}%
                    </span>
                  ) : null,
              }}
              chart={
                <ChartCard
                  type="area"
                  height={60}
                  data={kpi.history.map((h) => ({
                    x: h.date,
                    y: h.value,
                  }))}
                  tooltip={{
                    formatter: (datum: any) =>
                      `${dayjs(datum.x).format('MMM D')}: ${datum.y}`,
                  }}
                />
              }
            />
          ))}
        </ProCard>

        {/* ------------------------------------------------------------------ */}
        {/* Live participation counters                                       */}
        {/* ------------------------------------------------------------------ */}
        <ProCard
          title={
            <Space>
              <AreaChartOutlined />
              <span>Live participation</span>
            </Space>
          }
          gutter={[16, 16]}
          wrap
          style={{ marginBottom: 16 }}
        >
          {live.counters.map((c) => (
            <StatisticCard
              key={c.label}
              colSpan={{ xs: 24, sm: 12, md: 12, lg: 6 }}
              statistic={{
                title: (
                  <Space>
                    {c.label}
                    <Badge
                      status={
                        c.trend && c.trend > 0
                          ? 'success'
                          : c.trend && c.trend < 0
                          ? 'error'
                          : 'default'
                      }
                    />
                  </Space>
                ),
                value: c.value,
                precision: 0,
              }}
              chart={
                <ChartCard
                  type="line"
                  data={c.history.map(({ ts, value }) => ({
                    x: ts,
                    y: value,
                  }))}
                  height={50}
                />
              }
            />
          ))}
        </ProCard>

        {/* ------------------------------------------------------------------ */}
        {/* Trends & participation health                                     */}
        {/* ------------------------------------------------------------------ */}
        <ProCard gutter={[16, 16]} wrap style={{ marginBottom: 16 }}>
          <ProCard
            colSpan={{ xs: 24, xl: 16 }}
            title={
              <Space>
                <AreaChartOutlined />
                <span>Opinion trends</span>
              </Space>
            }
          >
            <Tabs
              items={trends.charts.map((c) => ({
                key: c.key,
                label: c.title,
                children: (
                  <ProCard ghost>
                    {c.type === 'line' && <Line {...c.config} />}
                    {c.type === 'area' && <Area {...c.config} />}
                    {c.type === 'heatmap' && <Heatmap {...c.config} />}
                  </ProCard>
                ),
              }))}
            />
          </ProCard>

          <ProCard
            colSpan={{ xs: 24, xl: 8 }}
            title={
              <Space>
                <PieChartOutlined />
                <span>Participation health</span>
              </Space>
            }
          >
            <ProCard split="horizontal" ghost>
              <ProCard title="Diversity radar">
                <Radar {...health.radarConfig} />
              </ProCard>
              <ProCard title="Ethics score breakdown">
                <Pie {...health.pieConfig} />
              </ProCard>
            </ProCard>
          </ProCard>
        </ProCard>

        {/* ------------------------------------------------------------------ */}
        {/* Outcomes & decisions                                              */}
        {/* ------------------------------------------------------------------ */}
        <ProCard gutter={[16, 16]} wrap>
          {/* Outcome KPIs */}
          <ProCard
            colSpan={{ xs: 24, xl: 8 }}
            title={
              <Space>
                <BarChartOutlined />
                <span>Impact ¬∑ Outcomes</span>
              </Space>
            }
          >
            <Space direction="vertical" style={{ width: '100%' }} size="large">
              <Space size="large" wrap>
                {outcomes.kpis.map((kpi) => (
                  <StatisticCard
                    key={kpi.key}
                    statistic={{
                      title: kpi.label,
                      value: kpi.value,
                      suffix: kpi.key === 'agreement' ? '%' : undefined,
                      description:
                        typeof kpi.delta === 'number' ? (
                          <span
                            style={{
                              color: kpi.delta >= 0 ? '#3f8600' : '#cf1322',
                            }}
                          >
                            {kpi.delta >= 0 ? '‚ñ≤' : '‚ñº'} {Math.abs(kpi.delta)}%
                          </span>
                        ) : null,
                    }}
                  />
                ))}
              </Space>

              <Divider />

              <Space direction="vertical" size={8}>
                <Text type="secondary">Highlights</Text>
                <ul style={{ paddingLeft: 20, margin: 0 }}>
                  <li>
                    <Text>
                      <Text strong>
                        {outcomes.kpis.find((k) => k.key === 'resolved')?.value ??
                          0}
                      </Text>{' '}
                      decisions resolved overall.
                    </Text>
                  </li>
                  <li>
                    <Text>
                      Average agreement is{' '}
                      <Text strong>
                        {outcomes.kpis.find((k) => k.key === 'agreement')?.value ??
                          0}
                        %
                      </Text>
                      , combining stance direction and turnout.
                    </Text>
                  </li>
                  <li>
                    <Text>
                      Participation volume is{' '}
                      <Text strong>
                        {outcomes.kpis.find((k) => k.key === 'participation')
                          ?.value ?? 0}
                      </Text>{' '}
                      total stances across all debates.
                    </Text>
                  </li>
                </ul>
              </Space>
            </Space>
          </ProCard>

          {/* Outcome charts */}
          <ProCard
            colSpan={{ xs: 24, xl: 8 }}
            title={
              <Space>
                <BarChartOutlined />
                <span>Outcome distribution</span>
              </Space>
            }
          >
            <Tabs
              items={outcomes.charts.map((c) => ({
                key: c.key,
                label: c.title,
                children: (
                  <ProCard ghost>
                    {c.type === 'line' && <Line {...c.config} />}
                    {c.type === 'bar' && <Bar {...c.config} />}
                  </ProCard>
                ),
              }))}
            />
          </ProCard>

          {/* Closed decisions table */}
          <ProCard
            colSpan={{ xs: 24, xl: 8 }}
            title="Closed decisions ¬∑ outcomes vs engagement"
            extra={
              <Text type="secondary">
                Filtered: {filteredDecisions.length} / {decisions.items.length}
              </Text>
            }
          >
            <ProCard split="horizontal" ghost>
              <ProCard title="Outcomes by region">
                {decisionOutcomeData.length === 0 ? (
                  <Empty
                    image={Empty.PRESENTED_IMAGE_SIMPLE}
                    description="No regional outcome data for current filters"
                  />
                ) : (
                  <Bar {...decisionOutcomeConfig} />
                )}
              </ProCard>

              <ProCard title="Closed decisions">
                <Table<DecisionRow>
                  size="small"
                  columns={decisionsColumns}
                  dataSource={filteredDecisions}
                  pagination={{ pageSize: 8 }}
                  rowKey="key"
                />
              </ProCard>
            </ProCard>
          </ProCard>
        </ProCard>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/insights/page.tsx =====


===== BEGIN app/ethikos/layout.tsx =====
// app/ethikos/layout.tsx
'use client'

/**
 * Updated Ethikos segment layout.
 *
 * Changes:
 *  - Keep existing defaulting to ?sidebar=ethikos (preserves URL hash on replace).
 *  - Use shared <MainLayout /> container for global nav + header.
 *  - Improve Suspense fallback with reusable <Loading fullscreen />.
 *  - Wrap children with ProComponents <WaterMark> to subtly brand the suite.
 *
 * Source references:
 *  - Original layout baseline: :contentReference[oaicite:0]{index=0}
 *  - MainLayout (global AntD shell): :contentReference[oaicite:1]{index=1}
 *  - Loading component used in fallback: :contentReference[oaicite:2]{index=2}
 */

import type { ReactNode } from 'react'
import React, { Suspense, useEffect } from 'react'
import { Layout } from 'antd'
import { WaterMark } from '@ant-design/pro-components'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'

import MainLayout from '@/components/layout-components/MainLayout'
import Loading from '@/components/Loading'

const { Content } = Layout

interface SegmentLayoutProps {
  children: ReactNode
}

/**
 * Inner shell that *defaults* the sidebar to "ethikos" via ?sidebar=ethikos
 * when the query param is missing.
 *
 * Important:
 * - If ?sidebar is already set (ekoh, keenkonnect, kreative, ‚Ä¶), it is respected.
 *   This lets the module switcher (LogoTitle) change suites even while you are
 *   on a /ethikos/* URL.
 */
function EthikosShell({ children }: SegmentLayoutProps) {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  useEffect(() => {
    const currentSidebar = searchParams.get('sidebar')

    // Only inject the default if the param is absent.
    // Do NOT override if the user explicitly chose another suite.
    if (currentSidebar !== null) return

    const params = new URLSearchParams(Array.from(searchParams.entries()))
    params.set('sidebar', 'ethikos')

    // Preserve current hash if present (client-only)
    const hash =
      typeof window !== 'undefined' && window.location?.hash
        ? window.location.hash
        : ''

    router.replace(`${pathname}?${params.toString()}${hash}`)
    // We intentionally depend on the stable searchParams object + router + pathname.
  }, [router, pathname, searchParams])

  return (
    <MainLayout>
      {/* Subtle suite watermark; page-level PageContainer can still set ghost or override visuals */}
      <WaterMark
        content="ethiKos"
        gapX={120}
        gapY={120}
        fontColor="rgba(0,0,0,0.04)"
      >
        {children}
      </WaterMark>
    </MainLayout>
  )
}

/**
 * Segment layout for all /ethikos/* pages.
 *
 * - Wraps content in MainLayout (global Ant Design layout + navigation).
 * - Ensures the Ethikos suite is active by default in the sidebar.
 * - Provides an Ant Design‚Äìbased Suspense fallback while children load.
 */
export default function SegmentLayout({ children }: SegmentLayoutProps) {
  return (
    <Suspense
      fallback={
        <Layout style={{ minHeight: '100vh' }}>
          <Content
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <Loading fullscreen message="Loading ethiKos‚Ä¶" />
          </Content>
        </Layout>
      }
    >
      <EthikosShell>{children}</EthikosShell>
    </Suspense>
  )
}

===== END app/ethikos/layout.tsx =====


===== BEGIN app/ethikos/learn/changelog/page.tsx =====
'use client';

// app/ethikos/learn/changelog/page.tsx.
import React, { useMemo, useState } from 'react';
import {
  PageContainer,
  ProCard,
  ProList,
  StatisticCard,
} from '@ant-design/pro-components';
import {
  Anchor,
  Badge,
  Button,
  DatePicker,
  Empty,
  Input,
  Segmented,
  Space,
  Tag,
  Timeline,
  Tooltip,
  Typography,
} from 'antd';
import {
  CalendarOutlined,
  ClockCircleOutlined,
  CopyOutlined,
  ReloadOutlined,
  UnorderedListOutlined,
  ApartmentOutlined,
  DownloadOutlined,
  FilterOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs, { Dayjs } from 'dayjs';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchChangelog, type ChangelogEntry } from '@/services/learn';
import EthikosPageShell from '../../EthikosPageShell';

const { RangePicker } = DatePicker;
const { Text, Title } = Typography;

type RangeValue = [Dayjs | null, Dayjs | null] | null;

// Local response type matching services/learn.ts
type ChangelogResponse = {
  entries: ChangelogEntry[];
};

const TAG_COLOR: Record<string, string> = {
  NEW: 'green',
  FIX: 'blue',
  IMPROVE: 'geekblue',
  DOCS: 'gold',
  CHORE: 'default',
  BREAKING: 'red',
  DEPRECATE: 'volcano',
  INITIAL: 'purple',
};

function normalizeTag(t: string): string {
  return t.trim().toUpperCase();
}

export default function Changelog() {
  // Kept for compatibility; EthikosPageShell will set the final <title>.
  usePageTitle('Learn ¬∑ Changelog');

  const { data, loading, error, refresh } = useRequest<ChangelogResponse, []>(
    fetchChangelog,
  );

  // Raw entries
  const entries: ChangelogEntry[] = data?.entries ?? [];

  // Sort newest ‚Üí oldest
  const sortedEntries = useMemo<ChangelogEntry[]>(
    () =>
      [...entries].sort(
        (a, b) => dayjs(b.date).valueOf() - dayjs(a.date).valueOf(),
      ),
    [entries],
  );

  // Derive available tags (normalized)
  const allTags = useMemo<string[]>(
    () =>
      Array.from(
        new Set(
          sortedEntries.flatMap((e: ChangelogEntry) =>
            e.tags.map((t: string) => normalizeTag(t)),
          ),
        ),
      ).sort(),
    [sortedEntries],
  );

  // Derive versions (keep order of first appearance in sorted list)
  const allVersions = useMemo<string[]>(() => {
    const seen = new Set<string>();
    const out: string[] = [];
    for (const e of sortedEntries) {
      if (!seen.has(e.version)) {
        seen.add(e.version);
        out.push(e.version);
      }
    }
    return out;
  }, [sortedEntries]);

  // UI state
  const [query, setQuery] = useState('');
  const [range, setRange] = useState<RangeValue>(null);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [view, setView] = useState<'timeline' | 'list'>('timeline');

  // Filtered list
  const filtered = useMemo<ChangelogEntry[]>(() => {
    let list: ChangelogEntry[] = sortedEntries;

    // text search (version or notes)
    const q = query.trim().toLowerCase();
    if (q) {
      list = list.filter((e: ChangelogEntry) => {
        if (e.version.toLowerCase().includes(q)) return true;
        return e.notes.some((n: string) => n.toLowerCase().includes(q));
      });
    }

    // tag filter (OR)
    if (selectedTags.length > 0) {
      const allow = new Set(selectedTags.map(normalizeTag));
      list = list.filter((e: ChangelogEntry) =>
        e.tags.map(normalizeTag).some((t: string) => allow.has(t)),
      );
    }

    // date range (inclusive)
    if (range && range[0] && range[1]) {
      const start = range[0].startOf('day').valueOf();
      const end = range[1].endOf('day').valueOf();
      list = list.filter((e: ChangelogEntry) => {
        const t = dayjs(e.date).valueOf();
        return t >= start && t <= end;
      });
    }

    return list;
  }, [sortedEntries, query, selectedTags, range]);

  // Stats
  const totalEntries = filtered.length;
  const versionCount = useMemo(
    () => new Set(filtered.map((e) => e.version)).size,
    [filtered],
  );
  const tagCounts = useMemo<[string, number][]>(() => {
    const m = new Map<string, number>();
    for (const e of filtered) {
      for (const t of e.tags) {
        const k = normalizeTag(t);
        m.set(k, (m.get(k) ?? 0) + 1);
      }
    }
    return Array.from(m.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 4); // top 4
  }, [filtered]);

  // Safely compute lastUpdated without risking undefined access
  const lastUpdated = useMemo<string | null>(() => {
    const firstEntry = sortedEntries[0];
    if (!firstEntry) return null;
    return dayjs(firstEntry.date).format('YYYY-MM-DD');
  }, [sortedEntries]);

  // Utilities
  function exportJSON() {
    const blob = new Blob([JSON.stringify(filtered, null, 2)], {
      type: 'application/json',
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ethikos-changelog.json';
    a.click();
    URL.revokeObjectURL(url);
  }

  async function copyMarkdown() {
    const md = filtered
      .map(
        (e: ChangelogEntry) =>
          `### ${e.version} ‚Äî ${dayjs(e.date).format('YYYY-MM-DD')}\n` +
          e.notes.map((n: string) => `- ${n}`).join('\n'),
      )
      .join('\n\n');
    try {
      await navigator.clipboard.writeText(md);
    } catch {
      // no-op
    }
  }

  // Render helpers
  function renderTags(tags: string[]) {
    return (
      <Space size={[4, 4]} wrap>
        {tags.map((t: string) => {
          const key = normalizeTag(t);
          const color = TAG_COLOR[key] ?? 'default';
          return (
            <Tag key={key} color={color}>
              {key}
            </Tag>
          );
        })}
      </Space>
    );
  }

  // Anchor for versions (filtered)
  const anchorItems =
    filtered.length > 0
      ? Array.from(new Set(filtered.map((e) => e.version))).map((v) => ({
          key: v,
          href: `#ver-${v}`,
          title: v,
        }))
      : [];

  const shellTitle = 'Learn ¬∑ Changelog';
  const shellSubtitle =
    'Versioned changes, fixes and improvements across the Ethikos layer.';
  const shellSectionLabel = 'Learn';

  const compactActions = (
    <Space>
      {lastUpdated && (
        <Badge
          count={
            <Tooltip title={`Last entry date ${lastUpdated}`}>
              <ClockCircleOutlined style={{ color: '#52c41a' }} />
            </Tooltip>
          }
        />
      )}
      <Button icon={<ReloadOutlined />} onClick={refresh} type="text" />
    </Space>
  );

  const fullActions = (
    <Space wrap>
      {lastUpdated && (
        <Badge
          count={
            <Tooltip title={`Last entry date ${lastUpdated}`}>
              <ClockCircleOutlined style={{ color: '#52c41a' }} />
            </Tooltip>
          }
        />
      )}

      <Segmented
        value={view}
        onChange={(val) => setView(val as typeof view)}
        options={[
          { label: 'Timeline', value: 'timeline', icon: <CalendarOutlined /> },
          { label: 'List', value: 'list', icon: <UnorderedListOutlined /> },
        ]}
      />

      <Tooltip title="Export JSON">
        <Button icon={<DownloadOutlined />} onClick={exportJSON} size="small" />
      </Tooltip>

      <Tooltip title="Copy Markdown">
        <Button icon={<CopyOutlined />} onClick={copyMarkdown} size="small" />
      </Tooltip>

      <Tooltip title="Refresh">
        <Button icon={<ReloadOutlined />} onClick={refresh} size="small" />
      </Tooltip>
    </Space>
  );

  // Loading / error / empty
  if (loading && !data) {
    return (
      <EthikosPageShell
        title={shellTitle}
        sectionLabel={shellSectionLabel}
        subtitle={shellSubtitle}
      >
        <PageContainer ghost loading>
          <div style={{ height: 240 }} />
        </PageContainer>
      </EthikosPageShell>
    );
  }

  if (error) {
    return (
      <EthikosPageShell
        title={shellTitle}
        sectionLabel={shellSectionLabel}
        subtitle={shellSubtitle}
        secondaryActions={compactActions}
      >
        <PageContainer ghost>
          <Empty description="Failed to load changelog." />
        </PageContainer>
      </EthikosPageShell>
    );
  }

  if (!filtered.length && !loading) {
    return (
      <EthikosPageShell
        title={shellTitle}
        sectionLabel={shellSectionLabel}
        subtitle={shellSubtitle}
        secondaryActions={compactActions}
      >
        <PageContainer ghost>
          <ProCard>
            <Empty description="No changelog entries match your filters." />
          </ProCard>
        </PageContainer>
      </EthikosPageShell>
    );
  }

  return (
    <EthikosPageShell
      title={shellTitle}
      sectionLabel={shellSectionLabel}
      subtitle={shellSubtitle}
      secondaryActions={fullActions}
    >
      <PageContainer ghost loading={loading}>
        {/* KPI / stats */}
        <ProCard gutter={[16, 16]} wrap style={{ marginBottom: 16 }}>
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 8, xl: 6 }}
            statistic={{
              title: 'Entries',
              value: totalEntries,
              description: <Text type="secondary">After filters</Text>,
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 8, xl: 6 }}
            statistic={{
              title: 'Versions',
              value: versionCount,
              description: <Text type="secondary">In current view</Text>,
            }}
          />
          {tagCounts.map(([tag, count]) => (
            <StatisticCard
              key={tag}
              colSpan={{ xs: 24, sm: 12, md: 8, xl: 6 }}
              statistic={{
                title: (
                  <Space>
                    <Tag color={TAG_COLOR[tag] ?? 'default'}>{tag}</Tag>
                  </Space>
                ),
                value: count,
                description: <Text type="secondary">Entries with tag</Text>,
              }}
            />
          ))}
        </ProCard>

        {/* Filters + content */}
        <ProCard split="vertical" ghost>
          {/* Left: filters + anchors */}
          <ProCard
            colSpan={{ xs: 24, md: 8, lg: 7, xl: 6 }}
            title={
              <Space>
                <FilterOutlined />
                <span>Filter</span>
              </Space>
            }
          >
            <Space direction="vertical" style={{ width: '100%' }} size="large">
              <div>
                <Text type="secondary">Search</Text>
                <Input.Search
                  placeholder="Version or note text‚Ä¶"
                  allowClear
                  value={query}
                  onChange={(e) => setQuery(e.target.value)}
                  style={{ marginTop: 8 }}
                />
              </div>

              <div>
                <Text type="secondary">Date range</Text>
                <div style={{ marginTop: 8 }}>
                  <RangePicker
                    allowEmpty={[true, true]}
                    value={range as any}
                    onChange={(val) => setRange(val as RangeValue)}
                    style={{ width: '100%' }}
                  />
                </div>
              </div>

              <div>
                <Text type="secondary">Tags</Text>
                <div style={{ marginTop: 8 }}>
                  <Space size={[6, 8]} wrap>
                    {allTags.length === 0 ? (
                      <Text type="secondary">No tags</Text>
                    ) : (
                      allTags.map((t: string) => (
                        <Tag.CheckableTag
                          key={t}
                          checked={selectedTags.includes(t)}
                          onChange={(checked) => {
                            setSelectedTags((prev) =>
                              checked
                                ? [...prev, t]
                                : prev.filter((p) => p !== t),
                            );
                          }}
                        >
                          <Tag
                            color={TAG_COLOR[t] ?? 'default'}
                            style={{ marginRight: 0 }}
                          >
                            {t}
                          </Tag>
                        </Tag.CheckableTag>
                      ))
                    )}
                  </Space>
                </div>
              </div>

              <div>
                <Text type="secondary">Versions</Text>
                <Anchor
                  affix={false}
                  items={anchorItems}
                  style={{ marginTop: 8, maxHeight: 320, overflow: 'auto' }}
                />
              </div>
            </Space>
          </ProCard>

          {/* Right: content */}
          <ProCard
            colSpan={{ xs: 24, md: 16, lg: 17, xl: 18 }}
            title={
              <Space>
                {view === 'timeline' ? (
                  <ApartmentOutlined />
                ) : (
                  <UnorderedListOutlined />
                )}
                <span>Changelog entries</span>
              </Space>
            }
          >
            {view === 'timeline' ? (
              <Timeline mode="left">
                {filtered.map((e: ChangelogEntry, idx: number) => {
                  const id = `ver-${e.version}`;
                  return (
                    <Timeline.Item
                      key={`${e.version}-${e.date}-${idx}`}
                      label={dayjs(e.date).format('YYYY-MM-DD')}
                      dot={<CalendarOutlined />}
                    >
                      <div id={id} style={{ scrollMarginTop: 72 }}>
                        <Space
                          direction="vertical"
                          size="small"
                          style={{ width: '100%' }}
                        >
                          <Space size="small" align="center" wrap>
                            <Title level={5} style={{ margin: 0 }}>
                              {e.version}
                            </Title>
                            {renderTags(e.tags)}
                          </Space>
                          <ul style={{ marginTop: 4 }}>
                            {e.notes.map((n: string, i: number) => (
                              <li key={i}>
                                <Text>{n}</Text>
                              </li>
                            ))}
                          </ul>
                        </Space>
                      </div>
                    </Timeline.Item>
                  );
                })}
              </Timeline>
            ) : (
              <ProList<ChangelogEntry>
                rowKey={(row, idx) => `${row.version}-${row.date}-${idx}`}
                dataSource={filtered}
                split
                pagination={{ pageSize: 10, showSizeChanger: false }}
                metas={{
                  title: {
                    render: (_dom, row) => (
                      <Space size="small" wrap>
                        <Text strong>{row.version}</Text>
                        <Tag icon={<CalendarOutlined />}>
                          {dayjs(row.date).format('YYYY-MM-DD')}
                        </Tag>
                      </Space>
                    ),
                  },
                  subTitle: {
                    render: (_dom, row) => renderTags(row.tags),
                  },
                  description: {
                    render: (_dom, row) => (
                      <ul style={{ marginTop: 4 }}>
                        {row.notes.map((n: string, i: number) => (
                          <li key={i}>
                            <Text>{n}</Text>
                          </li>
                        ))}
                      </ul>
                    ),
                  },
                }}
              />
            )}
          </ProCard>
        </ProCard>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/learn/changelog/page.tsx =====


===== BEGIN app/ethikos/learn/glossary/page.tsx =====
// app/ethikos/learn/glossary/page.tsx
// Sources: current implementation and related services in the dump
// :contentReference[oaicite:0]{index=0} :contentReference[oaicite:1]{index=1} :contentReference[oaicite:2]{index=2}

'use client';

import { useMemo, useState } from 'react';
import {
  PageContainer,
  ProTable,
} from '@ant-design/pro-components';
import type {
  ProColumns,
} from '@ant-design/pro-components';
import {
  Empty,
  Input,
  Tag,
  Typography,
  Segmented,
  Space,
  Button,
  Statistic,
  Tooltip,
} from 'antd';
import { SyncOutlined, DownloadOutlined } from '@ant-design/icons';
import { useRequest } from 'ahooks';
import { fetchGlossary } from '@/services/learn';
import type { GlossaryItem } from '@/services/learn';
import EthikosPageShell from '@/app/ethikos/EthikosPageShell';

export default function Glossary() {
  const { data, loading, error, refresh } = useRequest(fetchGlossary);
  const [query, setQuery] = useState('');
  const [letter, setLetter] = useState<string>('all');

  const items: GlossaryItem[] = data?.items ?? [];

  const letters = useMemo(() => {
    const set = new Set<string>();
    for (const it of items) {
      const ch = (it.term?.[0] ?? '').toUpperCase();
      const isAZ = ch >= 'A' && ch <= 'Z';
      set.add(isAZ ? ch : '#');
    }
    // ensure predictable order (All, #, A..Z filtered to present ones)
    const result: { label: string; value: string }[] = [{ label: 'All', value: 'all' }];
    if (set.has('#')) result.push({ label: '#', value: '#' });
    for (let c = 65; c <= 90; c++) {
      const l = String.fromCharCode(c);
      if (set.has(l)) result.push({ label: l, value: l });
    }
    return result;
  }, [items]);

  const filteredByQuery = useMemo(() => {
    const q = query.trim().toLowerCase();
    if (!q) return items;
    return items.filter((t) => {
      const def = t.definition ?? '';
      return t.term.toLowerCase().includes(q) || def.toLowerCase().includes(q);
    });
  }, [items, query]);

  const filtered = useMemo(() => {
    if (letter === 'all') return filteredByQuery;
    return filteredByQuery.filter((t) => {
      const ch = (t.term?.[0] ?? '').toUpperCase();
      const isAZ = ch >= 'A' && ch <= 'Z';
      return letter === '#' ? !isAZ : ch === letter;
    });
  }, [filteredByQuery, letter]);

  const columns: ProColumns<GlossaryItem>[] = [
    {
      title: 'Term',
      dataIndex: 'term',
      width: 280,
      sorter: (a, b) => a.term.localeCompare(b.term),
      render: (dom, record) => (
        <span>
          <Tag style={{ marginRight: 8 }}>
            {(record.term?.[0] ?? '#').toUpperCase()}
          </Tag>
          {dom}
        </span>
      ),
    },
    {
      title: 'Definition',
      dataIndex: 'definition',
      ellipsis: true,
    },
  ];

  function exportCsv(rows: GlossaryItem[]) {
    const header = ['Term', 'Definition', 'Initial'];
    const lines = rows.map((r) => {
      const term = (r.term ?? '').replace(/"/g, '""');
      const def = (r.definition ?? '').replace(/"/g, '""');
      const initial = (r.term?.[0] ?? '#').toUpperCase();
      return [`"${term}"`, `"${def}"`, `"${initial}"`].join(',');
    });
    const csv = [header.join(','), ...lines].join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ethikos_glossary.csv';
    a.click();
    URL.revokeObjectURL(url);
  }

  const headerStats = (
    <Space size="large" wrap>
      <Statistic title="Total terms" value={items.length} />
      <Statistic title="Shown" value={filtered.length} />
      <Tooltip title="Reload from server">
        <Button icon={<SyncOutlined />} onClick={refresh} />
      </Tooltip>
    </Space>
  );

  return (
    <EthikosPageShell
      title="Glossary"
      sectionLabel="Learn"
      subtitle="Glossary terms are synced from your Ethikos categories."
      secondaryActions={headerStats}
    >
      <PageContainer ghost loading={loading}>
        <Space
          direction="vertical"
          size="middle"
          style={{ width: '100%', marginBottom: 8 }}
        >
          <Space wrap>
            <Input.Search
              placeholder="Search by term or definition‚Ä¶"
              allowClear
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              style={{ width: 360 }}
            />
            <Segmented
              options={letters}
              value={letter}
              onChange={(val) => setLetter(String(val))}
            />
            <Button
              icon={<DownloadOutlined />}
              onClick={() => exportCsv(filtered)}
            >
              Export CSV
            </Button>
          </Space>
        </Space>

        {error && (
          <Typography.Paragraph type="danger" style={{ marginBottom: 16 }}>
            Unable to load the glossary right now. Please try again later.
          </Typography.Paragraph>
        )}

        <ProTable<GlossaryItem>
          rowKey="id"
          size="small"
          columns={columns}
          dataSource={filtered}
          search={false}
          pagination={{ pageSize: 20, showSizeChanger: true, showQuickJumper: true }}
          options={{ fullScreen: true, density: true, setting: true }}
          toolBarRender={() => [
            <Typography.Text key="count" type="secondary">
              {filtered.length} of {items.length} terms
            </Typography.Text>,
          ]}
          locale={{
            emptyText: (
              <Empty
                description={
                  query || letter !== 'all'
                    ? 'No terms match your filters'
                    : 'No glossary terms available yet'
                }
                image={Empty.PRESENTED_IMAGE_SIMPLE}
              />
            ),
          }}
        />
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/learn/glossary/page.tsx =====


===== BEGIN app/ethikos/learn/guides/page.tsx =====
'use client'

/**
 * Ethikos ¬∑ Learn ¬∑ Guides
 *
 * References:
 * - Baseline page implementation from the app dump.
 * - Data service: services/learn.ts (fetchGuides).
 */

import { useMemo, useState } from 'react'
import {
  PageContainer,
  ProCard,
  StatisticCard,
} from '@ant-design/pro-components'
import { Pie } from '@ant-design/plots'
import {
  Anchor,
  Typography,
  Input,
  Empty,
  Button,
  Space,
  Tag,
  FloatButton,
} from 'antd'
import { LinkOutlined, SyncOutlined, ReadOutlined } from '@ant-design/icons'
import { useRequest } from 'ahooks'
import EthikosPageShell from '../../EthikosPageShell'
import { fetchGuides } from '@/services/learn'

type GuideSection = {
  id: string
  title: string
  content: string
}

function wordsOf(text: string) {
  if (!text) return 0
  const m = text.trim().match(/\S+/g)
  return m ? m.length : 0
}

export default function Guides() {
  const { data, loading, error, refresh } = useRequest(fetchGuides)
  const [query, setQuery] = useState('')

  const sections: GuideSection[] = (data?.sections ?? []) as GuideSection[]

  const computed = useMemo(() => {
    const q = query.trim().toLowerCase()

    const enriched = sections.map((s) => {
      const wc = wordsOf(s.content)
      const minutes = Math.max(1, Math.round(wc / 220)) // ~220 wpm
      return { ...s, wc, minutes }
    })

    const filtered = q
      ? enriched.filter(
          (s) =>
            s.title.toLowerCase().includes(q) ||
            s.content.toLowerCase().includes(q),
        )
      : enriched

    const totals = filtered.reduce(
      (acc, s) => {
        acc.words += s.wc
        acc.minutes += s.minutes
        return acc
      },
      { words: 0, minutes: 0 },
    )

    const pieData = filtered.map((s) => ({
      type: s.title,
      value: s.wc || 1,
    }))

    const anchorItems = filtered.map((s) => ({
      key: s.id,
      href: `#${s.id}`,
      title: s.title,
    }))

    return { filtered, totals, pieData, anchorItems }
  }, [sections, query])

  const shellProps = {
    title: 'Guides',
    sectionLabel: 'Learn',
  } as const

  /* ---------- error state ---------- */
  if (error) {
    return (
      <EthikosPageShell {...shellProps}>
        <PageContainer ghost>
          <Empty
            description="Failed to load guides"
            image={Empty.PRESENTED_IMAGE_SIMPLE}
          >
            <Button icon={<SyncOutlined />} onClick={refresh} type="primary">
              Retry
            </Button>
          </Empty>
        </PageContainer>
      </EthikosPageShell>
    )
  }

  const pieConfig = {
    data: computed.pieData,
    angleField: 'value',
    colorField: 'type',
    radius: 0.9,
    legend: false as const,
    label: { type: 'inner', offset: '-30%', content: '' },
    interactions: [{ type: 'element-active' }],
  }

  return (
    <EthikosPageShell {...shellProps}>
      <PageContainer
        ghost
        loading={loading}
        extra={
          <Space size="large">
            <Space direction="vertical" size={0}>
              <Typography.Text type="secondary">Guides</Typography.Text>
              <Typography.Text strong>{sections.length}</Typography.Text>
            </Space>
            <Space direction="vertical" size={0}>
              <Typography.Text type="secondary">Est. reading</Typography.Text>
              <Typography.Text strong>
                {computed.totals.minutes} min
              </Typography.Text>
            </Space>
          </Space>
        }
      >
        {/* Overview stats */}
        <ProCard gutter={16} wrap style={{ marginBottom: 16 }}>
          <StatisticCard
            statistic={{
              title: 'Total guides',
              value: sections.length,
              icon: <ReadOutlined />,
            }}
          />
          <StatisticCard
            statistic={{
              title: 'Words (filtered)',
              value: computed.totals.words,
            }}
          />
          <StatisticCard
            statistic={{
              title: 'Est. read time',
              value: computed.totals.minutes,
              suffix: 'min',
            }}
          />
          <ProCard colSpan="100%" ghost />
        </ProCard>

        <ProCard split="vertical" ghost>
          {/* Left: Navigation & search */}
          <ProCard
            colSpan={{ xs: 24, sm: 24, md: 7, lg: 6, xl: 6 }}
            title="Navigate guides"
          >
            <Typography.Paragraph type="secondary">
              Practical walkthroughs for using ethiKos: when to launch a debate,
              choosing Elite vs Public, and how outcomes flow into impact.
            </Typography.Paragraph>

            <Input.Search
              placeholder="Filter guides‚Ä¶"
              allowClear
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              style={{ marginBottom: 16 }}
            />

            <Anchor
              affix={false}
              items={computed.anchorItems}
              style={{ maxHeight: 360, overflow: 'auto' }}
            />

            <Typography.Paragraph
              type="secondary"
              style={{ marginTop: 16, marginBottom: 0 }}
            >
              {computed.filtered.length} guide
              {computed.filtered.length === 1 ? '' : 's'} match your filter.
            </Typography.Paragraph>
          </ProCard>

          {/* Right: Content + mini chart */}
          <ProCard
            colSpan={{ xs: 24, sm: 24, md: 17, lg: 18, xl: 18 }}
            title="Guided flows"
          >
            {computed.filtered.length === 0 ? (
              <Empty description="No guides match your query." />
            ) : (
              <>
                {/* Mini chart to visualize section sizes */}
                <ProCard
                  ghost
                  style={{ marginBottom: 16 }}
                  title="Guide size breakdown"
                >
                  <Pie {...pieConfig} />
                </ProCard>

                {computed.filtered.map((s) => (
                  <section key={s.id} id={s.id} style={{ marginBottom: 32 }}>
                    <Space align="baseline" size="middle">
                      <Typography.Title level={3} style={{ marginTop: 0 }}>
                        {s.title}
                      </Typography.Title>
                      <Tag>{s.minutes} min</Tag>
                      <Button
                        type="text"
                        size="small"
                        icon={<LinkOutlined />}
                        onClick={() => {
                          const url = `${location.pathname}#${s.id}`
                          navigator.clipboard?.writeText(url)
                        }}
                      >
                        Copy link
                      </Button>
                    </Space>
                    <Typography.Paragraph style={{ whiteSpace: 'pre-line' }}>
                      {s.content}
                    </Typography.Paragraph>
                  </section>
                ))}
              </>
            )}
          </ProCard>
        </ProCard>

        <FloatButton.BackTop visibilityHeight={240} />
      </PageContainer>
    </EthikosPageShell>
  )
}

===== END app/ethikos/learn/guides/page.tsx =====


===== BEGIN app/ethikos/pulse/health/page.tsx =====
'use client';

/**
 * Updated from app dump and aligned with existing service API.
 * Baseline reference: app/ethikos/pulse/health/page.tsx in the dump. :contentReference[oaicite:0]{index=0}
 * Service contract & data shape: services/pulse.ts (fetchPulseHealth, HealthSummary). :contentReference[oaicite:1]{index=1}
 * Header/refresh pattern mirrored from Pulse Overview page implementation. :contentReference[oaicite:2]{index=2}
 */

import {
  PageContainer,
  ProCard,
  StatisticCard,
} from '@ant-design/pro-components';
import { Pie, Radar } from '@ant-design/plots';
import {
  Badge,
  Button,
  Empty,
  List,
  Skeleton,
  Space,
  Tooltip,
  Typography,
} from 'antd';
import { SyncOutlined, ClockCircleOutlined } from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';

import EthikosPageShell from '../../EthikosPageShell';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchPulseHealth, type HealthSummary } from '@/services/pulse';

const { Text } = Typography;

type RadarPoint = { metric: string; score: number };
type PiePoint = { type: string; value: number };

function computeHealthStatus(
  constructiveness?: number,
  engagement?: number,
): { status: 'success' | 'warning' | 'error'; label: string } {
  const c = constructiveness ?? 0;
  const e = engagement ?? 0;

  if (c >= 70 && e >= 50) return { status: 'success', label: 'Healthy' };
  if (c >= 50) return { status: 'warning', label: 'Watch' };
  return { status: 'error', label: 'At risk' };
}

export default function PulseHealth(): JSX.Element {
  usePageTitle('Pulse ¬∑ Participation Health');

  const { data, loading, error, refresh } = useRequest<HealthSummary, []>(
    fetchPulseHealth,
  );

  const lastUpdated = data ? dayjs(data.refreshedAt).format('HH:mm:ss') : null;
  const shellTitle = 'Pulse ¬∑ Participation Health';

  /* ---------- loading skeleton ---------- */
  if (loading && !data) {
    return (
      <EthikosPageShell title={shellTitle} sectionLabel="Pulse">
        <PageContainer ghost>
          <Skeleton active />
        </PageContainer>
      </EthikosPageShell>
    );
  }

  /* ---------- error state ---------- */
  if (error) {
    return (
      <EthikosPageShell title={shellTitle} sectionLabel="Pulse">
        <PageContainer ghost>
          <Empty
            description="Failed to load participation health"
            image={Empty.PRESENTED_IMAGE_SIMPLE}
          >
            <Button icon={<SyncOutlined />} onClick={refresh} type="primary">
              Retry
            </Button>
          </Empty>
        </PageContainer>
      </EthikosPageShell>
    );
  }

  /* ---------- empty safeguard ---------- */
  if (!data) {
    return (
      <EthikosPageShell title={shellTitle} sectionLabel="Pulse">
        <PageContainer ghost>
          <Empty description="No participation data available yet" />
        </PageContainer>
      </EthikosPageShell>
    );
  }

  /* ---------- derive metrics from configs ---------- */
  const radarPoints = (data.radarConfig?.data as RadarPoint[]) ?? [];
  const metricMap = new Map<string, number>();
  radarPoints.forEach((p) => {
    if (p && typeof p.metric === 'string') metricMap.set(p.metric, p.score);
  });

  const participation = metricMap.get('Participation');
  const engagement = metricMap.get('Engagement');
  const balance = metricMap.get('Balance');
  const constructiveness = metricMap.get('Constructiveness');

  const { status: healthStatus, label: healthLabel } = computeHealthStatus(
    constructiveness,
    engagement,
  );

  const piePoints = (data.pieConfig?.data as PiePoint[]) ?? [];
  const totalSentiment =
    piePoints.reduce(
      (sum, p) => (typeof p.value === 'number' ? sum + p.value : sum),
      0,
    ) || 0;

  const sentimentDetails = piePoints.map((p) => {
    const percent =
      totalSentiment > 0 ? Math.round((p.value / totalSentiment) * 100) : 0;
    return { label: p.type, count: p.value, percent };
  });

  const secondaryActions = (
    <Space>
      <Badge status={healthStatus} text={healthLabel} />
      {lastUpdated && (
        <Badge
          count={
            <Tooltip title={`Last refreshed at ${lastUpdated}`}>
              <ClockCircleOutlined style={{ color: '#52c41a' }} />
            </Tooltip>
          }
        />
      )}
      <Button
        icon={<SyncOutlined />}
        onClick={refresh}
        size="small"
        type="text"
      />
    </Space>
  );

  return (
    <EthikosPageShell
      title={shellTitle}
      sectionLabel="Pulse"
      secondaryActions={secondaryActions}
    >
      <PageContainer ghost>
        {/* KPI summary */}
        <ProCard gutter={[16, 16]} wrap style={{ marginBottom: 16 }}>
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 12, lg: 6 }}
            statistic={{
              title: 'Participation',
              value: participation ?? 0,
              suffix: '%',
              description: (
                <Text type="secondary">
                  Share of users who have expressed a stance.
                </Text>
              ),
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 12, lg: 6 }}
            statistic={{
              title: 'Engagement',
              value: engagement ?? 0,
              suffix: '%',
              description: (
                <Text type="secondary">
                  Voting and reactions across recent debates.
                </Text>
              ),
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 12, lg: 6 }}
            statistic={{
              title: 'Balance',
              value: balance ?? 0,
              suffix: '%',
              description: (
                <Text type="secondary">
                  How evenly positions are distributed between positive and
                  negative.
                </Text>
              ),
            }}
          />
          <StatisticCard
            colSpan={{ xs: 24, sm: 12, md: 12, lg: 6 }}
            statistic={{
              title: 'Constructiveness',
              value: constructiveness ?? 0,
              suffix: '%',
              description: (
                <Text type="secondary">
                  Composite of participation and balance.
                </Text>
              ),
            }}
          />
        </ProCard>

        {/* Radar + sentiment breakdown */}
        <ProCard gutter={[16, 16]} wrap>
          <ProCard
            colSpan={{ xs: 24, xl: 14 }}
            title="Participation health radar"
            extra={<Text type="secondary">Each axis normalised to 0‚Äì100.</Text>}
          >
            <Radar {...data.radarConfig} />
          </ProCard>

          <ProCard
            colSpan={{ xs: 24, xl: 10 }}
            title="Ethics sentiment breakdown"
            split="horizontal"
          >
            <ProCard ghost>
              <Pie {...data.pieConfig} />
            </ProCard>

            <ProCard ghost>
              <List
                size="small"
                dataSource={sentimentDetails}
                renderItem={(item) => (
                  <List.Item>
                    <Space>
                      <Text strong>{item.label}</Text>
                      <Text type="secondary">
                        {item.count} stances ({item.percent}%)
                      </Text>
                    </Space>
                  </List.Item>
                )}
              />
            </ProCard>
          </ProCard>
        </ProCard>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/pulse/health/page.tsx =====


===== BEGIN app/ethikos/pulse/live/page.tsx =====
// app/ethikos/pulse/live/page.tsx
'use client';

/**
 * Updated implementation based on Ant Design / ProComponents plan:
 * - Keep KPI counters with sparkline charts
 * - Add live activity feed (topics, stances, arguments)
 * - Add "Open debates" table with last activity
 * - Wire into existing services/hooks and axios helper
 */

import React from 'react';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import {
  PageContainer,
  ProCard,
  ProTable,
  StatisticCard,
  type ProColumns,
} from '@ant-design/pro-components';
import {
  Alert,
  Badge,
  Button,
  Empty,
  List,
  Space,
  Switch,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  ThunderboltOutlined,
  ClockCircleOutlined,
  SyncOutlined,
  FireOutlined,
  MessageOutlined,
  ProfileOutlined,
} from '@ant-design/icons';
import { useInterval, useRequest } from 'ahooks';

import EthikosPageShell from '../../EthikosPageShell';
import ChartCard from '@/components/charts/ChartCard';
import { fetchPulseLiveData, type LiveCounter } from '@/services/pulse';
import { get } from '@/services/_request';

dayjs.extend(relativeTime);

/* ------------------------------------------------------------------ */
/*  Minimal API DTOs (aligned with services/pulse.ts)                  */
/* ------------------------------------------------------------------ */

type TopicStatus = 'open' | 'closed' | 'archived';

type EthikosTopicApi = {
  id: number;
  title: string;
  status: TopicStatus;
  created_at: string;
  last_activity: string;
};

type EthikosStanceApi = {
  id: number;
  topic: number;
  value: number; // ‚àí3‚Ä¶+3
  timestamp: string;
};

type EthikosArgumentApi = {
  id: number;
  topic: number;
  user: string;
  content: string;
  created_at: string;
};

/* ------------------------------------------------------------------ */
/*  Local data loaders                                                 */
/* ------------------------------------------------------------------ */

async function fetchRecentActivity(): Promise<FeedItem[]> {
  const [topics, stances, args] = await Promise.all([
    get<EthikosTopicApi[]>('ethikos/topics/'),
    get<EthikosStanceApi[]>('ethikos/stances/'),
    get<EthikosArgumentApi[]>('ethikos/arguments/'),
  ]);

  const topicById = new Map<number, EthikosTopicApi>(
    topics.map((t) => [t.id, t]),
  );

  const items: FeedItem[] = [
    // New or updated debates (use created + last_activity as signals)
    ...topics.map<FeedItem>((t) => ({
      id: `topic-${t.id}-${t.created_at}`,
      ts: t.created_at,
      kind: 'topic',
      topicId: t.id,
      title: t.title,
      summary:
        t.status === 'open'
          ? 'New debate created'
          : `Debate status changed to ${t.status}`,
    })),
    // Stances
    ...stances.map<FeedItem>((s) => ({
      id: `stance-${s.id}`,
      ts: s.timestamp,
      kind: 'stance',
      topicId: s.topic,
      title: topicById.get(s.topic)?.title ?? `Topic #${s.topic}`,
      summary: `New stance submitted: ${s.value >= 0 ? '+' : ''}${s.value}`,
      extra: { value: s.value },
    })),
    // Arguments
    ...args.map<FeedItem>((a) => ({
      id: `arg-${a.id}`,
      ts: a.created_at,
      kind: 'argument',
      topicId: a.topic,
      title: topicById.get(a.topic)?.title ?? `Topic #${a.topic}`,
      summary: `${a.user} commented: ${truncate(a.content, 120)}`,
    })),
  ];

  // Sort newest first and take a reasonable slice
  return items
    .sort((a, b) => dayjs(b.ts).valueOf() - dayjs(a.ts).valueOf())
    .slice(0, 20);
}

async function fetchOpenTopics(): Promise<EthikosTopicApi[]> {
  const topics = await get<EthikosTopicApi[]>('ethikos/topics/');
  return topics
    .filter((t) => t.status === 'open')
    .sort(
      (a, b) =>
        dayjs(b.last_activity).valueOf() - dayjs(a.last_activity).valueOf(),
    );
}

/* ------------------------------------------------------------------ */
/*  Types & helpers                                                    */
/* ------------------------------------------------------------------ */

type FeedItem =
  | {
      id: string;
      ts: string;
      kind: 'topic';
      topicId: number;
      title: string;
      summary: string;
    }
  | {
      id: string;
      ts: string;
      kind: 'stance';
      topicId: number;
      title: string;
      summary: string;
      extra: { value: number };
    }
  | {
      id: string;
      ts: string;
      kind: 'argument';
      topicId: number;
      title: string;
      summary: string;
    };

function truncate(s: string, n = 100) {
  return s.length > n ? `${s.slice(0, n - 1)}‚Ä¶` : s;
}

/* ------------------------------------------------------------------ */
/*  Main component                                                     */
/* ------------------------------------------------------------------ */

export default function PulseLive(): JSX.Element {
  const [autoRefresh, setAutoRefresh] = React.useState(true);
  const [lastUpdated, setLastUpdated] = React.useState<string | null>(null);

  // Counters (with 20s polling by default)
  const liveReq = useRequest<{ counters: LiveCounter[] }, []>(
    fetchPulseLiveData,
    {
      pollingInterval: autoRefresh ? 20_000 : undefined,
      onSuccess: () => setLastUpdated(dayjs().format('HH:mm:ss')),
    },
  );

  // Live activity feed (stances, arguments, topics)
  const feedReq = useRequest<FeedItem[], []>(fetchRecentActivity, {
    pollingInterval: autoRefresh ? 20_000 : undefined,
  });

  // Open debates table
  const openReq = useRequest<EthikosTopicApi[], []>(fetchOpenTopics, {
    pollingInterval: autoRefresh ? 30_000 : undefined,
  });

  // Manual refresh safety-net (kept from original)
  useInterval(() => {
    if (!autoRefresh) return;
    liveReq.refresh();
  }, 20_000);

  const refreshAll = React.useCallback(() => {
    liveReq.refresh();
    feedReq.refresh();
    openReq.refresh();
  }, [liveReq, feedReq, openReq]);

  const counters = liveReq.data?.counters ?? [];

  const openColumns = React.useMemo<ProColumns<EthikosTopicApi>[]>(() => {
    return [
      {
        title: 'Debate',
        dataIndex: 'title',
        ellipsis: true,
        render: (dom, row) => (
          <Space size="small">
            <FireOutlined />
            <a href={`/ethikos/deliberate/${row.id}`}>{dom}</a>
          </Space>
        ),
      },
      {
        title: 'Status',
        dataIndex: 'status',
        width: 120,
        render: (_, row) =>
          row.status === 'open' ? (
            <Tag color="green">Open</Tag>
          ) : (
            <Tag>{row.status}</Tag>
          ),
      },
      {
        title: 'Last activity',
        dataIndex: 'last_activity',
        width: 180,
        render: (_, row) => (
          <Tooltip
            title={dayjs(row.last_activity).format('YYYY-MM-DD HH:mm')}
          >
            {dayjs(row.last_activity).fromNow()}
          </Tooltip>
        ),
      },
      {
        title: 'Created',
        dataIndex: 'created_at',
        width: 160,
        render: (_, row) => (
          <Tooltip title={dayjs(row.created_at).format('YYYY-MM-DD HH:mm')}>
            {dayjs(row.created_at).fromNow()}
          </Tooltip>
        ),
      },
    ];
  }, []);

  const secondaryActions = (
    <Space>
      {lastUpdated && (
        <Badge
          count={
            <Tooltip title={`Last refreshed at ${lastUpdated}`}>
              <ClockCircleOutlined style={{ color: '#52c41a' }} />
            </Tooltip>
          }
        />
      )}
      <Space size="small" align="center">
        <ThunderboltOutlined />
        <span>Auto‚Äërefresh</span>
        <Switch checked={autoRefresh} onChange={setAutoRefresh} size="small" />
      </Space>
      <Button icon={<SyncOutlined />} onClick={refreshAll} size="small">
        Refresh
      </Button>
    </Space>
  );

  const primaryAction = (
    <Button href="/ethikos/pulse/trends" type="primary">
      View opinion trends
    </Button>
  );

  return (
    <EthikosPageShell
      title="Pulse ¬∑ Live participation"
      sectionLabel="Pulse"
      subtitle="Real‚Äëtime counters, latest activity, and currently open debates."
      primaryAction={primaryAction}
      secondaryActions={secondaryActions}
    >
      <PageContainer ghost loading={liveReq.loading && !counters.length}>
        <Alert
          type="info"
          showIcon
          style={{ marginBottom: 16 }}
          message="Live view"
          description="This page auto‚Äërefreshes every 20 seconds while enabled. Use manual Refresh if needed."
        />

        {/* KPI counters with sparkline charts */}
        <ProCard gutter={16} wrap>
          {counters.map((c) => {
            const trend = c.trend ?? 0;
            return (
              <StatisticCard
                key={c.label}
                colSpan={{ xs: 24, sm: 12, md: 12, lg: 6 }}
                statistic={{
                  title: (
                    <Space>
                      {c.label}
                      <Badge
                        status={
                          trend > 0 ? 'success' : trend < 0 ? 'error' : 'default'
                        }
                      />
                    </Space>
                  ),
                  value: c.value,
                  precision: 0,
                }}
                chart={
                  <ChartCard
                    type="line"
                    height={50}
                    data={c.history.map(({ ts, value }) => ({
                      x: ts,
                      y: value,
                    }))}
                  />
                }
              />
            );
          })}
        </ProCard>

        {/* Live activity feed + Open debates */}
        <ProCard gutter={[16, 16]} wrap style={{ marginTop: 16 }}>
          {/* Live activity feed */}
          <ProCard
            colSpan={{ xs: 24, xl: 16 }}
            title={
              <Space>
                <MessageOutlined />
                <span>Live activity</span>
              </Space>
            }
            extra={
              <Typography.Text type="secondary">
                Latest 20 items across debates, stances, and comments
              </Typography.Text>
            }
            loading={feedReq.loading && !feedReq.data}
          >
            {feedReq.data && feedReq.data.length === 0 ? (
              <Empty description="No recent activity yet" />
            ) : (
              <List
                itemLayout="horizontal"
                dataSource={feedReq.data ?? []}
                renderItem={(item) => (
                  <List.Item key={item.id}>
                    <List.Item.Meta
                      avatar={
                        item.kind === 'topic' ? (
                          <ProfileOutlined />
                        ) : item.kind === 'stance' ? (
                          <Tag
                            color={item.extra.value >= 0 ? 'green' : 'red'}
                          >
                            {item.extra.value >= 0 ? '+' : ''}
                            {item.extra.value}
                          </Tag>
                        ) : (
                          <MessageOutlined />
                        )
                      }
                      title={
                        <Space size="small" wrap>
                          <a href={`/ethikos/deliberate/${item.topicId}`}>
                            {item.title}
                          </a>
                          <Tag
                            color={
                              item.kind === 'topic'
                                ? 'blue'
                                : item.kind === 'stance'
                                ? 'purple'
                                : 'cyan'
                            }
                          >
                            {item.kind}
                          </Tag>
                        </Space>
                      }
                      description={
                        <Space size="small" wrap>
                          <span>{item.summary}</span>
                          <Typography.Text type="secondary">
                            ¬∑ {dayjs(item.ts).fromNow()}
                          </Typography.Text>
                        </Space>
                      }
                    />
                  </List.Item>
                )}
              />
            )}
          </ProCard>

          {/* Open debates table */}
          <ProCard
            colSpan={{ xs: 24, xl: 8 }}
            title={
              <Space>
                <FireOutlined />
                <span>Open debates</span>
              </Space>
            }
            loading={openReq.loading && !openReq.data}
          >
            {openReq.data && openReq.data.length === 0 ? (
              <Empty description="No open debates at the moment" />
            ) : (
              <ProTable<EthikosTopicApi>
                rowKey="id"
                columns={openColumns}
                dataSource={openReq.data ?? []}
                pagination={{ pageSize: 6 }}
                search={false}
                size="small"
                toolBarRender={false}
              />
            )}
          </ProCard>
        </ProCard>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/pulse/live/page.tsx =====


===== BEGIN app/ethikos/pulse/overview/page.tsx =====
// app/ethikos/pulse/overview/page.tsx
'use client';

/* Sources:
   - Current page implementation in dump: app/ethikos/pulse/overview/page.tsx  :contentReference[oaicite:0]{index=0}
   - Data service used here: services/pulse.ts                                  :contentReference[oaicite:1]{index=1}
   - Shared page shell wrapper: app/ethikos/EthikosPageShell.tsx                :contentReference[oaicite:2]{index=2}
*/

import type { ReactNode } from 'react';
import {
  PageContainer,
  ProCard,
  StatisticCard,
} from '@ant-design/pro-components';
import {
  Alert,
  Badge,
  Button,
  Empty,
  List,
  Skeleton,
  Space,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  BarChartOutlined,
  ClockCircleOutlined,
  InfoCircleOutlined,
  LineChartOutlined,
  SyncOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';

import ChartCard from '@/components/charts/ChartCard';
import { fetchPulseOverview } from '@/services/pulse';
import EthikosPageShell from '../../EthikosPageShell';

const { Text } = Typography;

type OverviewData = Awaited<ReturnType<typeof fetchPulseOverview>>;

const KPI_DEFINITIONS: Record<string, { description: string; color: string }> = {
  topics: {
    description:
      'New debate topics created across Ethikos over the last 30 days.',
    color: 'blue',
  },
  stances: {
    description:
      'Individual stance submissions (positions / votes) linked to debates in the last 30 days.',
    color: 'green',
  },
  arguments: {
    description:
      'Arguments, comments and replies added to debates over the last 30 days.',
    color: 'purple',
  },
  votes: {
    description:
      'Weighted votes cast across topics and outcomes in the last 30 days.',
    color: 'volcano',
  },
};

/* ------------------------------------------------------------------ */
/*  Data-fetching hook                                                 */
/* ------------------------------------------------------------------ */

function usePulseOverview() {
  return useRequest<OverviewData, []>(fetchPulseOverview, { refreshDeps: [] });
}

/* ------------------------------------------------------------------ */
/*  Main component                                                     */
/* ------------------------------------------------------------------ */

export default function PulseOverview() {
  const { data, loading, error, refresh } = usePulseOverview();
  const lastUpdated = data ? dayjs(data.refreshedAt).format('HH:mm:ss') : null;

  const secondaryActions = (
    <Space>
      {lastUpdated && (
        <Badge
          count={
            <Tooltip title={`Last refreshed at ${lastUpdated}`}>
              <ClockCircleOutlined style={{ color: '#52c41a' }} />
            </Tooltip>
          }
        />
      )}
      <Button
        icon={<SyncOutlined />}
        onClick={refresh}
        size="small"
        type="text"
      />
    </Space>
  );

  let body: ReactNode;

  /* ---------- loading skeleton ---------- */
  if (loading && !data) {
    body = (
      <PageContainer ghost>
        <Skeleton active />
      </PageContainer>
    );
  } else if (error) {
    /* ---------- error state ---------- */
    body = (
      <PageContainer ghost>
        <Empty
          description="Failed to load metrics"
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        >
          <Button icon={<SyncOutlined />} onClick={refresh}>
            Retry
          </Button>
        </Empty>
      </PageContainer>
    );
  } else if (data && data.kpis.length === 0) {
    /* ---------- empty state ---------- */
    body = (
      <PageContainer ghost>
        <Empty description="No KPI data yet" />
      </PageContainer>
    );
  } else if (data) {
    /* ---------- happy path ---------- */
    body = (
      <PageContainer ghost>
        <Alert
          type="info"
          showIcon
          message="Aggregated participation metrics (last 30 days)"
          description="Debates, stances, arguments and votes aggregated daily across all Ethikos topics. Use this view as a quick pulse before drilling into trends or live participation."
          style={{ marginBottom: 16 }}
        />

        <ProCard gutter={16} wrap>
          {/* KPI grid with sparkline charts */}
          <ProCard colSpan={{ xs: 24, xl: 16 }} ghost>
            <ProCard gutter={[16, 16]} wrap>
              {data.kpis.map((kpi) => (
                <StatisticCard
                  key={kpi.label}
                  colSpan={{
                    xs: 24,
                    sm: 12,
                    md: 12,
                    lg: 6,
                  }}
                  statistic={{
                    title: kpi.label,
                    value: kpi.value,
                    suffix: kpi.delta !== undefined ? '%' : undefined,
                    description:
                      kpi.delta !== undefined ? (
                        <span
                          style={{
                            color: kpi.delta >= 0 ? '#3f8600' : '#cf1322',
                          }}
                        >
                          {kpi.delta >= 0 ? '‚ñ≤' : '‚ñº'} {Math.abs(kpi.delta)}%
                        </span>
                      ) : null,
                  }}
                  chart={
                    <ChartCard
                      type="area"
                      height={60}
                      data={kpi.history.map((h) => ({
                        x: h.date,
                        y: h.value,
                      }))}
                      tooltip={{
                        formatter: (datum: any) =>
                          `${dayjs(datum.x).format('MMM D')}: ${datum.y}`,
                      }}
                    />
                  }
                />
              ))}
            </ProCard>
          </ProCard>

          {/* Interpretation / metric dictionary */}
          <ProCard
            colSpan={{ xs: 24, xl: 8 }}
            title={
              <Space>
                <InfoCircleOutlined />
                <span>How to read these KPIs</span>
              </Space>
            }
          >
            <List
              size="small"
              dataSource={data.kpis}
              renderItem={(kpi) => {
                const meta = KPI_DEFINITIONS[kpi.key] ?? {
                  description: 'Activity metric in the Ethikos opinion layer.',
                  color: 'default',
                };
                return (
                  <List.Item key={kpi.key}>
                    <List.Item.Meta
                      title={
                        <Space size="small">
                          <Tag color={meta.color}>{kpi.label}</Tag>
                          {typeof kpi.delta === 'number' && (
                            <Text type={kpi.delta >= 0 ? 'success' : 'danger'}>
                              {kpi.delta >= 0
                                ? `+${kpi.delta}%`
                                : `${kpi.delta}%`}
                            </Text>
                          )}
                        </Space>
                      }
                      description={
                        <Text type="secondary">{meta.description}</Text>
                      }
                    />
                  </List.Item>
                );
              }}
            />
          </ProCard>
        </ProCard>

        {/* Navigation to deeper analytics views */}
        <ProCard
          ghost
          style={{ marginTop: 16 }}
          title={
            <Space>
              <LineChartOutlined />
              <span>Where to go next</span>
            </Space>
          }
        >
          <Space wrap>
            <Button href="/ethikos/pulse/live">Live participation</Button>
            <Button href="/ethikos/pulse/trends">Opinion trends</Button>
            <Button href="/ethikos/pulse/health">Participation health</Button>
            <Button href="/ethikos/insights" icon={<BarChartOutlined />}>
              Full analytics
            </Button>
          </Space>
        </ProCard>
      </PageContainer>
    );
  } else {
    // Fallback: no data and not loading/error
    body = (
      <PageContainer ghost>
        <Empty description="No data available" />
      </PageContainer>
    );
  }

  return (
    <EthikosPageShell
      title="Pulse ¬∑ Overview"
      subtitle="30-day snapshot of debates, stances, arguments and votes across Ethikos."
      primaryAction={
        <Button
          type="primary"
          href="/ethikos/insights"
          icon={<BarChartOutlined />}
        >
          Open opinion analytics
        </Button>
      }
      secondaryActions={secondaryActions}
    >
      {body}
    </EthikosPageShell>
  );
}

===== END app/ethikos/pulse/overview/page.tsx =====


===== BEGIN app/ethikos/pulse/trends/page.tsx =====
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { PageContainer, ProCard } from '@ant-design/pro-components';
import {
  Tabs,
  Space,
  Segmented,
  Tooltip,
  Badge,
  Empty,
  Skeleton,
  Button,
  Typography,
  Switch,
  message,
} from 'antd';
import type { TabsProps } from 'antd';
import { Line, Area, Heatmap } from '@ant-design/plots';
import {
  AreaChartOutlined,
  BarChartOutlined,
  HeatMapOutlined,
  SyncOutlined,
  ClockCircleOutlined,
  DownloadOutlined,
  BarChartOutlined as InsightsIcon,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';

import EthikosPageShell from '../../EthikosPageShell';
import { fetchPulseTrends } from '@/services/pulse';

type TimeRangeKey = '7d' | '30d' | '60d';

const { Text } = Typography;

type PulseChart = {
  key: string;
  type: 'line' | 'area' | 'heatmap' | string;
  title: string;
  config?: Record<string, any>;
};

/* ------------------------------------------------------------------ */
/*  Helpers                                                            */
/* ------------------------------------------------------------------ */

function getDaysForRange(range: TimeRangeKey): number {
  switch (range) {
    case '7d':
      return 7;
    case '30d':
      return 30;
    case '60d':
    default:
      return 60;
  }
}

function filterSeriesByDays(data: any[], days: number): any[] {
  if (!Array.isArray(data) || data.length === 0) return data;

  const now = dayjs();
  const start = now.startOf('day').subtract(days - 1, 'day');
  const startTs = start.valueOf();
  const endTs = now.endOf('day').valueOf();

  return data.filter((row: any) => {
    const value = row?.date ?? row?.x ?? row?.ts;
    if (!value) return true;

    const d = dayjs(value).startOf('day');
    const ts = d.valueOf();

    return ts >= startTs && ts <= endTs;
  });
}

/**
 * Build a comparison dataset that overlays the previous period onto
 * the current period. The previous period is time-shifted so that
 * day indices align (D‚Äë1 prev maps to D‚Äë1 current).
 */
function buildComparisonDataset(baseData: any[], days: number) {
  const now = dayjs().endOf('day');
  const startCurrent = now.startOf('day').subtract(days - 1, 'day');
  const startPrev = startCurrent.subtract(days, 'day');
  const endPrev = startCurrent.subtract(1, 'day').endOf('day');

  const getTs = (v: any) => dayjs(v?.date ?? v?.x ?? v?.ts).valueOf();

  const current = baseData
    .filter((r) => {
      const ts = getTs(r);
      return ts >= startCurrent.valueOf() && ts <= now.valueOf();
    })
    .map((r) => ({
      ...(r as any),
      date: dayjs(getTs(r)).format('YYYY-MM-DD'),
      period: 'This period',
    }));

  const prevRaw = baseData.filter((r) => {
    const ts = getTs(r);
    return ts >= startPrev.valueOf() && ts <= endPrev.valueOf();
  });

  const prev = prevRaw.map((r) => {
    const d = dayjs(getTs(r)).startOf('day');
    const dayIndex = d.diff(startPrev, 'day'); // 0..days-1
    const alignedDate = startCurrent.add(dayIndex, 'day').format('YYYY-MM-DD');
    return {
      ...(r as any),
      date: alignedDate,
      period: 'Previous period',
    };
  });

  return [...prev, ...current];
}

/* ------------------------------------------------------------------ */
/*  Page                                                               */
/* ------------------------------------------------------------------ */

export default function PulseTrends(): JSX.Element {
  const [range, setRange] = useState<TimeRangeKey>('30d');
  const [smoothLines, setSmoothLines] = useState<boolean>(true);
  const [comparePrev, setComparePrev] = useState<boolean>(false);
  const { data, loading, error, refresh } = useRequest<
    Awaited<ReturnType<typeof fetchPulseTrends>>,
    []
  >(fetchPulseTrends);

  const charts: PulseChart[] = (data?.charts ?? []) as PulseChart[];
  const [activeKey, setActiveKey] = useState<string | undefined>(undefined);

  // Ensure we select first tab once charts are available
  useEffect(() => {
    if (!activeKey && charts.length > 0) {
      const firstChart = charts[0];
      if (firstChart) {
        setActiveKey(firstChart.key);
      }
    }
  }, [charts, activeKey]);

  // Build per-tab configs with time-range filter, smoothing and comparison overlay.
  const enhancedConfigs = useMemo(
    () =>
      charts.map((chart) => {
        // Heatmap is an aggregate over hours/days, keep it mostly as-is
        if (chart.type === 'heatmap') {
          return {
            ...(chart.config ?? {}),
          };
        }

        const baseData = (chart.config?.data ?? []) as any[];
        const days = getDaysForRange(range);

        const cfg: any = {
          ...(chart.config ?? {}),
          data: filterSeriesByDays(baseData, days),
          smooth: smoothLines,
          // Some nice defaults for readability
          xField: chart.config?.xField ?? 'date',
          yField: chart.config?.yField ?? 'value',
          appendPadding: [8, 8, 8, 8],
          tooltip: {
            ...(chart.config?.tooltip ?? {}),
            // G2Plot formatter shape
            formatter: (datum: any) => {
              const x = datum.date ?? datum.x ?? datum.ts;
              return {
                name: datum.period ?? 'value',
                value: datum.value,
                title: dayjs(x).format('MMM D'),
              };
            },
          },
          xAxis: {
            ...(chart.config?.xAxis ?? {}),
            label: { ...(chart.config?.xAxis?.label ?? {}), autoHide: true },
          },
        };

        if (comparePrev) {
          const comp = buildComparisonDataset(baseData, days);
          cfg.data = comp;
          cfg.seriesField = 'period';
          // When comparing, area charts look better unstacked so trends are comparable
          if (chart.type === 'area') {
            cfg.isStack = false;
          }
        }

        return cfg;
      }),
    [charts, range, smoothLines, comparePrev],
  );

  const lastUpdatedLabel = useMemo(() => {
    if (!charts.length) return null;

    // Use the last date from the last non-heatmap series as a simple "data up to" marker
    for (let i = charts.length - 1; i >= 0; i -= 1) {
      const chart = charts[i];
      if (!chart) continue;
      if (chart.type === 'heatmap') continue;

      const series = (chart.config?.data ?? []) as any[];
      if (!series.length) continue;

      const last = series[series.length - 1] as any;
      const lastDate = last?.date ?? last?.x ?? last?.ts;
      if (!lastDate) continue;

      return dayjs(lastDate).format('MMM D');
    }
    return null;
  }, [charts]);

  /* ------------------------------------------------------------------ */
  /*  Export current tab to CSV                                         */
  /* ------------------------------------------------------------------ */

  async function exportCurrentChartCsv() {
    if (!charts.length || !activeKey) {
      message.info('Nothing to export.');
      return;
    }

    const idx = charts.findIndex((c) => c.key === activeKey);
    if (idx < 0 || idx >= charts.length || idx >= enhancedConfigs.length) {
      message.info('Nothing to export.');
      return;
    }

    const chart = charts[idx];
    const cfg = enhancedConfigs[idx];

    if (!chart || !cfg) {
      message.info('Nothing to export.');
      return;
    }

    // Only export series‚Äëbased charts; heatmap becomes a wide matrix (skip for now)
    if (chart.type === 'heatmap') {
      message.warning('Heatmap export is not supported.');
      return;
    }

    const rows = (cfg.data ?? []) as Array<{
      date?: string;
      x?: any;
      ts?: number;
      value: number;
      period?: string;
    }>;

    const header = comparePrev ? ['date', 'value', 'period'] : ['date', 'value'];
    const encodeCell = (value: unknown): string => {
      const str = value === null || value === undefined ? '' : String(value);
      if (/[",\n]/.test(str)) return `"${str.replace(/"/g, '""')}"`;
      return str;
    };

    const toDate = (r: {
      date?: string;
      x?: any;
      ts?: number;
    }): string => {
      const x = r.date ?? r.x ?? r.ts;
      return dayjs(x).format('YYYY-MM-DD');
    };

    const csv = [
      header,
      ...rows.map((r) =>
        comparePrev ? [toDate(r), r.value, r.period ?? 'This period'] : [toDate(r), r.value],
      ),
    ]
      .map((row) => row.map(encodeCell).join(','))
      .join('\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    link.href = url;
    link.download = `${chart.key}-${range}-${comparePrev ? 'compare' : 'single'}-${timestamp}.csv`;

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    message.success('Exported current chart as CSV.');
  }

  /* ------------------------------------------------------------------ */
  /*  Loading / error / empty states                                    */
  /* ------------------------------------------------------------------ */

  if (loading && !data) {
    return (
      <EthikosPageShell
        title="Pulse ¬∑ Trends"
        sectionLabel="Pulse"
        subtitle="Topic creation, stances and deliberation activity over time, with optional previous‚Äëperiod comparison."
        primaryAction={
          <Button type="primary" href="/ethikos/insights" icon={<InsightsIcon />}>
            Open opinion analytics
          </Button>
        }
      >
        <PageContainer ghost>
          <Skeleton active />
        </PageContainer>
      </EthikosPageShell>
    );
  }

  if (error) {
    return (
      <EthikosPageShell
        title="Pulse ¬∑ Trends"
        sectionLabel="Pulse"
        subtitle="Topic creation, stances and deliberation activity over time, with optional previous‚Äëperiod comparison."
        primaryAction={
          <Button type="primary" href="/ethikos/insights" icon={<InsightsIcon />}>
            Open opinion analytics
          </Button>
        }
      >
        <PageContainer ghost>
          <ProCard ghost>
            <Space direction="vertical" size="large" style={{ width: '100%', textAlign: 'center' }}>
              <Empty description="Unable to load trend data" />
              <Button icon={<SyncOutlined />} onClick={refresh} type="primary">
                Retry
              </Button>
            </Space>
          </ProCard>
        </PageContainer>
      </EthikosPageShell>
    );
  }

  if (!charts.length) {
    return (
      <EthikosPageShell
        title="Pulse ¬∑ Trends"
        sectionLabel="Pulse"
        subtitle="Topic creation, stances and deliberation activity over time, with optional previous‚Äëperiod comparison."
        primaryAction={
          <Button type="primary" href="/ethikos/insights" icon={<InsightsIcon />}>
            Open opinion analytics
          </Button>
        }
      >
        <PageContainer ghost>
          <Empty description="No trend data available yet" />
        </PageContainer>
      </EthikosPageShell>
    );
  }

  /* ------------------------------------------------------------------ */
  /*  Build Tabs                                                         */
  /* ------------------------------------------------------------------ */

  const tabItems: TabsProps['items'] = charts.map((chart, idx) => {
    let icon: React.ReactNode = <AreaChartOutlined />;

    if (chart.type === 'heatmap') icon = <HeatMapOutlined />;
    if (chart.type === 'area') icon = <BarChartOutlined />;
    if (chart.type === 'line') icon = <AreaChartOutlined />;

    const cfg = enhancedConfigs[idx] ?? {};

    return {
      key: chart.key,
      label: (
        <Space size="small">
          {icon}
          <span>{chart.title}</span>
        </Space>
      ),
      children: (
        <ProCard ghost>
          {chart.type === 'line' && <Line {...cfg} />}
          {chart.type === 'area' && <Area {...cfg} />}
          {chart.type === 'heatmap' && <Heatmap {...cfg} />}
        </ProCard>
      ),
    };
  });

  /* ------------------------------------------------------------------ */
  /*  Secondary actions (top‚Äëright in shell)                             */
  /* ------------------------------------------------------------------ */

  const secondaryActions = (
    <Space wrap>
      <Segmented
        size="small"
        value={range}
        onChange={(val) => setRange(val as TimeRangeKey)}
        options={[
          { label: '7d', value: '7d' },
          { label: '30d', value: '30d' },
          { label: '60d', value: '60d' },
        ]}
      />
      <Tooltip title="Smooth lines">
        <Switch size="small" checked={smoothLines} onChange={setSmoothLines} />
      </Tooltip>
      <Tooltip title="Compare with previous period">
        <Switch size="small" checked={comparePrev} onChange={setComparePrev} />
      </Tooltip>
      <Tooltip title="Last data point in the underlying series">
        <Badge
          count={
            <Space size={4}>
              <ClockCircleOutlined style={{ color: '#52c41a' }} />
              <Text type="secondary">{lastUpdatedLabel ?? '‚Äî'}</Text>
            </Space>
          }
          style={{ backgroundColor: '#f0f0f0' }}
        />
      </Tooltip>
      <Button icon={<DownloadOutlined />} size="small" onClick={exportCurrentChartCsv}>
        Export CSV
      </Button>
      <Button icon={<SyncOutlined />} size="small" onClick={refresh} />
    </Space>
  );

  /* ------------------------------------------------------------------ */
  /*  Render                                                             */
  /* ------------------------------------------------------------------ */

  return (
    <EthikosPageShell
      title="Pulse ¬∑ Trends"
      sectionLabel="Pulse"
      subtitle="Topic creation, stances, and deliberation activity over time. Filter by range, smooth lines, and optionally overlay the previous period."
      primaryAction={
        <Button type="primary" href="/ethikos/insights" icon={<InsightsIcon />}>
          Open opinion analytics
        </Button>
      }
      secondaryActions={secondaryActions}
    >
      <PageContainer ghost>
        <Tabs
          items={tabItems}
          activeKey={activeKey}
          onChange={(key) => setActiveKey(key)}
        />
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/pulse/trends/page.tsx =====


===== BEGIN app/ethikos/trust/badges/page.tsx =====
// app/ethikos/trust/badges/page.tsx
'use client';

// Source references (current code + services):
// - Current page baseline in dump: app/ethikos/trust/badges/page.tsx
// - Trust services (types + fetchUserBadges): frontend/services/trust.ts

import { useMemo, useState } from 'react';
import { PageContainer, ProCard, ProList } from '@ant-design/pro-components';
import {
  Badge as AntBadge,
  Divider,
  Empty,
  Input,
  Modal,
  Select,
  Space,
  Statistic,
  Tag,
  Typography,
} from 'antd';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';

import EthikosPageShell from '../../EthikosPageShell';
import { fetchUserBadges, type Badge as TrustBadge } from '@/services/trust';

const { Text, Paragraph } = Typography;

type SortOrder = 'newest' | 'oldest';
type TimeFilter = 'all' | '90d' | '365d';
type CatalogCategory = 'Stances' | 'Arguments' | 'Voting';
type CatalogShow = 'all' | 'earned' | 'locked';

type CatalogItem = {
  id: string;
  label: string;
  description: string;
  category: CatalogCategory;
  requirement: string;
};

const BADGE_CATEGORY_META: Record<
  string,
  { label: CatalogCategory; color: string }
> = {
  'first-stance': { label: 'Stances', color: 'blue' },
  'argument-builder': { label: 'Arguments', color: 'purple' },
  'active-voter': { label: 'Voting', color: 'green' },
};

// Central catalog (mirrors service logic/IDs)
const BADGE_CATALOG: CatalogItem[] = [
  {
    id: 'first-stance',
    label: 'First stance',
    description: 'Recorded your first stance in a debate.',
    category: 'Stances',
    requirement: 'Post at least one stance in any Ethikos debate.',
  },
  {
    id: 'argument-builder',
    label: 'Argument builder',
    description: 'Contributed at least 5 arguments to debates.',
    category: 'Arguments',
    requirement: 'Publish 5+ arguments across debates.',
  },
  {
    id: 'active-voter',
    label: 'Active voter',
    description: 'Cast at least 10 weighted votes across the platform.',
    category: 'Voting',
    requirement: 'Submit 10+ weighted votes on proposals.',
  },
];

export default function Badges() {
  const { data, loading } = useRequest<TrustBadge[], []>(fetchUserBadges);
  const badges = data ?? [];
  const earnedIds = useMemo(() => new Set(badges.map((b) => b.id)), [badges]);

  // Controls for "Your badges" grid
  const [sortOrder, setSortOrder] = useState<SortOrder>('newest');
  const [timeFilter, setTimeFilter] = useState<TimeFilter>('all');

  // Controls for "Badge catalog"
  const [catalogCategory, setCatalogCategory] = useState<
    CatalogCategory | 'All'
  >('All');
  const [catalogShow, setCatalogShow] = useState<CatalogShow>('all');
  const [catalogSearch, setCatalogSearch] = useState('');

  // Detail modal for a selected badge
  const [detail, setDetail] = useState<TrustBadge | null>(null);
  const detailMeta = detail ? BADGE_CATEGORY_META[detail.id] : undefined;

  // ---------- derived stats ----------
  const totalBadges = badges.length;
  const recent90 = badges.filter((b) =>
    dayjs(b.earnedAt).isAfter(dayjs().subtract(90, 'day')),
  ).length;

  let firstEarned: string | undefined;
  let lastEarned: string | undefined;
  if (badges.length > 0) {
    const dates = badges.map((b) => b.earnedAt);
    firstEarned = dates.reduce((min, d) =>
      dayjs(d).isBefore(min) ? d : min,
    );
    lastEarned = dates.reduce((max, d) =>
      dayjs(d).isAfter(max) ? d : max,
    );
  }

  // ---------- "Your badges" grid (filters + sorting) ----------
  const filteredBadges = useMemo(() => {
    let result = [...badges];

    if (timeFilter !== 'all') {
      const days = timeFilter === '90d' ? 90 : 365;
      const cutoff = dayjs().subtract(days, 'day');
      result = result.filter((b) => dayjs(b.earnedAt).isAfter(cutoff));
    }

    result.sort((a, b) => {
      const da = dayjs(a.earnedAt).valueOf();
      const db = dayjs(b.earnedAt).valueOf();
      return sortOrder === 'newest' ? db - da : da - db;
    });

    return result;
  }, [badges, sortOrder, timeFilter]);

  // ---------- "Badge catalog" with earned/locked status ----------
  const catalogRows = useMemo(() => {
    let rows = BADGE_CATALOG.map((c) => {
      const earned = earnedIds.has(c.id);
      const earnedBadge = badges.find((b) => b.id === c.id);
      return {
        ...c,
        earned,
        earnedAt: earnedBadge?.earnedAt,
      };
    });

    if (catalogCategory !== 'All') {
      rows = rows.filter((r) => r.category === catalogCategory);
    }

    if (catalogShow === 'earned') rows = rows.filter((r) => r.earned);
    if (catalogShow === 'locked') rows = rows.filter((r) => !r.earned);

    const q = catalogSearch.trim().toLowerCase();
    if (q) {
      rows = rows.filter(
        (r) =>
          r.label.toLowerCase().includes(q) ||
          r.description.toLowerCase().includes(q) ||
          r.requirement.toLowerCase().includes(q),
      );
    }

    // Keep earned first within each view for clarity
    rows.sort((a, b) =>
      a.earned === b.earned
        ? a.label.localeCompare(b.label)
        : a.earned
        ? -1
        : 1,
    );
    return rows;
  }, [badges, earnedIds, catalogCategory, catalogShow, catalogSearch]);

  const shellProps = {
    title: 'Badges',
    sectionLabel: 'Trust',
  } as const;

  return (
    <EthikosPageShell {...shellProps}>
      <PageContainer ghost loading={loading}>
        {/* Summary / explanation */}
        <ProCard gutter={[16, 16]} wrap>
          <ProCard
            colSpan={{ xs: 24, md: 12 }}
            bordered
            title="Reputation badges"
            subTitle="Derived from what you actually do in Ethikos"
          >
            <Space
              direction="vertical"
              size="middle"
              style={{ width: '100%' }}
            >
              <Paragraph type="secondary">
                Badges are granted automatically from your real activity in
                debates, arguments and weighted votes. They cannot be edited or
                purchased.
              </Paragraph>
              <Paragraph type="secondary">
                Use them as a compact way to communicate your track record when
                you join new consultations or structured debates.
              </Paragraph>
            </Space>
          </ProCard>

          <ProCard
            colSpan={{ xs: 24, md: 12 }}
            bordered
            title="At a glance"
          >
            <Space size="large" wrap>
              <Statistic title="Badges earned" value={totalBadges} />
              <Statistic title="Last 90 days" value={recent90} />
              {firstEarned && (
                <Statistic
                  title="First badge"
                  value={dayjs(firstEarned).format('MMM D, YYYY')}
                />
              )}
              {lastEarned && (
                <Statistic
                  title="Most recent"
                  value={dayjs(lastEarned).format('MMM D, YYYY')}
                />
              )}
            </Space>
          </ProCard>
        </ProCard>

        {/* Badge grid + controls */}
        <ProCard
          style={{ marginTop: 16 }}
          bordered
          title="Your badges"
          extra={
            <Space size="middle" wrap>
              <Space size={4}>
                <Text type="secondary">Show</Text>
                <Select<TimeFilter>
                  size="small"
                  value={timeFilter}
                  onChange={setTimeFilter}
                  style={{ minWidth: 150 }}
                  options={[
                    { value: 'all', label: 'All time' },
                    { value: '90d', label: 'Last 90 days' },
                    { value: '365d', label: 'Last 12 months' },
                  ]}
                />
              </Space>
              <Space size={4}>
                <Text type="secondary">Sort</Text>
                <Select<SortOrder>
                  size="small"
                  value={sortOrder}
                  onChange={setSortOrder}
                  style={{ minWidth: 150 }}
                  options={[
                    { value: 'newest', label: 'Newest first' },
                    { value: 'oldest', label: 'Oldest first' },
                  ]}
                />
              </Space>
            </Space>
          }
        >
          <Divider style={{ margin: '8px 0 16px' }} />

          <ProCard gutter={[16, 16]} wrap>
            {filteredBadges.length > 0 ? (
              filteredBadges.map((badge) => {
                const meta = BADGE_CATEGORY_META[badge.id];

                return (
                  <AntBadge.Ribbon
                    key={badge.id}
                    text={dayjs(badge.earnedAt).format('MMM D, YYYY')}
                    color="green"
                  >
                    <ProCard
                      hoverable
                      onClick={() => setDetail(badge)}
                      title={
                        <Space size={8}>
                          <span>{badge.label}</span>
                          {meta && <Tag color={meta.color}>{meta.label}</Tag>}
                        </Space>
                      }
                      style={{ width: 260, marginBottom: 16 }}
                    >
                      <Paragraph
                        type="secondary"
                        style={{ marginBottom: 8 }}
                      >
                        {badge.description}
                      </Paragraph>
                      <Text type="secondary" style={{ fontSize: 12 }}>
                        Earned on{' '}
                        {dayjs(badge.earnedAt).format('MMM D, YYYY')}
                      </Text>
                    </ProCard>
                  </AntBadge.Ribbon>
                );
              })
            ) : (
              <Empty description="No badges in this view" />
            )}
          </ProCard>
        </ProCard>

        {/* Catalog & criteria */}
        <ProCard
          style={{ marginTop: 16 }}
          title="Badge catalog & criteria"
          bordered
          extra={
            <Space wrap>
              <Select<CatalogShow>
                size="small"
                value={catalogShow}
                onChange={setCatalogShow}
                style={{ minWidth: 140 }}
                options={[
                  { value: 'all', label: 'All' },
                  { value: 'earned', label: 'Earned' },
                  { value: 'locked', label: 'Locked' },
                ]}
              />
              <Select<CatalogCategory | 'All'>
                size="small"
                value={catalogCategory}
                onChange={setCatalogCategory}
                style={{ minWidth: 160 }}
                options={[
                  { value: 'All', label: 'All categories' },
                  { value: 'Stances', label: 'Stances' },
                  { value: 'Arguments', label: 'Arguments' },
                  { value: 'Voting', label: 'Voting' },
                ]}
              />
              <Input
                size="small"
                placeholder="Search catalog‚Ä¶"
                allowClear
                value={catalogSearch}
                onChange={(e) => setCatalogSearch(e.target.value)}
                style={{ width: 220 }}
              />
            </Space>
          }
        >
          <ProList<CatalogItem & { earned: boolean; earnedAt?: string }>
            rowKey="id"
            dataSource={catalogRows}
            split
            metas={{
              title: {
                dataIndex: 'label',
              },
              subTitle: {
                render: (
                  _: unknown,
                  row: CatalogItem & { earned: boolean; earnedAt?: string },
                ) => {
                  const meta = BADGE_CATEGORY_META[row.id];
                  return meta ? (
                    <Tag color={meta.color}>{meta.label}</Tag>
                  ) : null;
                },
              },
              description: {
                render: (
                  _: unknown,
                  row: CatalogItem & { earned: boolean; earnedAt?: string },
                ) => (
                  <Space direction="vertical" size={2}>
                    <Text type="secondary">{row.description}</Text>
                    <Text type="secondary">
                      Criteria: {row.requirement}
                    </Text>
                  </Space>
                ),
              },
              extra: {
                render: (
                  _: unknown,
                  row: CatalogItem & { earned: boolean; earnedAt?: string },
                ) =>
                  row.earned ? (
                    <Tag color="green">
                      Earned{' '}
                      {row.earnedAt &&
                        `¬∑ ${dayjs(row.earnedAt).format('MMM D, YYYY')}`}
                    </Tag>
                  ) : (
                    <Tag>Locked</Tag>
                  ),
              },
            }}
          />
        </ProCard>

        {/* Detail modal */}
        <Modal
          open={!!detail}
          title={
            detail ? (
              <Space size={8}>
                <span>{detail.label}</span>
                {detailMeta && (
                  <Tag color={detailMeta.color}>{detailMeta.label}</Tag>
                )}
              </Space>
            ) : (
              'Badge'
            )
          }
          onCancel={() => setDetail(null)}
          onOk={() => setDetail(null)}
          okText="Close"
          cancelButtonProps={{ style: { display: 'none' } }}
        >
          {detail ? (
            <Space
              direction="vertical"
              size="small"
              style={{ width: '100%' }}
            >
              <Paragraph>{detail.description}</Paragraph>
              <Text type="secondary">
                Earned on {dayjs(detail.earnedAt).format('MMMM D, YYYY')}
              </Text>
            </Space>
          ) : null}
        </Modal>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/trust/badges/page.tsx =====


===== BEGIN app/ethikos/trust/credentials/page.tsx =====
// app/ethikos/trust/credentials/page.tsx
'use client';

/**
 * Sources used to build this implementation:
 * - Baseline page from the app dump (existing upload flow, alert, steps content).
 * - Trust services showing `uploadCredential` helper (currently a stub without a real backend).
 */

import { useMemo, useState } from 'react';
import Link from 'next/link';
import dayjs from 'dayjs';
import {
  PageContainer,
  ProCard,
  ProTable,
  ProDescriptions,
  type ProColumns,
  type ProDescriptionsItemProps,
} from '@ant-design/pro-components';
import {
  Alert,
  Button,
  Divider,
  Drawer,
  List,
  Popconfirm,
  Result,
  Space,
  Steps,
  Tag,
  Tooltip,
  Typography,
  Upload,
  message as antdMessage,
} from 'antd';
import {
  ClockCircleOutlined,
  EyeInvisibleOutlined,
  FileTextOutlined,
  InboxOutlined,
  SafetyCertificateOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';

import EthikosPageShell from '../../EthikosPageShell';
import { uploadCredential, type Credential } from '@/services/trust';

/* ---------------------------------------------
 * Types & local helpers
 * ------------------------------------------- */

type CredentialStatus = 'Verified' | 'Pending' | 'Rejected';

type CredentialRow = Credential & {
  status: CredentialStatus;
  notes?: string;
};

const statusColor: Record<CredentialStatus, string> = {
  Verified: 'green',
  Pending: 'gold',
  Rejected: 'red',
};

function toTitleFromFilename(name?: string): string {
  if (!name) return 'Untitled credential';
  return name.replace(/\.[a-zA-Z0-9]+$/, '').replace(/[_\-]+/g, ' ').trim();
}

/* ---------------------------------------------
 * Data fetching (no backend yet ‚Üí returns mock)
 * When backend is ready, replace the body with a GET
 * using the shared axios helper, e.g.:
 *   const { items } = await get<{items: CredentialRow[]}>('trust/credentials')
 * ------------------------------------------- */
async function fetchUserCredentials(): Promise<CredentialRow[]> {
  // Mocked examples to drive the UI until the real endpoint exists.
  return [
    {
      id: 'cred-001',
      title: 'MSc Climate Policy',
      issuer: 'London School of Economics',
      issuedAt: '2022-09-01T00:00:00.000Z',
      url: 'https://example.org/lse-msc.pdf',
      status: 'Verified',
      notes: 'Verified by steward #42',
    },
    {
      id: 'cred-002',
      title: 'Professional Engineer (P.Eng.)',
      issuer: 'PEO',
      issuedAt: '2021-03-15T00:00:00.000Z',
      status: 'Pending',
      notes: 'Queued for human review',
    },
    {
      id: 'cred-003',
      title: 'Research Fellow ‚Äì Energy Policy',
      issuer: 'Policy Institute',
      issuedAt: '2020-01-10T00:00:00.000Z',
      status: 'Rejected',
      notes: 'Insufficient documentation',
    },
  ];
}

/* ---------------------------------------------
 * Component
 * ------------------------------------------- */

const { Text, Paragraph } = Typography;

export default function Credentials() {
  const [done, setDone] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [lastFileName, setLastFileName] = useState<string | undefined>();
  const [detail, setDetail] = useState<CredentialRow | null>(null);

  // Existing stepper UX: 0=Upload, 1=Review, 2=Outcome
  const currentStep = done ? 2 : uploading ? 1 : 0;

  // List of existing credentials (mocked for now; see fetcher above).
  const { data, loading, refresh, mutate } = useRequest<CredentialRow[], []>(
    fetchUserCredentials,
  );

  const rows = data ?? [];

  // Quick counters
  const counters = useMemo(() => {
    const verified = rows.filter((r) => r.status === 'Verified').length;
    const pending = rows.filter((r) => r.status === 'Pending').length;
    const rejected = rows.filter((r) => r.status === 'Rejected').length;
    return { verified, pending, rejected, total: rows.length };
  }, [rows]);

  const summaryTags = (
    <Space wrap>
      <Tag key="total">Total: {counters.total}</Tag>
      <Tag color="green" key="v">
        Verified: {counters.verified}
      </Tag>
      <Tag color="gold" key="p">
        Pending: {counters.pending}
      </Tag>
      <Tag color="red" key="r">
        Rejected: {counters.rejected}
      </Tag>
    </Space>
  );

  // Upload handler, wired to services/trust::uploadCredential
  const uploadProps = {
    name: 'file',
    multiple: false,
    maxCount: 1,
    accept: '.pdf,.jpg,.jpeg,.png',
    beforeUpload: (file: any) => {
      const isAllowedType =
        file.type === 'application/pdf' ||
        file.type === 'image/jpeg' ||
        file.type === 'image/png';

      if (!isAllowedType) {
        antdMessage.error('Only PDF, JPG or PNG files are allowed.');
        return Upload.LIST_IGNORE;
      }

      const isLt5M = file.size / 1024 / 1024 < 5;
      if (!isLt5M) {
        antdMessage.error('File must be smaller than 5 MB.');
        return Upload.LIST_IGNORE;
      }

      return true;
    },
    // Match Ant Design's expected `(options) => void` signature
    customRequest: (options: any) => {
      const { file, onSuccess, onError } = options;
      const uploadFile = file as File;

      setUploading(true);
      setLastFileName(uploadFile.name);

      uploadCredential(uploadFile)
        .then(() => {
          onSuccess?.('ok');

          // Optimistic insert into the table list as "Pending"
          const optimistic: CredentialRow = {
            id: `tmp-${Date.now()}`,
            title: toTitleFromFilename(uploadFile.name),
            issuer: '‚Äî',
            issuedAt: new Date().toISOString(),
            status: 'Pending',
            notes: 'Awaiting manual verification',
          };
          mutate([optimistic, ...rows]);
          setDone(true);
          antdMessage.success(
            'Credential uploaded. It will be reviewed shortly.',
          );
        })
        .catch((error: unknown) => {
          onError?.(error);
          antdMessage.error('Upload failed. Please try again.');
        })
        .finally(() => {
          setUploading(false);
        });
    },
  };

  // Table columns
  const columns: ProColumns<CredentialRow>[] = [
    {
      title: 'Title',
      dataIndex: 'title',
      ellipsis: true,
      render: (_: any, row: CredentialRow) => (
        <Space size={6}>
          <FileTextOutlined />
          {row.url ? (
            <a href={row.url} target="_blank" rel="noreferrer">
              {row.title}
            </a>
          ) : (
            <span>{row.title}</span>
          )}
        </Space>
      ),
    },
    { title: 'Issuer', dataIndex: 'issuer', width: 220, ellipsis: true },
    {
      title: 'Issued',
      dataIndex: 'issuedAt',
      width: 140,
      valueType: 'date',
      renderText: (v: any) => dayjs(v).format('YYYY-MM-DD'),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      width: 120,
      valueEnum: {
        Verified: { text: 'Verified', status: 'Success' },
        Pending: { text: 'Pending', status: 'Processing' },
        Rejected: { text: 'Rejected', status: 'Error' },
      },
      render: (_: any, row: CredentialRow) => (
        <Tag color={statusColor[row.status]}>{row.status}</Tag>
      ),
    },
    {
      title: 'Actions',
      width: 260,
      valueType: 'option',
      render: (_: any, row: CredentialRow) => {
        const canDownload = !!row.url;
        return [
          <Button size="small" key="view" onClick={() => setDetail(row)}>
            View
          </Button>,
          <Button
            size="small"
            key="download"
            disabled={!canDownload}
            href={row.url}
            target="_blank"
            rel="noreferrer"
          >
            Download
          </Button>,
          row.status !== 'Rejected' ? (
            <Popconfirm
              key="remove"
              title="Request removal?"
              description="A steward will review and remove this credential from your profile."
              onConfirm={() => {
                antdMessage.success('Removal request submitted.');
              }}
            >
              <Button size="small" danger>
                Request removal
              </Button>
            </Popconfirm>
          ) : (
            <Tooltip
              key="resubmit"
              title="Attach additional documents and re‚Äësubmit"
            >
              <Button
                size="small"
                type="dashed"
                onClick={() => {
                  antdMessage.info(
                    'Re‚Äësubmit by uploading an updated document below.',
                  );
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }}
              >
                Re‚Äësubmit
              </Button>
            </Tooltip>
          ),
        ];
      },
    },
  ];

  const pageBody = (
    <PageContainer ghost>
      {/* Intro & guidance */}
      <Alert
        type="info"
        showIcon
        style={{ marginBottom: 24 }}
        message={
          <Space>
            <SafetyCertificateOutlined />
            <span>Optional but powerful trust signal</span>
            <Tag color="blue">Beta</Tag>
          </Space>
        }
        description={
          <Paragraph style={{ marginTop: 8, marginBottom: 0 }}>
            Upload real‚Äëworld credentials (certifications, professional
            memberships, academic records) that help stewards understand why
            your voice carries expertise in certain debates. These documents are
            reviewed manually and do not replace community‚Äëbased reputation.
          </Paragraph>
        }
      />

      <ProCard gutter={16} wrap>
        {/* Left column: upload flow */}
        <ProCard
          colSpan={{ xs: 24, lg: 14 }}
          title="Upload a new credential"
          bordered
          extra={<Tag color="default">Private review only</Tag>}
        >
          {done ? (
            <Result
              status="success"
              title="Credential received"
              subTitle={
                <>
                  {lastFileName && (
                    <div>
                      <Text strong>{lastFileName}</Text>
                      <br />
                    </div>
                  )}
                  <Text>
                    Your document is now queued for human review. If accepted,
                    it will appear as a verified note in your Ethikos trust
                    profile.
                  </Text>
                </>
              }
              extra={
                <Space wrap>
                  <Button type="primary" onClick={() => setDone(false)}>
                    Upload another
                  </Button>
                  <Link href="/ethikos/trust/profile">
                    <Button>View my trust profile</Button>
                  </Link>
                  <Link href="/ethikos/trust/badges">
                    <Button type="text">See my badges</Button>
                  </Link>
                </Space>
              }
            />
          ) : (
            <>
              <Upload.Dragger {...uploadProps} disabled={uploading}>
                <p className="ant-upload-drag-icon">
                  <InboxOutlined />
                </p>
                <p className="ant-upload-text">
                  Click or drag a credential file to this area to upload
                </p>
                <p className="ant-upload-hint">
                  Supported formats: PDF, JPG, PNG ¬∑ Max 5 MB ¬∑ One document at
                  a time.
                </p>
              </Upload.Dragger>

              <Divider />

              <Space
                direction="vertical"
                size="small"
                style={{ width: '100%' }}
              >
                <Text type="secondary">
                  Tip: upload focused evidence rather than full CVs. For
                  example, a single certification for climate policy is more
                  helpful than a long r√©sum√©.
                </Text>
                <Text type="secondary">
                  You can always complement these documents with
                  activity‚Äëbased reputation earned through debates, voting and
                  impact work.
                </Text>
              </Space>
            </>
          )}
        </ProCard>

        {/* Right column: how it works + examples */}
        <ProCard
          colSpan={{ xs: 24, lg: 10 }}
          title="How credentials fit into Ethikos trust"
          bordered
        >
          <Steps
            direction="vertical"
            size="small"
            current={currentStep}
            items={[
              {
                title: 'Upload',
                description:
                  'You submit a credential associated with your real‚Äëworld expertise.',
              },
              {
                title: 'Review',
                description:
                  'Stewards or administrators verify authenticity and relevance for debate topics.',
                icon: <ClockCircleOutlined />,
              },
              {
                title: 'Outcome',
                description:
                  'If accepted, a note is added to your profile and may influence role assignments.',
              },
            ]}
          />

          <Divider />

          <List
            size="small"
            header="Examples of accepted credentials"
            dataSource={[
              'Professional licensure (e.g. bar membership, medical board certification).',
              'Academic degrees in fields relevant to debates you join.',
              'Official appointments or advisory roles in public institutions.',
              'Peer‚Äëreviewed publications or major reports where you are a named author.',
            ]}
            renderItem={(item) => (
              <List.Item>
                <Text>{item}</Text>
              </List.Item>
            )}
          />

          <Divider />

          <List
            size="small"
            header={
              <Space>
                <EyeInvisibleOutlined />
                <span>Privacy and scope</span>
              </Space>
            }
            dataSource={[
              'Uploaded documents are only visible to designated reviewers, not to the general public.',
              'Metadata (type of credential, issuing body, year) may be surfaced in your profile once verified.',
              'You can request removal of a credential at any time once backend support exists.',
            ]}
            renderItem={(item) => (
              <List.Item>
                <Text type="secondary">{item}</Text>
              </List.Item>
            )}
          />
        </ProCard>

        {/* Full-width: My credentials */}
        <ProCard colSpan={24} title="My credentials" ghost>
          <ProTable<CredentialRow>
            rowKey="id"
            loading={loading}
            columns={columns}
            dataSource={rows}
            pagination={{ pageSize: 5, showSizeChanger: true }}
            search={false}
            toolBarRender={() => [
              <Tooltip key="refresh" title="Refresh">
                <Button onClick={() => refresh()}>Refresh</Button>
              </Tooltip>,
            ]}
          />
        </ProCard>
      </ProCard>

      {/* Drawer: credential details */}
      <Drawer
        open={!!detail}
        width={520}
        title="Credential details"
        onClose={() => setDetail(null)}
      >
        {detail && (
          <ProDescriptions<CredentialRow>
            column={1}
            dataSource={detail}
            columns={
              [
                { title: 'Title', dataIndex: 'title' },
                { title: 'Issuer', dataIndex: 'issuer' },
                {
                  title: 'Issued',
                  dataIndex: 'issuedAt',
                  render: (_: any, row: CredentialRow) =>
                    dayjs(row.issuedAt).format('YYYY-MM-DD'),
                },
                {
                  title: 'Status',
                  dataIndex: 'status',
                  render: (_: any, row: CredentialRow) => (
                    <Tag color={statusColor[row.status]}>{row.status}</Tag>
                  ),
                },
                detail.url
                  ? {
                      title: 'Document',
                      dataIndex: 'url',
                      render: (_: any, row: CredentialRow) => (
                        <a
                          href={row.url}
                          target="_blank"
                          rel="noreferrer"
                        >
                          Open document
                        </a>
                      ),
                    }
                  : undefined,
                detail.notes
                  ? {
                      title: 'Notes',
                      dataIndex: 'notes',
                    }
                  : undefined,
              ].filter(Boolean) as ProDescriptionsItemProps<CredentialRow>[]
            }
          />
        )}
      </Drawer>
    </PageContainer>
  );

  return (
    <EthikosPageShell
      title="Credentials"
      sectionLabel="Trust"
      subtitle="Upload and manage real‚Äëworld credentials that help stewards understand your expertise in Ethikos debates."
      secondaryActions={summaryTags}
    >
      {pageBody}
    </EthikosPageShell>
  );
}

===== END app/ethikos/trust/credentials/page.tsx =====


===== BEGIN app/ethikos/trust/profile/page.tsx =====
'use client';

/**
 * Updated implementation for: frontend/app/ethikos/trust/profile/page.tsx
 *
 * Baseline references:
 * - Previous app page structure & imports.
 * - Modules variant of the Trust profile page (layout & summary patterns).
 * - Trust services: ReputationProfile types, fetchUserProfile, fetchUserBadges.
 * - Combined reputation timeline hook (profile + badges ‚Üí timeline).
 *
 * Avatar behavior:
 * - Uses profile.avatarUrl when present (from backend /users/me/ avatar_url).
 * - Falls back to initial derived from displayName ‚Üí username ‚Üí level.
 */

import React, { useMemo } from 'react';
import Link from 'next/link';
import {
  PageContainer,
  ProCard,
  StatisticCard,
} from '@ant-design/pro-components';
import {
  Avatar,
  Badge as AntBadge,
  Button,
  Descriptions,
  Divider,
  Empty,
  List,
  Progress,
  Space,
  Tag,
  Timeline,
  Tooltip,
  Typography,
} from 'antd';
import {
  CrownOutlined,
  SafetyCertificateOutlined,
  ArrowUpOutlined,
  ArrowDownOutlined,
  ClockCircleOutlined,
} from '@ant-design/icons';
import { Radar } from '@ant-design/plots';
import dayjs from 'dayjs';

import EthikosPageShell from '@/app/ethikos/EthikosPageShell';
import useReputationEvents from '@/hooks/useReputationEvents';
import type { ReputationProfile } from '@/services/trust';

const { Text, Title } = Typography;

export default function TrustProfilePage() {
  // Compose profile + badges + synthetic timeline using existing services
  const { data, isLoading, error, refetch } = useReputationEvents();
  const profile: ReputationProfile | undefined = data?.profile;
  const badges = data?.badges ?? [];
  const timeline = data?.timeline ?? [];

  // Fallbacks
  const level = profile?.level ?? 'Visitor';
  const score = profile?.score ?? 0;
  const dimensions = profile?.dimensions ?? [];
  const recent = profile?.recent ?? [];

  // Derive UI helpers (avatar + initial)
  const avatarSrc = profile?.avatarUrl ?? undefined;
  const nameSeed = profile?.displayName ?? profile?.username ?? level;
  const initial = nameSeed.charAt(0).toUpperCase();

  const netRecentDelta = useMemo(
    () => recent.reduce((sum, r) => sum + (r.change ?? 0), 0),
    [recent],
  );

  const topDimension = useMemo(() => {
    if (!dimensions.length) return undefined;
    return [...dimensions].sort((a, b) => b.score - a.score)[0];
  }, [dimensions]);

  const radarConfig = useMemo(() => {
    const dataPoints = dimensions.map((d) => ({
      metric: d.label,
      score: Math.max(0, Math.min(100, Math.round(d.score))),
    }));
    return {
      data: dataPoints,
      xField: 'metric',
      yField: 'score',
      meta: { score: { min: 0, max: 100 } },
      point: { size: 2 },
      area: {},
    } as const;
  }, [dimensions]);

  const primaryAction = (
    <Link href="/ethikos/insights">
      <Button type="primary">Open analytics</Button>
    </Link>
  );

  const secondaryActions = (
    <Space>
      <Link href="/ethikos/trust/credentials">
        <Button icon={<SafetyCertificateOutlined />}>Upload credential</Button>
      </Link>
      <Link href="/ethikos/trust/badges">
        <Button>View badges</Button>
      </Link>
    </Space>
  );

  // Error state wrapped in EthikosPageShell
  if (error) {
    return (
      <EthikosPageShell
        title="My trust profile"
        sectionLabel="Trust"
        primaryAction={primaryAction}
        secondaryActions={secondaryActions}
      >
        <PageContainer ghost>
          <ProCard ghost>
            <Space
              direction="vertical"
              size="large"
              style={{ width: '100%', textAlign: 'center' }}
            >
              <Empty description="Unable to load trust profile" />
              <Button onClick={() => refetch()} type="primary">
                Retry
              </Button>
            </Space>
          </ProCard>
        </PageContainer>
      </EthikosPageShell>
    );
  }

  return (
    <EthikosPageShell
      title="My trust profile"
      sectionLabel="Trust"
      primaryAction={primaryAction}
      secondaryActions={secondaryActions}
    >
      <PageContainer ghost loading={isLoading}>
        {/* KPI strip */}
        <ProCard gutter={16} wrap>
          <StatisticCard
            key="overall-score"
            colSpan={{ xs: 24, sm: 12, lg: 6 }}
            statistic={{
              title: 'Overall reputation score',
              value: Math.round(score),
              suffix: '/100',
              description: (
                <Space size={4} wrap>
                  <Text type="secondary">Level:</Text>
                  <Tag
                    color={
                      level === 'Steward'
                        ? 'gold'
                        : level === 'Contributor'
                        ? 'blue'
                        : 'default'
                    }
                    style={{ marginInlineStart: 4 }}
                  >
                    {level}
                  </Tag>
                </Space>
              ),
            }}
            chart={
              <div style={{ paddingInline: 8 }}>
                <Progress percent={Math.round(score)} showInfo={false} />
              </div>
            }
          />

          <StatisticCard
            key="active-dimensions"
            colSpan={{ xs: 24, sm: 12, lg: 6 }}
            statistic={{
              title: 'Active dimensions',
              value: dimensions.length,
              description: (
                <Text type="secondary">
                  {dimensions.length > 0
                    ? 'Deliberation, Participation, Influence'
                    : 'No tracked signals yet'}
                </Text>
              ),
            }}
          />

          <StatisticCard
            key="recent-delta"
            colSpan={{ xs: 24, sm: 12, lg: 6 }}
            statistic={{
              title: 'Recent change (30 days)',
              value: Math.abs(netRecentDelta),
              suffix: netRecentDelta === 0 ? '' : ' pts',
              description:
                netRecentDelta > 0 ? (
                  <span style={{ color: '#3f8600' }}>
                    <ArrowUpOutlined /> Improved vs previous period
                  </span>
                ) : netRecentDelta < 0 ? (
                  <span style={{ color: '#cf1322' }}>
                    <ArrowDownOutlined /> Declined vs previous period
                  </span>
                ) : (
                  <Text type="secondary">No significant change</Text>
                ),
            }}
          />

          <StatisticCard
            key="top-dimension"
            colSpan={{ xs: 24, sm: 12, lg: 6 }}
            statistic={{
              title: 'Top dimension',
              value: topDimension?.score ?? 0,
              suffix: topDimension ? '/100' : undefined,
              description: topDimension ? (
                <Tag>{topDimension.label}</Tag>
              ) : (
                <Text type="secondary">N/A</Text>
              ),
            }}
          />
        </ProCard>

        {/* Main content: summary + breakdown + timeline */}
        <ProCard gutter={16} split="vertical" wrap>
          {/* Left summary panel */}
          <ProCard colSpan={{ xs: 24, md: 8 }} bordered>
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              <Space align="center" size="middle">
                <AntBadge.Ribbon text="Profile" color="purple">
                  <Avatar
                    size={64}
                    src={avatarSrc}
                    style={
                      avatarSrc
                        ? undefined
                        : { background: 'var(--ant-color-warning-bg)' }
                    }
                    icon={!avatarSrc ? <CrownOutlined /> : undefined}
                  >
                    {!avatarSrc && initial}
                  </Avatar>
                </AntBadge.Ribbon>
                <div>
                  <Title level={4} style={{ marginBottom: 4 }}>
                    My trust profile
                  </Title>
                  <Text type="secondary">
                    Reputation, participation and influence across Ethikos debates.
                  </Text>
                </div>
              </Space>

              <div>
                <Text type="secondary">Overall score</Text>
                <div style={{ marginTop: 8 }}>
                  <Progress
                    type="circle"
                    percent={Math.round(score)}
                    size={96}
                  />
                </div>
              </div>

              <Descriptions
                size="small"
                column={1}
                labelStyle={{ width: 160 }}
                style={{ marginTop: 8 }}
              >
                <Descriptions.Item label="Level">
                  <Tag
                    color={
                      level === 'Steward'
                        ? 'gold'
                        : level === 'Contributor'
                        ? 'blue'
                        : 'default'
                    }
                  >
                    {level}
                  </Tag>
                </Descriptions.Item>

                <Descriptions.Item label="Dimensions tracked">
                  {dimensions.length ? (
                    <Space size={[4, 4]} wrap>
                      {dimensions.map((dim) => (
                        <Tag key={dim.key}>{dim.label}</Tag>
                      ))}
                    </Space>
                  ) : (
                    <Text type="secondary">No reputation data yet.</Text>
                  )}
                </Descriptions.Item>

                <Descriptions.Item label="Net change (30d)">
                  <Space>
                    {netRecentDelta > 0 && (
                      <Text type="success">+{netRecentDelta}</Text>
                    )}
                    {netRecentDelta < 0 && (
                      <Text type="danger">{netRecentDelta}</Text>
                    )}
                    {netRecentDelta === 0 && (
                      <Text type="secondary">0</Text>
                    )}
                  </Space>
                </Descriptions.Item>
              </Descriptions>

              <Divider style={{ margin: '8px 0' }} />

              <Space wrap>
                <Link href="/ethikos/trust/credentials">
                  <Button icon={<SafetyCertificateOutlined />}>
                    Upload credential
                  </Button>
                </Link>
                <Link href="/ethikos/trust/badges">
                  <Button>View badges</Button>
                </Link>
              </Space>
            </Space>
          </ProCard>

          {/* Right: breakdown + timeline */}
          <ProCard colSpan={{ xs: 24, md: 16 }} split="horizontal">
            <ProCard title="Score by dimension">
              {dimensions.length ? (
                dimensions.map((dim) => (
                  <div key={dim.key} style={{ marginBottom: 16 }}>
                    <div
                      style={{
                        display: 'flex',
                        justifyContent: 'space-between',
                        marginBottom: 6,
                      }}
                    >
                      <Text>{dim.label}</Text>
                      <Text type="secondary">
                        {Math.round(dim.score)}/100
                      </Text>
                    </div>
                    <Progress
                      percent={Math.round(dim.score)}
                      showInfo={false}
                    />
                  </div>
                ))
              ) : (
                <Text type="secondary">
                  As you participate in debates, we will break down how your
                  score is composed.
                </Text>
              )}
            </ProCard>

            <ProCard title="Reputation timeline">
              {timeline.length ? (
                <Timeline
                  mode="left"
                  items={timeline.map((evt) => ({
                    key: evt.id,
                    dot: <ClockCircleOutlined />,
                    label: dayjs(evt.when).isValid()
                      ? dayjs(evt.when).format('YYYY-MM-DD')
                      : evt.when,
                    children: (
                      <Space direction="vertical" size={0}>
                        <Text strong>{evt.title}</Text>
                        <Text type="secondary">{evt.detail}</Text>
                      </Space>
                    ),
                  }))}
                />
              ) : (
                <Text type="secondary">
                  We haven‚Äôt detected any recent changes in your Ethikos activity.
                </Text>
              )}
            </ProCard>
          </ProCard>
        </ProCard>

        {/* Secondary row: radar + recent badges */}
        <ProCard gutter={16} wrap style={{ marginTop: 16 }}>
          <ProCard
            colSpan={{ xs: 24, lg: 14 }}
            title={
              <Space>
                <span>Trust signal radar</span>
                <Tooltip title="Normalised per-dimension scores (0‚Äì100)">
                  <AntBadge status="processing" />
                </Tooltip>
              </Space>
            }
          >
            {dimensions.length ? (
              <Radar {...radarConfig} />
            ) : (
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description="No dimension data yet"
              />
            )}
          </ProCard>

          <ProCard
            colSpan={{ xs: 24, lg: 10 }}
            title="Recent badges"
            extra={<Link href="/ethikos/trust/badges">All badges</Link>}
            split="horizontal"
          >
            <ProCard ghost>
              {badges.length ? (
                <List
                  size="small"
                  dataSource={badges.slice(0, 3)}
                  renderItem={(b) => (
                    <List.Item key={b.id}>
                      <List.Item.Meta
                        title={
                          <Space>
                            <Text strong>{b.label}</Text>
                            <Tag color="green">Verified</Tag>
                          </Space>
                        }
                        description={
                          <Space direction="vertical" size={0}>
                            <Text type="secondary">{b.description}</Text>
                            <Text type="secondary">
                              Earned {dayjs(b.earnedAt).format('MMM D, YYYY')}
                            </Text>
                          </Space>
                        }
                      />
                    </List.Item>
                  )}
                />
              ) : (
                <Empty description="No badges earned yet" />
              )}
            </ProCard>

            <ProCard ghost>
              <Text type="secondary">
                Badges are derived from your Ekoh activity (stances, arguments,
                votes) and are used as discovery signals in KeenKonnect.
              </Text>
            </ProCard>
          </ProCard>
        </ProCard>
      </PageContainer>
    </EthikosPageShell>
  );
}

===== END app/ethikos/trust/profile/page.tsx =====


===== BEGIN app/keenkonnect/ai-team-matching/find-teams/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import {
  Badge,
  Button,
  Card,
  Divider,
  Drawer,
  Empty,
  Input,
  List,
  Row,
  Col,
  Select,
  Space,
  Switch,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  FilterOutlined,
  InfoCircleOutlined,
  SearchOutlined,
  TeamOutlined,
  UserAddOutlined,
  HeartOutlined,
  ReloadOutlined,
} from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Title, Text, Paragraph } = Typography;
const { Option } = Select;

type TeamSizeFilter = 'all' | 'small' | 'medium' | 'large';

interface TeamMatch {
  id: string;
  name: string;
  description: string;
  domain: string;
  members: string[];
  teamSize: number;
  matchReason: string;
  isOpen: boolean;
}

const sampleTeamMatches: TeamMatch[] = [
  {
    id: '1',
    name: 'AI Innovators',
    description: 'A team focused on cutting-edge AI projects and research.',
    domain: 'AI & Robotics',
    members: ['Alice', 'Bob', 'Charlie'],
    teamSize: 3,
    matchReason: 'Your background in robotics aligns with the team‚Äôs focus.',
    isOpen: true,
  },
  {
    id: '2',
    name: 'Sustainable Cities Lab',
    description:
      'Collaborating on innovative solutions for sustainable urban development.',
    domain: 'Sustainable Cities',
    members: ['Dana', 'Eve'],
    teamSize: 2,
    matchReason:
      'Your interest in urban planning and green infrastructure is highly relevant.',
    isOpen: true,
  },
  {
    id: '3',
    name: 'HealthTech Pioneers',
    description:
      'Exploring new technologies in health and wellness management.',
    domain: 'Health & Wellness',
    members: ['Frank', 'Grace', 'Heidi', 'Ivan'],
    teamSize: 4,
    matchReason:
      'Your experience at the intersection of healthcare and digital platforms is a strong match.',
    isOpen: false,
  },
];

const getTeamSizeTag = (size: number) => {
  if (size <= 3) return { label: 'Small team', color: 'green' as const };
  if (size <= 6) return { label: 'Medium team', color: 'blue' as const };
  return { label: 'Large team', color: 'purple' as const };
};

const domainOptions = Array.from(new Set(sampleTeamMatches.map((t) => t.domain)));

const FindTeamsPage: React.FC = () => {
  const router = useRouter();

  const [searchText, setSearchText] = useState('');
  const [domainFilter, setDomainFilter] = useState<string>('all');
  const [teamSizeFilter, setTeamSizeFilter] = useState<TeamSizeFilter>('all');
  const [openOnly, setOpenOnly] = useState<boolean>(false);

  const [selectedTeam, setSelectedTeam] = useState<TeamMatch | null>(null);
  const [drawerVisible, setDrawerVisible] = useState(false);

  const handleOpenDrawer = (team: TeamMatch) => {
    setSelectedTeam(team);
    setDrawerVisible(true);
  };

  const handleCloseDrawer = () => {
    setDrawerVisible(false);
    setSelectedTeam(null);
  };

  const resetFilters = () => {
    setSearchText('');
    setDomainFilter('all');
    setTeamSizeFilter('all');
    setOpenOnly(false);
  };

  const filteredTeams = useMemo(
    () =>
      sampleTeamMatches.filter((team) => {
        const matchesSearch =
          !searchText ||
          team.name.toLowerCase().includes(searchText.toLowerCase()) ||
          team.description.toLowerCase().includes(searchText.toLowerCase()) ||
          team.domain.toLowerCase().includes(searchText.toLowerCase());

        const matchesDomain =
          domainFilter === 'all' || team.domain === domainFilter;

        const matchesOpen = !openOnly || team.isOpen;

        let matchesSize = true;
        if (teamSizeFilter === 'small') {
          matchesSize = team.teamSize <= 3;
        } else if (teamSizeFilter === 'medium') {
          matchesSize = team.teamSize > 3 && team.teamSize <= 6;
        } else if (teamSizeFilter === 'large') {
          matchesSize = team.teamSize > 6;
        }

        return matchesSearch && matchesDomain && matchesOpen && matchesSize;
      }),
    [searchText, domainFilter, teamSizeFilter, openOnly],
  );

  const hasActiveFilters =
    !!searchText ||
    domainFilter !== 'all' ||
    teamSizeFilter !== 'all' ||
    openOnly;

  const handleGoToPreferences = () => {
    router.push('/keenkonnect/ai-team-matching/match-preferences');
  };

  const handleViewMatches = () => {
    router.push('/keenkonnect/ai-team-matching/my-matches');
  };

  const handleViewWorkspace = (team: TeamMatch) => {
    router.push(
      `/keenkonnect/projects/project-workspace?teamId=${encodeURIComponent(
        team.id,
      )}`,
    );
  };

  return (
    <PageContainer title="Find AI‚Äërecommended teams">
      <Space direction="vertical" size="large" style={{ width: '100%' }}>
        {/* Intro / CTA */}
        <Card>
          <Row gutter={[16, 16]} align="middle">
            <Col xs={24} md={16}>
              <Space direction="vertical" size={8}>
                <Title level={3} style={{ marginBottom: 0 }}>
                  Discover teams that match your profile
                </Title>
                <Text type="secondary">
                  KeenKonnect uses your skills, experience, and preferences to
                  suggest teams where you‚Äôre likely to thrive. Refine the filters
                  or adjust your preferences to tune the recommendations.
                </Text>
              </Space>
            </Col>
            <Col xs={24} md={8}>
              <Space
                direction="vertical"
                size={8}
                style={{ width: '100%', justifyContent: 'flex-end' }}
              >
                <Space wrap style={{ width: '100%', justifyContent: 'flex-end' }}>
                  <Button
                    onClick={handleGoToPreferences}
                    icon={<FilterOutlined />}
                  >
                    Adjust match preferences
                  </Button>
                  <Button
                    type="primary"
                    onClick={handleViewMatches}
                    icon={<TeamOutlined />}
                  >
                    View my matches
                  </Button>
                </Space>
                <Text type="secondary">
                  <InfoCircleOutlined /> Results are simulated mock data for UI
                  only.
                </Text>
              </Space>
            </Col>
          </Row>
        </Card>

        {/* Filters */}
        <Card>
          <Space direction="vertical" size="middle" style={{ width: '100%' }}>
            <Row gutter={[16, 16]}>
              <Col xs={24} md={10}>
                <Input
                  allowClear
                  prefix={<SearchOutlined />}
                  placeholder="Search teams, domains, keywords‚Ä¶"
                  value={searchText}
                  onChange={(e) => setSearchText(e.target.value)}
                />
              </Col>
              <Col xs={24} sm={12} md={5}>
                <Select
                  style={{ width: '100%' }}
                  value={domainFilter}
                  onChange={(value) => setDomainFilter(value)}
                  placeholder="Domain"
                >
                  <Option value="all">All domains</Option>
                  {domainOptions.map((domain) => (
                    <Option key={domain} value={domain}>
                      {domain}
                    </Option>
                  ))}
                </Select>
              </Col>
              <Col xs={24} sm={12} md={5}>
                <Select
                  style={{ width: '100%' }}
                  value={teamSizeFilter}
                  onChange={(value: TeamSizeFilter) => setTeamSizeFilter(value)}
                >
                  <Option value="all">All team sizes</Option>
                  <Option value="small">Small (‚â§3)</Option>
                  <Option value="medium">Medium (4‚Äì6)</Option>
                  <Option value="large">Large (7+)</Option>
                </Select>
              </Col>
              <Col xs={24} sm={12} md={4}>
                <Space>
                  <Switch
                    checked={openOnly}
                    onChange={setOpenOnly}
                    size="small"
                  />
                  <Text>Open to new members only</Text>
                </Space>
              </Col>
            </Row>

            {hasActiveFilters && (
              <Row>
                <Col span={24}>
                  <Space wrap>
                    {searchText && (
                      <Tag closable onClose={() => setSearchText('')}>
                        Search: {searchText}
                      </Tag>
                    )}
                    {domainFilter !== 'all' && (
                      <Tag closable onClose={() => setDomainFilter('all')}>
                        Domain: {domainFilter}
                      </Tag>
                    )}
                    {teamSizeFilter !== 'all' && (
                      <Tag closable onClose={() => setTeamSizeFilter('all')}>
                        Team size: {teamSizeFilter}
                      </Tag>
                    )}
                    {openOnly && (
                      <Tag closable onClose={() => setOpenOnly(false)}>
                        Open teams only
                      </Tag>
                    )}
                    <Button
                      type="link"
                      size="small"
                      icon={<ReloadOutlined />}
                      onClick={resetFilters}
                    >
                      Clear all filters
                    </Button>
                  </Space>
                </Col>
              </Row>
            )}
          </Space>
        </Card>

        {/* Teams list */}
        <Card
          title={
            <Space>
              <TeamOutlined />
              <span>Recommended teams</span>
              <Badge
                count={filteredTeams.length}
                style={{ backgroundColor: '#1890ff' }}
              />
            </Space>
          }
        >
          {filteredTeams.length === 0 ? (
            <Empty
              description={
                <span>
                  No teams match your current filters. Try broadening your search
                  or{' '}
                  <Button
                    type="link"
                    size="small"
                    onClick={handleGoToPreferences}
                  >
                    updating your preferences
                  </Button>
                  .
                </span>
              }
            />
          ) : (
            <List
              grid={{
                gutter: 16,
                xs: 1,
                sm: 1,
                md: 2,
                lg: 2,
                xl: 3,
                xxl: 3,
              }}
              dataSource={filteredTeams}
              renderItem={(team) => {
                const sizeTag = getTeamSizeTag(team.teamSize);

                return (
                  <List.Item>
                    <Card
                      hoverable
                      onClick={() => handleOpenDrawer(team)}
                      actions={[
                        <Tooltip
                          key="join"
                          title="Express interest in joining this team"
                        >
                          <Button
                            type="link"
                            icon={<UserAddOutlined />}
                            onClick={(e) => {
                              e.stopPropagation();
                              handleOpenDrawer(team);
                            }}
                          >
                            Request to join
                          </Button>
                        </Tooltip>,
                        <Tooltip key="save" title="Save this team for later">
                          <Button
                            type="link"
                            icon={<HeartOutlined />}
                            onClick={(e) => e.stopPropagation()}
                          >
                            Save
                          </Button>
                        </Tooltip>,
                      ]}
                    >
                      <Space
                        direction="vertical"
                        size={8}
                        style={{ width: '100%' }}
                      >
                        <Space align="center" style={{ width: '100%' }}>
                          <Title
                            level={5}
                            style={{ marginBottom: 0, flex: 1 }}
                          >
                            {team.name}
                          </Title>
                          <Badge
                            status={team.isOpen ? 'success' : 'default'}
                            text={team.isOpen ? 'Open' : 'Currently full'}
                          />
                        </Space>

                        <Text type="secondary">{team.description}</Text>

                        <Space wrap size={[4, 4]}>
                          <Tag color="geekblue">{team.domain}</Tag>
                          <Tag color={sizeTag.color}>
                            {sizeTag.label} ({team.teamSize})
                          </Tag>
                          <Tag>{team.members.join(', ')}</Tag>
                        </Space>

                        <Divider style={{ margin: '8px 0' }} />

                        <Space direction="vertical" size={4}>
                          <Text strong>Why this is a good match</Text>
                          <Paragraph
                            type="secondary"
                            ellipsis={{ rows: 2 }}
                            style={{ marginBottom: 0 }}
                          >
                            {team.matchReason}
                          </Paragraph>
                        </Space>

                        <Button
                          type="default"
                          block
                          onClick={(e) => {
                            e.stopPropagation();
                            handleOpenDrawer(team);
                          }}
                        >
                          View details
                        </Button>
                      </Space>
                    </Card>
                  </List.Item>
                );
              }}
            />
          )}
        </Card>
      </Space>

      {/* Details drawer */}
      <Drawer
        title={
          selectedTeam ? (
            <Space direction="vertical" size={0}>
              <Space align="center">
                <TeamOutlined />
                <span>{selectedTeam.name}</span>
                {selectedTeam.isOpen && (
                  <Tag color="green">Open to new members</Tag>
                )}
              </Space>
              <Text type="secondary">{selectedTeam.domain}</Text>
            </Space>
          ) : (
            'Team details'
          )
        }
        width={520}
        open={drawerVisible}
        onClose={handleCloseDrawer}
        destroyOnClose
      >
        {selectedTeam && (
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <section>
              <Title level={5}>Overview</Title>
              <Paragraph>{selectedTeam.description}</Paragraph>
              <Text type="secondary">
                <InfoCircleOutlined /> This team recommendation is based on your
                profile and AI matching preferences.
              </Text>
            </section>

            <section>
              <Title level={5}>Why you‚Äôre a match</Title>
              <Paragraph>{selectedTeam.matchReason}</Paragraph>
            </section>

            <section>
              <Title level={5}>Team composition</Title>
              <Space direction="vertical" style={{ width: '100%' }}>
                <Space size="small" wrap>
                  <Tag icon={<TeamOutlined />}>
                    {selectedTeam.teamSize} member
                    {selectedTeam.teamSize > 1 ? 's' : ''}
                  </Tag>
                  {selectedTeam.isOpen ? (
                    <Tag color="green">Actively recruiting</Tag>
                  ) : (
                    <Tag color="default">Currently full</Tag>
                  )}
                </Space>
                <List
                  size="small"
                  bordered
                  dataSource={selectedTeam.members}
                  renderItem={(member, index) => (
                    <List.Item>
                      <Text>
                        {index + 1}. {member}
                      </Text>
                    </List.Item>
                  )}
                />
              </Space>
            </section>

            <section>
              <Title level={5}>Next steps</Title>
              <Space direction="vertical" style={{ width: '100%' }}>
                <Button
                  type="primary"
                  icon={<UserAddOutlined />}
                  block
                  onClick={() => {
                    // Placeholder for future integration
                    // eslint-disable-next-line no-console
                    console.log('Request to join', selectedTeam.id);
                  }}
                >
                  Request to join this team
                </Button>
                <Button block onClick={() => handleViewWorkspace(selectedTeam)}>
                  View team workspace (mock)
                </Button>
                <Button
                  type="dashed"
                  icon={<HeartOutlined />}
                  block
                  onClick={() => {
                    // eslint-disable-next-line no-console
                    console.log('Saved team', selectedTeam.id);
                  }}
                >
                  Save this team
                </Button>
              </Space>
            </section>
          </Space>
        )}
      </Drawer>
    </PageContainer>
  );
};

export default FindTeamsPage;

===== END app/keenkonnect/ai-team-matching/find-teams/page.tsx =====


===== BEGIN app/keenkonnect/ai-team-matching/match-preferences/page.tsx =====
'use client';

import React from 'react';
import { Card, Space, Typography } from 'antd';
import {
  StepsForm,
  ProFormSlider,
  ProFormSelect,
  ProFormSwitch,
  ProFormTextArea,
} from '@ant-design/pro-components';

const { Title, Paragraph } = Typography;

const MatchPreferencesPage: React.FC = () => {
  return (
    <div style={{ maxWidth: 960, margin: '0 auto', padding: 24 }}>
      <Space direction="vertical" size="large" style={{ width: '100%' }}>
        <div>
          <Title level={2} style={{ marginBottom: 8 }}>
            Pr√©f√©rences de matching
          </Title>
          <Paragraph type="secondary" style={{ marginBottom: 0 }}>
            Configure tes pr√©f√©rences pour que KeenKonnect puisse te proposer des √©quipes et
            co√©quipier¬∑√®res qui te correspondent vraiment.
          </Paragraph>
        </div>

        <Card>
          <StepsForm
            containerStyle={{ maxWidth: 840, margin: '0 auto' }}
            onFinish={async (values: Record<string, unknown>) => {
              // TODO: brancher sur ton backend / API de matching
              // eslint-disable-next-line no-console
              console.log('Match preferences:', values);
              return true;
            }}
            stepsFormRender={(dom, submitter) => (
              <div>
                {dom}
                <div style={{ marginTop: 24 }}>{submitter}</div>
              </div>
            )}
          >
            {/* √âtape 1 ‚Äî Profil & objectifs */}
            <StepsForm.StepForm
              name="profile"
              title="Profil & objectifs"
              stepProps={{
                description: 'Ce que tu cherches dans l‚Äô√©quipe',
              }}
            >
              <ProFormSelect
                name="matchGoal"
                label="Objectif principal"
                placeholder="Choisis ton objectif principal"
                rules={[{ required: true, message: 'Merci de pr√©ciser ton objectif principal.' }]}
                options={[
                  { label: 'Trouver un¬∑e cofondateur¬∑rice', value: 'cofounder' },
                  { label: 'Trouver une √©quipe pour un projet', value: 'join_team' },
                  { label: 'Trouver des freelances / experts', value: 'freelance' },
                  { label: 'Brainstorm / networking uniquement', value: 'networking' },
                ]}
              />

              <ProFormSlider
                name="seniorityPreference"
                label="Niveau d‚Äôexp√©rience souhait√© dans l‚Äô√©quipe"
                min={1}
                max={10}
                marks={{
                  1: 'Tr√®s junior',
                  5: 'Mixte',
                  10: 'Tr√®s senior',
                }}
                tooltip={{
                  formatter: (value?: number) =>
                    value !== undefined ? `${value}/10` : undefined,
                }}
              />

              <ProFormSelect
                name="timeCommitment"
                label="Disponibilit√© souhait√©e des membres"
                placeholder="S√©lectionne une option"
                allowClear
                options={[
                  { label: 'Side project (3‚Äì5 h / semaine)', value: 'side' },
                  { label: 'Engagement mod√©r√© (5‚Äì10 h / semaine)', value: 'medium' },
                  { label: 'Engagement √©lev√© (10h+ / semaine)', value: 'high' },
                ]}
              />

              <ProFormSwitch
                name="remoteOnly"
                label="Je veux uniquement des collaborations 100% √† distance"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Non',
                }}
              />
            </StepsForm.StepForm>

            {/* √âtape 2 ‚Äî Style d‚Äô√©quipe */}
            <StepsForm.StepForm
              name="team"
              title="Style d‚Äô√©quipe"
              stepProps={{
                description: 'Comment tu aimes travailler',
              }}
            >
              <ProFormSlider
                name="teamSize"
                label="Taille d‚Äô√©quipe id√©ale"
                min={2}
                max={12}
                marks={{
                  2: 'Tr√®s lean',
                  5: '√âquipe moyenne',
                  10: 'Grosse √©quipe',
                }}
              />

              <ProFormSelect
                name="communicationStyle"
                label="Style de communication pr√©f√©r√©"
                placeholder="S√©lectionne ce qui te ressemble le plus"
                options={[
                  {
                    label: 'Tr√®s structur√© (notes, comptes-rendus, suivi serr√©)',
                    value: 'structured',
                  },
                  { label: 'Flexible mais r√©actif', value: 'flexible' },
                  { label: 'Informel, au feeling', value: 'casual' },
                ]}
              />

              <ProFormSlider
                name="asyncPreference"
                label="Pr√©f√©rence pour le travail asynchrone"
                min={0}
                max={10}
                marks={{
                  0: 'Tout en temps r√©el',
                  5: 'Mixte',
                  10: 'Quasi 100% asynchrone',
                }}
              />

              <ProFormSwitch
                name="needsFacilitator"
                label="Je pr√©f√®re qu‚Äôil y ait un¬∑e facilitateur¬∑rice / PM dans l‚Äô√©quipe"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Pas n√©cessaire',
                }}
              />

              <ProFormSwitch
                name="preferDiverseBackgrounds"
                label="Je souhaite une √©quipe avec des profils tr√®s vari√©s"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Peu importe',
                }}
              />
            </StepsForm.StepForm>

            {/* √âtape 3 ‚Äî Contraintes & priorit√©s */}
            <StepsForm.StepForm
              name="constraints"
              title="Contraintes & priorit√©s"
              stepProps={{
                description: 'Ce qui est non n√©gociable pour toi',
              }}
            >
              <ProFormSlider
                name="timeZoneOverlap"
                label="Chevauchement horaire minimum souhait√©"
                min={0}
                max={8}
                marks={{
                  0: 'Peu importe',
                  2: '2h',
                  4: '4h',
                  6: '6h',
                  8: '8h+',
                }}
                tooltip={{
                  formatter: (value?: number) =>
                    value !== undefined ? `${value}h de chevauchement` : undefined,
                }}
              />

              <ProFormSelect
                name="meetingFrequency"
                label="Fr√©quence de r√©unions souhait√©e"
                placeholder="S√©lectionne une option"
                allowClear
                options={[
                  { label: '1 fois par semaine', value: 'weekly' },
                  { label: '2‚Äì3 fois par semaine', value: 'twice_week' },
                  { label: 'Quotidien stand-up court', value: 'daily' },
                  { label: 'Au besoin uniquement', value: 'on_demand' },
                ]}
              />

              <ProFormSwitch
                name="openToWeekend"
                label="Ok pour travailler ponctuellement le week‚Äëend"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Non',
                }}
              />

              <ProFormSwitch
                name="openToNightSessions"
                label="Ok pour des sessions tard le soir si n√©cessaire"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Non',
                }}
              />

              <ProFormTextArea
                name="notes"
                label="D√©tails compl√©mentaires pour l‚Äôalgorithme de matching"
                placeholder="Ex.: je pr√©f√®re les √©quipes qui prototypent rapidement, j‚Äô√©vite les projets blockchain, etc."
                fieldProps={{
                  autoSize: { minRows: 3, maxRows: 6 },
                  showCount: true,
                  maxLength: 600,
                }}
              />
            </StepsForm.StepForm>
          </StepsForm>
        </Card>
      </Space>
    </div>
  );
};

export default MatchPreferencesPage;

===== END app/keenkonnect/ai-team-matching/match-preferences/page.tsx =====


===== BEGIN app/keenkonnect/ai-team-matching/my-matches/page.tsx =====
'use client';

import React from 'react';
import Head from 'next/head';
import { ProTable, ProCard, type ProColumns } from '@ant-design/pro-components';
import { Badge, Button, Drawer, Progress, Space, Tag, Typography } from 'antd';

const { Text, Title, Paragraph } = Typography;

type MatchType = 'team' | 'partner';

interface MatchRow {
  id: string;
  type: MatchType;
  name: string;
  matchScore: number;
  commonInterests: string;
  roleOrNeed: string;
  location?: string;
  availability?: string;
  membersCount?: number;
  new?: boolean;
}

/**
 * Donn√©es mock ‚Äì Teams
 * (√† remplacer par l‚ÄôAPI AI Team Matching plus tard)
 */
const teamMatches: MatchRow[] = [
  {
    id: 'team1',
    type: 'team',
    name: 'Alpha Team',
    matchScore: 92,
    commonInterests: 'UI/UX, Backend, DevOps',
    roleOrNeed: 'Recherche un¬∑e full‚Äëstack pour stabiliser le MVP.',
    location: 'Remote / Europe-friendly',
    availability: '3‚Äì5 h / semaine',
    membersCount: 4,
    new: true,
  },
  {
    id: 'team2',
    type: 'team',
    name: 'Beta Squad',
    matchScore: 85,
    commonInterests: 'Mobile, Frontend, Design System',
    roleOrNeed: 'Besoin d‚Äôun¬∑e designer produit + front React Native.',
    location: 'Montr√©al / Hybrid',
    availability: 'Soirs & week-ends',
    membersCount: 3,
  },
  {
    id: 'team3',
    type: 'team',
    name: 'Gamma Builders',
    matchScore: 78,
    commonInterests: 'Data, ML Ops, Product Analytics',
    roleOrNeed: 'Profil orient√© data storytelling & dashboards.',
    location: 'Remote',
    availability: 'Flexible',
    membersCount: 5,
  },
];

/**
 * Donn√©es mock ‚Äì Partenaires individuels
 */
const partnerMatches: MatchRow[] = [
  {
    id: 'partner1',
    type: 'partner',
    name: 'Jane Doe',
    matchScore: 88,
    commonInterests: 'Product Management, Design Thinking, Strategy',
    roleOrNeed: 'Veut co‚Äëlead un produit AI early‚Äëstage.',
    location: 'Montr√©al / Hybrid',
    availability: 'Soirs de semaine',
    new: true,
  },
  {
    id: 'partner2',
    type: 'partner',
    name: 'John Smith',
    matchScore: 80,
    commonInterests: 'Data Science, Machine Learning, Experimentation',
    roleOrNeed: 'Cherche une √©quipe pour un projet ML appliqu√©.',
    location: 'Remote / North America',
    availability: '2‚Äì3 soirs / semaine',
  },
  {
    id: 'partner3',
    type: 'partner',
    name: 'Amina K.',
    matchScore: 73,
    commonInterests: 'Community building, Facilitation, UX research',
    roleOrNeed: 'Souhaite rejoindre un projet orient√© impact social.',
    location: 'Paris',
    availability: 'Week-ends',
  },
];

export default function MyMatchesPage(): JSX.Element {
  const [selectedMatch, setSelectedMatch] = React.useState<MatchRow | null>(null);
  const [drawerOpen, setDrawerOpen] = React.useState(false);

  const allMatches: MatchRow[] = [...teamMatches, ...partnerMatches];

  const total = allMatches.length;
  const newCount = allMatches.filter((m) => m.new).length;
  const avgScore = total
    ? Math.round(allMatches.reduce((acc, m) => acc + m.matchScore, 0) / total)
    : 0;
  const strongMatches = allMatches.filter((m) => m.matchScore >= 80).length;

  const columns: ProColumns<MatchRow>[] = [
    {
      title: 'Type',
      dataIndex: 'type',
      width: 140,
      filters: [
        { text: 'Teams', value: 'team' },
        { text: 'Partners', value: 'partner' },
      ],
      onFilter: (value, row) => row.type === String(value),
      render: (_, row) => (
        <Tag color={row.type === 'team' ? 'blue' : 'purple'}>
          {row.type === 'team' ? 'Team match' : 'Partner match'}
        </Tag>
      ),
    },
    {
      title: 'Nom',
      dataIndex: 'name',
      width: 240,
      render: (_, row) => (
        <Space>
          {row.new && <Badge dot />}
          <Text strong>{row.name}</Text>
        </Space>
      ),
    },
    {
      title: 'Match',
      dataIndex: 'matchScore',
      width: 220,
      sorter: (a, b) => a.matchScore - b.matchScore,
      render: (_, row) => (
        <Space direction="vertical" size={4} style={{ width: '100%' }}>
          <Progress
            percent={row.matchScore}
            size="small"
            status={
              row.matchScore >= 85
                ? 'success'
                : row.matchScore >= 70
                ? 'active'
                : 'normal'
            }
          />
          <Text type="secondary">{row.matchScore}% de compatibilit√© globale</Text>
        </Space>
      ),
    },
    {
      title: 'Points communs',
      dataIndex: 'commonInterests',
      ellipsis: true,
    },
    {
      title: 'R√¥le / Besoin',
      dataIndex: 'roleOrNeed',
      ellipsis: true,
      width: 260,
    },
    {
      title: 'Localisation',
      dataIndex: 'location',
      width: 180,
      render: (_, row) =>
        row.location ? (
          <Text>{row.location}</Text>
        ) : (
          <Text type="secondary">‚Äî</Text>
        ),
    },
    {
      title: 'Actions',
      valueType: 'option',
      width: 200,
      render: (_, row) => [
        <Button
          key="view"
          type="link"
          onClick={() => {
            setSelectedMatch(row);
            setDrawerOpen(true);
          }}
        >
          Voir le d√©tail
        </Button>,
        <Button key="connect" type="link">
          Proposer une connexion
        </Button>,
      ],
    },
  ];

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Mes correspondances</title>
      </Head>

      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-4">Mes correspondances</h1>
        <p className="text-gray-500 mb-6">
          R√©sum√© de tes matches g√©n√©r√©s par l‚ÄôAI Team Matching&nbsp;: √©quipes, partenaires
          potentiels et niveau de compatibilit√©.
        </p>

        <Space direction="vertical" size="large" style={{ width: '100%' }}>
          {/* Bandeau de KPIs / r√©sum√© */}
          <ProCard ghost gutter={[16, 16]} wrap>
            <ProCard colSpan={{ xs: 24, sm: 12, md: 6 }} bordered>
              <Text type="secondary">Total de matches</Text>
              <Title level={3} style={{ marginTop: 8, marginBottom: 0 }}>
                {total}
              </Title>
            </ProCard>

            <ProCard colSpan={{ xs: 24, sm: 12, md: 6 }} bordered>
              <Text type="secondary">Nouveaux matches</Text>
              <Space align="baseline">
                <Title level={3} style={{ marginTop: 8, marginBottom: 0 }}>
                  {newCount}
                </Title>
                {newCount > 0 && (
                  <Badge
                    count="Nouveau"
                    style={{ backgroundColor: '#52c41a', marginLeft: 8 }}
                  />
                )}
              </Space>
            </ProCard>

            <ProCard colSpan={{ xs: 24, sm: 12, md: 6 }} bordered>
              <Text type="secondary">Compatibilit√© moyenne</Text>
              <Title level={3} style={{ marginTop: 8, marginBottom: 0 }}>
                {avgScore}%
              </Title>
              <Progress
                percent={avgScore}
                size="small"
                style={{ marginTop: 8 }}
                status={
                  avgScore >= 85 ? 'success' : avgScore >= 70 ? 'active' : 'normal'
                }
              />
            </ProCard>

            <ProCard colSpan={{ xs: 24, sm: 12, md: 6 }} bordered>
              <Text type="secondary">Matches forts (‚â• 80%)</Text>
              <Title level={3} style={{ marginTop: 8, marginBottom: 0 }}>
                {strongMatches}
              </Title>
            </ProCard>
          </ProCard>

          {/* Tableau principal */}
          <ProTable<MatchRow>
            rowKey="id"
            columns={columns}
            dataSource={allMatches}
            search={false}
            pagination={{ pageSize: 6 }}
            options={false}
            onRow={(record) => ({
              onClick: () => {
                setSelectedMatch(record);
                setDrawerOpen(true);
              },
            })}
          />
        </Space>

        {/* Drawer de d√©tail d‚Äôun match */}
        <Drawer
          title={selectedMatch ? selectedMatch.name : 'D√©tail du match'}
          open={drawerOpen}
          width={520}
          onClose={() => {
            setDrawerOpen(false);
            setSelectedMatch(null);
          }}
        >
          {selectedMatch && (
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              <Space>
                <Tag color={selectedMatch.type === 'team' ? 'blue' : 'purple'}>
                  {selectedMatch.type === 'team' ? 'Team match' : 'Partner match'}
                </Tag>
                {selectedMatch.new && (
                  <Badge count="Nouveau" style={{ backgroundColor: '#52c41a' }} />
                )}
              </Space>

              <Space align="center">
                <Progress
                  type="dashboard"
                  percent={selectedMatch.matchScore}
                  status={
                    selectedMatch.matchScore >= 85
                      ? 'success'
                      : selectedMatch.matchScore >= 70
                      ? 'active'
                      : 'normal'
                  }
                  style={{ marginRight: 16 }}
                />
                <div>
                  <Text strong>
                    {selectedMatch.matchScore}% de compatibilit√© globale
                  </Text>
                  <Paragraph type="secondary" style={{ marginBottom: 0 }}>
                    Calcul√© √† partir des int√©r√™ts, comp√©tences, disponibilit√© et
                    style de collaboration.
                  </Paragraph>
                </div>
              </Space>

              <div>
                <Title level={5}>Ce que vous avez en commun</Title>
                <Paragraph>{selectedMatch.commonInterests}</Paragraph>
              </div>

              <div>
                <Title level={5}>R√¥le &amp; attentes</Title>
                <Paragraph>{selectedMatch.roleOrNeed}</Paragraph>
              </div>

              {selectedMatch.location && (
                <Paragraph>
                  <Text strong>Localisation :</Text> {selectedMatch.location}
                </Paragraph>
              )}

              {selectedMatch.availability && (
                <Paragraph>
                  <Text strong>Disponibilit√© :</Text>{' '}
                  {selectedMatch.availability}
                </Paragraph>
              )}

              {selectedMatch.membersCount != null && (
                <Paragraph>
                  <Text strong>Taille de l‚Äô√©quipe :</Text>{' '}
                  {selectedMatch.membersCount} membres
                </Paragraph>
              )}

              <Space>
                <Button type="primary">Proposer une connexion</Button>
                <Button>Voir le profil complet</Button>
              </Space>
            </Space>
          )}
        </Drawer>
      </div>
    </>
  );
}

===== END app/keenkonnect/ai-team-matching/my-matches/page.tsx =====


===== BEGIN app/keenkonnect/dashboard/page.tsx =====
'use client';

import React from 'react';
import Link from 'next/link';
import { PageContainer, ProCard, StatisticCard } from '@ant-design/pro-components';
import {
  Badge,
  Button,
  List,
  Space,
  Tag,
  Timeline,
  Typography,
  Avatar,
  Divider,
  Progress,
} from 'antd';
import {
  AppstoreOutlined,
  RocketOutlined,
  TeamOutlined,
  FileTextOutlined,
  DashboardOutlined,
  CrownOutlined,
  PlusOutlined,
  BellOutlined,
  ClockCircleOutlined,
  ArrowRightOutlined,
} from '@ant-design/icons';
import usePageTitle from '@/hooks/usePageTitle';

const { Text, Paragraph } = Typography;

type SummaryMetric = {
  key: string;
  title: string;
  value: number;
  suffix?: string;
  description?: string;
};

type Project = {
  id: string;
  name: string;
  status: 'In Progress' | 'Planning' | 'Completed';
  role: string;
};

type Workspace = {
  id: string;
  name: string;
  participants: number;
  focus: string;
};

type KnowledgeItem = {
  id: string;
  title: string;
  type: string;
  link: string;
};

type Task = {
  id: string;
  title: string;
  due: string;
  priority: 'Low' | 'Medium' | 'High';
};

type NotificationItem = {
  id: string;
  message: string;
  type: 'info' | 'warning' | 'success';
  time: string;
};

type TimelineEvent = {
  id: string;
  time: string;
  description: string;
};

type QuickAction = {
  key: string;
  title: string;
  description: string;
  href: string;
  icon: React.ReactNode;
};

// --- Mock data ---

const summaryMetrics: SummaryMetric[] = [
  {
    key: 'projects',
    title: 'Active Projects',
    value: 7,
    description: 'Across your ecosystems',
  },
  {
    key: 'workspaces',
    title: 'Live Workspaces',
    value: 3,
    description: 'Teams currently collaborating',
  },
  {
    key: 'knowledge',
    title: 'Knowledge Assets',
    value: 32,
    description: 'Docs, methods & playbooks',
  },
  {
    key: 'aiMatches',
    title: 'New AI Matches',
    value: 4,
    description: 'Suggested teams to review',
  },
];

const myProjects: Project[] = [
  {
    id: 'p1',
    name: 'Climate-Resilient Urban Plan',
    status: 'In Progress',
    role: 'Lead Facilitator',
  },
  {
    id: 'p2',
    name: 'Circular Economy Innovation Challenge',
    status: 'Planning',
    role: 'Program Orchestrator',
  },
  {
    id: 'p3',
    name: 'Multi-city Just Transition Portfolio',
    status: 'In Progress',
    role: 'Steward',
  },
];

const activeWorkspaces: Workspace[] = [
  {
    id: 'w1',
    name: 'Regional Sustainability Lab ‚Äì Montreal',
    participants: 24,
    focus: 'Climate & urban resilience',
  },
  {
    id: 'w2',
    name: 'Just Transition Story Lab',
    participants: 18,
    focus: 'Narratives & social impact',
  },
  {
    id: 'w3',
    name: 'Circular Solutions Sprint ‚Äì Q4',
    participants: 12,
    focus: 'Circular economy pilots',
  },
];

const knowledgeItems: KnowledgeItem[] = [
  {
    id: 'k1',
    title: 'Impact Evaluation Framework ‚Äì Urban Resilience',
    type: 'Methodology',
    link: '/keenkonnect/knowledge/browse-repository',
  },
  {
    id: 'k2',
    title: 'Stakeholder Mapping Canvas ‚Äì Just Transition',
    type: 'Template',
    link: '/keenkonnect/knowledge/browse-repository',
  },
  {
    id: 'k3',
    title: 'Systems Story Library ‚Äì Circular Economy',
    type: 'Story Library',
    link: '/keenkonnect/knowledge/browse-repository',
  },
];

const myTasks: Task[] = [
  {
    id: 't1',
    title: 'Finalize proposal for Climate-Resilient Urban Plan',
    due: 'Today',
    priority: 'High',
  },
  {
    id: 't2',
    title: 'Review AI-recommended collaborators for Just Transition Lab',
    due: 'Tomorrow',
    priority: 'Medium',
  },
  {
    id: 't3',
    title: 'Tag and upload new blueprint to repository',
    due: 'This week',
    priority: 'Low',
  },
];

const notifications: NotificationItem[] = [
  {
    id: 'n1',
    message:
      'You have a pending invitation from Team Delta to join "Circular Solutions Sprint ‚Äì Q4".',
    type: 'info',
    time: '2 hours ago',
  },
  {
    id: 'n2',
    message: 'Repository "Sustainable Materials" has 3 new documents.',
    type: 'success',
    time: 'Yesterday',
  },
  {
    id: 'n3',
    message:
      'Workspace "Regional Sustainability Lab ‚Äì Montreal" starts its next cycle on Monday.',
    type: 'warning',
    time: '2 days ago',
  },
];

const activityTimeline: TimelineEvent[] = [
  {
    id: 'a1',
    time: '09:15',
    description: 'You created the project "Climate-Resilient Urban Plan".',
  },
  {
    id: 'a2',
    time: '10:02',
    description:
      'AI Team Matching suggested 2 new collaborators for "Just Transition Story Lab".',
  },
  {
    id: 'a3',
    time: '11:30',
    description:
      'New blueprint uploaded to the repository for "Circular Solutions Sprint ‚Äì Q4".',
  },
  {
    id: 'a4',
    time: '14:05',
    description:
      'Workspace "Regional Sustainability Lab ‚Äì Montreal" scheduled its next session.',
  },
];

const quickActions: QuickAction[] = [
  {
    key: 'newProject',
    title: 'Create project',
    description: 'Set up a new multi-partner initiative.',
    href: '/keenkonnect/projects/create-new-project',
    icon: <PlusOutlined />,
  },
  {
    key: 'launchWorkspace',
    title: 'Launch workspace',
    description: 'Open a collaboration space for your team.',
    href: '/keenkonnect/workspaces/launch-new-workspace',
    icon: <RocketOutlined />,
  },
  {
    key: 'browseRepository',
    title: 'Browse repository',
    description: 'Explore blueprints and shared documents.',
    href: '/keenkonnect/knowledge/browse-repository',
    icon: <AppstoreOutlined />,
  },
  {
    key: 'uploadDocument',
    title: 'Upload document',
    description: 'Add a new asset to the knowledge base.',
    href: '/keenkonnect/knowledge/upload-new-document',
    icon: <FileTextOutlined />,
  },
  {
    key: 'sustainabilityDashboard',
    title: 'Impact dashboard',
    description: 'Track sustainability metrics across projects.',
    href: '/keenkonnect/sustainability-impact/sustainability-dashboard',
    icon: <DashboardOutlined />,
  },
  {
    key: 'viewReputation',
    title: 'View reputation',
    description: 'See your Ethikos reputation profile.',
    href: '/keenkonnect/user-reputation/view-reputation-ekoh',
    icon: <CrownOutlined />,
  },
];

export default function KeenKonnectDashboard(): JSX.Element {
  usePageTitle('KeenKonnect ¬∑ Dashboard');

  return (
    <PageContainer
      ghost
      header={{
        title: 'KeenKonnect Dashboard',
        subTitle:
          'Orchestrate projects, workspaces, and knowledge across your ecosystems ‚Äî and keep an eye on AI matches, impact, and your Ethikos profile.',
        extra: (
          <Space>
            <Link href="/keenkonnect/projects/my-projects">
              <Button>View projects</Button>
            </Link>
            <Link href="/keenkonnect/ai-team-matching/match-preferences">
              <Button type="primary" icon={<TeamOutlined />}>
                AI team matching
              </Button>
            </Link>
          </Space>
        ),
      }}
    >
      {/* KPI band */}
      <ProCard gutter={16} wrap style={{ marginBottom: 16 }}>
        {summaryMetrics.map((metric) => (
          <StatisticCard
            key={metric.key}
            colSpan={{ xs: 24, sm: 12, md: 12, lg: 6 }}
            statistic={{
              title: metric.title,
              value: metric.value,
              suffix: metric.suffix,
              description: metric.description,
            }}
          />
        ))}
      </ProCard>

      {/* Main columns: projects/workspaces vs today-at-a-glance */}
      <ProCard split="vertical" gutter={16} style={{ marginBottom: 16 }}>
        {/* Projects & Workspaces */}
        <ProCard
          colSpan={{ xs: 24, xl: 16 }}
          title="Projects & Workspaces"
          subTitle="Where collaboration actually happens"
        >
          <ProCard split="horizontal" ghost>
            {/* My Projects */}
            <ProCard
              title="My Projects"
              bordered={false}
              extra={
                <Link href="/keenkonnect/projects/my-projects">
                  <Space size={4}>
                    <span>View all</span>
                    <ArrowRightOutlined />
                  </Space>
                </Link>
              }
            >
              <List
                itemLayout="horizontal"
                dataSource={myProjects}
                renderItem={(project) => (
                  <List.Item
                    key={project.id}
                    actions={[
                      <Link key="open" href="/keenkonnect/projects/my-projects">
                        Open
                      </Link>,
                    ]}
                  >
                    <List.Item.Meta
                      title={
                        <Space>
                          <Text strong>{project.name}</Text>
                          <Tag color="blue">{project.role}</Tag>
                        </Space>
                      }
                      description={
                        <Space size="small">
                          <Badge
                            status={
                              project.status === 'In Progress'
                                ? 'processing'
                                : project.status === 'Planning'
                                ? 'warning'
                                : 'success'
                            }
                          />
                          <Text type="secondary">{project.status}</Text>
                        </Space>
                      }
                    />
                  </List.Item>
                )}
              />
            </ProCard>

            <Divider style={{ margin: '12px 0' }} />

            {/* Active Workspaces */}
            <ProCard
              title="Active Workspaces"
              bordered={false}
              extra={
                <Link href="/keenkonnect/workspaces/my-workspaces">
                  <Space size={4}>
                    <span>View all</span>
                    <ArrowRightOutlined />
                  </Space>
                </Link>
              }
            >
              <List
                itemLayout="horizontal"
                dataSource={activeWorkspaces}
                renderItem={(workspace) => (
                  <List.Item
                    key={workspace.id}
                    actions={[
                      <Link key="open" href="/keenkonnect/workspaces/my-workspaces">
                        Open
                      </Link>,
                    ]}
                  >
                    <List.Item.Meta
                      title={
                        <Space>
                          <Text strong>{workspace.name}</Text>
                          <Tag color="geekblue">{workspace.focus}</Tag>
                        </Space>
                      }
                      description={
                        <Text type="secondary">
                          {workspace.participants} participants currently active
                        </Text>
                      }
                    />
                  </List.Item>
                )}
              />
            </ProCard>
          </ProCard>
        </ProCard>

        {/* Today at a Glance */}
        <ProCard
          colSpan={{ xs: 24, xl: 8 }}
          title="Today at a Glance"
          extra={<Badge count={notifications.length} offset={[8, 0]} />}
        >
          {/* My Tasks */}
          <ProCard
            title="My Tasks"
            bordered={false}
            size="small"
            // moved from "extra" to "subTitle" to avoid vertical, super-tall header
            subTitle={<Text type="secondary">Focus on impact-critical items</Text>}
          >
            <List
              size="small"
              dataSource={myTasks}
              renderItem={(task) => (
                <List.Item key={task.id}>
                  <List.Item.Meta
                    title={
                      <Space>
                        <Text>{task.title}</Text>
                        <Tag
                          color={
                            task.priority === 'High'
                              ? 'red'
                              : task.priority === 'Medium'
                              ? 'orange'
                              : 'default'
                          }
                        >
                          {task.priority}
                        </Tag>
                      </Space>
                    }
                    description={
                      <Text type="secondary">
                        Due: <strong>{task.due}</strong>
                      </Text>
                    }
                  />
                </List.Item>
              )}
            />
          </ProCard>

          <Divider style={{ margin: '12px 0' }} />

          {/* Notifications */}
          <ProCard
            title={
              <Space>
                <BellOutlined />
                <span>Notifications</span>
              </Space>
            }
            bordered={false}
            size="small"
          >
            <List
              size="small"
              dataSource={notifications}
              renderItem={(item) => (
                <List.Item key={item.id}>
                  <Space direction="vertical" size={0} style={{ width: '100%' }}>
                    <Text>{item.message}</Text>
                    <Text type="secondary" style={{ fontSize: 12 }}>
                      {item.time}
                    </Text>
                  </Space>
                </List.Item>
              )}
            />
          </ProCard>
        </ProCard>
      </ProCard>

      {/* Knowledge Hub & Recent Activity */}
      <ProCard gutter={16} split="vertical" style={{ marginBottom: 16 }}>
        {/* Knowledge Hub */}
        <ProCard
          colSpan={{ xs: 24, md: 12 }}
          title="Knowledge Hub"
          subTitle="Methods, playbooks, and shared assets"
          extra={
            <Link href="/keenkonnect/knowledge/browse-repository">
              <Space size={4}>
                <span>Open knowledge hub</span>
                <ArrowRightOutlined />
              </Space>
            </Link>
          }
        >
          <List
            itemLayout="horizontal"
            dataSource={knowledgeItems}
            renderItem={(item) => (
              <List.Item
                key={item.id}
                actions={[
                  <Link key="open" href={item.link}>
                    View
                  </Link>,
                ]}
              >
                <List.Item.Meta
                  avatar={
                    <Avatar
                      style={{ backgroundColor: '#f5f5f5', color: '#555' }}
                      icon={<FileTextOutlined />}
                    />
                  }
                  title={
                    <Space>
                      <Text strong>{item.title}</Text>
                      <Tag>{item.type}</Tag>
                    </Space>
                  }
                  description={
                    <Text type="secondary">Recently used in your workspaces</Text>
                  }
                />
              </List.Item>
            )}
          />
        </ProCard>

        {/* Recent Activity */}
        <ProCard
          colSpan={{ xs: 24, md: 12 }}
          title="Recent Activity"
          subTitle="What changed in your ecosystem"
        >
          <Timeline
            mode="left"
            items={activityTimeline.map((event) => ({
              key: event.id,
              dot: <ClockCircleOutlined />,
              children: (
                <Space direction="vertical" size={0}>
                  <Text strong>{event.time}</Text>
                  <Text type="secondary">{event.description}</Text>
                </Space>
              ),
            }))}
          />
        </ProCard>
      </ProCard>

      {/* AI matching + Ethikos Profile & Quick Actions */}
      <ProCard gutter={16} split="vertical">
        {/* AI Team Matching */}
        <ProCard
          colSpan={{ xs: 24, md: 12 }}
          title="AI Team Matching"
          subTitle="Smart suggestions for project teams"
          extra={
            <Space>
              <Link href="/keenkonnect/ai-team-matching/my-matches">
                <Button type="link" size="small">
                  View matches
                </Button>
              </Link>
              <Link href="/keenkonnect/ai-team-matching/match-preferences">
                <Button type="primary" size="small" icon={<TeamOutlined />}>
                  New matching run
                </Button>
              </Link>
            </Space>
          }
        >
          <Paragraph>
            AI matching analyses expertise, diversity, and collaboration patterns across
            your ecosystem to propose high‚Äëimpact teams.
          </Paragraph>
          <List
            size="small"
            header={<Text strong>Highlights</Text>}
            dataSource={[
              '4 new suggested teams for climate resilience projects',
              '2 under‚Äëutilised experts flagged for upcoming workspaces',
              '1 cross‚Äëecosystem collaboration opportunity linking Montreal & Nairobi labs',
            ]}
            renderItem={(text, idx) => (
              <List.Item key={idx}>
                <Text>{text}</Text>
              </List.Item>
            )}
          />
        </ProCard>

        {/* Ethikos Profile & Quick Actions */}
        <ProCard
          colSpan={{ xs: 24, md: 12 }}
          title="Ethikos Profile & Impact"
          subTitle="How your orchestration shows up across the network"
        >
          <Space direction="vertical" size="middle" style={{ width: '100%' }}>
            <Space align="center">
              <Badge.Ribbon text="Beta">
                <Avatar
                  size={56}
                  style={{ backgroundColor: '#faad14', marginRight: 12 }}
                  icon={<CrownOutlined />}
                />
              </Badge.Ribbon>
              <div>
                <Text strong>Ethikos Orchestrator Profile</Text>
                <br />
                <Text type="secondary">
                  Reputation, trust and ethical alignment ‚Äî integrated with KeenKonnect.
                </Text>
              </div>
            </Space>

            <div>
              <Text type="secondary">Profile completeness</Text>
              <Progress percent={68} size="small" />
            </div>

            <div>
              <Text type="secondary">Impact coverage across SDGs</Text>
              <Progress
                percent={72}
                size="small"
                success={{ percent: 40 }}
                format={(percent) => `${percent}% of mapped initiatives`}
              />
            </div>

            <Divider style={{ margin: '8px 0' }} />

            <ProCard
              title="Quick actions"
              bordered={false}
              size="small"
              ghost
              style={{ padding: 0 }}
            >
              <List
                grid={{ gutter: 16, xs: 1, sm: 2 }}
                dataSource={quickActions}
                renderItem={(action) => (
                  <List.Item key={action.key}>
                    <Space direction="vertical" size={4} style={{ width: '100%' }}>
                      <Link href={action.href}>
                        <Button block icon={action.icon}>
                          {action.title}
                        </Button>
                      </Link>
                      <Text type="secondary" style={{ fontSize: 12 }}>
                        {action.description}
                      </Text>
                    </Space>
                  </List.Item>
                )}
              />
            </ProCard>
          </Space>
        </ProCard>
      </ProCard>
    </PageContainer>
  );
}

===== END app/keenkonnect/dashboard/page.tsx =====


===== BEGIN app/keenkonnect/KeenPageShell.tsx =====
'use client';

import React from 'react';
import Head from 'next/head';
import usePageTitle from '@/hooks/usePageTitle';

type KeenPageProps = {
  /** Gros titre de la page, affich√© en <h1> */
  title: string;

  /** Sous-titre / description sous le titre */
  description?: string;

  /** Titre <title> du navigateur. Si non fourni, on g√©n√®re "KeenKonnect ¬∑ {title}" */
  metaTitle?: string;

  /** Contenu principal de la page */
  children: React.ReactNode;

  /**
   * √âl√©ment(s) √† droite du titre (boutons d‚Äôaction, filtres, etc.)
   * ex: <Button type="primary">New</Button>
   */
  toolbar?: React.ReactNode;

  /** Largeur max de la zone centrale */
  maxWidth?: number | string;
};

export default function KeenPage({
  title,
  description,
  metaTitle,
  children,
  toolbar,
  maxWidth = 1200,
}: KeenPageProps) {
  const finalMetaTitle = metaTitle ?? `KeenKonnect ¬∑ ${title}`;

  // Synchronise le titre de l‚Äôonglet (hook existant dans ton codebase)
  usePageTitle(finalMetaTitle);

  return (
    <>
      <Head>
        <title>{finalMetaTitle}</title>
      </Head>

      <div className="container mx-auto p-5" style={{ maxWidth }}>
        {/* Header de page standardis√© */}
        <div className="mb-4 flex flex-wrap items-center justify-between gap-3">
          <div>
            <h1 className="text-2xl font-bold">{title}</h1>
            {description && (
              <p className="mt-1 text-gray-500">{description}</p>
            )}
          </div>

          {toolbar && <div className="flex items-center gap-2">{toolbar}</div>}
        </div>

        {/* Contenu sp√©cifique √† la page */}
        {children}
      </div>
    </>
  );
}

===== END app/keenkonnect/KeenPageShell.tsx =====


===== BEGIN app/keenkonnect/knowledge/browse-repository/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import Head from 'next/head';
import { Card, Row, Col, Tree, Input, Select, Tag, Space, Typography } from 'antd';
import type { DataNode, TreeProps } from 'antd/es/tree';
import { ProTable, type ProColumns } from '@ant-design/pro-components';
import { FolderOpenOutlined, FileTextOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';

const { Search } = Input;
const { Title, Text } = Typography;

/**
 * Vocabulaire du d√©p√¥t de connaissances KeenKonnect
 * (align√© avec la doc : domaines, types, niveaux d'acc√®s, statuts)
 */
const DOMAINS = ['Robotics', 'Healthcare', 'Education', 'Civic Engagement'] as const;
const KINDS = ['Blueprint', 'Protocol', 'Case Study', 'Toolkit'] as const;

type Domain = (typeof DOMAINS)[number];
type Kind = (typeof KINDS)[number];
type AccessLevel = 'Public' | 'Member' | 'Partner';
type Status = 'Published' | 'Draft';

type KnowledgeDocument = {
  id: string;
  title: string;
  domain: Domain;
  kind: Kind;
  access: AccessLevel;
  status: Status;
  updatedAt: string; // ISO date string
  owner: string;
  tags: string[];
};

type TreeKey = 'all' | Domain | `${Domain}|${Kind}`;
type AccessFilter = 'all' | AccessLevel;
type StatusFilter = 'all' | Status;

/**
 * Arborescence du d√©p√¥t : domaine -> type de ressource
 */
const treeData: DataNode[] = [
  {
    key: 'all' as TreeKey,
    title: 'Tous les contenus',
    icon: <FolderOpenOutlined />,
  },
  {
    key: 'Robotics' as TreeKey,
    title: 'Robotics',
    icon: <FolderOpenOutlined />,
    children: [
      { key: 'Robotics|Blueprint' as TreeKey, title: 'Blueprints', icon: <FileTextOutlined /> },
      { key: 'Robotics|Protocol' as TreeKey, title: 'Protocols', icon: <FileTextOutlined /> },
      { key: 'Robotics|Case Study' as TreeKey, title: 'Case Studies', icon: <FileTextOutlined /> },
      { key: 'Robotics|Toolkit' as TreeKey, title: 'Toolkits', icon: <FileTextOutlined /> },
    ],
  },
  {
    key: 'Healthcare' as TreeKey,
    title: 'Healthcare',
    icon: <FolderOpenOutlined />,
    children: [
      { key: 'Healthcare|Blueprint' as TreeKey, title: 'Blueprints', icon: <FileTextOutlined /> },
      { key: 'Healthcare|Protocol' as TreeKey, title: 'Protocols', icon: <FileTextOutlined /> },
      { key: 'Healthcare|Case Study' as TreeKey, title: 'Case Studies', icon: <FileTextOutlined /> },
      { key: 'Healthcare|Toolkit' as TreeKey, title: 'Toolkits', icon: <FileTextOutlined /> },
    ],
  },
  {
    key: 'Education' as TreeKey,
    title: 'Education',
    icon: <FolderOpenOutlined />,
    children: [
      { key: 'Education|Blueprint' as TreeKey, title: 'Blueprints', icon: <FileTextOutlined /> },
      { key: 'Education|Protocol' as TreeKey, title: 'Protocols', icon: <FileTextOutlined /> },
      { key: 'Education|Case Study' as TreeKey, title: 'Case Studies', icon: <FileTextOutlined /> },
      { key: 'Education|Toolkit' as TreeKey, title: 'Toolkits', icon: <FileTextOutlined /> },
    ],
  },
  {
    key: 'Civic Engagement' as TreeKey,
    title: 'Civic Engagement',
    icon: <FolderOpenOutlined />,
    children: [
      {
        key: 'Civic Engagement|Blueprint' as TreeKey,
        title: 'Blueprints',
        icon: <FileTextOutlined />,
      },
      {
        key: 'Civic Engagement|Protocol' as TreeKey,
        title: 'Protocols',
        icon: <FileTextOutlined />,
      },
      {
        key: 'Civic Engagement|Case Study' as TreeKey,
        title: 'Case Studies',
        icon: <FileTextOutlined />,
      },
      {
        key: 'Civic Engagement|Toolkit' as TreeKey,
        title: 'Toolkits',
        icon: <FileTextOutlined />,
      },
    ],
  },
];

/**
 * Donn√©es de d√©monstration align√©es avec KeenKonnect Knowledge
 * (domains, types, tags...).
 */
const MOCK_DOCUMENTS: KnowledgeDocument[] = [
  {
    id: 'doc-001',
    title: 'Blueprint robotique ‚Äì Drone civique open-source',
    domain: 'Robotics',
    kind: 'Blueprint',
    access: 'Public',
    status: 'Published',
    updatedAt: '2025-02-15',
    owner: 'Collectif Drones Montr√©al',
    tags: ['drone', 'mobilit√©', 'open hardware'],
  },
  {
    id: 'doc-002',
    title: 'Toolkit ‚Äì Robots d‚Äôassistance pour biblioth√®ques de quartier',
    domain: 'Robotics',
    kind: 'Toolkit',
    access: 'Member',
    status: 'Published',
    updatedAt: '2025-01-20',
    owner: 'KeenKonnect Robotics Guild',
    tags: ['inclusion', 'accessibilit√©', 'biblioth√®que'],
  },
  {
    id: 'doc-003',
    title: 'Protocole de t√©l√©m√©decine pour cliniques mobiles',
    domain: 'Healthcare',
    kind: 'Protocol',
    access: 'Public',
    status: 'Draft',
    updatedAt: '2025-03-02',
    owner: 'Coop Sant√© Quartier-Nord',
    tags: ['t√©l√©m√©decine', 'clinique mobile', 'sant√©'],
  },
  {
    id: 'doc-004',
    title: '√âtude de cas ‚Äì R√©seau de soins communautaires',
    domain: 'Healthcare',
    kind: 'Case Study',
    access: 'Partner',
    status: 'Published',
    updatedAt: '2025-01-05',
    owner: 'Healthcare Civic Lab',
    tags: ['r√©seau', 'communaut√©', 'sant√©'],
  },
  {
    id: 'doc-005',
    title: 'Toolkit ‚Äì Atelier de litt√©ratie num√©rique pour ados',
    domain: 'Education',
    kind: 'Toolkit',
    access: 'Public',
    status: 'Published',
    updatedAt: '2024-12-18',
    owner: 'KeenKonnect Learning Hub',
    tags: ['√©ducation', 'num√©rique', 'atelier'],
  },
  {
    id: 'doc-006',
    title: 'Blueprint ‚Äì FabLab scolaire low-cost',
    domain: 'Education',
    kind: 'Blueprint',
    access: 'Member',
    status: 'Draft',
    updatedAt: '2025-02-01',
    owner: 'FabLab √âcole-ouverte',
    tags: ['fablab', '√©cole', 'DIY'],
  },
  {
    id: 'doc-007',
    title: '√âtude de cas ‚Äì Budget participatif de quartier',
    domain: 'Civic Engagement',
    kind: 'Case Study',
    access: 'Public',
    status: 'Published',
    updatedAt: '2024-11-30',
    owner: 'Lab Participation Citoyenne',
    tags: ['budget participatif', 'civic tech', 'gouvernance'],
  },
  {
    id: 'doc-008',
    title: 'Protocole ‚Äì Facilitation d‚Äôassembl√©es citoyennes hybrides',
    domain: 'Civic Engagement',
    kind: 'Protocol',
    access: 'Partner',
    status: 'Draft',
    updatedAt: '2025-01-28',
    owner: 'Civic Engagement Studio',
    tags: ['assembl√©e', 'hybride', 'facilitation'],
  },
];

const ACCESS_FILTER_OPTIONS: { label: string; value: AccessFilter }[] = [
  { label: 'Tous les acc√®s', value: 'all' },
  { label: 'Public', value: 'Public' },
  { label: 'Membres', value: 'Member' },
  { label: 'Partenaires', value: 'Partner' },
];

const STATUS_FILTER_OPTIONS: { label: string; value: StatusFilter }[] = [
  { label: 'Tous les statuts', value: 'all' },
  { label: 'Publi√©', value: 'Published' },
  { label: 'Brouillon', value: 'Draft' },
];

function BrowseRepositoryPage(): JSX.Element {
  const router = useRouter();

  const [selectedKey, setSelectedKey] = useState<TreeKey>('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [accessFilter, setAccessFilter] = useState<AccessFilter>('all');
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');

  const handleTreeSelect: TreeProps['onSelect'] = (keys) => {
    if (!keys || !keys.length) return;
    setSelectedKey(keys[0] as TreeKey);
  };

  const filteredData = useMemo(
    () =>
      MOCK_DOCUMENTS.filter((doc) => {
        // 1) Filtre par arborescence (domaine / type)
        if (selectedKey !== 'all') {
          const [domainKey, kindKey] = selectedKey.split('|') as [
            Domain | undefined,
            Kind | undefined,
          ];

          if (domainKey && doc.domain !== domainKey) {
            return false;
          }
          if (kindKey && doc.kind !== kindKey) {
            return false;
          }
        }

        // 2) Filtre par niveau d‚Äôacc√®s
        if (accessFilter !== 'all' && doc.access !== accessFilter) {
          return false;
        }

        // 3) Filtre par statut
        if (statusFilter !== 'all' && doc.status !== statusFilter) {
          return false;
        }

        // 4) Recherche plein texte
        const trimmed = searchTerm.trim();
        if (!trimmed) return true;

        const needle = trimmed.toLowerCase();
        return (
          doc.title.toLowerCase().includes(needle) ||
          doc.owner.toLowerCase().includes(needle) ||
          doc.domain.toLowerCase().includes(needle) ||
          doc.kind.toLowerCase().includes(needle) ||
          doc.tags.some((tag) => tag.toLowerCase().includes(needle))
        );
      }),
    [selectedKey, accessFilter, statusFilter, searchTerm],
  );

  const columns: ProColumns<KnowledgeDocument>[] = useMemo(
    () => [
      {
        title: 'Titre',
        dataIndex: 'title',
        ellipsis: true,
        width: 260,
      },
      {
        title: 'Domaine',
        dataIndex: 'domain',
        width: 150,
        filters: DOMAINS.map((domain) => ({ text: domain, value: domain })),
        onFilter: (value, record) => record.domain === (value as Domain),
      },
      {
        title: 'Type',
        dataIndex: 'kind',
        width: 150,
        filters: KINDS.map((kind) => ({ text: kind, value: kind })),
        onFilter: (value, record) => record.kind === (value as Kind),
      },
      {
        title: 'Acc√®s',
        dataIndex: 'access',
        width: 120,
        render: (_dom, row) => {
          let color: string = 'default';

          if (row.access === 'Public') color = 'green';
          if (row.access === 'Member') color = 'blue';
          if (row.access === 'Partner') color = 'purple';

          return <Tag color={color}>{row.access}</Tag>;
        },
      },
      {
        title: 'Statut',
        dataIndex: 'status',
        width: 120,
        render: (_dom, row) => (
          <Tag color={row.status === 'Published' ? 'green' : 'gold'}>
            {row.status === 'Published' ? 'Publi√©' : 'Brouillon'}
          </Tag>
        ),
      },
      {
        title: 'Mise √† jour',
        dataIndex: 'updatedAt',
        valueType: 'date',
        width: 130,
      },
      {
        title: 'Propri√©taire',
        dataIndex: 'owner',
        width: 180,
      },
      {
        title: 'Tags',
        dataIndex: 'tags',
        search: false,
        render: (_dom, row) => (
          <Space size={4} wrap>
            {row.tags.map((tag) => (
              <Tag key={tag}>{tag}</Tag>
            ))}
          </Space>
        ),
      },
      {
        title: 'Actions',
        valueType: 'option',
        width: 120,
        render: (_dom, row) => [
          <a
            key="open"
            onClick={() =>
              router.push(`/keenkonnect/knowledge/document/${encodeURIComponent(row.id)}`)
            }
          >
            Ouvrir
          </a>,
        ],
      },
    ],
    [router],
  );

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Parcourir le d√©p√¥t de connaissances</title>
        <meta
          name="description"
          content="Parcourir le d√©p√¥t de connaissances KeenKonnect par domaine, type de ressource et filtres avanc√©s."
        />
      </Head>

      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-4">Parcourir le d√©p√¥t de connaissances</h1>

        <Row gutter={[24, 24]}>
          {/* Panneau de gauche : arbre de navigation */}
          <Col xs={24} lg={6}>
            <Card
              size="small"
              bordered={false}
              title="Arborescence du d√©p√¥t"
              headStyle={{ fontWeight: 600 }}
            >
              <Text type="secondary">
                Naviguez par domaine et type de ressource pour filtrer la liste √† droite.
              </Text>

              <div style={{ marginTop: 16 }}>
                <Tree
                  showIcon
                  blockNode
                  defaultExpandAll
                  selectedKeys={[selectedKey]}
                  onSelect={handleTreeSelect}
                  treeData={treeData}
                />
              </div>
            </Card>
          </Col>

          {/* Panneau de droite : recherche + ProTable */}
          <Col xs={24} lg={18}>
            <Card
              size="small"
              bordered={false}
              title={
                <Space direction="vertical" size={0}>
                  <Title level={4} style={{ margin: 0 }}>
                    Parcourir les ressources
                  </Title>
                  <Text type="secondary">
                    Combinez l‚Äôarborescence, la recherche et les filtres pour trouver
                    rapidement les ressources KeenKonnect.
                  </Text>
                </Space>
              }
            >
              <Space direction="vertical" size="large" style={{ width: '100%' }}>
                <Space
                  wrap
                  style={{
                    width: '100%',
                    justifyContent: 'space-between',
                    rowGap: 16,
                  }}
                >
                  <Search
                    placeholder="Rechercher par titre, tag, propri√©taire‚Ä¶"
                    allowClear
                    style={{ maxWidth: 360 }}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    onSearch={(value) => setSearchTerm(value.trim())}
                  />

                  <Space wrap>
                    <Select<AccessFilter>
                      allowClear
                      placeholder="Niveau d'acc√®s"
                      style={{ minWidth: 160 }}
                      value={accessFilter === 'all' ? undefined : accessFilter}
                      onChange={(value) => setAccessFilter(value ?? 'all')}
                      options={ACCESS_FILTER_OPTIONS}
                    />
                    <Select<StatusFilter>
                      allowClear
                      placeholder="Statut"
                      style={{ minWidth: 160 }}
                      value={statusFilter === 'all' ? undefined : statusFilter}
                      onChange={(value) => setStatusFilter(value ?? 'all')}
                      options={STATUS_FILTER_OPTIONS}
                    />
                  </Space>
                </Space>

                <ProTable<KnowledgeDocument>
                  rowKey="id"
                  search={false}
                  options={false}
                  toolBarRender={false}
                  size="small"
                  dataSource={filteredData}
                  columns={columns}
                  pagination={{
                    pageSize: 10,
                    showSizeChanger: false,
                  }}
                />
              </Space>
            </Card>
          </Col>
        </Row>
      </div>
    </>
  );
}

export default BrowseRepositoryPage;

===== END app/keenkonnect/knowledge/browse-repository/page.tsx =====


===== BEGIN app/keenkonnect/knowledge/document-management/page.tsx =====
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Avatar,
  Button,
  Card,
  Col,
  Divider,
  Drawer,
  Input,
  List,
  Row,
  Space,
  Switch,
  Tag,
  Tooltip,
  message,
} from 'antd';
import {
  EyeOutlined,
  PlusOutlined,
  SaveOutlined,
  UploadOutlined,
} from '@ant-design/icons';
import {
  EditableProTable,
  ModalForm,
  ProFormSelect,
  ProFormSwitch,
  ProFormText,
  ProFormTextArea,
  type ProColumns,
} from '@ant-design/pro-components';
import { Comment } from '@ant-design/compatible';
import usePageTitle from '@/hooks/usePageTitle';

const { TextArea } = Input;

type DocumentStatus = 'Draft' | 'Published' | 'Archived';

type ManagedDocument = {
  id: string;
  title: string;
  category: string;
  language: string;
  owner: string;
  status: DocumentStatus;
  aiIndexed: boolean;
  visible: boolean;
  version: string;
  updatedAt: string;
  tags: string[];
  summary: string;
};

type VersionItem = {
  version: string;
  timestamp: string;
  author: string;
  changeSummary: string;
};

type CommentItem = {
  id: number;
  author: string;
  avatar: string;
  content: string;
  datetime: string;
};

type NewDocumentFormValues = {
  title: string;
  category: string;
  language: string;
  owner?: string;
  status?: DocumentStatus;
  aiIndexed?: boolean;
  visible?: boolean;
  tags?: string[];
  summary?: string;
};

const initialDocuments: ManagedDocument[] = [
  {
    id: 'doc-1',
    title: 'Innovative Research Document',
    category: 'Research',
    language: 'English',
    owner: 'Dr. Alice Chen',
    status: 'Published',
    aiIndexed: true,
    visible: true,
    version: '1.4',
    updatedAt: '2025-05-12',
    tags: ['robotics', 'clinical-trials'],
    summary:
      'Over the last three funding cycles, the robotics and clinical teams have collaborated on a shared protocol that aligns safety thresholds and trial milestones across sites.',
  },
  {
    id: 'doc-2',
    title: 'Robotics Safety Guidelines ‚Äì v2',
    category: 'Safety & Compliance',
    language: 'English',
    owner: 'Security Office',
    status: 'Draft',
    aiIndexed: false,
    visible: true,
    version: '2.0-draft',
    updatedAt: '2025-04-30',
    tags: ['safety', 'protocol'],
    summary:
      'Draft revision of robotics safety guidelines, including new proximity sensor checks and human-in-the-loop overrides for high‚Äërisk procedures.',
  },
  {
    id: 'doc-3',
    title: 'Clinical Trial Template (Phase II)',
    category: 'Clinical Protocol',
    language: 'French',
    owner: 'Clinical Ops',
    status: 'Published',
    aiIndexed: true,
    visible: true,
    version: '1.1',
    updatedAt: '2025-03-18',
    tags: ['template', 'phase-II'],
    summary:
      'Standardized template for Phase II clinical trials, ready for localization and site‚Äëspecific amendments.',
  },
  {
    id: 'doc-4',
    title: 'Legacy Device Integration Notes',
    category: 'Design Blueprint',
    language: 'English',
    owner: 'Systems Engineering',
    status: 'Archived',
    aiIndexed: false,
    visible: false,
    version: '0.9',
    updatedAt: '2024-12-02',
    tags: ['legacy', 'integration'],
    summary:
      'Historical notes on integrating first‚Äëgeneration devices with the current control stack. Kept for traceability.',
  },
  {
    id: 'doc-5',
    title: 'Onboarding Learning Module ‚Äì Robotics Basics',
    category: 'Learning Module',
    language: 'French',
    owner: 'People & Culture',
    status: 'Published',
    aiIndexed: true,
    visible: true,
    version: '1.0',
    updatedAt: '2025-01-10',
    tags: ['onboarding', 'training'],
    summary:
      'Introductory learning module that covers robotics fundamentals, safety posture, and escalation paths for new team members.',
  },
];

const versionHistory: VersionItem[] = [
  {
    version: '1.4',
    timestamp: '2025-05-12 10:15',
    author: 'Dr. Alice Chen',
    changeSummary: 'Clarified safety thresholds for Phase II trials.',
  },
  {
    version: '1.3',
    timestamp: '2025-03-28 16:42',
    author: 'Dr. Omar El‚ÄëSayed',
    changeSummary: 'Added cross-site comparison metrics and monitoring hooks.',
  },
  {
    version: '1.2',
    timestamp: '2024-12-09 09:20',
    author: 'Dr. Helena Ruiz',
    changeSummary: 'Aligned terminology with the institutional ethics committee.',
  },
  {
    version: '1.1',
    timestamp: '2024-07-18 14:55',
    author: 'Dr. Alice Chen',
    changeSummary: 'Initial roll‚Äëout for robotics‚Äìclinical protocol harmonization.',
  },
];

const commentsData: CommentItem[] = [
  {
    id: 1,
    author: 'Dr. Alice Chen',
    avatar: 'https://xsgames.co/randomusers/avatar.php?g=female',
    content:
      'Let‚Äôs keep the safety thresholds conservative for the first pilot sites. We can relax them once we have stable telemetry.',
    datetime: '2 hours ago',
  },
  {
    id: 2,
    author: 'Dr. Omar El‚ÄëSayed',
    avatar: 'https://xsgames.co/randomusers/avatar.php?g=male',
    content:
      'Agreed. I‚Äôd also like to add one more metric around post‚Äëop mobility for the robotics‚Äëassisted procedures.',
    datetime: '1 hour ago',
  },
  {
    id: 3,
    author: 'Dr. Helena Ruiz',
    avatar: 'https://xsgames.co/randomusers/avatar.php?g=female',
    content:
      'Once this goes live, I‚Äôll present it to the ethics board. Please tag any sections you expect to change in the next revision.',
    datetime: '25 minutes ago',
  },
];

const getStatusColor = (status: DocumentStatus): string => {
  switch (status) {
    case 'Published':
      return 'green';
    case 'Draft':
      return 'gold';
    case 'Archived':
    default:
      return 'default';
  }
};

export default function DocumentManagementPage() {
  usePageTitle('KeenKonnect ¬∑ Knowledge ¬∑ Document Management');
  const router = useRouter();

  const [dataSource, setDataSource] = useState<ManagedDocument[]>(initialDocuments);
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>([]);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [selectedDocument, setSelectedDocument] =
    useState<ManagedDocument | null>(null);

  const updateDocument = (id: string, patch: Partial<ManagedDocument>) => {
    setDataSource(prev =>
      prev.map(item => (item.id === id ? { ...item, ...patch } : item)),
    );
    setSelectedDocument(prev =>
      prev && prev.id === id ? ({ ...prev, ...patch } as ManagedDocument) : prev,
    );
  };

  const handleSaveChanges = () => {
    if (!selectedDocument) return;
    // Simulation d‚Äôun appel API
    // eslint-disable-next-line no-console
    console.log('Saving changes for document', selectedDocument.id);
    message.success('Changes saved (simulated).');
  };

  const handlePublishNewVersion = () => {
    if (!selectedDocument) return;
    // eslint-disable-next-line no-console
    console.log('Publishing new version for document', selectedDocument.id);
    message.success('New version published (simulated).');
  };

  const handleCreateDocument = async (values: NewDocumentFormValues) => {
    const now = new Date();
    const newDoc: ManagedDocument = {
      id: `doc-${now.getTime()}`,
      title: values.title,
      category: values.category,
      language: values.language,
      owner: values.owner || 'You',
      status: values.status || 'Draft',
      aiIndexed: values.aiIndexed ?? true,
      visible: values.visible ?? true,
      version: '1.0',
      updatedAt: now.toISOString().slice(0, 10),
      tags: values.tags && values.tags.length ? values.tags : ['draft'],
      summary:
        values.summary ||
        'New document created from Document Management. Replace this text with the actual content or link to your storage layer.',
    };

    setDataSource(prev => [...prev, newDoc]);
    setSelectedDocument(newDoc);
    setDrawerOpen(true);
    message.success('Document entry created (local example).');

    return true;
  };

  const columns: ProColumns<ManagedDocument>[] = [
    {
      title: 'Title',
      dataIndex: 'title',
      ellipsis: true,
      copyable: true,
      formItemProps: {
        rules: [{ required: true, message: 'Title is required' }],
      },
    },
    {
      title: 'Category',
      dataIndex: 'category',
      valueType: 'select',
      filters: true,
      onFilter: true,
      valueEnum: {
        Research: { text: 'Research' },
        'Safety & Compliance': { text: 'Safety & Compliance' },
        'Clinical Protocol': { text: 'Clinical Protocol' },
        'Design Blueprint': { text: 'Design Blueprint' },
        'Learning Module': { text: 'Learning Module' },
      },
    },
    {
      title: 'Language',
      dataIndex: 'language',
      valueType: 'select',
      filters: true,
      onFilter: true,
      valueEnum: {
        English: { text: 'English' },
        French: { text: 'French' },
      },
      width: 110,
    },
    {
      title: 'Owner',
      dataIndex: 'owner',
      width: 180,
    },
    {
      title: 'Status',
      dataIndex: 'status',
      valueType: 'select',
      filters: true,
      onFilter: true,
      valueEnum: {
        Draft: { text: 'Draft', status: 'Default' },
        Published: { text: 'Published', status: 'Success' },
        Archived: { text: 'Archived', status: 'Default' },
      },
      render: (_, record) => (
        <Tag color={getStatusColor(record.status)}>{record.status}</Tag>
      ),
      width: 120,
    },
    {
      title: 'AI indexing',
      dataIndex: 'aiIndexed',
      valueType: 'switch',
      render: (_, record) => (
        <Tooltip
          title={
            record.aiIndexed
              ? 'Document is used by assistants and semantic search.'
              : 'Document is excluded from AI‚Äëpowered features.'
          }
        >
          <Switch
            size="small"
            checked={record.aiIndexed}
            onChange={checked => updateDocument(record.id, { aiIndexed: checked })}
          />
        </Tooltip>
      ),
      width: 140,
    },
    {
      title: 'Visible',
      dataIndex: 'visible',
      valueType: 'switch',
      render: (_, record) => (
        <Switch
          size="small"
          checked={record.visible}
          onChange={checked => updateDocument(record.id, { visible: checked })}
        />
      ),
      width: 110,
    },
    {
      title: 'Tags',
      dataIndex: 'tags',
      search: false,
      render: (_, record) =>
        record.tags && record.tags.length ? (
          <Space size={[0, 8]} wrap>
            {record.tags.map(tag => (
              <Tag key={tag}>{tag}</Tag>
            ))}
          </Space>
        ) : (
          <span style={{ color: '#999' }}>‚Äî</span>
        ),
    },
    {
      title: 'Last updated',
      dataIndex: 'updatedAt',
      valueType: 'date',
      sorter: (a, b) =>
        new Date(a.updatedAt).getTime() - new Date(b.updatedAt).getTime(),
      width: 140,
    },
    {
      title: 'Version',
      dataIndex: 'version',
      width: 90,
    },
    {
      title: 'Actions',
      valueType: 'option',
      fixed: 'right',
      width: 170,
      render: (_, record, __, action) => [
        <a
          key="view"
          onClick={() => {
            setSelectedDocument(record);
            setDrawerOpen(true);
          }}
        >
          Details
        </a>,
        <a
          key="edit"
          onClick={() => {
            (action as any)?.startEditable?.(record.id);
          }}
        >
          Edit
        </a>,
      ],
    },
  ];

  return (
    <div className="container mx-auto p-5">
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div>
          <h1 className="text-2xl font-bold">Document Management</h1>
          <p className="text-gray-500">
            Manage your knowledge documents, control AI indexing and visibility, and
            inspect versions and comments from one place.
          </p>
        </div>
        <Space>
          <Button
            onClick={() =>
              router.push('/keenkonnect/knowledge/browse-repository')
            }
          >
            Go to library view
          </Button>
        </Space>
      </div>

      <EditableProTable<ManagedDocument>
        rowKey="id"
        bordered
        size="small"
        value={dataSource}
        // important: value from EditableProTable is readonly, so clone it
        onChange={(value: readonly ManagedDocument[]) =>
          setDataSource([...value])
        }
        maxLength={50}
        recordCreatorProps={{
          position: 'bottom',
          newRecordType: 'dataSource',
          record: () => ({
            id: `temp-${Date.now()}`,
            title: 'New document',
            category: 'Research',
            language: 'English',
            owner: 'You',
            status: 'Draft' as DocumentStatus,
            aiIndexed: true,
            visible: true,
            version: '0.1',
            updatedAt: new Date().toISOString().slice(0, 10),
            tags: ['draft'],
            summary:
              'New draft document created inline from the table. Use the drawer to refine metadata and content.',
          }),
        }}
        toolBarRender={() => [
          <ModalForm<NewDocumentFormValues>
            key="new"
            title="Add document entry"
            trigger={
              <Button type="primary" icon={<PlusOutlined />}>
                New document
              </Button>
            }
            modalProps={{ destroyOnClose: true }}
            initialValues={{
              status: 'Draft',
              language: 'English',
              aiIndexed: true,
              visible: true,
            }}
            onFinish={handleCreateDocument}
          >
            <ProFormText
              name="title"
              label="Title"
              rules={[{ required: true, message: 'Please enter a title' }]}
            />
            <ProFormSelect
              name="category"
              label="Category"
              options={[
                { label: 'Research', value: 'Research' },
                { label: 'Safety & Compliance', value: 'Safety & Compliance' },
                { label: 'Clinical Protocol', value: 'Clinical Protocol' },
                { label: 'Design Blueprint', value: 'Design Blueprint' },
                { label: 'Learning Module', value: 'Learning Module' },
              ]}
              rules={[{ required: true, message: 'Please choose a category' }]}
            />
            <ProFormSelect
              name="language"
              label="Language"
              options={[
                { label: 'English', value: 'English' },
                { label: 'French', value: 'French' },
              ]}
              rules={[{ required: true, message: 'Please choose a language' }]}
            />
            <ProFormText name="owner" label="Owner" />
            <ProFormSelect
              name="status"
              label="Status"
              options={[
                { label: 'Draft', value: 'Draft' },
                { label: 'Published', value: 'Published' },
                { label: 'Archived', value: 'Archived' },
              ]}
            />
            <ProFormSelect
              name="tags"
              label="Tags"
              mode="tags"
              fieldProps={{
                tokenSeparators: [','],
              }}
              placeholder="Add tags (press Enter or comma)"
            />
            <ProFormSwitch
              name="aiIndexed"
              label="Include in AI indexing"
            />
            <ProFormSwitch
              name="visible"
              label="Visible in library"
            />
            <ProFormTextArea
              name="summary"
              label="Short content / summary"
              fieldProps={{ rows: 4 }}
            />
          </ModalForm>,
          <Button
            key="upload"
            icon={<UploadOutlined />}
            onClick={() =>
              router.push('/keenkonnect/knowledge/upload-new-document')
            }
          >
            Upload new file
          </Button>,
        ]}
        columns={columns}
        editable={{
          type: 'multiple',
          editableKeys,
          onChange: setEditableRowKeys,
          onSave: async (_key, row) => {
            setDataSource(prev =>
              prev.map(item => (item.id === row.id ? { ...item, ...row } : item)),
            );
          },
        }}
      />

      <Drawer
        title={selectedDocument ? 'Document details' : undefined}
        open={drawerOpen}
        onClose={() => setDrawerOpen(false)}
        width={1000}
        destroyOnClose
      >
        {selectedDocument && (
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <div className="flex flex-wrap items-center justify-between gap-3">
              <div>
                <h2 className="mb-1 text-xl font-semibold">
                  {selectedDocument.title}
                </h2>
                <div className="text-sm text-gray-500">
                  Last updated {selectedDocument.updatedAt} ¬∑ Owner{' '}
                  {selectedDocument.owner}
                </div>
              </div>
              <Space wrap>
                <Tag color={getStatusColor(selectedDocument.status)}>
                  {selectedDocument.status}
                </Tag>
                {selectedDocument.tags.map(tag => (
                  <Tag key={tag}>{tag}</Tag>
                ))}
              </Space>
            </div>

            <Row gutter={16}>
              <Col xs={24} md={14}>
                <Card
                  title="Real‚Äëtime editing (simulated)"
                  extra={
                    <Tooltip title="Open full editor in Konstruct (future integration)">
                      <Button type="link" icon={<EyeOutlined />}>
                        Open in Konstruct
                      </Button>
                    </Tooltip>
                  }
                >
                  <TextArea
                    rows={10}
                    value={selectedDocument.summary}
                    onChange={e =>
                      updateDocument(selectedDocument.id, {
                        summary: e.target.value,
                      })
                    }
                  />
                  <Divider />
                  <Space>
                    <Button
                      type="primary"
                      icon={<SaveOutlined />}
                      onClick={handleSaveChanges}
                    >
                      Save changes
                    </Button>
                    <Button
                      icon={<UploadOutlined />}
                      onClick={handlePublishNewVersion}
                    >
                      Publish new version
                    </Button>
                  </Space>
                </Card>
              </Col>

              <Col xs={24} md={10}>
                <Card title="Metadata & access control">
                  <p>
                    <strong>Category:</strong> {selectedDocument.category}
                  </p>
                  <p>
                    <strong>Language:</strong> {selectedDocument.language}
                  </p>
                  <p>
                    <strong>Version:</strong> {selectedDocument.version}
                  </p>
                  <p>
                    <strong>AI indexing:</strong>{' '}
                    <Switch
                      size="small"
                      checked={selectedDocument.aiIndexed}
                      onChange={checked =>
                        updateDocument(selectedDocument.id, {
                          aiIndexed: checked,
                        })
                      }
                    />
                  </p>
                  <p>
                    <strong>Visible in library:</strong>{' '}
                    <Switch
                      size="small"
                      checked={selectedDocument.visible}
                      onChange={checked =>
                        updateDocument(selectedDocument.id, {
                          visible: checked,
                        })
                      }
                    />
                  </p>
                  <p>
                    <strong>Tags:</strong>{' '}
                    {selectedDocument.tags.length ? (
                      <Space size={[0, 8]} wrap>
                        {selectedDocument.tags.map(tag => (
                          <Tag key={tag}>{tag}</Tag>
                        ))}
                      </Space>
                    ) : (
                      <span style={{ color: '#999' }}>None</span>
                    )}
                  </p>
                </Card>

                <Card title="Version history" className="mt-4">
                  <List
                    size="small"
                    dataSource={versionHistory}
                    renderItem={item => (
                      <List.Item key={item.version}>
                        <List.Item.Meta
                          title={`${item.version} ¬∑ ${item.timestamp}`}
                          description={
                            <>
                              <div>
                                <strong>{item.author}</strong>
                              </div>
                              <div>{item.changeSummary}</div>
                            </>
                          }
                        />
                      </List.Item>
                    )}
                  />
                  <Button
                    type="link"
                    style={{ padding: 0, marginTop: 8 }}
                  >
                    Compare / restore versions
                  </Button>
                </Card>

                <Card title="Comments (simulated thread)" className="mt-4">
                  <List
                    itemLayout="horizontal"
                    dataSource={commentsData}
                    renderItem={comment => (
                      <Comment
                        key={comment.id}
                        author={comment.author}
                        avatar={<Avatar src={comment.avatar} />}
                        content={comment.content}
                        datetime={comment.datetime}
                      />
                    )}
                  />
                </Card>
              </Col>
            </Row>
          </Space>
        )}
      </Drawer>
    </div>
  );
}

===== END app/keenkonnect/knowledge/document-management/page.tsx =====


===== BEGIN app/keenkonnect/knowledge/search-filter-documents/page.tsx =====
// app/keenkonnect/knowledge/search-filter-documents/page.tsx
'use client'

import React, { useMemo, useState } from 'react'
import { Card, Alert, Pagination, Tag } from 'antd'
import type { PaginationProps } from 'antd'
import dayjs, { Dayjs } from 'dayjs'
import type { ProColumns } from '@ant-design/pro-components'
import {
  ProTable,
  QueryFilter,
  ProFormText,
  ProFormSelect,
  ProFormDateRangePicker,
} from '@ant-design/pro-components'
import KeenPage from '@/app/keenkonnect/KeenPageShell'

interface DocumentResource {
  key: string
  title: string
  snippet: string
  author: string
  tags: string[]
  language: string
  version: string
  lastUpdated: string // ISO date
  relevanceScore: number
}

type DateRangeValue = [Dayjs, Dayjs] | undefined
type SortOption = 'relevance' | 'date' | 'popularity'

interface FilterState {
  keyword?: string
  authors?: string[]
  tags?: string[]
  language?: string
  dateRange?: DateRangeValue
  sort: SortOption
}

// Demo data (same content as the previous version)
const sampleDocuments: DocumentResource[] = [
  {
    key: '1',
    title: 'Robotics Blueprint',
    snippet: 'Detailed blueprint for advanced robotics design.',
    author: 'Alice',
    tags: ['Robotics', 'Engineering'],
    language: 'English',
    version: '1.0',
    lastUpdated: '2023-09-01',
    relevanceScore: 95,
  },
  {
    key: '2',
    title: 'AI Ethics Guidelines',
    snippet: 'Comprehensive guidelines for ethical AI development.',
    author: 'Bob',
    tags: ['AI', 'Ethics'],
    language: 'English',
    version: '2.0',
    lastUpdated: '2023-08-15',
    relevanceScore: 90,
  },
  {
    key: '3',
    title: 'Healthcare Innovation Report',
    snippet: 'Annual report on innovation in healthcare technologies.',
    author: 'Charlie',
    tags: ['Healthcare', 'Innovation'],
    language: 'French',
    version: '1.2',
    lastUpdated: '2023-07-20',
    relevanceScore: 88,
  },
  {
    key: '4',
    title: 'Environmental Impact Study',
    snippet: 'Study on environmental impact of industrial activities.',
    author: 'Diana',
    tags: ['Environment', 'Sustainability'],
    language: 'English',
    version: '1.3',
    lastUpdated: '2023-06-10',
    relevanceScore: 85,
  },
  {
    key: '5',
    title: 'Quantum Computing Overview',
    snippet: 'Introduction to quantum computing concepts and applications.',
    author: 'Alice',
    tags: ['Quantum', 'Computing'],
    language: 'English',
    version: '1.1',
    lastUpdated: '2023-05-05',
    relevanceScore: 92,
  },
]

const allAuthors = Array.from(new Set(sampleDocuments.map((d) => d.author))).sort()
const allTags = Array.from(new Set(sampleDocuments.flatMap((d) => d.tags))).sort()
const allLanguages = Array.from(new Set(sampleDocuments.map((d) => d.language))).sort()

const DEFAULT_SORT: SortOption = 'relevance'

export default function SearchFilterDocumentsPage(): JSX.Element {
  const [filters, setFilters] = useState<FilterState>({
    sort: DEFAULT_SORT,
  })
  const [currentPage, setCurrentPage] = useState<number>(1)
  const [pageSize, setPageSize] = useState<number>(5)

  const handleFilterFinish = async (values: Record<string, any>) => {
    const nextFilters: FilterState = {
      keyword: values.keyword?.trim() || undefined,
      authors: values.authors ?? [],
      tags: values.tags ?? [],
      language: values.language || undefined,
      dateRange: values.dateRange as DateRangeValue,
      sort: (values.sort as SortOption) ?? DEFAULT_SORT,
    }

    setFilters(nextFilters)
    setCurrentPage(1)

    // ProForm expects a boolean from onFinish
    return true
  }

  const handleFilterReset = () => {
    setFilters({ sort: DEFAULT_SORT })
    setCurrentPage(1)
  }

  const filteredDocuments = useMemo(() => {
    const { keyword, authors, tags, language, dateRange } = filters

    return sampleDocuments.filter((doc) => {
      const matchesKeyword =
        !keyword ||
        doc.title.toLowerCase().includes(keyword.toLowerCase()) ||
        doc.snippet.toLowerCase().includes(keyword.toLowerCase())

      const matchesAuthor =
        !authors || authors.length === 0 || authors.includes(doc.author)

      const matchesTags =
        !tags || tags.length === 0 || tags.every((t) => doc.tags.includes(t))

      const matchesLanguage = !language || doc.language === language

      let matchesDate = true
      if (dateRange && dateRange[0] && dateRange[1]) {
        const [start, end] = dateRange
        const docDate = dayjs(doc.lastUpdated)

        if (start) {
          matchesDate =
            docDate.isSame(start, 'day') || docDate.isAfter(start, 'day')
        }
        if (matchesDate && end) {
          matchesDate =
            docDate.isSame(end, 'day') || docDate.isBefore(end, 'day')
        }
      }

      return (
        matchesKeyword &&
        matchesAuthor &&
        matchesTags &&
        matchesLanguage &&
        matchesDate
      )
    })
  }, [filters])

  const sortedDocuments = useMemo(() => {
    const docs = [...filteredDocuments]
    const sort = filters.sort

    switch (sort) {
      case 'date':
        docs.sort(
          (a, b) =>
            new Date(b.lastUpdated).getTime() -
            new Date(a.lastUpdated).getTime(),
        )
        break
      case 'popularity':
        // Placeholder: reuse relevance score
        docs.sort((a, b) => b.relevanceScore - a.relevanceScore)
        break
      case 'relevance':
      default:
        docs.sort((a, b) => b.relevanceScore - a.relevanceScore)
        break
    }

    return docs
  }, [filteredDocuments, filters.sort])

  const paginatedDocuments = useMemo(() => {
    const start = (currentPage - 1) * pageSize
    const end = start + pageSize
    return sortedDocuments.slice(start, end)
  }, [sortedDocuments, currentPage, pageSize])

  const total = sortedDocuments.length

  const activeFilterCount = useMemo(() => {
    let count = 0
    if (filters.keyword && filters.keyword.trim()) count++
    if (filters.authors && filters.authors.length > 0) count++
    if (filters.tags && filters.tags.length > 0) count++
    if (filters.language) count++
    if (filters.dateRange && filters.dateRange[0] && filters.dateRange[1]) {
      count++
    }
    return count
  }, [filters])

  const columns: ProColumns<DocumentResource>[] = [
    {
      title: 'Title & Snippet',
      dataIndex: 'title',
      key: 'title',
      ellipsis: true,
      render: (_, record) => (
        <div>
          <div style={{ fontWeight: 500 }}>{record.title}</div>
          <div
            style={{
              fontSize: 12,
              color: 'rgba(0,0,0,0.45)',
              marginTop: 4,
            }}
          >
            {record.snippet}
          </div>
        </div>
      ),
    },
    {
      title: 'Author',
      dataIndex: 'author',
      key: 'author',
      width: 140,
    },
    {
      title: 'Tags',
      dataIndex: 'tags',
      key: 'tags',
      width: 220,
      render: (_, record) => (
        <>
          {record.tags.map((tag) => (
            <Tag key={tag}>{tag}</Tag>
          ))}
        </>
      ),
    },
    {
      title: 'Language',
      dataIndex: 'language',
      key: 'language',
      width: 110,
    },
    {
      title: 'Version',
      dataIndex: 'version',
      key: 'version',
      width: 90,
    },
    {
      title: 'Last Updated',
      dataIndex: 'lastUpdated',
      key: 'lastUpdated',
      width: 140,
    },
    {
      title: 'Relevance',
      dataIndex: 'relevanceScore',
      key: 'relevanceScore',
      width: 120,
      sorter: (a, b) => a.relevanceScore - b.relevanceScore,
    },
  ]

  const paginationProps: PaginationProps = {
    current: currentPage,
    pageSize,
    total,
    showSizeChanger: true,
    pageSizeOptions: ['5', '10', '20'],
    showTotal: (totalItems, range) =>
      `${range[0]}-${range[1]} of ${totalItems} document${
        totalItems > 1 ? 's' : ''
      }`,
    onChange: (page, size) => {
      setCurrentPage(page)
      setPageSize(size || pageSize)
    },
  }

  const sortLabel = filters.sort
    .toString()
    .replace(/^\w/, (c) => c.toUpperCase())

  return (
    <KeenPage
      title="Search & Filter Documents"
      description="Advanced search and filtering for knowledge documents in KeenKonnect."
    >
      {/* Advanced filters (QueryFilter) */}
      <Card className="mb-4">
        <QueryFilter
          onFinish={handleFilterFinish}
          onReset={handleFilterReset}
          labelWidth="auto"
          defaultCollapsed={false}
          span={8}
          initialValues={{ sort: DEFAULT_SORT }}
        >
          <ProFormText
            name="keyword"
            label="Keywords"
            placeholder="Search by title or content"
          />

          <ProFormSelect
            name="authors"
            label="Authors"
            placeholder="Select authors"
            mode="multiple"
            options={allAuthors.map((a) => ({
              label: a,
              value: a,
            }))}
          />

          <ProFormSelect
            name="tags"
            label="Tags"
            placeholder="Select tags"
            mode="multiple"
            options={allTags.map((t) => ({
              label: t,
              value: t,
            }))}
          />

          <ProFormSelect
            name="language"
            label="Language"
            placeholder="All languages"
            allowClear
            options={allLanguages.map((lang) => ({
              label: lang,
              value: lang,
            }))}
          />

          <ProFormDateRangePicker
            name="dateRange"
            label="Last Updated"
            placeholder={['From', 'To']}
          />

          <ProFormSelect
            name="sort"
            label="Sort By"
            options={[
              { label: 'Relevance', value: 'relevance' },
              { label: 'Date', value: 'date' },
              { label: 'Popularity', value: 'popularity' },
            ]}
          />
        </QueryFilter>
      </Card>

      {/* Summary of results / filters */}
      <Alert
        type={total === 0 ? 'warning' : 'info'}
        showIcon
        className="mb-4"
        message={
          total === 0
            ? 'No documents match your criteria.'
            : `${total} document${total > 1 ? 's' : ''} match your criteria.`
        }
        description={
          <div style={{ fontSize: 12 }}>
            <div>
              Sort: <strong>{sortLabel}</strong>
            </div>
            <div>
              Active filters: <strong>{activeFilterCount}</strong>
            </div>
          </div>
        }
      />

      {/* Main table + external pagination */}
      <Card>
        <ProTable<DocumentResource>
          rowKey="key"
          columns={columns}
          dataSource={paginatedDocuments}
          search={false}
          options={false}
          pagination={false} // Manual pagination below
          rowSelection={false}
          toolBarRender={false}
        />

        {total > 0 && (
          <div style={{ marginTop: 16, textAlign: 'right' }}>
            <Pagination {...paginationProps} />
          </div>
        )}
      </Card>
    </KeenPage>
  )
}

===== END app/keenkonnect/knowledge/search-filter-documents/page.tsx =====


===== BEGIN app/keenkonnect/knowledge/upload-new-document/page.tsx =====
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { message as antdMessage } from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import {
  PageContainer,
  ProCard,
  ProForm,
  ProFormText,
  ProFormTextArea,
  ProFormSelect,
  ProFormSwitch,
  ProFormUploadDragger,
} from '@ant-design/pro-components';
import { InboxOutlined } from '@ant-design/icons';
import api from '@/api';
import usePageTitle from '@/hooks/usePageTitle';

type CategoryOption = 'Robotics' | 'Healthcare' | 'Technology' | 'Energy' | 'Education';
type LanguageOption = 'English' | 'French';

interface UploadDocumentFormValues {
  title: string;
  description: string;
  category: CategoryOption;
  version: string;
  language: LanguageOption;
  publishNow: boolean;
  documentFile?: UploadFile[]; // optional in typing, required via rules
}

// Normalise Upload event -> UploadFile[]
const normFile = (e: any): UploadFile[] => {
  if (Array.isArray(e)) {
    return e as UploadFile[];
  }
  return (e?.fileList ?? []) as UploadFile[];
};

export default function UploadNewDocumentPage(): JSX.Element {
  usePageTitle('KeenKonnect ¬∑ Knowledge ¬∑ Upload document');
  const router = useRouter();
  const [submitting, setSubmitting] = useState(false);

  const handleFinish = async (values: UploadDocumentFormValues) => {
    const fileList = values.documentFile ?? [];
    const file = fileList[0]?.originFileObj;

    if (!file) {
      antdMessage.error('Please upload a document file before submitting.');
      return false;
    }

    const formData = new FormData();
    // M√©tadonn√©es principales
    formData.append('title', values.title);
    formData.append('description', values.description);
    formData.append('category', values.category);
    formData.append('version', values.version);
    formData.append('language', values.language);
    formData.append('publishNow', values.publishNow ? 'true' : 'false');
    // Fichier lui‚Äëm√™me
    formData.append('file', file as File);

    try {
      setSubmitting(true);

      await api.post('/knowledge/documents/upload', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });

      antdMessage.success('Document uploaded successfully');
      router.push('/keenkonnect/knowledge/document-management');
      return true;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Document upload error:', error);
      antdMessage.error('Failed to upload document. Please try again.');
      return false;
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <PageContainer
      ghost
      header={{
        title: 'Upload New Document',
        subTitle: 'Add a new knowledge asset to KeenKonnect',
      }}
    >
      <div className="max-w-4xl mx-auto">
        <ProCard>
          <ProForm<UploadDocumentFormValues>
            layout="vertical"
            onFinish={handleFinish}
            initialValues={{
              publishNow: true,
            }}
            submitter={{
              searchConfig: {
                submitText: 'Upload Document',
                resetText: 'Reset',
              },
              submitButtonProps: {
                loading: submitting,
                type: 'primary',
              },
            }}
          >
            <ProFormText
              name="title"
              label="Document Title"
              placeholder="Enter document title"
              rules={[
                { required: true, message: 'Please enter a document title' },
                { max: 200, message: 'Title is too long' },
              ]}
            />

            <ProFormTextArea
              name="description"
              label="Description / Abstract"
              placeholder="Short summary of the document contents"
              fieldProps={{ rows: 4 }}
              rules={[
                { required: true, message: 'Please provide a description or abstract' },
              ]}
            />

            <ProFormSelect<CategoryOption>
              name="category"
              label="Category / Topic"
              placeholder="Select a category"
              rules={[{ required: true, message: 'Please select a category/topic' }]}
              options={[
                { label: 'Robotics', value: 'Robotics' },
                { label: 'Healthcare', value: 'Healthcare' },
                { label: 'Technology', value: 'Technology' },
                { label: 'Energy', value: 'Energy' },
                { label: 'Education', value: 'Education' },
              ]}
            />

            <ProFormText
              name="version"
              label="Version"
              placeholder="e.g. 1.0"
              rules={[
                { required: true, message: 'Please specify the document version' },
              ]}
            />

            <ProFormSelect<LanguageOption>
              name="language"
              label="Language"
              placeholder="Select language"
              rules={[{ required: true, message: 'Please select a language' }]}
              options={[
                { label: 'English', value: 'English' },
                { label: 'French', value: 'French' },
              ]}
            />

            <ProFormUploadDragger
              name="documentFile"
              label="Document File"
              max={1}
              valuePropName="fileList"
              getValueFromEvent={normFile}
              rules={[
                { required: true, message: 'Please upload the document file' },
              ]}
              fieldProps={{
                multiple: false,
                beforeUpload: () => false, // pas d'upload auto, on g√®re tout dans onFinish
                accept: '.pdf,.doc,.docx,.ppt,.pptx,.txt',
              }}
            >
              <div style={{ padding: '24px 0' }}>
                <InboxOutlined style={{ fontSize: 32 }} />
                <div style={{ marginTop: 8 }}>
                  Click or drag file to this area to upload
                </div>
                <div style={{ marginTop: 4, fontSize: 12, color: 'rgba(0,0,0,0.45)' }}>
                  Supported formats: PDF, DOC/DOCX, PPT/PPTX, TXT (single file).
                </div>
              </div>
            </ProFormUploadDragger>

            <ProFormSwitch
              name="publishNow"
              label="Publish Status"
              fieldProps={{
                checkedChildren: 'Publish Now',
                unCheckedChildren: 'Save as Draft',
              }}
            />
          </ProForm>
        </ProCard>
      </div>
    </PageContainer>
  );
}

===== END app/keenkonnect/knowledge/upload-new-document/page.tsx =====


===== BEGIN app/keenkonnect/layout.tsx =====
// app/keenkonnect/layout.tsx
'use client'

import type { ReactNode } from 'react'
import React, { Suspense, useEffect } from 'react'
import { Layout, Spin } from 'antd'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'

import MainLayout from '@/components/layout-components/MainLayout'

const { Content } = Layout

interface SegmentLayoutProps {
  children: ReactNode
}

/**
 * Inner shell that *defaults* the sidebar to "keenkonnect" via ?sidebar=keenkonnect
 * when the query param is missing.
 *
 * Important:
 * - If ?sidebar is already set (ekoh, ethikos, kreative, ‚Ä¶), it is respected.
 *   This lets the module switcher (LogoTitle) change suites even while you are
 *   on a /keenkonnect/* URL.
 */
function KeenKonnectShell({ children }: SegmentLayoutProps) {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  useEffect(() => {
    const currentSidebar = searchParams.get('sidebar')

    // Only inject the default if the param is absent.
    // Do NOT override if the user explicitly chose another suite.
    if (currentSidebar !== null) return

    const params = new URLSearchParams(Array.from(searchParams.entries()))
    params.set('sidebar', 'keenkonnect')

    router.replace(`${pathname}?${params.toString()}`)
  }, [router, pathname, searchParams])

  return <MainLayout>{children}</MainLayout>
}

/**
 * Segment layout for all /keenkonnect/* pages.
 * Reuses the global MainLayout (Ant Design Layout + navigation)
 * and provides an Ant Design‚Äìbased Suspense fallback.
 */
export default function SegmentLayout({ children }: SegmentLayoutProps) {
  return (
    <Suspense
      fallback={
        <Layout style={{ minHeight: '100vh' }}>
          <Content
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <Spin size="large" />
          </Content>
        </Layout>
      }
    >
      <KeenKonnectShell>{children}</KeenKonnectShell>
    </Suspense>
  )
}

===== END app/keenkonnect/layout.tsx =====


===== BEGIN app/keenkonnect/projects/browse-projects/page.tsx =====
// app/keenkonnect/projects/browse-projects/page.tsx
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import Head from 'next/head';
import { PageContainer, ProCard } from '@ant-design/pro-components';
import {
  Avatar,
  Button,
  Card,
  Col,
  Divider,
  Drawer,
  Empty,
  Input,
  Pagination,
  Row,
  Select,
  Space,
  Tabs,
  Tag,
  Tooltip,
  Spin,
} from 'antd';
import {
  PlusOutlined,
  SearchOutlined,
  TeamOutlined,
  UserOutlined,
} from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import api from '@/api';
import usePageTitle from '@/hooks/usePageTitle';

const { Search } = Input;
const { Option } = Select;

// Aligned with Django router: /api/keenkonnect/projects/
const PROJECTS_ENDPOINT = 'keenkonnect/projects/'; // relative to NEXT_PUBLIC_API_BASE

type SortCriteria = 'newest' | 'mostMembers';

interface ApiProject {
  id: number;
  title: string;
  description: string;
  creator: string;
  category: string;
  status: string;
  created_at: string;
  updated_at: string;
  tags: number[];
}

interface Project {
  id: string;
  name: string;
  description: string;
  owner: string;
  technologies: string[];
  domain: string;
  members: number;
  createdAt: string; // ISO date string
}

export default function BrowseProjectsPage(): JSX.Element {
  const router = useRouter();

  // Sync browser tab title with suite naming
  usePageTitle('KeenKonnect ¬∑ Browse Projects');

  const [projects, setProjects] = useState<Project[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const [drawerVisible, setDrawerVisible] = useState(false);
  const [selectedProject, setSelectedProject] = useState<Project | null>(null);

  const [searchText, setSearchText] = useState('');
  const [selectedDomain, setSelectedDomain] = useState<string>('All');
  const [selectedTechnology, setSelectedTechnology] = useState<string>('All');
  const [sortCriteria, setSortCriteria] = useState<SortCriteria>('newest');
  const [activeDomainTabKey, setActiveDomainTabKey] = useState<string>('All');

  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 6;

  useEffect(() => {
    const fetchProjects = async () => {
      try {
        setLoading(true);
        setError(null);

        const data = await api.get<ApiProject[]>(PROJECTS_ENDPOINT);

        // Map backend Project objects to the UI shape used by this page
        const mapped: Project[] = data.map((p) => ({
          id: String(p.id),
          name: p.title,
          description: p.description ?? '',
          owner: p.creator ?? '',
          domain: p.category ?? 'Uncategorized',
          technologies: [], // TODO: map from tags or related data when available
          members: 0, // TODO: replace with real team size when project-team endpoints are wired
          createdAt: p.created_at,
        }));

        setProjects(mapped);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error('Failed to load projects', err);
        setError('Unable to load projects from the server.');
      } finally {
        setLoading(false);
      }
    };

    void fetchProjects();
  }, []);

  const domainOptions = useMemo(() => {
    const unique = Array.from(
      new Set(projects.map((p) => p.domain || 'Uncategorized')),
    );
    return ['All', ...unique];
  }, [projects]);

  const technologyOptions = useMemo(() => {
    const allTechs = new Set<string>();
    projects.forEach((p) => {
      p.technologies.forEach((t) => allTechs.add(t));
    });
    return ['All', ...Array.from(allTechs)];
  }, [projects]);

  const filteredProjects = useMemo(
    () =>
      projects.filter((project) => {
        const matchesSearch =
          !searchText ||
          project.name.toLowerCase().includes(searchText.toLowerCase()) ||
          project.description.toLowerCase().includes(searchText.toLowerCase());

        const matchesDomain =
          selectedDomain === 'All' || project.domain === selectedDomain;

        const matchesTechnology =
          selectedTechnology === 'All' ||
          project.technologies.includes(selectedTechnology);

        return matchesSearch && matchesDomain && matchesTechnology;
      }),
    [projects, searchText, selectedDomain, selectedTechnology],
  );

  const sortedProjects = useMemo(() => {
    const next = [...filteredProjects];
    if (sortCriteria === 'newest') {
      next.sort(
        (a, b) =>
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
      );
    } else if (sortCriteria === 'mostMembers') {
      next.sort((a, b) => b.members - a.members);
    }
    return next;
  }, [filteredProjects, sortCriteria]);

  const paginatedProjects = useMemo(() => {
    const startIndex = (currentPage - 1) * pageSize;
    return sortedProjects.slice(startIndex, startIndex + pageSize);
  }, [sortedProjects, currentPage]);

  const handleOpenDrawer = (project: Project) => {
    setSelectedProject(project);
    setDrawerVisible(true);
  };

  const handleCloseDrawer = () => {
    setDrawerVisible(false);
    setSelectedProject(null);
  };

  const handleDomainTabChange = (key: string) => {
    setActiveDomainTabKey(key);
    setSelectedDomain(key);
    setCurrentPage(1);
  };

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Browse Projects</title>
      </Head>

      <PageContainer
        ghost
        header={{
          title: 'Browse Projects',
          subTitle:
            'Discover projects and collaborate through KeenKonnect. Data is loaded from the Django backend.',
          extra: [
            <Button
              key="create"
              type="primary"
              icon={<PlusOutlined />}
              onClick={() =>
                router.push('/keenkonnect/projects/create-new-project')
              }
            >
              Create New Project
            </Button>,
          ],
        }}
      >
        <ProCard ghost>
          {loading && (
            <div style={{ textAlign: 'center', padding: 24 }}>
              <Spin />
            </div>
          )}

          {error && (
            <div style={{ marginBottom: 16 }}>
              <Tag color="red">{error}</Tag>
            </div>
          )}

          {/* Tabs + filters */}
          <ProCard bordered={false}>
            {/* Quick domain Tabs */}
            <Tabs
              activeKey={activeDomainTabKey}
              onChange={handleDomainTabChange}
              items={domainOptions.map((domain) => ({
                key: domain,
                label: domain === 'All' ? 'All Domains' : domain,
              }))}
            />

            {/* Filters */}
            <Row gutter={[16, 16]} style={{ marginTop: 8 }}>
              <Col xs={24} md={10}>
                <Search
                  placeholder="Search by name or description"
                  allowClear
                  prefix={<SearchOutlined />}
                  value={searchText}
                  onChange={(e) => {
                    setSearchText(e.target.value);
                    setCurrentPage(1);
                  }}
                />
              </Col>
              <Col xs={24} sm={12} md={7}>
                <Select
                  value={selectedDomain}
                  style={{ width: '100%' }}
                  onChange={(value) => {
                    setSelectedDomain(value);
                    setActiveDomainTabKey(value);
                    setCurrentPage(1);
                  }}
                >
                  {domainOptions.map((domain) => (
                    <Option key={domain} value={domain}>
                      {domain === 'All' ? 'All Domains' : domain}
                    </Option>
                  ))}
                </Select>
              </Col>
              <Col xs={24} sm={12} md={7}>
                <Select
                  value={selectedTechnology}
                  style={{ width: '100%' }}
                  onChange={(value) => {
                    setSelectedTechnology(value);
                    setCurrentPage(1);
                  }}
                >
                  {technologyOptions.map((tech) => (
                    <Option key={tech} value={tech}>
                      {tech === 'All' ? 'All Technologies' : tech}
                    </Option>
                  ))}
                </Select>
              </Col>
            </Row>

            {/* Sorter */}
            <Row style={{ marginTop: 16 }}>
              <Col span={24}>
                <Space>
                  <span>Sort by:</span>
                  <Select<SortCriteria>
                    value={sortCriteria}
                    onChange={(value) => setSortCriteria(value)}
                    style={{ width: 180 }}
                  >
                    <Option value="newest">Newest first</Option>
                    <Option value="mostMembers">Most members</Option>
                  </Select>
                </Space>
              </Col>
            </Row>
          </ProCard>

          {/* Content */}
          <ProCard ghost style={{ marginTop: 16 }}>
            {projects.length === 0 && !loading && !error && (
              <Empty
                description={
                  <Space direction="vertical">
                    <span>No projects found yet.</span>
                    <Button
                      type="primary"
                      icon={<PlusOutlined />}
                      onClick={() =>
                        router.push('/keenkonnect/projects/create-new-project')
                      }
                    >
                      Create the first project
                    </Button>
                  </Space>
                }
              />
            )}

            {projects.length > 0 && (
              <Row gutter={[16, 16]}>
                {paginatedProjects.map((project) => (
                  <Col key={project.id} xs={24} sm={12} md={8}>
                    <Card
                      hoverable
                      title={
                        <Space>
                          <TeamOutlined />
                          <span>{project.name}</span>
                        </Space>
                      }
                      onClick={() => handleOpenDrawer(project)}
                      extra={
                        <Space size={8}>
                          <Tooltip title="Open workspace">
                            <Button
                              type="link"
                              icon={<UserOutlined />}
                              onClick={(e) => {
                                e.stopPropagation();
                                router.push(
                                  `/keenkonnect/projects/project-workspace?projectId=${project.id}`,
                                );
                              }}
                            >
                              Open
                            </Button>
                          </Tooltip>
                          <Tooltip title="View collaborators (coming soon)">
                            <Button
                              type="link"
                              icon={<TeamOutlined />}
                              onClick={(e) => e.stopPropagation()}
                            >
                              Team
                            </Button>
                          </Tooltip>
                        </Space>
                      }
                    >
                      <Space
                        direction="vertical"
                        size={8}
                        style={{ width: '100%' }}
                      >
                        <div>
                          <Tag color="blue">{project.domain}</Tag>
                        </div>

                        <div
                          style={{
                            minHeight: 48,
                            color: 'rgba(0,0,0,0.65)',
                            fontSize: 13,
                          }}
                        >
                          {project.description ||
                            'No description provided yet.'}
                        </div>

                        {/* Technologies */}
                        <Space wrap>
                          {project.technologies.length === 0 ? (
                            <Tag>No technologies listed</Tag>
                          ) : (
                            project.technologies.map((tech) => (
                              <Tag key={tech}>{tech}</Tag>
                            ))
                          )}
                        </Space>

                        {/* Avatars + owner + CTA */}
                        <Row
                          justify="space-between"
                          align="middle"
                          style={{ marginTop: 8 }}
                        >
                          <Col>
                            <Space size={8}>
                              <Avatar.Group maxCount={3} size="small">
                                <Avatar icon={<UserOutlined />} />
                                <Avatar>
                                  {project.owner
                                    ? project.owner.charAt(0).toUpperCase()
                                    : '?'}
                                </Avatar>
                                <Avatar icon={<UserOutlined />} />
                              </Avatar.Group>
                              <span
                                style={{
                                  fontSize: 12,
                                  color: 'rgba(0,0,0,0.45)',
                                }}
                              >
                                Owner: {project.owner || 'Unknown'}
                              </span>
                            </Space>
                          </Col>
                          <Col>
                            <Button
                              type="link"
                              size="small"
                              onClick={(e) => {
                                e.stopPropagation();
                                router.push(
                                  `/keenkonnect/projects/project-workspace?projectId=${project.id}`,
                                );
                              }}
                            >
                              Open workspace
                            </Button>
                          </Col>
                        </Row>
                      </Space>
                    </Card>
                  </Col>
                ))}

                {paginatedProjects.length === 0 && projects.length > 0 && (
                  <Col span={24}>
                    <Card>
                      <Space direction="vertical">
                        <span>No projects match your filters.</span>
                        <Button
                          type="primary"
                          icon={<PlusOutlined />}
                          onClick={() =>
                            router.push(
                              '/keenkonnect/projects/create-new-project',
                            )
                          }
                        >
                          Start a New Project
                        </Button>
                      </Space>
                    </Card>
                  </Col>
                )}
              </Row>
            )}
          </ProCard>

          {/* Pagination */}
          {sortedProjects.length > pageSize && (
            <div style={{ textAlign: 'center', marginTop: 24 }}>
              <Pagination
                current={currentPage}
                pageSize={pageSize}
                total={sortedProjects.length}
                showSizeChanger={false}
                onChange={(page) => setCurrentPage(page)}
              />
            </div>
          )}

          {/* Drawer: project details */}
          <Drawer
            title={selectedProject?.name}
            placement="right"
            width={420}
            open={drawerVisible}
            onClose={handleCloseDrawer}
          >
            {selectedProject && (
              <Space
                direction="vertical"
                size="middle"
                style={{ width: '100%' }}
              >
                <Space align="center">
                  <Avatar.Group maxCount={3}>
                    <Avatar size="large" icon={<UserOutlined />} />
                    <Avatar>
                      {selectedProject.owner
                        ? selectedProject.owner.charAt(0).toUpperCase()
                        : '?'}
                    </Avatar>
                    <Avatar icon={<UserOutlined />} />
                  </Avatar.Group>
                  <div>
                    <div>
                      <strong>Owner: </strong>
                      {selectedProject.owner || 'Unknown'}
                    </div>
                    <div>
                      <strong>Members: </strong>
                      {selectedProject.members}
                    </div>
                  </div>
                </Space>

                <Divider />

                <div>
                  <p>
                    <strong>Description</strong>
                  </p>
                  <p>
                    {selectedProject.description ||
                      'No detailed description provided yet.'}
                  </p>
                </div>

                <div>
                  <p>
                    <strong>Domain</strong>
                  </p>
                  <Tag color="blue">{selectedProject.domain}</Tag>
                </div>

                <div>
                  <p>
                    <strong>Technologies</strong>
                  </p>
                  <Space wrap>
                    {selectedProject.technologies.length === 0 ? (
                      <Tag>No technologies listed</Tag>
                    ) : (
                      selectedProject.technologies.map((tech) => (
                        <Tag key={tech}>{tech}</Tag>
                      ))
                    )}
                  </Space>
                </div>

                <div>
                  <p>
                    <strong>Created At</strong>
                  </p>
                  <span>{selectedProject.createdAt}</span>
                </div>
              </Space>
            )}
          </Drawer>
        </ProCard>
      </PageContainer>
    </>
  );
}

===== END app/keenkonnect/projects/browse-projects/page.tsx =====


===== BEGIN app/keenkonnect/projects/create-new-project/page.tsx =====
// app/keenkonnect/projects/create-new-project/page.tsx
'use client';

import React, { Suspense, useState } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/navigation';
import { Row, Col, Card, Typography, message } from 'antd';
import {
  StepsForm,
  ProFormText,
  ProFormTextArea,
  ProFormSelect,
  ProFormDatePicker,
  ProFormUploadButton,
} from '@ant-design/pro-components';
import type { UploadFile } from 'antd/es/upload/interface';
import api from '@/api';

const { Paragraph } = Typography;

// Backend route: /api/keenkonnect/projects/
const PROJECTS_ENDPOINT = 'keenkonnect/projects/';

type CreateProjectFormValues = {
  name: string;
  description?: string;
  category?: string;
  team?: string;
  startDate?: any;
  endDate?: any;
  attachments?: UploadFile[];
  notes?: string;
};

export default function PageWrapper() {
  return (
    <Suspense fallback={null}>
      <Content />
    </Suspense>
  );
}

function Content() {
  const router = useRouter();
  const [submitting, setSubmitting] = useState(false);

  const handleFinish = async (values: CreateProjectFormValues) => {
    try {
      setSubmitting(true);

      // Minimal payload aligned with Django ProjectSerializer
      const payload = {
        title: values.name,
        description: values.description ?? '',
        category: values.category ?? 'Uncategorized',
        status: 'idea' as const,
      };

      await api.post(PROJECTS_ENDPOINT, payload);

      message.success('Project created successfully!');
      router.push('/keenkonnect/projects/my-projects');
      return true;
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Create project error:', err);
      message.error('Failed to create project.');
      return false;
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <>
      <Head>
        <title>Create New Project ‚Äì KeenKonnect</title>
      </Head>

      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-2">Create New Project</h1>
        <Paragraph type="secondary" className="mb-4">
          Use this guided wizard to describe your project, configure the team and
          timeline, and attach any supporting files. The core project record is
          created in the Django backend.
        </Paragraph>

        <Row justify="center">
          <Col xs={24} lg={18} xl={16}>
            <Card>
              <StepsForm<CreateProjectFormValues>
                onFinish={handleFinish}
                formProps={{
                  layout: 'vertical',
                }}
                submitter={{
                  searchConfig: {
                    submitText: 'Create Project',
                  },
                  submitButtonProps: {
                    loading: submitting,
                  },
                }}
              >
                {/* Step 1 ‚Äì Basic Info */}
                <StepsForm.StepForm name="basic" title="Basic Info">
                  <ProFormText
                    name="name"
                    label="Project Name"
                    placeholder="Enter project name"
                    rules={[
                      { required: true, message: 'Please enter a project name' },
                    ]}
                  />

                  <ProFormTextArea
                    name="description"
                    label="Description"
                    placeholder="Describe your project goals, context, and expected outcomes"
                    fieldProps={{ rows: 4 }}
                  />

                  <ProFormSelect
                    name="category"
                    label="Category"
                    placeholder="Choose a domain or focus area"
                    options={[
                      { label: 'Civic', value: 'Civic' },
                      { label: 'Arts', value: 'Arts' },
                      { label: 'Education', value: 'Education' },
                      { label: 'Environment', value: 'Environment' },
                      { label: 'Other', value: 'Other' },
                    ]}
                  />
                </StepsForm.StepForm>

                {/* Step 2 ‚Äì Team & Timeline */}
                <StepsForm.StepForm
                  name="team-settings"
                  title="Team & Timeline"
                >
                  <ProFormSelect
                    name="team"
                    label="Team"
                    placeholder="Select team (optional for now)"
                    options={[
                      { label: 'Team Alpha', value: 'alpha' },
                      { label: 'Team Beta', value: 'beta' },
                    ]}
                  />

                  <Row gutter={16}>
                    <Col xs={24} md={12}>
                      <ProFormDatePicker
                        name="startDate"
                        label="Start Date"
                        fieldProps={{ style: { width: '100%' } }}
                      />
                    </Col>
                    <Col xs={24} md={12}>
                      <ProFormDatePicker
                        name="endDate"
                        label="End Date"
                        fieldProps={{ style: { width: '100%' } }}
                      />
                    </Col>
                  </Row>
                </StepsForm.StepForm>

                {/* Step 3 ‚Äì Attachments & Notes */}
                <StepsForm.StepForm
                  name="attachments"
                  title="Attachments & Notes"
                >
                  <ProFormUploadButton
                    name="attachments"
                    label="Attachments"
                    max={5}
                    fieldProps={{
                      multiple: true,
                      // No automatic upload; files are kept in form state
                      beforeUpload: () => false,
                      listType: 'text',
                    }}
                    extra="Optional: upload briefs, specs, or reference documents."
                  />

                  <ProFormTextArea
                    name="notes"
                    label="Additional Notes"
                    placeholder="Anything else your collaborators should know?"
                    fieldProps={{ rows: 4 }}
                  />
                </StepsForm.StepForm>
              </StepsForm>
            </Card>
          </Col>
        </Row>
      </div>
    </>
  );
}

===== END app/keenkonnect/projects/create-new-project/page.tsx =====


===== BEGIN app/keenkonnect/projects/my-projects/page.tsx =====
// app/keenkonnect/projects/my-projects/page.tsx
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import {
  Button,
  Typography,
  Space,
  Tag,
  Select,
  Dropdown,
  Progress,
  Spin,
} from 'antd';
import {
  EyeOutlined,
  EditOutlined,
  RocketOutlined,
  PlusOutlined,
  TeamOutlined,
} from '@ant-design/icons';
import type { ProColumns } from '@ant-design/pro-components';
import { ProTable } from '@ant-design/pro-components';
import { useRouter } from 'next/navigation';
import usePageTitle from '@/hooks/usePageTitle';
import api from '@/api';

const { Text } = Typography;
const { Option } = Select;

// Aligne avec le backend: /api/keenkonnect/projects/
const PROJECTS_ENDPOINT = 'keenkonnect/projects/';

type ProjectStatus = 'idea' | 'progress' | 'completed' | 'validated';

interface ApiProject {
  id: number;
  title: string;
  description: string;
  creator: string;
  category: string;
  status: string;
  created_at: string;
  updated_at: string;
  tags: number[];
}

interface Project {
  id: number;
  name: string;
  owner: string;
  category: string;
  status: ProjectStatus;
  createdAt: string; // ISO date string
  progress: number; // 0‚Äì100 (placeholder for now)
}

export default function MyProjectsPage(): JSX.Element {
  const router = useRouter();
  usePageTitle('KeenKonnect ‚Äì My Projects');

  const [projects, setProjects] = useState<Project[]>([]);
  const [statusFilter, setStatusFilter] = useState<ProjectStatus | 'all'>('all');
  const [loading, setLoading] = useState<boolean>(false);

  useEffect(() => {
    const fetchProjects = async () => {
      try {
        setLoading(true);

        const data = await api.get<ApiProject[]>(PROJECTS_ENDPOINT);

        const mapped: Project[] = data.map((p) => ({
          id: p.id,
          name: p.title,
          owner: p.creator ?? '',
          category: p.category ?? 'Uncategorized',
          status: (p.status as ProjectStatus) || 'idea',
          createdAt: p.created_at,
          // For now, progress is a placeholder; you can later map it
          // from tasks completion stats or a dedicated field.
          progress: 0,
        }));

        setProjects(mapped);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error('Failed to load projects', err);
      } finally {
        setLoading(false);
      }
    };

    void fetchProjects();
  }, []);

  const filtered: Project[] = useMemo(() => {
    if (statusFilter === 'all') return projects;
    return projects.filter((p) => p.status === statusFilter);
  }, [projects, statusFilter]);

  const handleView = (id: number): void => {
    router.push(`/keenkonnect/projects/project-workspace?projectId=${id}`);
  };

  const handleEdit = (id: number): void => {
    // Placeholder: adapt when you add an edit page
    router.push(`/keenkonnect/projects/project-workspace?projectId=${id}`);
  };

  const handleLaunch = (id: number): void => {
    router.push(`/keenkonnect/projects/project-workspace?projectId=${id}`);
  };

  const statusColors: Record<
    ProjectStatus,
    'default' | 'processing' | 'success' | 'warning' | 'error'
  > = {
    idea: 'default',
    progress: 'processing',
    completed: 'success',
    validated: 'success',
  };

  const columns: ProColumns<Project>[] = [
    {
      title: 'Project',
      dataIndex: 'name',
      key: 'name',
      render: (_, record) => (
        <Space direction="vertical" size={0}>
          <Text strong>{record.name}</Text>
          <Space size="small">
            <Tag icon={<TeamOutlined />}>Owner: {record.owner || 'Unknown'}</Tag>
            <Tag>{record.category}</Tag>
          </Space>
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      valueType: 'select',
      valueEnum: {
        idea: { text: 'Idea' },
        progress: { text: 'In progress' },
        completed: { text: 'Completed' },
        validated: { text: 'Validated' },
      },
      render: (_, record) => (
        <Tag color={statusColors[record.status]}>
          {record.status === 'progress' ? 'In progress' : record.status}
        </Tag>
      ),
    },
    {
      title: 'Progress',
      dataIndex: 'progress',
      key: 'progress',
      width: 200,
      render: (_, record) => (
        <Progress
          percent={record.progress}
          size="small"
          status={record.progress === 100 ? 'success' : 'active'}
        />
      ),
    },
    {
      title: 'Created',
      dataIndex: 'createdAt',
      key: 'createdAt',
      valueType: 'date',
    },
    {
      title: 'Actions',
      key: 'actions',
      valueType: 'option',
      render: (_, record) => [
        <Dropdown.Button
          key="actions"
          type="primary"
          icon={<RocketOutlined />}
          onClick={() => handleLaunch(record.id)}
          menu={{
            items: [
              {
                key: 'view',
                label: (
                  <span>
                    <EyeOutlined style={{ marginRight: 8 }} />
                    View
                  </span>
                ),
              },
              {
                key: 'edit',
                label: (
                  <span>
                    <EditOutlined style={{ marginRight: 8 }} />
                    Edit
                  </span>
                ),
              },
              {
                key: 'launch',
                label: (
                  <span>
                    <RocketOutlined style={{ marginRight: 8 }} />
                    Launch
                  </span>
                ),
              },
            ],
            onClick: ({ key }) => {
              if (key === 'view') {
                handleView(record.id);
              } else if (key === 'edit') {
                handleEdit(record.id);
              } else if (key === 'launch') {
                handleLaunch(record.id);
              }
            },
          }}
        >
          Launch
        </Dropdown.Button>,
      ],
    },
  ];

  return (
    <div>
      {loading && (
        <div style={{ textAlign: 'center', marginBottom: 16 }}>
          <Spin />
        </div>
      )}

      <ProTable<Project>
        rowKey="id"
        headerTitle="My Projects"
        columns={columns}
        dataSource={filtered}
        pagination={{ pageSize: 10 }}
        search={false}
        options={false}
        loading={loading}
        cardBordered
        toolBarRender={() => [
          <Space key="filters" align="center">
            <Text>Status:</Text>
            <Select<ProjectStatus | 'all'>
              value={statusFilter}
              onChange={(value) => setStatusFilter(value)}
              style={{ width: 220 }}
            >
              <Option value="all">All</Option>
              <Option value="idea">Idea</Option>
              <Option value="progress">In progress</Option>
              <Option value="completed">Completed</Option>
              <Option value="validated">Validated</Option>
            </Select>
          </Space>,
          <Button
            key="create"
            type="primary"
            icon={<PlusOutlined />}
            onClick={() =>
              router.push('/keenkonnect/projects/create-new-project')
            }
          >
            Create New Project
          </Button>,
        ]}
      />
    </div>
  );
}

===== END app/keenkonnect/projects/my-projects/page.tsx =====


===== BEGIN app/keenkonnect/projects/project-workspace/page.tsx =====
// app/keenkonnect/projects/project-workspace/page.tsx
'use client';

import React, { Suspense, useEffect, useState } from 'react';
import { useSearchParams } from 'next/navigation';
import { ProCard } from '@ant-design/pro-components';
import { Comment } from '@ant-design/compatible';
import type { MenuProps, TabsProps } from 'antd';
import {
  Avatar,
  Badge,
  Button,
  Drawer,
  Empty,
  List,
  Menu,
  Spin,
  Tabs,
  Tag,
  Timeline,
  Typography,
  Space,
} from 'antd';
import api from '@/api';

const { Title, Text, Paragraph } = Typography;

const PROJECTS_ENDPOINT = '/api/projects/';

interface ApiProject {
  id: number;
  title: string;
  description: string;
  creator: string;
  category: string;
  status: string;
  created_at: string;
  updated_at: string;
  tags: number[];
}

interface WorkspaceViewModel {
  id: number;
  name: string;
  description?: string;
  owner: string;
  status: string;
  domain?: string;
  createdAt: string;
  currentSprint?: string;
  deadline?: string;
  tasks?: any[];
  members?: any[];
  comments?: any[];
  activity?: any[];
  timeline?: any[];
}

export default function PageWrapper() {
  return (
    <Suspense fallback={<Spin style={{ marginTop: 40 }} />}>
      <Content />
    </Suspense>
  );
}

function Content(): JSX.Element {
  const searchParams = useSearchParams();
  const projectIdParam =
    searchParams.get('projectId') || searchParams.get('id');
  const projectId = projectIdParam ? Number(projectIdParam) : null;

  const [workspace, setWorkspace] = useState<WorkspaceViewModel | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [activeKey, setActiveKey] = useState<string>('overview');
  const [drawerOpen, setDrawerOpen] = useState<boolean>(false);
  const [selectedTask, setSelectedTask] = useState<any | null>(null);

  // Load workspace
  useEffect(() => {
    if (!projectId) {
      setError(
        'No project selected. Open this workspace from the projects list or pass ?projectId=<id>.',
      );
      setLoading(false);
      return;
    }

    const fetchWorkspace = async () => {
      try {
        setLoading(true);
        setError(null);

        const data = await api.get<ApiProject>(
          `${PROJECTS_ENDPOINT}${projectId}/`,
        );

        const mapped: WorkspaceViewModel = {
          id: data.id,
          name: data.title,
          description: data.description ?? '',
          owner: data.creator ?? '',
          status: data.status || 'Active',
          domain: data.category ?? 'Uncategorized',
          createdAt: data.created_at,
          // These can later be wired to real endpoints (tasks, messages, etc.)
          tasks: [],
          members: [],
          comments: [],
          activity: [],
        };

        setWorkspace(mapped);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error('Failed to load project workspace', err);
        setError(
          'Error loading workspace. Some information may be unavailable.',
        );
      } finally {
        setLoading(false);
      }
    };

    void fetchWorkspace();
  }, [projectId]);

  // Update document title (App Router replacement for next/head here)
  useEffect(() => {
    if (workspace?.name) {
      document.title = `KeenKonnect ‚Äì ${workspace.name}`;
    } else {
      document.title = 'KeenKonnect ‚Äì Project Workspace';
    }
  }, [workspace?.name]);

  // Safely derive arrays from the workspace payload
  const tasks: any[] = Array.isArray(workspace?.tasks)
    ? (workspace?.tasks as any[])
    : [];
  const members: any[] = Array.isArray(workspace?.members)
    ? (workspace?.members as any[])
    : [];
  const comments: any[] = Array.isArray(workspace?.comments)
    ? (workspace?.comments as any[])
    : [];

  let activity: any[] = [];
  if (Array.isArray(workspace?.activity)) {
    activity = (workspace?.activity as any[]) ?? [];
  } else if (Array.isArray(workspace?.timeline)) {
    activity = (workspace?.timeline as any[]) ?? [];
  }

  const derivedActivity =
    activity.length > 0
      ? activity
      : tasks.map((task: any, index: number) => ({
          key: task.id || `task-${index}`,
          title: task.title,
          description: task.description,
          status: task.status,
          date: task.dueDate || workspace?.deadline,
        }));

  const statusText: string = workspace?.status || 'Active';

  const statusTagColor =
    statusText === 'On Track'
      ? 'success'
      : statusText === 'At Risk'
      ? 'warning'
      : statusText === 'Blocked'
      ? 'error'
      : 'default';

  const totalTasks = tasks.length;
  const completedTasks = tasks.filter(
    (task) => task.status === 'Done' || task.status === 'Completed',
  ).length;
  const inProgressTasks = tasks.filter(
    (task) => task.status === 'In Progress' || task.status === 'Doing',
  ).length;

  const menuItems: MenuProps['items'] = [
    {
      key: 'overview',
      label: 'Overview',
    },
    {
      key: 'tasks',
      label: 'Tasks & Sprints',
    },
    {
      key: 'timeline',
      label: 'Timeline',
    },
    {
      key: 'discussion',
      label: 'Discussion',
    },
  ];

  const handleMenuClick: MenuProps['onClick'] = ({ key }) => {
    setActiveKey(key as string);
  };

  const handleTabChange = (key: string) => {
    setActiveKey(key);
  };

  const handleTaskClick = (task: any) => {
    setSelectedTask(task);
    setDrawerOpen(true);
  };

  // New Tabs API (items) instead of deprecated Tabs.TabPane
  const tabsItems: TabsProps['items'] = [
    {
      key: 'overview',
      label: 'Overview',
      children: (
        <>
          <ProCard
            bordered
            title="Highlights"
            style={{ marginBottom: 16 }}
            bodyStyle={{ padding: 16 }}
          >
            <List
              size="small"
              dataSource={[
                {
                  key: 'status',
                  label: 'Current status',
                  value: statusText,
                },
                {
                  key: 'sprint',
                  label: 'Active sprint',
                  value:
                    workspace?.currentSprint || 'No active sprint configured',
                },
                {
                  key: 'deadline',
                  label: 'Next deadline',
                  value: workspace?.deadline || 'No deadline set',
                },
              ]}
              renderItem={(item) => (
                <List.Item key={item.key}>
                  <Space>
                    <Text type="secondary">{item.label}:</Text>
                    <Text>{item.value}</Text>
                  </Space>
                </List.Item>
              )}
            />
          </ProCard>

          <ProCard
            bordered
            title="Recent activity"
            bodyStyle={{ padding: 16 }}
            extra={
              <Button
                type="link"
                size="small"
                onClick={() => setActiveKey('timeline')}
              >
                View full timeline
              </Button>
            }
          >
            {derivedActivity.length === 0 ? (
              <Empty description="No recent activity yet." />
            ) : (
              <Timeline
                style={{ marginTop: 8 }}
                items={derivedActivity.slice(0, 5).map((item: any) => ({
                  color:
                    item.status === 'Completed' || item.status === 'Done'
                      ? 'green'
                      : item.status === 'Blocked'
                      ? 'red'
                      : 'blue',
                  children: (
                    <div>
                      <Text strong>{item.title}</Text>
                      {item.date && (
                        <div>
                          <Text type="secondary">{item.date}</Text>
                        </div>
                      )}
                      {item.description && (
                        <Paragraph style={{ marginBottom: 0 }}>
                          {item.description}
                        </Paragraph>
                      )}
                    </div>
                  ),
                }))}
              />
            )}
          </ProCard>
        </>
      ),
    },
    {
      key: 'tasks',
      label: 'Tasks & Sprints',
      children: (
        <List
          itemLayout="horizontal"
          dataSource={tasks}
          locale={{
            emptyText: 'No tasks configured for this workspace yet.',
          }}
          renderItem={(task: any) => (
            <List.Item
              key={task.id || task.title}
              onClick={() => handleTaskClick(task)}
              style={{ cursor: 'pointer' }}
            >
              <List.Item.Meta
                title={
                  <Space size="small">
                    <Text strong>{task.title}</Text>
                    {task.status && <Tag>{task.status}</Tag>}
                  </Space>
                }
                description={
                  <Space direction="vertical" size={2}>
                    {task.description && (
                      <Text type="secondary">{task.description}</Text>
                    )}
                    <Space size="small">
                      {task.assignee && (
                        <Text type="secondary">
                          Owner:&nbsp;
                          <Text>{task.assignee}</Text>
                        </Text>
                      )}
                      {task.dueDate && (
                        <Text type="secondary">
                          ¬∑ Due:&nbsp;
                          <Text>{task.dueDate}</Text>
                        </Text>
                      )}
                    </Space>
                  </Space>
                }
              />
            </List.Item>
          )}
        />
      ),
    },
    {
      key: 'timeline',
      label: 'Timeline',
      children:
        derivedActivity.length === 0 ? (
          <Empty description="No timeline events to show yet." />
        ) : (
          <Timeline
            style={{ marginTop: 8 }}
            items={derivedActivity.map((item: any) => ({
              color:
                item.status === 'Completed' || item.status === 'Done'
                  ? 'green'
                  : item.status === 'Blocked'
                  ? 'red'
                  : 'blue',
              children: (
                <div>
                  <Text strong>{item.title}</Text>
                  {item.date && (
                    <div>
                      <Text type="secondary">{item.date}</Text>
                    </div>
                  )}
                  {item.description && (
                    <Paragraph style={{ marginBottom: 0 }}>
                      {item.description}
                    </Paragraph>
                  )}
                </div>
              ),
            }))}
          />
        ),
    },
    {
      key: 'discussion',
      label: 'Discussion',
      children: (
        <List
          dataSource={comments}
          locale={{
            emptyText:
              'No discussion yet. Start the conversation with your team.',
          }}
          renderItem={(comment: any) => (
            <li key={comment.id}>
              <Comment
                author={comment.author}
                avatar={
                  comment.avatar || (
                    <Avatar>
                      {comment.author?.charAt(0)?.toUpperCase() ?? '?'}
                    </Avatar>
                  )
                }
                content={comment.content}
                datetime={comment.datetime}
              />
            </li>
          )}
        />
      ),
    },
  ];

  if (loading) {
    return (
      <div style={{ padding: 24, textAlign: 'center' }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <div style={{ padding: 24 }}>
      <Title level={2} style={{ marginBottom: 8 }}>
        {workspace?.name || 'Project Workspace'}
      </Title>

      <Paragraph
        type="secondary"
        style={{ marginBottom: 24, maxWidth: 720 }}
      >
        {workspace?.description ||
          'Central hub for coordinating your project, tracking tasks, and collaborating with your team in KeenKonnect.'}
      </Paragraph>

      {error && (
        <Paragraph type="danger" style={{ marginBottom: 16 }}>
          {error}
        </Paragraph>
      )}

      <ProCard split="vertical" gutter={24} bordered>
        {/* Left column: context + menu + team */}
        <ProCard
          colSpan={{ xs: 24, sm: 24, md: 8, lg: 7, xl: 6 }}
          title="Workspace overview"
          bordered={false}
        >
          <Space
            direction="vertical"
            size="middle"
            style={{ width: '100%' }}
          >
            <div>
              <Text strong>Status:&nbsp;</Text>
              <Tag color={statusTagColor}>{statusText}</Tag>
            </div>

            {workspace?.currentSprint && (
              <div>
                <Text strong>Current sprint:&nbsp;</Text>
                <Text>{workspace.currentSprint}</Text>
              </div>
            )}

            {workspace?.deadline && (
              <div>
                <Text strong>Deadline:&nbsp;</Text>
                <Text>{workspace.deadline}</Text>
              </div>
            )}

            <Space size="large" style={{ marginTop: 4 }}>
              <Badge
                color="blue"
                text={
                  <span>
                    Total tasks:&nbsp;
                    <Text strong>{totalTasks}</Text>
                  </span>
                }
              />
              <Badge
                color="green"
                text={
                  <span>
                    Completed:&nbsp;
                    <Text strong>{completedTasks}</Text>
                  </span>
                }
              />
              <Badge
                color="gold"
                text={
                  <span>
                    In progress:&nbsp;
                    <Text strong>{inProgressTasks}</Text>
                  </span>
                }
              />
            </Space>

            <div style={{ marginTop: 8 }}>
              <Text strong style={{ display: 'block', marginBottom: 8 }}>
                Sections
              </Text>
              <Menu
                mode="inline"
                selectedKeys={[activeKey]}
                onClick={handleMenuClick}
                items={menuItems}
                style={{ borderRight: 0 }}
              />
            </div>

            <div style={{ marginTop: 16 }}>
              <Text strong style={{ display: 'block', marginBottom: 8 }}>
                Team members
              </Text>
              <List
                size="small"
                dataSource={members}
                locale={{
                  emptyText:
                    'No team members linked to this workspace yet.',
                }}
                renderItem={(member: any) => (
                  <List.Item key={member.id || member.name}>
                    <List.Item.Meta
                      avatar={
                        member.avatar ? (
                          <Avatar size="small" src={member.avatar} />
                        ) : (
                          <Avatar size="small">
                            {member.name?.charAt(0)?.toUpperCase() ?? '?'}
                          </Avatar>
                        )
                      }
                      title={member.name}
                      description={
                        member.role || member.title || 'Contributor'
                      }
                    />
                  </List.Item>
                )}
              />
            </div>
          </Space>
        </ProCard>

        {/* Right column: main content with tabs */}
        <ProCard colSpan="auto" bordered={false}>
          <Tabs
            activeKey={activeKey}
            onChange={handleTabChange}
            items={tabsItems}
          />
        </ProCard>
      </ProCard>

      {/* Drawer for task details */}
      <Drawer
        title={selectedTask?.title}
        placement="right"
        width={400}
        open={drawerOpen}
        onClose={() => setDrawerOpen(false)}
      >
        {selectedTask ? (
          <Space
            direction="vertical"
            size="middle"
            style={{ width: '100%' }}
          >
            <div>
              <Text strong>Status:</Text>{' '}
              {selectedTask.status || 'N/A'}
            </div>
            {selectedTask.description && (
              <Paragraph>{selectedTask.description}</Paragraph>
            )}
            <div>
              <Text strong>Owner:</Text>{' '}
              {selectedTask.assignee || 'Unassigned'}
            </div>
            {selectedTask.dueDate && (
              <div>
                <Text strong>Due date:</Text> {selectedTask.dueDate}
              </div>
            )}
          </Space>
        ) : (
          <Empty description="No task selected." />
        )}
      </Drawer>
    </div>
  );
}

===== END app/keenkonnect/projects/project-workspace/page.tsx =====


===== BEGIN app/keenkonnect/sustainability-impact/submit-impact-reports/page.tsx =====
'use client';

import React, { Suspense, useState } from 'react';
import Head from 'next/head';
import Link from 'next/link';
import { StepsForm, ProFormDigit } from '@ant-design/pro-components';
import {
  Button,
  Card,
  DatePicker,
  Form,
  Input,
  Select,
  Upload,
  Result,
  Spin,
  message,
} from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import type { Dayjs } from 'dayjs';
import dayjs from 'dayjs';
import { InboxOutlined } from '@ant-design/icons';
import api from '@/api';

const { Option } = Select;
const { TextArea } = Input;
const { Dragger } = Upload;

type SustainabilityReportFormValues = {
  project: string;
  date: Dayjs;
  category: string;
  co2Reduction?: number;
  energySaved?: number;
  peopleImpacted?: number;
  budgetUsed?: number;
  description: string;
  attachments?: UploadFile[];
};

export default function PageWrapper() {
  return (
    <Suspense fallback={<Spin style={{ marginTop: 40 }} />}>
      <Content />
    </Suspense>
  );
}

function Content(): JSX.Element {
  const [completed, setCompleted] = useState(false);
  const [referenceId, setReferenceId] = useState<string | undefined>();

  const handleFinish = async (
    values: SustainabilityReportFormValues,
  ): Promise<boolean> => {
    try {
      const payload = {
        ...values,
        date: values.date?.format('YYYY-MM-DD'),
        // No real upload here ‚Äì we just serialize metadata:
        attachments: values.attachments?.map((file) => ({
          name: file.name,
          uid: file.uid,
        })),
      };

      const res = await api.post('/impact/sustainability/report', payload);

      if (res && typeof res === 'object' && 'reference' in (res as any)) {
        setReferenceId((res as any).reference as string);
      }

      message.success('Impact report submitted successfully!');
      setCompleted(true);
      return true;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Submit impact report error:', error);
      message.error('Failed to submit impact report. Please try again.');
      return false;
    }
  };

  // Typed helper to normalize Upload value
  const normFile = (e: any): UploadFile[] => {
    if (Array.isArray(e)) {
      return e as UploadFile[];
    }
    return (e?.fileList ?? []) as UploadFile[];
  };

  if (completed) {
    return (
      <>
        <Head>
          <title>KeenKonnect ‚Äì Submit Impact Report</title>
        </Head>

        <Result
          status="success"
          title="Impact report submitted"
          subTitle={
            referenceId
              ? `Reference: ${referenceId}. You can now track this impact in your dashboard.`
              : 'Your report has been saved. You can now track this impact in your dashboard.'
          }
          extra={[
            <Link
              key="track"
              href="/keenkonnect/sustainability-impact/track-project-impact"
            >
              <Button type="primary">Go to Track Project Impact</Button>
            </Link>,
            <Button key="again" onClick={() => setCompleted(false)}>
              Submit another report
            </Button>,
          ]}
        />
      </>
    );
  }

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Submit Impact Report</title>
      </Head>

      <h1 style={{ fontSize: 24, fontWeight: 600, marginBottom: 24 }}>
        Submit Impact Report
      </h1>

      <Card>
        <StepsForm<SustainabilityReportFormValues>
          onFinish={handleFinish}
          submitter={{
            // SearchConfig in ProComponents v2 only supports resetText / submitText
            searchConfig: {
              submitText: 'Submit report',
            },
            render: (props, dom) => (
              <div style={{ marginTop: 24, textAlign: 'right' }}>{dom}</div>
            ),
          }}
        >
          {/* Step 1 ‚Äì Project & timeframe */}
          <StepsForm.StepForm
            name="basic"
            title="Project & timeframe"
            layout="vertical"
            initialValues={{
              date: dayjs(),
            }}
          >
            <Form.Item
              label="Project"
              name="project"
              rules={[{ required: true, message: 'Please select a project' }]}
            >
              <Select placeholder="Select the project">
                {/* TODO: replace with dynamic project list */}
                <Option value="project-a">Project A</Option>
                <Option value="project-b">Project B</Option>
              </Select>
            </Form.Item>

            <Form.Item
              label="Date"
              name="date"
              rules={[{ required: true, message: 'Please select a date' }]}
            >
              <DatePicker style={{ width: '100%' }} />
            </Form.Item>

            <Form.Item
              label="Impact category"
              name="category"
              rules={[{ required: true, message: 'Please choose a category' }]}
            >
              <Select placeholder="Select impact category">
                <Option value="environment">Environment</Option>
                <Option value="social">Social</Option>
                <Option value="governance">Governance</Option>
              </Select>
            </Form.Item>
          </StepsForm.StepForm>

          {/* Step 2 ‚Äì Quantitative metrics */}
          <StepsForm.StepForm
            name="metrics"
            title="Impact metrics"
            layout="vertical"
          >
            <ProFormDigit
              name="co2Reduction"
              label="CO‚ÇÇ reduction (tons)"
              min={0}
              fieldProps={{ precision: 2 }}
              tooltip="Estimated CO‚ÇÇ equivalent reduced by this initiative"
            />

            <ProFormDigit
              name="energySaved"
              label="Energy saved (kWh)"
              min={0}
              fieldProps={{ precision: 0 }}
            />

            <ProFormDigit
              name="peopleImpacted"
              label="People positively impacted"
              min={0}
              fieldProps={{ precision: 0 }}
            />

            <ProFormDigit
              name="budgetUsed"
              label="Budget used (USD)"
              min={0}
              fieldProps={{ precision: 2 }}
            />
          </StepsForm.StepForm>

          {/* Step 3 ‚Äì Evidence & narrative */}
          <StepsForm.StepForm
            name="evidence"
            title="Evidence & narrative"
            layout="vertical"
          >
            <Form.Item
              label="Impact narrative"
              name="description"
              rules={[
                {
                  required: true,
                  message: 'Please describe the impact you observed',
                },
              ]}
            >
              <TextArea
                rows={4}
                placeholder="Describe the impact, context and key outcomes..."
              />
            </Form.Item>

            <Form.Item
              label="Supporting files"
              name="attachments"
              valuePropName="fileList"
              getValueFromEvent={normFile}
            >
              <Dragger
                name="files"
                multiple
                beforeUpload={() => false}
                accept=".pdf,.doc,.docx,.xlsx,.csv,image/*"
              >
                <p className="ant-upload-drag-icon">
                  <InboxOutlined />
                </p>
                <p className="ant-upload-text">
                  Click or drag files to this area to upload
                </p>
                <p className="ant-upload-hint">
                  Attach reports, spreadsheets, dashboards or photos that support
                  your impact.
                </p>
              </Dragger>
            </Form.Item>
          </StepsForm.StepForm>
        </StepsForm>
      </Card>
    </>
  );
}

===== END app/keenkonnect/sustainability-impact/submit-impact-reports/page.tsx =====


===== BEGIN app/keenkonnect/sustainability-impact/sustainability-dashboard/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import Head from 'next/head';
import { Card, Select, Space, Tag, Table, Row, Col, Statistic, Typography } from 'antd';
import type { ColumnsType } from 'antd/es/table';
import { Line, Area, Column } from '@ant-design/plots';
import usePageTitle from '@/hooks/usePageTitle';

const { Title, Paragraph } = Typography;

type TimeRange = '3m' | '6m' | '12m';

type ProjectRow = {
  key: string;
  name: string;
  owner: string;
  co2SavedKg: number;
  energySavedKwh: number;
  impactScore: number;
  tags: string[];
};

// --- Donn√©es simul√©es (placeholder) ---

const overviewStats = {
  totalCo2SavedKg: 28450,
  totalEnergySavedKwh: 19320,
  wasteDivertedKg: 5270,
  activeProjects: 12,
};

const co2TrendBase = [
  { month: '2025-01', value: 1200 },
  { month: '2025-02', value: 1350 },
  { month: '2025-03', value: 1480 },
  { month: '2025-04', value: 1600 },
  { month: '2025-05', value: 1705 },
  { month: '2025-06', value: 1820 },
  { month: '2025-07', value: 1960 },
  { month: '2025-08', value: 2100 },
  { month: '2025-09', value: 2240 },
  { month: '2025-10', value: 2390 },
  { month: '2025-11', value: 2525 },
  { month: '2025-12', value: 2680 },
];

const energyTrendBase = [
  { month: '2025-01', value: 800 },
  { month: '2025-02', value: 950 },
  { month: '2025-03', value: 1020 },
  { month: '2025-04', value: 1100 },
  { month: '2025-05', value: 1200 },
  { month: '2025-06', value: 1300 },
  { month: '2025-07', value: 1380 },
  { month: '2025-08', value: 1450 },
  { month: '2025-09', value: 1525 },
  { month: '2025-10', value: 1600 },
  { month: '2025-11', value: 1680 },
  { month: '2025-12', value: 1760 },
];

const categoryDistribution = [
  { category: 'CO‚ÇÇ reduction', value: 42 },
  { category: 'Energy efficiency', value: 28 },
  { category: 'Waste diversion', value: 18 },
  { category: 'Water savings', value: 12 },
];

const projectLeaderboard: ProjectRow[] = [
  {
    key: 'p1',
    name: 'Green Data Center Optimization',
    owner: 'IT & Infrastructure',
    co2SavedKg: 12000,
    energySavedKwh: 8300,
    impactScore: 96,
    tags: ['Scope 2', 'Cloud', 'Efficiency'],
  },
  {
    key: 'p2',
    name: 'Smart Building Automation',
    owner: 'Facilities',
    co2SavedKg: 7800,
    energySavedKwh: 6200,
    impactScore: 92,
    tags: ['Scope 1', 'IoT'],
  },
  {
    key: 'p3',
    name: 'Remote Work Program',
    owner: 'HR',
    co2SavedKg: 5400,
    energySavedKwh: 2300,
    impactScore: 88,
    tags: ['Commuting', 'Culture'],
  },
  {
    key: 'p4',
    name: 'Waste-to-Value Initiative',
    owner: 'Operations',
    co2SavedKg: 3250,
    energySavedKwh: 520,
    impactScore: 84,
    tags: ['Circularity', 'Waste'],
  },
];

export default function SustainabilityDashboardPage(): JSX.Element {
  usePageTitle('KeenKonnect ¬∑ Sustainability Impact Dashboard');

  const [timeRange, setTimeRange] = useState<TimeRange>('6m');

  const filteredCo2Trend = useMemo(() => {
    if (timeRange === '3m') return co2TrendBase.slice(-3);
    if (timeRange === '6m') return co2TrendBase.slice(-6);
    return co2TrendBase;
  }, [timeRange]);

  const filteredEnergyTrend = useMemo(() => {
    if (timeRange === '3m') return energyTrendBase.slice(-3);
    if (timeRange === '6m') return energyTrendBase.slice(-6);
    return energyTrendBase;
  }, [timeRange]);

  // --- Configs graphiques @ant-design/plots (typed as any to keep TS relaxed) ---

  const co2LineConfig: any = {
    data: filteredCo2Trend,
    xField: 'month',
    yField: 'value',
    height: 260,
    smooth: true,
    xAxis: {
      label: {
        formatter: (v: string) => v.slice(5), // Affiche seulement le mois
      },
    },
    yAxis: {
      label: {
        formatter: (v: number) => `${v} kg`,
      },
    },
    tooltip: {
      formatter: (datum: { month: string; value: number }) => ({
        name: 'CO‚ÇÇ saved',
        value: `${datum.value.toLocaleString()} kg`,
      }),
    },
  };

  const energyAreaConfig: any = {
    data: filteredEnergyTrend,
    xField: 'month',
    yField: 'value',
    height: 260,
    smooth: true,
    xAxis: {
      label: {
        formatter: (v: string) => v.slice(5),
      },
    },
    yAxis: {
      label: {
        formatter: (v: number) => `${v} kWh`,
      },
    },
    areaStyle: {
      fillOpacity: 0.3,
    },
    tooltip: {
      formatter: (datum: { month: string; value: number }) => ({
        name: 'Energy saved',
        value: `${datum.value.toLocaleString()} kWh`,
      }),
    },
  };

  const categoryColumnConfig: any = {
    data: categoryDistribution,
    xField: 'category',
    yField: 'value',
    height: 260,
    columnStyle: {
      radius: [4, 4, 0, 0],
    },
    label: {
      position: 'middle' as const,
      formatter: (datum: { value: number }) => `${datum.value}%`,
    },
    tooltip: {
      formatter: (datum: { category: string; value: number }) => ({
        name: datum.category,
        value: `${datum.value}%`,
      }),
    },
  };

  // --- Tableau des projets ---

  const columns: ColumnsType<ProjectRow> = [
    {
      title: 'Project',
      dataIndex: 'name',
      key: 'name',
      ellipsis: true,
    },
    {
      title: 'Owner',
      dataIndex: 'owner',
      key: 'owner',
    },
    {
      title: 'CO‚ÇÇ saved (kg)',
      dataIndex: 'co2SavedKg',
      key: 'co2SavedKg',
      render: (value: number) => value.toLocaleString(),
    },
    {
      title: 'Energy saved (kWh)',
      dataIndex: 'energySavedKwh',
      key: 'energySavedKwh',
      render: (value: number) => value.toLocaleString(),
    },
    {
      title: 'Impact score',
      dataIndex: 'impactScore',
      key: 'impactScore',
      render: (value: number) => `${value}/100`,
    },
    {
      title: 'Tags',
      dataIndex: 'tags',
      key: 'tags',
      render: (tags: string[]) => (
        <>
          {tags.map((tag) => (
            <Tag key={tag}>{tag}</Tag>
          ))}
        </>
      ),
    },
  ];

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Sustainability Impact Dashboard</title>
      </Head>

      <div className="container mx-auto p-5">
        {/* Header align√© sur search-filter-documents */}
        <div className="mb-4 flex flex-wrap items-center justify-between gap-3">
          <div>
            <Title level={2} style={{ marginBottom: 4 }}>
              Sustainability Impact Dashboard
            </Title>
            <Paragraph type="secondary" style={{ marginBottom: 0 }}>
              High-level dashboard aggregating sustainability impact across KeenKonnect
              projects.
            </Paragraph>
          </div>

          <Space>
            <span>Time range:</span>
            <Select<TimeRange>
              size="small"
              value={timeRange}
              onChange={setTimeRange}
              options={[
                { label: 'Last 3 months', value: '3m' },
                { label: 'Last 6 months', value: '6m' },
                { label: 'Last 12 months', value: '12m' },
              ]}
              style={{ minWidth: 140 }}
            />
          </Space>
        </div>

        {/* KPIs principaux (4 stats) */}
        <Card className="mb-4">
          <Row gutter={[16, 16]}>
            <Col xs={12} md={6}>
              <Statistic
                title="Total CO‚ÇÇ saved"
                value={overviewStats.totalCo2SavedKg}
                suffix="kg"
              />
            </Col>
            <Col xs={12} md={6}>
              <Statistic
                title="Total energy saved"
                value={overviewStats.totalEnergySavedKwh}
                suffix="kWh"
              />
            </Col>
            <Col xs={12} md={6}>
              <Statistic
                title="Waste diverted"
                value={overviewStats.wasteDivertedKg}
                suffix="kg"
              />
            </Col>
            <Col xs={12} md={6}>
              <Statistic
                title="Active projects"
                value={overviewStats.activeProjects}
              />
            </Col>
          </Row>
        </Card>

        {/* Lignes / Colonnes principales */}
        <Row gutter={[16, 16]} className="mb-4">
          <Col xs={24} xl={16}>
            <Card title="Timeline of CO‚ÇÇ saved (kg)">
              <Line {...co2LineConfig} />
            </Card>
          </Col>

          <Col xs={24} xl={8}>
            <Card title="Impact category distribution">
              <Column {...categoryColumnConfig} />
            </Card>
          </Col>
        </Row>

        {/* Area + Leaderboard */}
        <Row gutter={[16, 16]}>
          <Col xs={24} xl={12}>
            <Card title="Energy savings trend (kWh)">
              <Area {...energyAreaConfig} />
            </Card>
          </Col>

          <Col xs={24} xl={12}>
            <Card title="Top projects by impact">
              <Table<ProjectRow>
                size="small"
                rowKey="key"
                columns={columns}
                dataSource={projectLeaderboard}
                pagination={false}
              />
            </Card>
          </Col>
        </Row>
      </div>
    </>
  );
}

===== END app/keenkonnect/sustainability-impact/sustainability-dashboard/page.tsx =====


===== BEGIN app/keenkonnect/sustainability-impact/track-project-impact/page.tsx =====
'use client'

import React, { Suspense, useState, useEffect, useMemo } from 'react'
import Head from 'next/head'
import {
  Row,
  Col,
  Card,
  DatePicker,
  Select,
  Spin,
  Tabs,
  Timeline,
  Descriptions,
  Empty,
} from 'antd'
import {
  PieChart,
  Pie,
  Cell,
  Tooltip as ReTooltip,
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
} from 'recharts'
import api from '@/api'
import dayjs from 'dayjs'

const { RangePicker } = DatePicker
const { TabPane } = Tabs

type ImpactItem = {
  category: string
  value: number
}

type Filters = {
  from: string
  to: string
  team?: string
}

const COLORS = ['#4e91ff', '#34c759', '#ff9f0a', '#ff375f', '#af52de']

export default function PageWrapper() {
  return (
    <Suspense fallback={<Spin style={{ marginTop: 40 }} />}>
      <Content />
    </Suspense>
  )
}

function Content(): JSX.Element {
  const [loading, setLoading] = useState(true)
  const [filters, setFilters] = useState<Filters>({
    from: dayjs().subtract(7, 'days').format('YYYY-MM-DD'),
    to: dayjs().format('YYYY-MM-DD'),
    team: undefined,
  })

  const [impactData, setImpactData] = useState<ImpactItem[]>([])

  useEffect(() => {
    const load = async () => {
      setLoading(true)
      try {
        const res = await api.get<ImpactItem[]>('/impact/sustainability/track', {
          params: {
            fromDate: filters.from,
            toDate: filters.to,
            team: filters.team,
          },
        })
        setImpactData(res ?? [])
      } catch (err) {
        console.error('Track impact load error:', err)
      } finally {
        setLoading(false)
      }
    }

    void load()
  }, [filters])

  const chartData = useMemo(
    () =>
      (impactData ?? []).map((item) => ({
        name: item.category,
        value: item.value,
      })),
    [impactData],
  )

  const totalImpact = useMemo(
    () => (impactData ?? []).reduce((sum, item) => sum + (item.value ?? 0), 0),
    [impactData],
  )

  const topCategory = useMemo(() => {
    if (!impactData || impactData.length === 0) return undefined

    // ImpactItem is guaranteed by the length check; use non-null assertion on index 0
    return impactData.reduce<ImpactItem>(
      (max, item) => (item.value > max.value ? item : max),
      impactData[0]!,
    )
  }, [impactData])

  if (loading) {
    return (
      <div style={{ textAlign: 'center', padding: 40 }}>
        <Spin size="large" />
      </div>
    )
  }

  const hasData = chartData.length > 0

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Track Project Impact</title>
      </Head>

      <h1 style={{ fontSize: 24, fontWeight: 600, marginBottom: 24 }}>
        Track Project Impact
      </h1>

      {/* Filtres principaux */}
      <Card style={{ marginBottom: 24 }}>
        <Row gutter={24}>
          <Col xs={24} md={12}>
            <RangePicker
              defaultValue={[dayjs(filters.from), dayjs(filters.to)]}
              style={{ width: '100%' }}
              onChange={(range) => {
                if (!range || !range[0] || !range[1]) return
                const [start, end] = range
                setFilters((f) => ({
                  ...f,
                  from: start.format('YYYY-MM-DD'),
                  to: end.format('YYYY-MM-DD'),
                }))
              }}
            />
          </Col>

          <Col xs={24} md={12}>
            <Select
              placeholder="Filter by team"
              style={{ width: '100%' }}
              allowClear
              value={filters.team}
              onChange={(value) =>
                setFilters((f) => ({
                  ...f,
                  team: value || undefined,
                }))
              }
              options={[
                { label: 'Team A', value: 'team-a' },
                { label: 'Team B', value: 'team-b' },
                { label: 'Team C', value: 'team-c' },
              ]}
            />
          </Col>
        </Row>
      </Card>

      {!hasData ? (
        <Card>
          <Empty description="No impact data for the selected filters" />
        </Card>
      ) : (
        <Tabs defaultActiveKey="overview">
          {/* === Onglet OVERVIEW : pie chart + Descriptions === */}
          <TabPane tab="Overview" key="overview">
            <Row gutter={[24, 24]}>
              <Col xs={24} md={14}>
                <Card title="Impact by Category">
                  <ResponsiveContainer width="100%" height={320}>
                    <PieChart>
                      <Pie
                        data={chartData}
                        dataKey="value"
                        nameKey="name"
                        cx="50%"
                        cy="50%"
                        outerRadius={110}
                      >
                        {chartData.map((_, i) => (
                          <Cell key={i} fill={COLORS[i % COLORS.length]} />
                        ))}
                      </Pie>
                      <ReTooltip />
                    </PieChart>
                  </ResponsiveContainer>
                </Card>
              </Col>

              <Col xs={24} md={10}>
                <Card title="Summary">
                  <Descriptions column={1} size="small" bordered>
                    <Descriptions.Item label="Total impact value">
                      {totalImpact}
                    </Descriptions.Item>
                    <Descriptions.Item label="Number of categories">
                      {impactData.length}
                    </Descriptions.Item>
                    <Descriptions.Item label="Top category">
                      {topCategory?.category ?? '‚Äî'}
                    </Descriptions.Item>
                    <Descriptions.Item label="Top category value">
                      {topCategory?.value ?? '‚Äî'}
                    </Descriptions.Item>
                  </Descriptions>
                </Card>
              </Col>
            </Row>
          </TabPane>

          {/* === Onglet TIMELINE : visualisation s√©quentielle === */}
          <TabPane tab="Timeline" key="timeline">
            <Card title="Impact Timeline">
              <Timeline>
                {impactData.map((item, index) => (
                  <Timeline.Item key={`${item.category}-${index}`}>
                    <div style={{ fontWeight: 500 }}>{item.category}</div>
                    <div style={{ color: '#666' }}>
                      Impact value: {item.value}
                    </div>
                  </Timeline.Item>
                ))}
              </Timeline>
            </Card>
          </TabPane>

          {/* === Onglet BREAKDOWN : bar chart + d√©tails compl√©mentaires === */}
          <TabPane tab="Category Breakdown" key="breakdown">
            <Row gutter={[24, 24]}>
              <Col xs={24} md={16}>
                <Card title="Impact by Category (Bar Chart)">
                  <ResponsiveContainer width="100%" height={320}>
                    <BarChart data={chartData}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="name" />
                      <YAxis />
                      <ReTooltip />
                      <Bar dataKey="value">
                        {chartData.map((_, index) => (
                          <Cell
                            key={index}
                            fill={COLORS[index % COLORS.length]}
                          />
                        ))}
                      </Bar>
                    </BarChart>
                  </ResponsiveContainer>
                </Card>
              </Col>

              <Col xs={24} md={8}>
                <Card title="Category Details">
                  <Descriptions column={1} size="small" bordered>
                    {impactData.map((item, index) => (
                      <Descriptions.Item
                        key={`${item.category}-${index}`}
                        label={item.category}
                      >
                        {item.value}
                      </Descriptions.Item>
                    ))}
                  </Descriptions>
                </Card>
              </Col>
            </Row>
          </TabPane>
        </Tabs>
      )}
    </>
  )
}

===== END app/keenkonnect/sustainability-impact/track-project-impact/page.tsx =====


===== BEGIN app/keenkonnect/user-reputation/account-preferences/page.tsx =====
Ôªø// app/keenkonnect/user-reputation/account-preferences/page.tsx
'use client';

import React, { useState } from 'react';
import {
  Tabs,
  Upload,
  Switch,
  Checkbox,
  Button,
  Modal,
  Radio,
  Form,
  Input,
  message as antdMessage,
} from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import { UploadOutlined } from '@ant-design/icons';
import { uploadUserAvatar } from '@/services/user';

const { TabPane } = Tabs;
const { TextArea } = Input;

type NotificationTypeValue =
  | 'team-invites'
  | 'project-matches'
  | 'reputation-updates'
  | 'comments-mentions';

type PrivacyShareValue = 'teams' | 'org' | 'public';

type ProfileFormValues = {
  name: string;
  headline?: string;
  email: string;
  bio?: string;
  avatar?: UploadFile[];
  discoverable?: boolean;
};

type SecurityFormValues = {
  currentPassword: string;
  newPassword: string;
  confirmNewPassword: string;
  twoFactorEnabled?: boolean;
  loginAlerts?: boolean;
};

type NotificationFormValues = {
  emailNotifications?: boolean;
  inAppNotifications?: boolean;
  notificationTypes: NotificationTypeValue[];
};

type PrivacyFormValues = {
  visibility: 'public' | 'private';
  shareReputationWith?: PrivacyShareValue[];
  showInSearch?: boolean;
};

const notificationEventOptions = [
  { label: 'Team invitations & join requests', value: 'team-invites' as const },
  { label: 'New project matches', value: 'project-matches' as const },
  {
    label: 'Reputation badges & level changes',
    value: 'reputation-updates' as const,
  },
  { label: 'Comments & mentions', value: 'comments-mentions' as const },
];

const privacySharingOptions = [
  { label: 'My teams & collaborators', value: 'teams' as const },
  { label: 'Organization admins', value: 'org' as const },
  { label: 'Everyone on KeenKonnect', value: 'public' as const },
];

// ‚úÖ Always return UploadFile[]
const normFile = (e: any): UploadFile[] => {
  if (Array.isArray(e)) {
    return e as UploadFile[];
  }
  return (e?.fileList ?? []) as UploadFile[];
};

export default function AccountPreferencesPage(): JSX.Element {
  const [isModalVisible, setIsModalVisible] = useState(false);

  // === Submit handlers =======================================================

  const onFinishProfile = async (values: ProfileFormValues) => {
    try {
      const avatarFile = values.avatar?.[0]?.originFileObj as
        | File
        | undefined;

      if (avatarFile) {
        await uploadUserAvatar(avatarFile);
      }

      // TODO: wire name / headline / bio to a real profile endpoint
      // when the backend fields are available.
      // eslint-disable-next-line no-console
      console.log('Profile info submitted:', values);

      antdMessage.success('Profile information updated successfully.');
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Failed to update profile', error);
      antdMessage.error(
        'Unable to update profile for now. Please try again later.',
      );
    }
  };

  const onFinishSecurity = (values: SecurityFormValues) => {
    // eslint-disable-next-line no-console
    console.log('Security settings submitted:', values);
    antdMessage.success('Security settings updated successfully.');
  };

  const onFinishNotifications = (values: NotificationFormValues) => {
    // eslint-disable-next-line no-console
    console.log('Notification settings submitted:', values);
    antdMessage.success('Notification preferences updated successfully.');
  };

  const onFinishPrivacy = (values: PrivacyFormValues) => {
    // eslint-disable-next-line no-console
    console.log('Privacy settings submitted:', values);
    antdMessage.success('Privacy preferences updated successfully.');
  };

  // === Danger zone modal =====================================================

  const showDeleteModal = () => {
    setIsModalVisible(true);
  };

  const handleDeleteCancel = () => {
    setIsModalVisible(false);
  };

  const handleDeleteConfirm = () => {
    // eslint-disable-next-line no-console
    console.log('Account deletion requested');
    antdMessage.success(
      'Account deletion requested. We will contact you shortly.',
    );
    setIsModalVisible(false);
  };

  return (
    <div className="container mx-auto p-5">
      <h1 className="text-2xl font-bold mb-4">Account &amp; Preferences</h1>

      <Tabs defaultActiveKey="profile">
        {/* ================= Profile Info ================= */}
        <TabPane tab="Profile Info" key="profile">
          <Form<ProfileFormValues>
            layout="vertical"
            onFinish={onFinishProfile}
            initialValues={{
              name: 'Jane Doe',
              email: 'jane.doe@example.com',
              discoverable: true,
            }}
          >
            <Form.Item
              name="name"
              label="Name"
              rules={[{ required: true, message: 'Please enter your name' }]}
            >
              <Input placeholder="Your display name on KeenKonnect" />
            </Form.Item>

            <Form.Item
              name="headline"
              label="Headline"
              tooltip="Short headline shown in suggestions and team matching."
            >
              <Input placeholder="Product leader, open to cross‚Äëteam collaboration" />
            </Form.Item>

            <Form.Item name="email" label="Email">
              <Input disabled />
            </Form.Item>

            <Form.Item
              name="bio"
              label="Short bio"
              tooltip="Explain how you like to work, preferred domains, or collaboration style."
            >
              <TextArea
                autoSize={{ minRows: 3, maxRows: 5 }}
                placeholder="Tell collaborators a bit about how you like to work."
              />
            </Form.Item>

            <Form.Item
              name="avatar"
              label="Profile picture"
              valuePropName="fileList"
              getValueFromEvent={normFile}
              extra="This picture is visible to collaborators across Ekoh & KeenKonnect."
            >
              <Upload
                name="avatar"
                listType="picture-card"
                maxCount={1}
                // We handle the upload on form submit
                beforeUpload={() => false}
              >
                <div>
                  <UploadOutlined />
                  <div style={{ marginTop: 8 }}>Upload</div>
                </div>
              </Upload>
            </Form.Item>

            <Form.Item
              name="discoverable"
              label="Profile discoverability"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Make my KeenKonnect profile discoverable in search & suggestions
                </span>
              </div>
            </Form.Item>

            <Form.Item>
              <Button type="primary" htmlType="submit">
                Save Profile
              </Button>
            </Form.Item>
          </Form>
        </TabPane>

        {/* ================= Security ===================== */}
        <TabPane tab="Security" key="security">
          <Form<SecurityFormValues>
            layout="vertical"
            onFinish={onFinishSecurity}
            initialValues={{
              loginAlerts: true,
            }}
          >
            <Form.Item
              name="currentPassword"
              label="Current password"
              rules={[
                { required: true, message: 'Please enter your current password' },
              ]}
            >
              <Input.Password />
            </Form.Item>

            <Form.Item
              name="newPassword"
              label="New password"
              rules={[
                { required: true, message: 'Please enter your new password' },
              ]}
            >
              <Input.Password />
            </Form.Item>

            <Form.Item
              name="confirmNewPassword"
              label="Confirm new password"
              dependencies={['newPassword']}
              rules={[
                { required: true, message: 'Please confirm your new password' },
                ({ getFieldValue }) => ({
                  validator(_, value) {
                    if (!value || getFieldValue('newPassword') === value) {
                      return Promise.resolve();
                    }
                    return Promise.reject(
                      new Error(
                        'The new password and confirmation do not match.',
                      ),
                    );
                  },
                }),
              ]}
            >
              <Input.Password />
            </Form.Item>

            <Form.Item
              name="twoFactorEnabled"
              label="Two‚Äëfactor authentication"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Require a second step when signing in from a new device
                </span>
              </div>
            </Form.Item>

            <Form.Item
              name="loginAlerts"
              label="Login alerts"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Send me an alert when my account is accessed from a new location
                </span>
              </div>
            </Form.Item>

            <Form.Item>
              <Button type="primary" htmlType="submit">
                Save Security Settings
              </Button>
            </Form.Item>
          </Form>
        </TabPane>

        {/* ================= Notifications ================= */}
        <TabPane tab="Notifications" key="notifications">
          <Form<NotificationFormValues>
            layout="vertical"
            onFinish={onFinishNotifications}
            initialValues={{
              emailNotifications: true,
              inAppNotifications: true,
              notificationTypes: ['team-invites', 'reputation-updates'],
            }}
          >
            <Form.Item
              name="emailNotifications"
              label="Email notifications"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Receive important updates by email
                </span>
              </div>
            </Form.Item>

            <Form.Item
              name="inAppNotifications"
              label="In‚Äëapp notifications"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Show notifications inside Ekoh & KeenKonnect
                </span>
              </div>
            </Form.Item>

            <Form.Item
              name="notificationTypes"
              label="Notify me about"
              rules={[
                {
                  required: true,
                  message: 'Select at least one type of notification',
                },
              ]}
            >
              <Checkbox.Group options={notificationEventOptions} />
            </Form.Item>

            <Form.Item>
              <Button type="primary" htmlType="submit">
                Save Notification Settings
              </Button>
            </Form.Item>
          </Form>
        </TabPane>

        {/* ================= Privacy ======================= */}
        <TabPane tab="Privacy" key="privacy">
          <Form<PrivacyFormValues>
            layout="vertical"
            onFinish={onFinishPrivacy}
            initialValues={{
              visibility: 'public',
              shareReputationWith: ['teams', 'org'],
              showInSearch: true,
            }}
          >
            <Form.Item name="visibility" label="Profile visibility">
              <Radio.Group>
                <Radio value="public">
                  Public ‚Äì visible to all KeenKonnect users
                </Radio>
                <Radio value="private">
                  Private ‚Äì only visible to you
                </Radio>
              </Radio.Group>
            </Form.Item>

            <Form.Item
              name="shareReputationWith"
              label="Share my reputation details with"
            >
              <Checkbox.Group options={privacySharingOptions} />
            </Form.Item>

            <Form.Item
              name="showInSearch"
              label="Search visibility"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Allow my profile to appear in team matching & collaborator search
                </span>
              </div>
            </Form.Item>

            <Form.Item>
              <Button type="primary" htmlType="submit">
                Save Privacy Settings
              </Button>
            </Form.Item>
          </Form>
        </TabPane>

        {/* ================= Danger Zone =================== */}
        <TabPane tab="Danger Zone" key="danger">
          <div
            style={{
              border: '1px solid #ffccc7',
              borderRadius: 8,
              padding: 24,
              background: '#fff1f0',
            }}
          >
            <h3 style={{ color: '#cf1322', marginBottom: 8 }}>Delete Account</h3>
            <p style={{ marginBottom: 16 }}>
              Deleting your account will permanently remove your KeenKonnect profile,
              reputation data and collaboration history. This action cannot be undone.
            </p>
            <Button danger type="primary" onClick={showDeleteModal}>
              Delete my account
            </Button>

            <Modal
              title="Confirm Account Deletion"
              open={isModalVisible}
              okText="Yes, delete my account"
              okButtonProps={{ danger: true }}
              onOk={handleDeleteConfirm}
              onCancel={handleDeleteCancel}
            >
              <p>
                Are you sure you want to delete your account? This will remove your
                KeenKonnect profile and unlink your reputation from any teams.
              </p>
            </Modal>
          </div>
        </TabPane>
      </Tabs>
    </div>
  );
}

===== END app/keenkonnect/user-reputation/account-preferences/page.tsx =====


===== BEGIN app/keenkonnect/user-reputation/manage-expertise-areas/page.tsx =====
Ôªø'use client';

import React, { useMemo, useState } from 'react';
import { Form, Alert, Divider, Typography, List, Tag, Rate, Space } from 'antd';
import { ProForm, ProFormSelect } from '@ant-design/pro-components';
import PageContainer from '@/components/PageContainer';

const { Text, Paragraph } = Typography;
const { CheckableTag } = Tag;

type Visibility = 'public' | 'team-only' | 'private';

type FormValues = {
  currentExpertise: string[];
  newFields?: string[];
  visibility: Visibility;
};

interface ExpertiseItem {
  key: string;
  label: string;
  description: string;
  defaultLevel: number; // 1‚Äì5, for Rate
}

// Catalogue d‚Äôexpertises disponibles dans KeenKonnect
const EXPERTISE_CATALOG: ExpertiseItem[] = [
  {
    key: 'frontend',
    label: 'Frontend Development',
    description:
      'React, TypeScript, modern component patterns and design systems.',
    defaultLevel: 4.5,
  },
  {
    key: 'backend',
    label: 'Backend Development',
    description:
      'APIs, microservices, Node.js / Python, data modelling & reliability.',
    defaultLevel: 4,
  },
  {
    key: 'uiux',
    label: 'UI/UX Design',
    description:
      'User journeys, wireframes, interactive prototypes, design systems.',
    defaultLevel: 4.5,
  },
  {
    key: 'data-science',
    label: 'Data Science',
    description:
      'Exploratory analysis, ML models, dashboards, decision support.',
    defaultLevel: 3.5,
  },
  {
    key: 'devops',
    label: 'DevOps',
    description:
      'CI/CD, observability, infrastructure-as-code, cloud environments.',
    defaultLevel: 3.5,
  },
  {
    key: 'mobile',
    label: 'Mobile Development',
    description:
      'Native & cross‚Äëplatform apps, performance and offline patterns.',
    defaultLevel: 3,
  },
  {
    key: 'qa',
    label: 'QA',
    description: 'Testing strategy, automation, regression & release quality.',
    defaultLevel: 3.5,
  },
  {
    key: 'pm',
    label: 'Project Management',
    description:
      'Roadmapping, stakeholder alignment, agile delivery and rituals.',
    defaultLevel: 4,
  },
];

const CURRENT_EXPERTISE_INITIAL: string[] = [
  'Frontend Development',
  'UI/UX Design',
];

const SELECTABLE_FIELDS: string[] = [
  'React',
  'Next.js',
  'TypeScript',
  'Figma',
  'GraphQL',
  'Node.js',
  'Cypress',
  'Jest',
];

const VISIBILITY_OPTIONS = [
  { label: 'Public', value: 'public' as const },
  { label: 'Team only', value: 'team-only' as const },
  { label: 'Private', value: 'private' as const },
];

export default function ManageExpertiseAreasPage(): JSX.Element {
  const [form] = Form.useForm<FormValues>();

  // Gestion interne de la s√©lection via Tag.CheckableTag
  const [selectedTags, setSelectedTags] = useState<string[]>(
    CURRENT_EXPERTISE_INITIAL,
  );

  // Liste pour l‚Äôaper√ßu (List + Rate) bas√©e sur les tags s√©lectionn√©s
  const previewExpertise = useMemo(
    () => EXPERTISE_CATALOG.filter((item) => selectedTags.includes(item.label)),
    [selectedTags],
  );

  const handleTagChange = (label: string, checked: boolean) => {
    const nextSelected = checked
      ? Array.from(new Set([...selectedTags, label]))
      : selectedTags.filter((tag) => tag !== label);

    setSelectedTags(nextSelected);
    form.setFieldsValue({ currentExpertise: nextSelected });
  };

  const handleFinish = async (values: FormValues): Promise<boolean> => {
    // Stub : √† brancher sur l‚ÄôAPI de profil / Ekoh plus tard
    // eslint-disable-next-line no-console
    console.log('Manage Expertise Areas ‚Äì submit:', values);
    return true;
  };

  return (
    <PageContainer title="Manage Expertise Areas">
      {/* ‚úÖ description moved inside instead of using a PageContainer prop */}
      <Paragraph type="secondary" style={{ marginBottom: 16 }}>
        Declare and fine‚Äëtune the expertise areas used by Ekoh, KeenKonnect
        matching, and Smart Vote.
      </Paragraph>

      <Divider orientation="left">Your expertise profile</Divider>

      <Alert
        type="info"
        showIcon
        style={{ marginBottom: 16 }}
        message="Your declared expertise influences Ekoh reputation, KeenKonnect matching, and Smart Vote weight."
      />

      {/* Formulaire principal avec ProForm + ProFormSelect */}
      <ProForm<FormValues>
        form={form}
        layout="vertical"
        initialValues={{
          currentExpertise: CURRENT_EXPERTISE_INITIAL,
          visibility: 'team-only',
          newFields: [],
        }}
        submitter={{
          searchConfig: {
            submitText: 'Save Changes',
          },
          render: (_, dom) => <div style={{ marginTop: 16 }}>{dom}</div>,
        }}
        onFinish={handleFinish}
      >
        {/* S√©lection des expertises actuelles via Tag.CheckableTag */}
        <Form.Item
          name="currentExpertise"
          label="Current expertise areas"
          rules={[
            {
              required: true,
              message: 'Please select at least one expertise area.',
            },
          ]}
        >
          <div style={{ marginBottom: 8 }}>
            {EXPERTISE_CATALOG.map((item) => (
              <CheckableTag
                key={item.key}
                checked={selectedTags.includes(item.label)}
                onChange={(checked) => handleTagChange(item.label, checked)}
                style={{ marginBottom: 8 }}
              >
                {item.label}
              </CheckableTag>
            ))}
          </div>
        </Form.Item>

        {/* ProFormSelect pour affiner / ajouter des champs pr√©cis */}
        <ProFormSelect
          name="newFields"
          label="Add or refine fields (optional)"
          mode="multiple"
          placeholder="Select specific technologies, tools, or domains"
          allowClear
          options={SELECTABLE_FIELDS.map((field) => ({
            label: field,
            value: field,
          }))}
        />

        {/* ProFormSelect pour la visibilit√© du profil d‚Äôexpertise */}
        <ProFormSelect
          name="visibility"
          label="Visibility of your expertise"
          placeholder="Choose who can view your expertise profile"
          options={VISIBILITY_OPTIONS}
          rules={[
            {
              required: true,
              message: 'Please choose a visibility level.',
            },
          ]}
        />

        <Alert
          style={{ marginTop: 16 }}
          type="info"
          showIcon
          message="Note: New expertise or fields may need validation through activity and peer endorsements before they impact your Ekoh score."
        />
      </ProForm>

      <Divider orientation="left">Preview: how others see your expertise</Divider>

      {/* Aper√ßu des domaines s√©lectionn√©s via List + Rate */}
      <List
        bordered
        itemLayout="vertical"
        dataSource={previewExpertise}
        locale={{
          emptyText:
            'Select at least one expertise area above to see the preview.',
        }}
        renderItem={(item) => (
          <List.Item key={item.key}>
            <List.Item.Meta
              title={
                <Space>
                  <Text strong>{item.label}</Text>
                  <Tag color="blue">Core expertise</Tag>
                </Space>
              }
              description={item.description}
            />
            <div>
              <Text type="secondary" style={{ marginRight: 8 }}>
                Typical expertise level
              </Text>
              {/* Rate utilis√© ici en lecture seule pour l‚Äôaper√ßu */}
              <Rate allowHalf disabled defaultValue={item.defaultLevel} />
            </div>
          </List.Item>
        )}
      />
    </PageContainer>
  );
}

===== END app/keenkonnect/user-reputation/manage-expertise-areas/page.tsx =====


===== BEGIN app/keenkonnect/user-reputation/view-reputation-ekoh/page.tsx =====
// app/keenkonnect/user-reputation/view-reputation-ekoh/page.tsx
'use client';

import React, { type ReactNode } from 'react';
import Head from 'next/head';
import {
  Avatar,
  Card,
  Descriptions,
  Timeline,
  List,
  Tag,
  Typography,
  Space,
  Row,
  Col,
  Spin,
  Alert,
} from 'antd';
import {
  StarFilled,
  ThunderboltOutlined,
  ExperimentOutlined,
  TeamOutlined,
} from '@ant-design/icons';
import usePageTitle from '@/hooks/usePageTitle';
import useReputationEvents from '@/hooks/useReputationEvents';

const { Title, Text } = Typography;

type ExpertiseArea = {
  id: string;
  label: string;
  domain: string;
  level: 'core' | 'supporting';
};

/**
 * Static placeholder until we have a real "expertise from Ekoh" API.
 * This only affects the lower section ‚Äì the core score/timeline/badges
 * now come from the backend.
 */
const expertiseAreas: ExpertiseArea[] = [
  {
    id: 'exp-1',
    label: 'Sustainable product roadmapping',
    domain: 'Sustainability',
    level: 'core',
  },
  {
    id: 'exp-2',
    label: 'Experimentation & A/B testing',
    domain: 'Product Strategy',
    level: 'core',
  },
  {
    id: 'exp-3',
    label: 'AI fairness & guardrails',
    domain: 'AI Ethics',
    level: 'supporting',
  },
];

/**
 * Badge metadata for visual display, keyed by backend badge id.
 * Back-end provides: id, label, description, earnedAt.
 * Here we attach category, color and icon for the UI.
 */
const BADGE_META: Record<
  string,
  { icon: ReactNode; color: string; category: string }
> = {
  'first-stance': {
    icon: <TeamOutlined />,
    color: 'green',
    category: 'Participation',
  },
  'argument-builder': {
    icon: <ExperimentOutlined />,
    color: 'geekblue',
    category: 'Depth',
  },
  'active-voter': {
    icon: <ThunderboltOutlined />,
    color: 'volcano',
    category: 'Voting',
  },
};

export default function ViewReputationEkohPage(): JSX.Element {
  usePageTitle('KeenKonnect ¬∑ Ekoh reputation');

  const { data, isLoading, isError, error } = useReputationEvents();

  const profile = data?.profile;
  const timeline = data?.timeline ?? [];
  const rawBadges = data?.badges ?? [];

  // High-level numbers derived from Ekoh profile
  const ekohScore = profile?.score ?? 0;

  const influenceDimension = profile?.dimensions.find(
    (d) => d.key === 'influence',
  );

  // Simple, explicit mapping from influence index (0‚Äì100) to a weight multiplier
  const smartVoteWeight =
    influenceDimension != null
      ? Number((1 + influenceDimension.score / 50).toFixed(1))
      : 1.0;

  // Aggregated interaction index ‚Äì not a literal count, but a readable big number
  const totalInteractions =
    profile != null ? Math.max(ekohScore, 0) : 0;

  const tierLabel =
    profile?.level === 'Steward'
      ? 'Trusted steward'
      : profile?.level === 'Contributor'
      ? 'Active contributor'
      : profile?.level === 'Visitor'
      ? 'New voice'
      : 'Not initialized yet';

  const badges = rawBadges.map((b) => {
    const meta =
      BADGE_META[b.id] ?? {
        icon: <StarFilled />,
        color: 'default',
        category: 'Reputation',
      };
    return { ...b, ...meta };
  });

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Ekoh reputation</title>
      </Head>

      <div className="container mx-auto p-5">
        {/* Page header */}
        <header className="mb-6">
          <h1 className="text-2xl font-bold mb-1">Ekoh reputation</h1>
          <p className="text-gray-500">
            How your Ekoh trust &amp; expertise are used inside KeenKonnect.
          </p>
        </header>

        {/* Loading / error states for the reputation fetch */}
        {isLoading && (
          <div className="mb-4">
            <Spin />
          </div>
        )}

        {isError && (
          <div className="mb-4">
            <Alert
              type="error"
              message="Unable to load Ekoh reputation"
              description={
                (error as Error | undefined)?.message ??
                'Please try again in a moment.'
              }
            />
          </div>
        )}

        {/* Main two-column layout: summary + timeline */}
        <Row gutter={[24, 24]}>
          {/* Left: profile + summary card */}
          <Col xs={24} lg={8}>
            <Card>
              <Space
                direction="vertical"
                align="center"
                style={{ width: '100%' }}
              >
                <Avatar
                  size={80}
                  style={{
                    backgroundColor: '#1e6864',
                    color: '#ffffff',
                  }}
                >
                  EK
                </Avatar>

                <div style={{ textAlign: 'center' }}>
                  <Title level={4} style={{ marginBottom: 4 }}>
                    Ekoh profile signal
                  </Title>
                  <Text type="secondary">
                    Imported reputation used for matching &amp; project discovery
                    in KeenKonnect.
                  </Text>
                </div>
              </Space>

              <Descriptions
                size="small"
                column={1}
                style={{ marginTop: 24 }}
                labelStyle={{ width: 160 }}
              >
                <Descriptions.Item label="Ekoh score">
                  <Text strong>{ekohScore}</Text>
                </Descriptions.Item>

                <Descriptions.Item label="Smart vote weight">
                  <Text strong>{smartVoteWeight.toFixed(1)}√ó</Text>{' '}
                  <Text type="secondary">(relative influence index)</Text>
                </Descriptions.Item>

                <Descriptions.Item label="Tier">
                  <Tag color="blue">{tierLabel}</Tag>
                </Descriptions.Item>

                <Descriptions.Item label="Last sync from Ekoh">
                  <Text type="secondary">
                    Based on your recent Ethikos &amp; KonnectED activity.
                  </Text>
                </Descriptions.Item>
              </Descriptions>
            </Card>
          </Col>

          {/* Right: big stats + timeline */}
          <Col xs={24} lg={16}>
            {/* 3-number summary */}
            <Card className="mb-4">
              <Row gutter={[16, 16]}>
                <Col xs={24} md={8}>
                  <Space direction="vertical">
                    <Text type="secondary">Global Ekoh score</Text>
                    <Title level={3} style={{ margin: 0 }}>
                      {ekohScore}
                    </Title>
                    <Text type="secondary">
                      Used as a global trust signal across all KeenKonnect
                      workspaces.
                    </Text>
                  </Space>
                </Col>

                <Col xs={24} md={8}>
                  <Space direction="vertical">
                    <Text type="secondary">Smart vote weight</Text>
                    <Title level={3} style={{ margin: 0 }}>
                      {smartVoteWeight.toFixed(1)}√ó
                    </Title>
                    <Text type="secondary">
                      Your votes weigh more when teams use Ekoh-backed
                      decisions.
                    </Text>
                  </Space>
                </Col>

                <Col xs={24} md={8}>
                  <Space direction="vertical">
                    <Text type="secondary">
                      Validated interactions (index)
                    </Text>
                    <Title level={3} style={{ margin: 0 }}>
                      {totalInteractions}
                    </Title>
                    <Text type="secondary">
                      Aggregated indicator based on your contributions and
                      votes.
                    </Text>
                  </Space>
                </Col>
              </Row>
            </Card>

            {/* Timeline from backend-derived events */}
            <Card title="Reputation timeline">
              <Timeline
                mode="left"
                items={timeline.map((item) => ({
                  key: item.id,
                  label: item.when,
                  children: (
                    <div>
                      <Text strong>{item.title}</Text>
                      <div>
                        <Text type="secondary">{item.detail}</Text>
                      </div>
                    </div>
                  ),
                }))}
              />
            </Card>
          </Col>
        </Row>

        {/* Expertise section (still static for now) */}
        <Card
          title="Expertise imported from Ekoh"
          className="mt-6"
        >
          <List
            size="small"
            dataSource={expertiseAreas}
            renderItem={(area) => (
              <List.Item key={area.id}>
                <Space direction="vertical" style={{ width: '100%' }}>
                  <Space>
                    <Tag color={area.level === 'core' ? 'geekblue' : 'default'}>
                      {area.level === 'core' ? 'Core domain' : 'Supporting'}
                    </Tag>
                    <Text strong>{area.label}</Text>
                  </Space>
                  <Text type="secondary">
                    Domain:{' '}
                    <Text type="secondary" strong>
                      {area.domain}
                    </Text>{' '}
                    ‚Äì used for project matching &amp; workspace
                    recommendations.
                  </Text>
                </Space>
              </List.Item>
            )}
          />
        </Card>

        {/* Badges mapped from backend -> visual cards */}
        <Card
          title="Badges & achievements from Ekoh"
          extra={
            <Text type="secondary">
              Displayed in KeenKonnect when teams browse your profile.
            </Text>
          }
          className="mt-6"
        >
          <List
            grid={{ gutter: 16, xs: 1, sm: 2, md: 3 }}
            dataSource={badges}
            renderItem={(badge) => (
              <List.Item key={badge.id}>
                <Card hoverable>
                  <Space align="start">
                    <Avatar
                      shape="square"
                      size={40}
                      style={{
                        backgroundColor: 'var(--ant-color-primary-bg)',
                      }}
                      icon={badge.icon}
                    />
                    <div>
                      <Space style={{ marginBottom: 4 }}>
                        <Text strong>{badge.label}</Text>
                        <Tag color={badge.color}>{badge.category}</Tag>
                      </Space>
                      <Text type="secondary">{badge.description}</Text>
                    </div>
                  </Space>
                </Card>
              </List.Item>
            )}
          />
        </Card>
      </div>
    </>
  );
}

===== END app/keenkonnect/user-reputation/view-reputation-ekoh/page.tsx =====


===== BEGIN app/keenkonnect/workspaces/browse-available-workspaces/page.tsx =====
// File: app/keenkonnect/workspaces/browse-available-workspaces/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import {
  List,
  Card,
  Input,
  Select,
  Button,
  Row,
  Col,
  Pagination,
  Divider,
  Tag,
  Typography,
  Tabs,
  Avatar,
  Space,
  Badge,
} from 'antd';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Search } = Input;
const { Text } = Typography;

type WorkspaceCategory = 'focus' | 'collaboration' | 'creative' | 'innovation';

interface Workspace {
  id: string;
  name: string;
  owner: string;
  purpose: string;
  tools: string[];
  category: WorkspaceCategory;
  currentUsers: number;
  lastActive: string;
  isJoinable: boolean;
  participants: string[];
}

const sampleWorkspaces: Workspace[] = [
  {
    id: '1',
    name: 'Data Science Hub',
    owner: 'Alice',
    purpose: 'Collaborative workspace for data analysis and machine learning projects.',
    tools: ['Data Science Notebook', 'Python'],
    category: 'focus',
    currentUsers: 10,
    lastActive: '2023-09-06 10:00',
    isJoinable: true,
    participants: ['Alice', 'Noah', 'Luc'],
  },
  {
    id: '2',
    name: 'VR Collaboration Space',
    owner: 'Bob',
    purpose: 'Virtual reality space for immersive teamwork.',
    tools: ['VR', '3D Modeling'],
    category: 'collaboration',
    currentUsers: 5,
    lastActive: '2023-09-06 09:30',
    isJoinable: false,
    participants: ['Bob', 'Ravi'],
  },
  {
    id: '3',
    name: 'Programming Lab',
    owner: 'Charlie',
    purpose: 'Workspace for coding projects and software development.',
    tools: ['Programming', 'Collaboration Tools'],
    category: 'focus',
    currentUsers: 8,
    lastActive: '2023-09-06 11:15',
    isJoinable: true,
    participants: ['Charlie', 'Mia', 'Jon'],
  },
  {
    id: '4',
    name: 'Design Studio',
    owner: 'Diana',
    purpose: 'Creative space for design brainstorming and UI/UX work.',
    tools: ['Design Tools', 'Whiteboard'],
    category: 'creative',
    currentUsers: 3,
    lastActive: '2023-09-06 08:45',
    isJoinable: true,
    participants: ['Diana', 'Lea'],
  },
  {
    id: '5',
    name: 'Innovators Room',
    owner: 'Edward',
    purpose: 'Workspace for innovative projects and ideation.',
    tools: ['Brainstorming', 'Prototyping'],
    category: 'innovation',
    currentUsers: 12,
    lastActive: '2023-09-06 10:30',
    isJoinable: false,
    participants: ['Edward', 'Sara', 'Tom', 'Yasmin'],
  },
];

const workspaceTabs = [
  { key: 'all', label: 'All Workspaces' },
  { key: 'focus', label: 'Focus Pods' },
  { key: 'collaboration', label: 'Collaboration Spaces' },
  { key: 'creative', label: 'Creative Studios' },
  { key: 'innovation', label: 'Innovation Labs' },
];

export default function BrowseAvailableWorkspaces(): JSX.Element {
  const router = useRouter();

  const [searchText, setSearchText] = useState('');
  const [selectedTool, setSelectedTool] = useState<string>('All');
  const [activeTab, setActiveTab] = useState<string>('all');
  const [currentPage, setCurrentPage] = useState(1);
  const pageSize = 4;

  const filteredWorkspaces = useMemo(() => {
    const lowerSearch = searchText.toLowerCase();

    return sampleWorkspaces.filter((workspace) => {
      const matchesTab =
        activeTab === 'all' ||
        workspace.category === (activeTab as WorkspaceCategory);

      const matchesSearch =
        !lowerSearch ||
        workspace.name.toLowerCase().includes(lowerSearch) ||
        workspace.purpose.toLowerCase().includes(lowerSearch);

      const matchesTool =
        selectedTool === 'All' || workspace.tools.includes(selectedTool);

      return matchesTab && matchesSearch && matchesTool;
    });
  }, [searchText, selectedTool, activeTab]);

  const paginatedWorkspaces = useMemo(() => {
    const startIndex = (currentPage - 1) * pageSize;
    return filteredWorkspaces.slice(startIndex, startIndex + pageSize);
  }, [filteredWorkspaces, currentPage, pageSize]);

  const handleJoinAction = (workspace: Workspace) => {
    if (workspace.isJoinable) {
      router.push(`/keenkonnect/workspaces/join?id=${workspace.id}`);
    } else {
      router.push(`/keenkonnect/workspaces/request-access?id=${workspace.id}`);
    }
  };

  const handleTabChange = (key: string) => {
    setActiveTab(key);
    setCurrentPage(1);
  };

  return (
    <PageContainer title="Browse Available Workspaces">
      {/* Top-right CTA (inside page content for consistency) */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'flex-end',
          marginBottom: 16,
        }}
      >
        <Button
          type="primary"
          onClick={() =>
            router.push('/keenkonnect/workspaces/launch-new-workspace')
          }
        >
          Launch New Workspace
        </Button>
      </div>

      {/* Search & filters */}
      <Row gutter={[16, 16]} style={{ marginBottom: 16 }}>
        <Col xs={24} sm={12}>
          <Search
            placeholder="Search workspaces"
            allowClear
            onSearch={(value) => {
              setSearchText(value);
              setCurrentPage(1);
            }}
          />
        </Col>
        <Col xs={24} sm={12}>
          <Select
            value={selectedTool}
            style={{ width: '100%' }}
            onChange={(value: string) => {
              setSelectedTool(value);
              setCurrentPage(1);
            }}
            options={[
              { value: 'All', label: 'All Tools' },
              { value: 'Data Science Notebook', label: 'Data Science Notebook' },
              { value: 'VR', label: 'VR' },
              { value: 'Programming', label: 'Programming' },
              { value: 'Design Tools', label: 'Design Tools' },
              { value: '3D Modeling', label: '3D Modeling' },
              { value: 'Whiteboard', label: 'Whiteboard' },
              { value: 'Brainstorming', label: 'Brainstorming' },
              { value: 'Prototyping', label: 'Prototyping' },
            ]}
          />
        </Col>
      </Row>

      {/* Category tabs */}
      <Tabs
        items={workspaceTabs}
        activeKey={activeTab}
        onChange={handleTabChange}
        style={{ marginBottom: 16 }}
      />

      <Divider />

      {/* Workspaces list */}
      <List
        grid={{ gutter: 16, xs: 1, sm: 2, md: 3, lg: 3 }}
        dataSource={paginatedWorkspaces}
        renderItem={(workspace: Workspace) => (
          <List.Item key={workspace.id}>
            <Card
              hoverable
              title={workspace.name}
              extra={
                <Space size="small">
                  <Text type="secondary">Host: {workspace.owner}</Text>
                  <Badge
                    status={workspace.isJoinable ? 'success' : 'warning'}
                    text={workspace.isJoinable ? 'Joinable' : 'Request only'}
                  />
                </Space>
              }
              actions={[
                <Button
                  key="join"
                  type="primary"
                  onClick={() => handleJoinAction(workspace)}
                >
                  {workspace.isJoinable ? 'Join' : 'Request Access'}
                </Button>,
              ]}
            >
              <Space direction="vertical" style={{ width: '100%' }}>
                <Text>{workspace.purpose}</Text>

                <Space wrap>
                  <Tag color="blue">{workspace.category.toUpperCase()}</Tag>
                  {workspace.tools.map((tool) => (
                    <Tag key={tool}>{tool}</Tag>
                  ))}
                </Space>

                <Divider style={{ margin: '12px 0' }} />

                <Row justify="space-between" align="middle">
                  <Col>
                    <Space direction="vertical" size={0}>
                      <Text type="secondary">Currently online</Text>
                      <Tag color="geekblue">
                        {workspace.currentUsers} users
                      </Tag>
                    </Space>
                  </Col>
                  <Col>
                    <Space
                      direction="vertical"
                      size={0}
                      style={{ textAlign: 'right' }}
                    >
                      <Text type="secondary">Last active</Text>
                      <Text>{workspace.lastActive}</Text>
                    </Space>
                  </Col>
                </Row>

                <Divider style={{ margin: '12px 0' }} />

                {/* Avatar.Group showing sample participants */}
                <Space direction="vertical" size={4}>
                  <Text type="secondary">Active collaborators</Text>
                  <Avatar.Group maxCount={3}>
                    {workspace.participants.map((name) => (
                      <Avatar key={name}>
                        {name.charAt(0).toUpperCase()}
                      </Avatar>
                    ))}
                  </Avatar.Group>
                </Space>
              </Space>
            </Card>
          </List.Item>
        )}
      />

      <Row justify="center" style={{ marginTop: 24 }}>
        <Pagination
          current={currentPage}
          pageSize={pageSize}
          total={filteredWorkspaces.length}
          onChange={(page) => setCurrentPage(page)}
        />
      </Row>
    </PageContainer>
  );
}

===== END app/keenkonnect/workspaces/browse-available-workspaces/page.tsx =====


===== BEGIN app/keenkonnect/workspaces/launch-new-workspace/page.tsx =====
'use client';

import React, { Suspense, useState } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/navigation';
import { Card, Result, Button, message } from 'antd';
import {
  ProForm,
  ProFormText,
  ProFormSelect,
  ProFormSwitch,
} from '@ant-design/pro-components';
import api from '@/api';

type LaunchWorkspaceFormValues = {
  name: string;
  team: string;
  tools: string[];
  isPublic: boolean;
};

function Content() {
  const router = useRouter();
  const [submitted, setSubmitted] = useState(false);
  const [lastValues, setLastValues] = useState<LaunchWorkspaceFormValues | null>(null);

  const handleFinish = async (values: LaunchWorkspaceFormValues) => {
    try {
      await api.post('/workspaces/launch', values);
      setLastValues(values);
      setSubmitted(true);
      return true;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error(error);
      message.error("√âchec du lancement de l'espace de travail. Veuillez r√©essayer.");
      return false;
    }
  };

  const handleLaunchAnother = () => {
    setSubmitted(false);
    setLastValues(null);
  };

  const pageTitle = 'Launch a New Workspace';
  const pageDescription =
    "Configurez un nouvel espace de travail collaboratif pour votre √©quipe : choisissez l‚Äô√©quipe responsable, les outils inclus et la visibilit√© de l‚Äôespace.";

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Launch New Workspace</title>
      </Head>

      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-4">{pageTitle}</h1>
        <p className="text-gray-500 mb-6">{pageDescription}</p>

        <Card>
          {submitted && lastValues ? (
            <Result
              status="success"
              title="Espace de travail lanc√© avec succ√®s"
              subTitle={`L'espace ¬´ ${lastValues.name} ¬ª est maintenant pr√™t pour votre √©quipe.`}
              extra={[
                <Button type="primary" key="again" onClick={handleLaunchAnother}>
                  Lancer un autre espace
                </Button>,
                <Button
                  key="workspaces"
                  onClick={() => router.push('/keenkonnect/workspaces/my-workspaces')}
                >
                  Voir mes espaces de travail
                </Button>,
              ]}
            />
          ) : (
            <ProForm<LaunchWorkspaceFormValues>
              layout="vertical"
              onFinish={handleFinish}
              initialValues={{
                isPublic: true,
              }}
              submitter={{
                searchConfig: {
                  submitText: "Lancer l'espace",
                },
              }}
            >
              {/* Nom de l‚Äôespace */}
              <ProFormText
                name="name"
                label="Nom de l‚Äôespace de travail"
                placeholder="ex. KeenKonnect Quantum Strategy Lab"
                rules={[
                  { required: true, message: 'Veuillez donner un nom √† cet espace.' },
                ]}
              />

              {/* √âquipe responsable */}
              <ProFormSelect
                name="team"
                label="√âquipe responsable"
                placeholder="S√©lectionnez une √©quipe"
                options={[
                  { label: 'Team Alpha ‚Äì Strategic Vision', value: 'Team Alpha' },
                  { label: 'Team Beta ‚Äì Quantum Strategists', value: 'Team Beta' },
                  { label: 'Team Gamma ‚Äì Innovation Pod', value: 'Team Gamma' },
                  { label: 'Special Guests ‚Äì Invited Fellows', value: 'Special Guests' },
                ]}
                rules={[
                  {
                    required: true,
                    message: 'Veuillez s√©lectionner une √©quipe responsable.',
                  },
                ]}
              />

              {/* Outils & environnements (multi‚Äëselect) */}
              <ProFormSelect
                name="tools"
                label="Outils & environnements inclus"
                placeholder="Choisissez un ou plusieurs environnements"
                fieldProps={{
                  mode: 'multiple',
                }}
                options={[
                  { label: 'Data Science Notebook', value: 'Data Science Notebook' },
                  { label: 'VR Lab', value: 'VR Lab' },
                  { label: 'Programming Workspace', value: 'Programming Workspace' },
                  { label: 'Design Studio', value: 'Design Studio' },
                  { label: '3D Modeling', value: '3D Modeling' },
                  { label: 'Virtual Whiteboard', value: 'Virtual Whiteboard' },
                  { label: 'Brainstorming Hub', value: 'Brainstorming Hub' },
                  { label: 'Prototyping Area', value: 'Prototyping Area' },
                ]}
                rules={[
                  {
                    required: true,
                    message: 'Veuillez choisir au moins un outil ou environnement.',
                  },
                ]}
              />

              {/* Visibilit√© */}
              <ProFormSwitch
                name="isPublic"
                label="Espace visible √† l‚Äôensemble de KeenKonnect"
                tooltip="Quand activ√©, les membres de KeenKonnect pourront d√©couvrir cet espace et demander √† le rejoindre."
              />
            </ProForm>
          )}
        </Card>
      </div>
    </>
  );
}

export default function PageWrapper() {
  return (
    <Suspense fallback={null}>
      <Content />
    </Suspense>
  );
}

===== END app/keenkonnect/workspaces/launch-new-workspace/page.tsx =====


===== BEGIN app/keenkonnect/workspaces/my-workspaces/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Row,
  Col,
  Select,
  Divider,
  Typography,
  Tag,
  Dropdown,
  Popconfirm,
  message,
  Button,
} from 'antd';
import type { MenuProps } from 'antd';
import { DownOutlined } from '@ant-design/icons';
import { ProTable, type ProColumns } from '@ant-design/pro-components';

const { Title, Text } = Typography;

interface Workspace {
  id: string;
  name: string;
  project: string;
  status: 'active' | 'inactive';
  description: string;
  environment: string; // e.g. "Python environment", "Design whiteboard"
}

const sampleWorkspaces: Workspace[] = [
  {
    id: '1',
    name: 'Workspace Alpha',
    project: 'Project Alpha',
    status: 'active',
    description: 'Interactive Python coding environment for data analysis.',
    environment: 'Python environment',
  },
  {
    id: '2',
    name: 'Workspace Beta',
    project: 'Project Beta',
    status: 'inactive',
    description: 'Digital whiteboard for design brainstorming.',
    environment: 'Design whiteboard',
  },
  {
    id: '3',
    name: 'Workspace Gamma',
    project: 'Project Alpha',
    status: 'active',
    description: 'Collaborative space for real-time coding and testing.',
    environment: 'Development environment',
  },
  {
    id: '4',
    name: 'Workspace Delta',
    project: 'Project Delta',
    status: 'inactive',
    description: 'Project planning and management space.',
    environment: 'Planning Board',
  },
];

export default function MyWorkspaces() {
  const router = useRouter();

  // Filter by project
  const [selectedProject, setSelectedProject] = useState<string>('All');
  // Local list so we can "remove" a workspace from the view (Popconfirm action)
  const [visibleWorkspaces, setVisibleWorkspaces] =
    useState<Workspace[]>(sampleWorkspaces);

  const filteredWorkspaces = useMemo(() => {
    const base = visibleWorkspaces;
    if (selectedProject === 'All') return base;
    return base.filter((ws) => ws.project === selectedProject);
  }, [selectedProject, visibleWorkspaces]);

  const activeCount = useMemo(
    () => visibleWorkspaces.filter((ws) => ws.status === 'active').length,
    [visibleWorkspaces],
  );

  const projectOptions = useMemo(() => {
    const projects = Array.from(
      new Set(visibleWorkspaces.map((ws) => ws.project)),
    );
    return ['All', ...projects];
  }, [visibleWorkspaces]);

  const handleWorkspacePrimaryAction = (ws: Workspace) => {
    router.push(`/keenkonnect/workspaces/launch-new-workspace?id=${ws.id}`);
  };

  const handleManageSettings = (ws: Workspace) => {
    // corrig√© : "launch-new-workspace" (sans "s")
    router.push(
      `/keenkonnect/workspaces/launch-new-workspace?id=${ws.id}&manage=1`,
    );
  };

  const handleRemoveFromMyWorkspaces = (ws: Workspace) => {
    setVisibleWorkspaces((prev) => prev.filter((item) => item.id !== ws.id));
    message.success(`Workspace "${ws.name}" removed from your list.`);
  };

  const columns: ProColumns<Workspace>[] = [
    {
      title: 'Workspace',
      dataIndex: 'name',
      key: 'name',
      render: (_dom, record) => (
        <div>
          <div style={{ fontWeight: 500 }}>{record.name}</div>
          <Text type="secondary">{record.description}</Text>
        </div>
      ),
    },
    {
      title: 'Project',
      dataIndex: 'project',
      key: 'project',
    },
    {
      title: 'Environment',
      dataIndex: 'environment',
      key: 'environment',
      // IMPORTANT : on respecte la signature (dom, entity, index, action, schema)
      render: (_dom, record) => <Tag>{record.environment}</Tag>,
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (_dom, record) =>
        record.status === 'active' ? (
          <Tag color="green">Active</Tag>
        ) : (
          <Tag color="default">Inactive</Tag>
        ),
    },
    {
      title: 'Actions',
      key: 'actions',
      valueType: 'option',
      render: (_dom, record) => {
        const isActive = record.status === 'active';
        const primaryLabel = isActive ? 'Join Now' : 'Launch';

        const menuItems: MenuProps['items'] = [
          {
            key: 'manage',
            label: 'Manage Settings',
          },
          {
            key: 'remove',
            label: (
              <Popconfirm
                title="Remove from My Workspaces?"
                description="This will remove the workspace from your list (the workspace itself is not deleted)."
                okText="Yes, remove"
                cancelText="Cancel"
                onConfirm={() => handleRemoveFromMyWorkspaces(record)}
              >
                <span>Remove from list</span>
              </Popconfirm>
            ),
          },
        ];

        const onMenuClick: MenuProps['onClick'] = ({ key }) => {
          if (key === 'manage') {
            handleManageSettings(record);
          }
        };

        return (
          <Dropdown.Button
            type="primary"
            size="small"
            menu={{ items: menuItems, onClick: onMenuClick }}
            onClick={() => handleWorkspacePrimaryAction(record)}
            icon={<DownOutlined />}
          >
            {primaryLabel}
          </Dropdown.Button>
        );
      },
    },
  ];

  return (
    <div className="container mx-auto p-5">
      <Title level={2}>My Workspaces</Title>
      <Divider />

      <Row gutter={[16, 16]} className="mb-4">
        <Col xs={24} sm={12}>
          <Text strong>Total Active Workspaces: {activeCount}</Text>
        </Col>
        <Col
          xs={24}
          sm={12}
          style={{ textAlign: 'right', marginTop: 8, marginBottom: 8 }}
        >
          <Button
            type="default"
            style={{ marginRight: 8 }}
            onClick={() =>
              router.push('/keenkonnect/workspaces/browse-available-workspaces')
            }
          >
            Browse Available Workspaces
          </Button>
          <Button
            type="primary"
            onClick={() =>
              router.push('/keenkonnect/workspaces/launch-new-workspace')
            }
          >
            Launch New Workspace
          </Button>
        </Col>
      </Row>

      <Row gutter={[16, 16]} className="mb-4">
        <Col xs={24} sm={12}>
          <Text>Filter by Project:</Text>
          <Select
            value={selectedProject}
            onChange={(value) => setSelectedProject(value)}
            style={{ width: '100%', marginTop: 4 }}
            options={projectOptions.map((p) => ({ label: p, value: p }))}
          />
        </Col>
      </Row>

      <Divider />

      <ProTable<Workspace>
        rowKey="id"
        columns={columns}
        dataSource={filteredWorkspaces}
        search={false}
        pagination={{
          pageSize: 5,
          showSizeChanger: false,
        }}
        options={false}
      />
    </div>
  );
}

===== END app/keenkonnect/workspaces/my-workspaces/page.tsx =====


===== BEGIN app/konnected/certifications/certification-programs/page.tsx =====
Ôªø// app/konnected/certifications/certification-programs/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import { PageContainer, ProCard } from '@ant-design/pro-components';
import {
  Alert,
  Badge,
  Button,
  Card,
  Col,
  Drawer,
  Empty,
  Input,
  Pagination,
  Progress,
  Row,
  Space,
  Statistic,
  Tag,
  Tooltip,
} from 'antd';
import {
  ArrowRightOutlined,
  InfoCircleOutlined,
  SafetyCertificateOutlined,
  SearchOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';

import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import usePageTitle from '@/hooks/usePageTitle';
import { get } from '@/services/_request';
import { normalizeError } from '@/shared/errors';

const CERT_PASS_PERCENT = 80;

type ProgramDifficulty = 'beginner' | 'intermediate' | 'advanced' | 'expert';

type ProgramStatus = 'not_started' | 'in_progress' | 'completed';

interface ProgramSkill {
  id: string;
  name: string;
  category?: string;
}

interface ProgramUserProgress {
  status: ProgramStatus;
  completionPercent: number;
  lastActivityAt?: string;
  nextRecommendedStep?: string;
}

interface CertificationProgram {
  id: string;
  code: string;
  title: string;
  description: string;
  difficulty: ProgramDifficulty;
  estimatedHours?: number;
  category?: string;
  tags?: string[];
  skills?: ProgramSkill[];
  requiresProctoring?: boolean;
  attemptsAllowed?: number;
  passPercent?: number;
  isFeatured?: boolean;
  kpi_enrolledCount?: number;
  kpi_completionRate?: number;
  userProgress?: ProgramUserProgress;
}

interface ProgramsResponse {
  items: CertificationProgram[];
}

/**
 * Minimal payload shape coming from the CertifiKation paths endpoint.
 * This mirrors what exam-registration already expects from:
 *   GET /api/konnected/certifications/paths/
 */
interface CertificationPathPayload {
  id: number;
  name: string;
  description?: string;
  level?: string;
  tags?: string[];
  already_passed?: boolean;
  cooldown_remaining_minutes?: number | null;
}

/**
 * Maps backend "level" to the UI difficulty scale.
 */
function mapLevelToDifficulty(level?: string | null): ProgramDifficulty {
  const normalized = (level ?? '').toLowerCase();

  if (!normalized) return 'intermediate';
  if (normalized.includes('beginner') || normalized.includes('intro')) return 'beginner';
  if (normalized.includes('expert')) return 'expert';
  if (normalized.includes('advanced')) return 'advanced';
  return 'intermediate';
}

/**
 * Maps a CertificationPath payload into the richer CertificationProgram
 * shape used by this page. Fields with no direct backend equivalent are
 * left undefined.
 */
function mapPathToProgram(path: CertificationPathPayload): CertificationProgram {
  const difficulty = mapLevelToDifficulty(path.level);
  const alreadyPassed = Boolean(path.already_passed);
  const completionPercent = alreadyPassed ? 100 : 0;

  const userProgress: ProgramUserProgress = {
    status: alreadyPassed ? 'completed' : 'not_started',
    completionPercent,
  };

  return {
    id: String(path.id),
    code: `PATH-${path.id}`,
    title: path.name,
    description: path.description ?? '',
    difficulty,
    category: undefined,
    tags: path.tags ?? [],
    skills: [],
    requiresProctoring: false,
    attemptsAllowed: undefined,
    passPercent: CERT_PASS_PERCENT,
    isFeatured: false,
    kpi_enrolledCount: undefined,
    kpi_completionRate: undefined,
    userProgress,
  };
}

/**
 * API client for the CertifiKation catalog.
 *
 * Uses the canonical KonnectED CertifiKation endpoint:
 *   GET /api/konnected/certifications/paths/
 *
 * This keeps the Programs page aligned with the same source used by
 * exam-registration, without relying on mock data.
 */
async function fetchCertificationPrograms(): Promise<ProgramsResponse> {
  const paths = await get<CertificationPathPayload[]>('konnected/certifications/paths/');

  return {
    items: paths.map(mapPathToProgram),
  };
}

export default function CertificationProgramsPage(): JSX.Element {
  usePageTitle('KonnectED ¬∑ Certification Programs');
  const router = useRouter();

  const [search, setSearch] = useState('');
  const [difficultyFilter, setDifficultyFilter] = useState<ProgramDifficulty | 'all'>('all');
  const [statusFilter, setStatusFilter] = useState<ProgramStatus | 'all'>('all');
  const [categoryFilter, setCategoryFilter] = useState<string | 'all'>('all');
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(6);
  const [selectedProgram, setSelectedProgram] = useState<CertificationProgram | null>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);

  const { data, loading, error, refresh } = useRequest<ProgramsResponse, []>(
    fetchCertificationPrograms,
  );

  const programs = data?.items ?? [];

  const categories = useMemo(() => {
    const set = new Set<string>();
    programs.forEach((p) => {
      if (p.category) set.add(p.category);
    });
    return Array.from(set).sort();
  }, [programs]);

  const filteredPrograms = useMemo(() => {
    const query = search.trim().toLowerCase();

    return programs.filter((program) => {
      const matchesSearch =
        !query ||
        program.title.toLowerCase().includes(query) ||
        program.description.toLowerCase().includes(query) ||
        (program.code && program.code.toLowerCase().includes(query)) ||
        (program.tags ?? []).some((t) => t.toLowerCase().includes(query));

      const matchesDifficulty =
        difficultyFilter === 'all' || program.difficulty === difficultyFilter;

      const matchesCategory =
        categoryFilter === 'all' || program.category === categoryFilter;

      const status = program.userProgress?.status ?? 'not_started';
      const matchesStatus = statusFilter === 'all' || status === statusFilter;

      return matchesSearch && matchesDifficulty && matchesCategory && matchesStatus;
    });
  }, [programs, search, difficultyFilter, categoryFilter, statusFilter]);

  const total = filteredPrograms.length;
  const startIndex = (currentPage - 1) * pageSize;
  const paginatedPrograms = filteredPrograms.slice(startIndex, startIndex + pageSize);

  const stats = useMemo(() => {
    if (!programs.length) {
      return {
        totalPrograms: 0,
        activePrograms: 0,
        completedPrograms: 0,
        averageCompletion: 0,
      };
    }

    let active = 0;
    let completed = 0;
    let sumCompletion = 0;
    let counted = 0;

    programs.forEach((p) => {
      const progress = p.userProgress;
      if (!progress) return;

      if (progress.status === 'in_progress') active += 1;
      if (progress.status === 'completed') completed += 1;
      if (typeof progress.completionPercent === 'number') {
        sumCompletion += progress.completionPercent;
        counted += 1;
      }
    });

    return {
      totalPrograms: programs.length,
      activePrograms: active,
      completedPrograms: completed,
      averageCompletion: counted ? Math.round(sumCompletion / counted) : 0,
    };
  }, [programs]);

  const handleOpenDetails = (program: CertificationProgram) => {
    setSelectedProgram(program);
    setDrawerOpen(true);
  };

  const handleStartOrContinue = (program: CertificationProgram) => {
    const status = program.userProgress?.status ?? 'not_started';

    if (status === 'not_started') {
      router.push(`/konnected/certifications/exam-registration?pathId=${program.id}`);
      return;
    }

    if (status === 'in_progress') {
      router.push(`/konnected/certifications/exam-preparation?pathId=${program.id}`);
      return;
    }

    if (status === 'completed') {
      router.push(`/konnected/certifications/exam-dashboard-results?pathId=${program.id}`);
    }
  };

  const renderStatusTag = (program: CertificationProgram) => {
    const progress = program.userProgress;

    if (!progress || progress.status === 'not_started') {
      return <Tag>Not started</Tag>;
    }

    if (progress.status === 'in_progress') {
      return <Tag color="blue">In progress</Tag>;
    }

    if (progress.status === 'completed') {
      return <Tag color="green">Completed</Tag>;
    }

    return null;
  };

  const renderDifficultyTag = (difficulty: ProgramDifficulty) => {
    switch (difficulty) {
      case 'beginner':
        return <Tag color="green">Beginner</Tag>;
      case 'intermediate':
        return <Tag color="blue">Intermediate</Tag>;
      case 'advanced':
        return <Tag color="orange">Advanced</Tag>;
      case 'expert':
        return <Tag color="red">Expert</Tag>;
      default:
        return null;
    }
  };

  const errorState = error ? normalizeError(error) : null;
  const errorMessage = errorState?.message ?? null;

  return (
    <KonnectedPageShell
      title="Certification Programs"
      subtitle="Browse certification paths, track your progress, and launch formal evaluations."
      primaryAction={
        <Button
          type="primary"
          icon={<SafetyCertificateOutlined />}
          onClick={() => {
            const target =
              programs.find((p) => p.userProgress?.status === 'in_progress') ??
              programs.find((p) => p.isFeatured) ??
              programs[0];

            if (target) {
              handleStartOrContinue(target);
            }
          }}
          disabled={!programs.length}
        >
          Go to my next certification
        </Button>
      }
    >
      <PageContainer ghost loading={loading}>
        <Row gutter={[16, 16]}>
          {/* Stats */}
          <Col xs={24} md={10} lg={8}>
            <ProCard
              ghost
              title="My CertifiKation overview"
              extra={
                <Tooltip title={`Global pass threshold is ${CERT_PASS_PERCENT}% for most exams.`}>
                  <InfoCircleOutlined />
                </Tooltip>
              }
            >
              <Row gutter={[16, 16]}>
                <Col span={12}>
                  <Statistic title="Total programs" value={stats.totalPrograms} />
                </Col>
                <Col span={12}>
                  <Statistic title="Active" value={stats.activePrograms} />
                </Col>
                <Col span={12}>
                  <Statistic title="Completed" value={stats.completedPrograms} />
                </Col>
                <Col span={12}>
                  <Statistic
                    title="Avg. completion"
                    value={stats.averageCompletion}
                    suffix="%"
                  />
                </Col>
              </Row>
              <div style={{ marginTop: 16 }}>
                <div
                  style={{
                    marginBottom: 4,
                    display: 'flex',
                    justifyContent: 'space-between',
                  }}
                >
                  <span>Overall progress toward certifications</span>
                  <span>{stats.averageCompletion}%</span>
                </div>
                <Progress percent={stats.averageCompletion} size="small" />
              </div>
            </ProCard>
          </Col>

          {/* Filters */}
          <Col xs={24} md={14} lg={16}>
            <ProCard ghost title="Filter programs">
              <Row gutter={[12, 12]}>
                <Col span={24}>
                  <Input
                    allowClear
                    prefix={<SearchOutlined />}
                    placeholder="Search by name, code, tag, or description"
                    value={search}
                    onChange={(e) => {
                      setSearch(e.target.value);
                      setCurrentPage(1);
                    }}
                  />
                </Col>

                <Col xs={24} sm={8}>
                  <Space direction="vertical" size={4} style={{ width: '100%' }}>
                    <span>Difficulty</span>
                    <Space wrap>
                      <Button
                        size="small"
                        type={difficultyFilter === 'all' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('all');
                          setCurrentPage(1);
                        }}
                      >
                        All
                      </Button>
                      <Button
                        size="small"
                        type={difficultyFilter === 'beginner' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('beginner');
                          setCurrentPage(1);
                        }}
                      >
                        Beginner
                      </Button>
                      <Button
                        size="small"
                        type={difficultyFilter === 'intermediate' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('intermediate');
                          setCurrentPage(1);
                        }}
                      >
                        Intermediate
                      </Button>
                      <Button
                        size="small"
                        type={difficultyFilter === 'advanced' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('advanced');
                          setCurrentPage(1);
                        }}
                      >
                        Advanced
                      </Button>
                      <Button
                        size="small"
                        type={difficultyFilter === 'expert' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('expert');
                          setCurrentPage(1);
                        }}
                      >
                        Expert
                      </Button>
                    </Space>
                  </Space>
                </Col>

                <Col xs={24} sm={8}>
                  <Space direction="vertical" size={4} style={{ width: '100%' }}>
                    <span>Status</span>
                    <Space wrap>
                      <Button
                        size="small"
                        type={statusFilter === 'all' ? 'primary' : 'default'}
                        onClick={() => {
                          setStatusFilter('all');
                          setCurrentPage(1);
                        }}
                      >
                        All
                      </Button>
                      <Button
                        size="small"
                        type={statusFilter === 'not_started' ? 'primary' : 'default'}
                        onClick={() => {
                          setStatusFilter('not_started');
                          setCurrentPage(1);
                        }}
                      >
                        Not started
                      </Button>
                      <Button
                        size="small"
                        type={statusFilter === 'in_progress' ? 'primary' : 'default'}
                        onClick={() => {
                          setStatusFilter('in_progress');
                          setCurrentPage(1);
                        }}
                      >
                        In progress
                      </Button>
                      <Button
                        size="small"
                        type={statusFilter === 'completed' ? 'primary' : 'default'}
                        onClick={() => {
                          setStatusFilter('completed');
                          setCurrentPage(1);
                        }}
                      >
                        Completed
                      </Button>
                    </Space>
                  </Space>
                </Col>

                <Col xs={24} sm={8}>
                  <Space direction="vertical" size={4} style={{ width: '100%' }}>
                    <span>Category</span>
                    <Space wrap>
                      <Button
                        size="small"
                        type={categoryFilter === 'all' ? 'primary' : 'default'}
                        onClick={() => {
                          setCategoryFilter('all');
                          setCurrentPage(1);
                        }}
                      >
                        All
                      </Button>
                      {categories.map((cat) => (
                        <Button
                          key={cat}
                          size="small"
                          type={categoryFilter === cat ? 'primary' : 'default'}
                          onClick={() => {
                            setCategoryFilter(cat);
                            setCurrentPage(1);
                          }}
                        >
                          {cat}
                        </Button>
                      ))}
                    </Space>
                  </Space>
                </Col>
              </Row>
            </ProCard>
          </Col>
        </Row>

        {/* Error state */}
        {errorMessage && (
          <Alert
            type="error"
            showIcon
            style={{ marginTop: 16 }}
            message="Unable to load certification programs"
            description={
              <Space align="start">
                <span>{errorMessage}</span>
                <Button size="small" onClick={() => refresh()}>
                  Retry
                </Button>
              </Space>
            }
          />
        )}

        {/* Catalog */}
        <Row gutter={[16, 16]} style={{ marginTop: 16 }}>
          {paginatedPrograms.length === 0 && !loading ? (
            <Col span={24}>
              <Card>
                <Empty
                  description={
                    search ||
                    difficultyFilter !== 'all' ||
                    statusFilter !== 'all' ||
                    categoryFilter !== 'all'
                      ? 'No certification programs match your filters.'
                      : 'No certification programs are available yet.'
                  }
                >
                  {(search ||
                    difficultyFilter !== 'all' ||
                    statusFilter !== 'all' ||
                    categoryFilter !== 'all') && (
                    <Button
                      onClick={() => {
                        setSearch('');
                        setDifficultyFilter('all');
                        setStatusFilter('all');
                        setCategoryFilter('all');
                        setCurrentPage(1);
                      }}
                    >
                      Clear filters
                    </Button>
                  )}
                </Empty>
              </Card>
            </Col>
          ) : (
            paginatedPrograms.map((program) => {
              const progress = program.userProgress;
              const percent = progress?.completionPercent ?? 0;
              const passPercent = program.passPercent ?? CERT_PASS_PERCENT;

              return (
                <Col key={program.id} xs={24} md={12} lg={8}>
                  <Badge.Ribbon
                    text={program.isFeatured ? 'Featured' : undefined}
                    color={program.isFeatured ? 'gold' : undefined}
                  >
                    <Card
                      hoverable
                      title={
                        <Space>
                          <SafetyCertificateOutlined />
                          <span>{program.title}</span>
                        </Space>
                      }
                      extra={renderStatusTag(program)}
                      onClick={() => handleOpenDetails(program)}
                    >
                      <Space direction="vertical" size={8} style={{ width: '100%' }}>
                        <div>
                          <div style={{ marginBottom: 4 }}>
                            <Space size={8} wrap>
                              {program.code && <Tag bordered={false}>{program.code}</Tag>}
                              {renderDifficultyTag(program.difficulty)}
                              {program.category && (
                                <Tag color="default">{program.category}</Tag>
                              )}
                              {program.requiresProctoring && (
                                <Tag color="purple">Proctored</Tag>
                              )}
                            </Space>
                          </div>
                          <div style={{ minHeight: 48 }}>{program.description}</div>
                        </div>

                        <Space
                          direction="vertical"
                          size={4}
                          style={{ width: '100%' }}
                        >
                          <div
                            style={{
                              display: 'flex',
                              justifyContent: 'space-between',
                            }}
                          >
                            <span>My progress</span>
                            <span>{percent}%</span>
                          </div>
                          <Progress
                            percent={percent}
                            size="small"
                            status={percent >= passPercent ? 'success' : 'active'}
                          />
                        </Space>

                        {!!program.tags?.length && (
                          <Space wrap size={4}>
                            {program.tags.map((tag) => (
                              <Tag key={tag}>{tag}</Tag>
                            ))}
                          </Space>
                        )}

                        <Space style={{ justifyContent: 'space-between', width: '100%' }}>
                          <Button
                            type="primary"
                            icon={<ArrowRightOutlined />}
                            onClick={(e) => {
                              e.stopPropagation();
                              handleStartOrContinue(program);
                            }}
                          >
                            {program.userProgress?.status === 'completed'
                              ? 'View results'
                              : program.userProgress?.status === 'in_progress'
                              ? 'Continue'
                              : 'Start'}
                          </Button>
                        </Space>
                      </Space>
                    </Card>
                  </Badge.Ribbon>
                </Col>
              );
            })
          )}
        </Row>

        {total > pageSize && (
          <div style={{ marginTop: 16, textAlign: 'right' }}>
            <Pagination
              current={currentPage}
              pageSize={pageSize}
              total={total}
              showSizeChanger
              pageSizeOptions={['6', '12', '24']}
              onChange={(page, size) => {
                setCurrentPage(page);
                if (size && size !== pageSize) {
                  setPageSize(size);
                }
              }}
            />
          </div>
        )}

        <Drawer
          title={selectedProgram?.title}
          open={drawerOpen}
          width={480}
          onClose={() => setDrawerOpen(false)}
        >
          {selectedProgram && (
            <Space direction="vertical" size={16} style={{ width: '100%' }}>
              <Space direction="vertical" size={4}>
                <Space wrap>
                  {selectedProgram.code && (
                    <Tag bordered={false}>{selectedProgram.code}</Tag>
                  )}
                  {renderDifficultyTag(selectedProgram.difficulty)}
                  {selectedProgram.category && (
                    <Tag color="default">{selectedProgram.category}</Tag>
                  )}
                  {selectedProgram.requiresProctoring && (
                    <Tag color="purple">Proctored</Tag>
                  )}
                </Space>
              </Space>

              <div>
                <h3>Description</h3>
                <p>{selectedProgram.description}</p>
              </div>

              {!!selectedProgram.skills?.length && (
                <div>
                  <h3>Key skills verified</h3>
                  <Space wrap>
                    {selectedProgram.skills.map((skill) => (
                      <Tag key={skill.id}>{skill.name}</Tag>
                    ))}
                  </Space>
                </div>
              )}

              <div>
                <h3>Assessment rules</h3>
                <ul style={{ paddingLeft: 20 }}>
                  <li>
                    Passing threshold:{' '}
                    <strong>
                      {selectedProgram.passPercent ?? CERT_PASS_PERCENT}%
                    </strong>
                  </li>
                  {selectedProgram.attemptsAllowed && (
                    <li>
                      Attempts allowed:{' '}
                      <strong>{selectedProgram.attemptsAllowed}</strong>
                    </li>
                  )}
                  {typeof selectedProgram.estimatedHours === 'number' && (
                    <li>
                      Estimated learning time:{' '}
                      <strong>~{selectedProgram.estimatedHours} hours</strong>
                    </li>
                  )}
                </ul>
              </div>

              {selectedProgram.userProgress && (
                <div>
                  <h3>My current status</h3>
                  <Space direction="vertical" size={8} style={{ width: '100%' }}>
                    <Space>
                      {renderStatusTag(selectedProgram)}
                      {typeof selectedProgram.userProgress.completionPercent ===
                        'number' && (
                        <span>
                          {selectedProgram.userProgress.completionPercent}
                          % complete
                        </span>
                      )}
                    </Space>
                    <Progress
                      percent={selectedProgram.userProgress.completionPercent}
                      status={
                        selectedProgram.userProgress.status === 'completed'
                          ? 'success'
                          : 'active'
                      }
                    />
                    {selectedProgram.userProgress.nextRecommendedStep && (
                      <Alert
                        type="info"
                        showIcon
                        message="Next recommended step"
                        description={selectedProgram.userProgress.nextRecommendedStep}
                      />
                    )}
                  </Space>
                </div>
              )}

              <Space style={{ marginTop: 8 }}>
                <Button
                  type="primary"
                  icon={<ArrowRightOutlined />}
                  onClick={() => handleStartOrContinue(selectedProgram)}
                >
                  {selectedProgram.userProgress?.status === 'completed'
                    ? 'View results'
                    : selectedProgram.userProgress?.status === 'in_progress'
                    ? 'Continue certification'
                    : 'Start certification'}
                </Button>
              </Space>
            </Space>
          )}
        </Drawer>
      </PageContainer>
    </KonnectedPageShell>
  );
}

===== END app/konnected/certifications/certification-programs/page.tsx =====


===== BEGIN app/konnected/certifications/exam-dashboard-results/page.tsx =====
// app/konnected/certifications/exam-dashboard-results/page.tsx
'use client'

import React, { useMemo, useState } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import {
  Alert,
  Badge,
  Button,
  Card,
  Col,
  Drawer,
  Empty,
  List,
  Result,
  Row,
  Space,
  Spin,
  Statistic,
  Table,
  Tag,
  Tooltip,
  Typography,
  message,
} from 'antd'
import type { ColumnsType } from 'antd/es/table'
import {
  CheckCircleOutlined,
  ClockCircleOutlined,
  ExclamationCircleOutlined,
  FilePdfOutlined,
  ReloadOutlined,
  WarningOutlined,
  EyeOutlined,
} from '@ant-design/icons'
import { useRequest } from 'ahooks'

import KonnectedPageShell from '@/app/konnected/KonnectedPageShell'
import api from '@/services/_request'

const { Title, Text, Paragraph } = Typography

// NOTE: These thresholds mirror the global params from the CertifiKation spec.
// Keep in sync with backend/global-params.
const CERT_PASS_PERCENT = 80
const EXAM_RETRY_COOLDOWN_MIN = 30

// -----------------------------------------------------------------------------
// Domain types (aligned with Evaluation / CertificationPath / Portfolio models)
// -----------------------------------------------------------------------------

export type EvaluationStatus =
  | 'passed'
  | 'failed'
  | 'pending_peer'
  | 'under_review'
  | 'scheduled'
  | 'in_progress'

export interface ExamAttempt {
  id: string
  certificationPathId: string
  certificationPathName: string
  attemptNumber: number
  takenAt: string // ISO date
  deliveryMode: 'online' | 'offline' | 'blended'
  proctored: boolean
  scorePercent: number | null
  maxScore: number | null
  status: EvaluationStatus

  // Peer validation / review
  peerValidationRequired: boolean
  peerValidationStatus?: 'approved' | 'rejected' | 'pending'
  appealStatus?: 'none' | 'open' | 'resolved' | 'rejected'

  // Portfolio / certificate linkage
  certificateId?: string
  certificateUrl?: string
  portfolioItemId?: string
  portfolioUrl?: string

  // Retry & cooldown metadata
  canRetry: boolean
  nextRetryAt?: string // ISO date if blocked by cooldown
}

interface ExamAttemptsResponse {
  attempts: ExamAttempt[]
}

// -----------------------------------------------------------------------------
// API endpoint helpers
// -----------------------------------------------------------------------------
//
// IMPORTANT:
// - we use *relative* URLs WITHOUT a leading "/" so that axios baseURL
//   (NEXT_PUBLIC_API_BASE or "/api") is correctly applied.
// - On the wire this becomes:  /api/konnected/certifications/...
//

const EXAM_ATTEMPTS_ENDPOINT = 'konnected/certifications/exam-attempts/me'
const EXAM_ATTEMPT_DETAIL_ENDPOINT = (attemptId: string) =>
  `konnected/certifications/exam-attempts/${attemptId}`
const EXAM_APPEAL_ENDPOINT = (attemptId: string) =>
  `konnected/certifications/exam-attempts/${attemptId}/appeal`
const EXAM_RETRY_ENDPOINT = (attemptId: string) =>
  `konnected/certifications/exam-attempts/${attemptId}/retry`

async function fetchExamAttempts(): Promise<ExamAttemptsResponse> {
  return api.get<ExamAttemptsResponse>(EXAM_ATTEMPTS_ENDPOINT)
}

// -----------------------------------------------------------------------------
// Utility helpers
// -----------------------------------------------------------------------------

const formatDateTime = (iso: string | undefined) => {
  if (!iso) return '‚Äî'
  const date = new Date(iso)
  if (Number.isNaN(date.getTime())) return iso
  return date.toLocaleString()
}

const getStatusTag = (attempt: ExamAttempt) => {
  if (attempt.status === 'scheduled') {
    return (
      <Tag icon={<ClockCircleOutlined />} color="default">
        Scheduled
      </Tag>
    )
  }

  if (attempt.status === 'in_progress') {
    return (
      <Tag icon={<ClockCircleOutlined />} color="processing">
        In progress
      </Tag>
    )
  }

  if (attempt.status === 'passed') {
    if (attempt.peerValidationRequired && attempt.peerValidationStatus !== 'approved') {
      // Passed automated evaluation but still waiting on peers
      return (
        <Tag icon={<ClockCircleOutlined />} color="processing">
          Pending peer validation
        </Tag>
      )
    }
    return (
      <Tag icon={<CheckCircleOutlined />} color="success">
        Passed
      </Tag>
    )
  }

  if (attempt.status === 'failed') {
    return (
      <Tag icon={<ExclamationCircleOutlined />} color="error">
        Not passed
      </Tag>
    )
  }

  if (attempt.status === 'pending_peer') {
    return (
      <Tag icon={<ClockCircleOutlined />} color="processing">
        Pending peer validation
      </Tag>
    )
  }

  if (attempt.status === 'under_review') {
    return (
      <Tag icon={<ClockCircleOutlined />} color="warning">
        Under review
      </Tag>
    )
  }

  return <Tag>Unknown</Tag>
}

const getAppealTag = (attempt: ExamAttempt) => {
  if (!attempt.appealStatus || attempt.appealStatus === 'none') {
    return null
  }

  if (attempt.appealStatus === 'open') {
    return (
      <Tag color="processing" icon={<ClockCircleOutlined />}>
        Appeal open
      </Tag>
    )
  }

  if (attempt.appealStatus === 'resolved') {
    return (
      <Tag color="success" icon={<CheckCircleOutlined />}>
        Appeal resolved
      </Tag>
    )
  }

  if (attempt.appealStatus === 'rejected') {
    return (
      <Tag color="error" icon={<ExclamationCircleOutlined />}>
        Appeal rejected
      </Tag>
    )
  }

  return null
}

type ScoreColor = 'success' | 'warning' | 'danger' | undefined

const getScoreColor = (percent: number | null): ScoreColor => {
  if (percent == null) return undefined
  if (percent >= CERT_PASS_PERCENT) return 'success'
  if (percent >= CERT_PASS_PERCENT - 10) return 'warning'
  return 'danger'
}

// -----------------------------------------------------------------------------
// Main component
// -----------------------------------------------------------------------------

const ExamDashboardResultsPage: React.FC = () => {
  const [selectedAttempt, setSelectedAttempt] = useState<ExamAttempt | null>(null)
  const [appealLoadingId, setAppealLoadingId] = useState<string | null>(null)
  const [retryLoadingId, setRetryLoadingId] = useState<string | null>(null)

  const router = useRouter()
  const searchParams = useSearchParams()
  const pathIdFromQuery = searchParams.get('pathId')

  const {
    data,
    loading,
    error,
    refresh: refreshAttempts,
  } = useRequest(fetchExamAttempts, {
    retryCount: 1,
  })

  const allAttempts = data?.attempts ?? []

  // If pathId is present, filter attempts to that certification path
  const attempts = useMemo(
    () =>
      pathIdFromQuery
        ? allAttempts.filter((a) => a.certificationPathId === pathIdFromQuery)
        : allAttempts,
    [allAttempts, pathIdFromQuery],
  )

  const stats = useMemo(() => {
    if (!attempts.length) {
      return {
        totalAttempts: 0,
        passedCount: 0,
        passRate: 0,
        avgScore: 0,
        uniqueCerts: 0,
      }
    }

    const totalAttempts = attempts.length
    const scoredAttempts = attempts.filter(
      (a) => typeof a.scorePercent === 'number',
    ) as Array<ExamAttempt & { scorePercent: number }>
    const passedCount = scoredAttempts.filter((a) => a.scorePercent >= CERT_PASS_PERCENT).length
    const passRate = scoredAttempts.length
      ? Math.round((passedCount / scoredAttempts.length) * 100)
      : 0
    const avgScore = scoredAttempts.length
      ? Math.round(
          scoredAttempts.reduce((sum, a) => sum + (a.scorePercent ?? 0), 0) /
            scoredAttempts.length,
        )
      : 0
    const uniqueCerts = new Set(
      attempts.map((a) => a.certificationPathId || a.certificationPathName),
    ).size

    return { totalAttempts, passedCount, passRate, avgScore, uniqueCerts }
  }, [attempts])

  const handleOpenDetails = async (attempt: ExamAttempt) => {
    try {
      const detail = await api.get<ExamAttempt>(EXAM_ATTEMPT_DETAIL_ENDPOINT(attempt.id))
      setSelectedAttempt(detail)
    } catch {
      // Fallback to row data if detail endpoint is not yet wired.
      setSelectedAttempt(attempt)
    }
  }

  const handleCloseDetails = () => {
    setSelectedAttempt(null)
  }

  const handleOpenCertificate = (attempt: ExamAttempt) => {
    if (attempt.certificateUrl) {
      window.open(attempt.certificateUrl, '_blank', 'noopener,noreferrer')
    } else {
      message.info('Certificate is not yet available for this attempt.')
    }
  }

  const handleOpenPortfolio = (attempt: ExamAttempt) => {
    if (attempt.portfolioUrl) {
      window.open(attempt.portfolioUrl, '_blank', 'noopener,noreferrer')
    } else {
      message.info('This attempt is not yet linked to your portfolio.')
    }
  }

  const handleOpenAppeal = async (attempt: ExamAttempt) => {
    setAppealLoadingId(attempt.id)
    try {
      const updated = await api.post<ExamAttempt>(EXAM_APPEAL_ENDPOINT(attempt.id))
      setSelectedAttempt((prev) => (prev && prev.id === attempt.id ? updated : prev))
      refreshAttempts()
      message.success('Appeal request submitted. You will be notified when it is reviewed.')
    } catch {
      message.error('Unable to submit appeal. Please try again or contact support.')
    } finally {
      setAppealLoadingId(null)
    }
  }

  const handleRetry = async (attempt: ExamAttempt) => {
    setRetryLoadingId(attempt.id)
    try {
      const newAttempt = await api.post<ExamAttempt>(EXAM_RETRY_ENDPOINT(attempt.id))
      refreshAttempts()
      message.success('New attempt scheduled successfully.')

      // Redirect into the certification flow for this path
      if (newAttempt.certificationPathId) {
        router.push(
          `/konnected/certifications/exam-preparation?pathId=${newAttempt.certificationPathId}`,
        )
      } else if (attempt.certificationPathId) {
        router.push(
          `/konnected/certifications/exam-preparation?pathId=${attempt.certificationPathId}`,
        )
      }
    } catch (err: any) {
      const detail =
        (err &&
          typeof err === 'object' &&
          'response' in err &&
          (err as any).response?.data?.detail) ||
        null

      if (detail) {
        // e.g. "Retry cooldown is still active for this exam."
        message.error(detail)
      } else {
        message.error('Unable to start a new attempt. Please try again or contact support.')
      }
    } finally {
      setRetryLoadingId(null)
    }
  }

  const columns: ColumnsType<ExamAttempt> = [
    {
      title: 'Certification path',
      dataIndex: 'certificationPathName',
      key: 'certificationPathName',
      render: (text: string, record) => (
        <Space direction="vertical" size={0}>
          <Text strong>{text}</Text>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Attempt #{record.attemptNumber}
          </Text>
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      filters: [
        { text: 'Passed', value: 'passed' },
        { text: 'Not passed', value: 'failed' },
        { text: 'Pending peer validation', value: 'pending_peer' },
        { text: 'Under review', value: 'under_review' },
      ],
      onFilter: (value, record) => record.status === value,
      render: (_value, record) => (
        <Space direction="vertical" size={2}>
          {getStatusTag(record)}
          {getAppealTag(record)}
        </Space>
      ),
    },
    {
      title: 'Score',
      dataIndex: 'scorePercent',
      key: 'scorePercent',
      render: (value: number | null) => {
        if (value == null) {
          return <Text type="secondary">Pending</Text>
        }
        const color = getScoreColor(value)
        return (
          <Space direction="vertical" size={0}>
            <Text
              strong
              type={
                color === 'success'
                  ? 'success'
                  : color === 'danger'
                  ? 'danger'
                  : color === 'warning'
                  ? 'warning'
                  : undefined
              }
            >
              {value}%
            </Text>
            <Text type="secondary" style={{ fontSize: 12 }}>
              Pass threshold: {CERT_PASS_PERCENT}%
            </Text>
          </Space>
        )
      },
    },
    {
      title: 'Date',
      dataIndex: 'takenAt',
      key: 'takenAt',
      render: (value: string) => <Text>{formatDateTime(value)}</Text>,
      sorter: (a, b) => {
        const aTime = new Date(a.takenAt).getTime()
        const bTime = new Date(b.takenAt).getTime()
        return aTime - bTime
      },
      defaultSortOrder: 'descend',
    },
    {
      title: 'Delivery',
      dataIndex: 'deliveryMode',
      key: 'deliveryMode',
      render: (_value, record) => (
        <Space direction="vertical" size={0}>
          <Text>{record.deliveryMode === 'online' ? 'Online' : record.deliveryMode}</Text>
          {record.proctored && (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Proctored
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'Validation',
      key: 'validation',
      render: (_value, record) => {
        if (!record.peerValidationRequired) {
          return <Text type="secondary">Not required</Text>
        }
        if (!record.peerValidationStatus || record.peerValidationStatus === 'pending') {
          return (
            <Tag icon={<ClockCircleOutlined />} color="processing">
              Waiting for peers
            </Tag>
          )
        }
        if (record.peerValidationStatus === 'approved') {
          return (
            <Tag icon={<CheckCircleOutlined />} color="success">
              Peer-approved
            </Tag>
          )
        }
        if (record.peerValidationStatus === 'rejected') {
          return (
            <Tag icon={<ExclamationCircleOutlined />} color="error">
              Peer-rejected
            </Tag>
          )
        }
        return <Text type="secondary">‚Äî</Text>
      },
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_value, record) => (
        <Space>
          <Tooltip title="View attempt details">
            <Button
              size="small"
              icon={<EyeOutlined />}
              onClick={() => handleOpenDetails(record)}
            />
          </Tooltip>
          <Tooltip title="Open certificate (if available)">
            <Button
              size="small"
              icon={<FilePdfOutlined />}
              onClick={() => handleOpenCertificate(record)}
              disabled={!record.certificateUrl}
            />
          </Tooltip>
          <Tooltip title="Open portfolio entry (if available)">
            <Button
              size="small"
              onClick={() => handleOpenPortfolio(record)}
              disabled={!record.portfolioUrl}
            >
              Portfolio
            </Button>
          </Tooltip>
          <Tooltip title="Request a manual review of this attempt">
            <Button
              size="small"
              type="default"
              icon={<WarningOutlined />}
              loading={appealLoadingId === record.id}
              onClick={() => handleOpenAppeal(record)}
              disabled={record.appealStatus === 'open'}
            >
              Appeal
            </Button>
          </Tooltip>
          <Tooltip title="Start a new attempt (if allowed)">
            <Button
              size="small"
              type="primary"
              icon={<ReloadOutlined />}
              loading={retryLoadingId === record.id}
              onClick={() => handleRetry(record)}
              disabled={!record.canRetry}
            >
              Retry
            </Button>
          </Tooltip>
        </Space>
      ),
    },
  ]

  // ---------------------------------------------------------------------------
  // Derived blocks
  // ---------------------------------------------------------------------------

  const kpiCards = (
    <Row gutter={[16, 16]}>
      <Col xs={24} sm={12} md={6}>
        <Card>
          <Statistic title="Total attempts" value={stats.totalAttempts} />
        </Card>
      </Col>
      <Col xs={24} sm={12} md={6}>
        <Card>
          <Statistic
            title="Paths passed"
            value={stats.passedCount}
            suffix={`/ ${stats.uniqueCerts || stats.totalAttempts || 0}`}
          />
        </Card>
      </Col>
      <Col xs={24} sm={12} md={6}>
        <Card>
          <Statistic title="Pass rate" value={stats.passRate} suffix="%" />
        </Card>
      </Col>
      <Col xs={24} sm={12} md={6}>
        <Card>
          <Statistic title="Average score" value={stats.avgScore} suffix="%" />
        </Card>
      </Col>
    </Row>
  )

  const cooldownAlerts = (() => {
    const blockedAttempts = attempts.filter(
      (a) => !a.canRetry && a.nextRetryAt && a.status === 'failed',
    )
    if (!blockedAttempts.length) return null

    return (
      <Alert
        type="info"
        showIcon
        style={{ marginBottom: 16 }}
        message="Retry cooldown in effect"
        description={
          <Space direction="vertical">
            <Text>
              Some attempts are temporarily blocked from retries to prevent burnout and
              encourage reflection.
            </Text>
            <List
              size="small"
              dataSource={blockedAttempts}
              renderItem={(a) => (
                <List.Item>
                  <Space direction="vertical" size={0}>
                    <Text strong>{a.certificationPathName}</Text>
                    <Text type="secondary" style={{ fontSize: 12 }}>
                      Next retry available: {formatDateTime(a.nextRetryAt)}
                    </Text>
                  </Space>
                </List.Item>
              )}
            />
            <Text type="secondary">
              Global policy: {EXAM_RETRY_COOLDOWN_MIN} minutes minimum between failed attempts
              on the same path (configurable per tenant).
            </Text>
          </Space>
        }
      />
    )
  })()

  // ---------------------------------------------------------------------------
  // Global loading / error / empty handling
  // ---------------------------------------------------------------------------

  if (loading && !data) {
    return (
      <KonnectedPageShell
        title="Exam Dashboard & Results"
        subtitle="Track your certification exam attempts, scores, and outcomes."
      >
        <div style={{ padding: 24, textAlign: 'center' }}>
          <Spin size="large" />
        </div>
      </KonnectedPageShell>
    )
  }

  if (error) {
    return (
      <KonnectedPageShell
        title="Exam Dashboard & Results"
        subtitle="Track your certification exam attempts, scores, and outcomes."
      >
        <div style={{ padding: 24 }}>
          <Result
            status="error"
            title="We could not load your exam results."
            subTitle="There was a problem contacting the CertifiKation service. Please try again in a few seconds."
            extra={
              <Button type="primary" onClick={() => refreshAttempts()}>
                Retry loading
              </Button>
            }
          />
        </div>
      </KonnectedPageShell>
    )
  }

  // No attempts at all for this user (global empty state)
  if (!allAttempts.length) {
    return (
      <KonnectedPageShell
        title="Exam Dashboard & Results"
        subtitle="Track your certification exam attempts, scores, and outcomes."
      >
        <Row gutter={24}>
          <Col xs={24} md={16}>
            <Card>
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description={
                  <Space direction="vertical">
                    <Text>You have not attempted any certification exams yet.</Text>
                    <Text type="secondary">
                      Once you complete an exam in the CertifiKation module, it will appear
                      here with your score, status, and certificate links.
                    </Text>
                  </Space>
                }
              >
                <Button
                  type="primary"
                  href="/konnected/certifications/exam-registration"
                >
                  Browse certification exams
                </Button>
              </Empty>
            </Card>
          </Col>
          <Col xs={24} md={8}>
            <Card title="How this dashboard works">
              <Space direction="vertical">
                <Text>
                  This dashboard consolidates all your exam attempts from the CertifiKation
                  module.
                </Text>
                <List
                  size="small"
                  dataSource={[
                    'Each attempt shows your score, pass/fail status, and validation state.',
                    'If peer validation is required, you will see when it is pending or approved.',
                    'Once a certification is granted, you can open the official certificate and any portfolio entry.',
                  ]}
                  renderItem={(item) => (
                    <List.Item>
                      <Text type="secondary">{item}</Text>
                    </List.Item>
                  )}
                />
              </Space>
            </Card>
          </Col>
        </Row>
      </KonnectedPageShell>
    )
  }

  // There are attempts overall, but none for the current path filter
  if (!attempts.length) {
    return (
      <KonnectedPageShell
        title="Exam Dashboard & Results"
        subtitle="Track your certification exam attempts, scores, and outcomes."
      >
        <Row gutter={24}>
          <Col xs={24} md={16}>
            <Card>
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description={
                  <Space direction="vertical">
                    <Text>No attempts yet for this certification.</Text>
                    <Text type="secondary">
                      You can register for an exam session from the Exam Registration page.
                    </Text>
                  </Space>
                }
              >
                <Button
                  type="primary"
                  href="/konnected/certifications/exam-registration"
                >
                  Go to exam registration
                </Button>
              </Empty>
            </Card>
          </Col>
        </Row>
      </KonnectedPageShell>
    )
  }

  // ---------------------------------------------------------------------------
  // Main content (normal case with attempts)
  // ---------------------------------------------------------------------------

  return (
    <KonnectedPageShell
      title="Exam Dashboard & Results"
      subtitle="Track your certification exam attempts, scores, and outcomes."
    >
      <Space direction="vertical" size={24} style={{ width: '100%' }}>
        {cooldownAlerts}

        {kpiCards}

        <Row gutter={24}>
          <Col xs={24} lg={16}>
            <Card
              title="Recent exam attempts"
              extra={
                <Space>
                  <Badge color="success" text="Passed" />
                  <Badge color="error" text="Not passed" />
                  <Badge color="processing" text="Pending / In progress" />
                </Space>
              }
            >
              <Table<ExamAttempt>
                rowKey="id"
                columns={columns}
                dataSource={attempts}
                loading={loading}
                pagination={{ pageSize: 10, showSizeChanger: false }}
                onRow={(record) => ({
                  onClick: () => handleOpenDetails(record),
                })}
              />
            </Card>
          </Col>

          <Col xs={24} lg={8}>
            <Space direction="vertical" size={16} style={{ width: '100%' }}>
              <Card title="Certification outcomes">
                <Space direction="vertical" size={8} style={{ width: '100%' }}>
                  <Paragraph>
                    When you pass a CertifiKation path (and, if required, peer validation is
                    approved), your certification is:
                  </Paragraph>
                  <List
                    size="small"
                    dataSource={[
                      'Recorded in the Evaluation & CertificationPath tables.',
                      'Linked to your Portfolio as a verifiable achievement.',
                      'Exposed as a downloadable/shareable certificate.',
                    ]}
                    renderItem={(item) => (
                      <List.Item>
                        <Text type="secondary">{item}</Text>
                      </List.Item>
                    )}
                  />
                </Space>
              </Card>

              <Card title="Tips for improving your score">
                <List
                  size="small"
                  dataSource={[
                    'Review the learning path content linked to this certification.',
                    'Use the Exam Preparation page to practice with sample questions.',
                    'Respect cooldowns between attempts to avoid rushed retries.',
                  ]}
                  renderItem={(item) => (
                    <List.Item>
                      <Text type="secondary">{item}</Text>
                    </List.Item>
                  )}
                />
              </Card>
            </Space>
          </Col>
        </Row>

        {/* Details drawer */}
        <Drawer
          title="Exam attempt details"
          width={520}
          open={!!selectedAttempt}
          onClose={handleCloseDetails}
          destroyOnClose
        >
          {selectedAttempt ? (
            <Space direction="vertical" size={16} style={{ width: '100%' }}>
              <div>
                <Title level={4}>{selectedAttempt.certificationPathName}</Title>
                <Text type="secondary">
                  Attempt #{selectedAttempt.attemptNumber} ¬∑{' '}
                  {formatDateTime(selectedAttempt.takenAt)}
                </Text>
              </div>

              <Space size={16}>
                <Statistic
                  title="Score"
                  value={selectedAttempt.scorePercent ?? 0}
                  suffix="%"
                />
                <Statistic
                  title="Pass threshold"
                  value={CERT_PASS_PERCENT}
                  suffix="%"
                />
              </Space>

              <Space direction="vertical" size={8}>
                <Text strong>Status</Text>
                {getStatusTag(selectedAttempt)}
                {getAppealTag(selectedAttempt)}
              </Space>

              <Space direction="vertical" size={8}>
                <Text strong>Validation & review</Text>
                <Space direction="vertical" size={4}>
                  <Text>
                    Peer validation required:{' '}
                    {selectedAttempt.peerValidationRequired ? 'Yes' : 'No'}
                  </Text>
                  <Text>
                    Peer validation status:{' '}
                    {selectedAttempt.peerValidationStatus ?? '‚Äî'}
                  </Text>
                  <Text>Appeal status: {selectedAttempt.appealStatus ?? 'none'}</Text>
                </Space>
              </Space>

              <Space direction="vertical" size={8}>
                <Text strong>Delivery & conditions</Text>
                <Space direction="vertical" size={4}>
                  <Text>Mode: {selectedAttempt.deliveryMode}</Text>
                  <Text>Proctored: {selectedAttempt.proctored ? 'Yes' : 'No'}</Text>
                </Space>
              </Space>

              <Space direction="vertical" size={8}>
                <Text strong>Linked assets</Text>
                <Space>
                  <Button
                    icon={<FilePdfOutlined />}
                    onClick={() => handleOpenCertificate(selectedAttempt)}
                    disabled={!selectedAttempt.certificateUrl}
                  >
                    Open certificate
                  </Button>
                  <Button
                    onClick={() => handleOpenPortfolio(selectedAttempt)}
                    disabled={!selectedAttempt.portfolioUrl}
                  >
                    View portfolio entry
                  </Button>
                </Space>
              </Space>

              {selectedAttempt.nextRetryAt && (
                <Alert
                  type={selectedAttempt.canRetry ? 'success' : 'info'}
                  showIcon
                  message={
                    selectedAttempt.canRetry
                      ? 'You can start a new attempt now.'
                      : 'Retry cooldown in effect for this path.'
                  }
                  description={
                    <Space direction="vertical" size={4}>
                      <Text>
                        Next retry available: {formatDateTime(selectedAttempt.nextRetryAt)}
                      </Text>
                      <Text type="secondary">
                        Global cooldown: {EXAM_RETRY_COOLDOWN_MIN} minutes between attempts
                        on the same path.
                      </Text>
                    </Space>
                  }
                />
              )}

              <Space>
                <Button
                  type="default"
                  icon={<WarningOutlined />}
                  loading={appealLoadingId === selectedAttempt.id}
                  onClick={() => handleOpenAppeal(selectedAttempt)}
                  disabled={selectedAttempt.appealStatus === 'open'}
                >
                  Open appeal
                </Button>
                <Button
                  type="primary"
                  icon={<ReloadOutlined />}
                  loading={retryLoadingId === selectedAttempt.id}
                  onClick={() => handleRetry(selectedAttempt)}
                  disabled={!selectedAttempt.canRetry}
                >
                  Start new attempt
                </Button>
              </Space>
            </Space>
          ) : (
            <Spin />
          )}
        </Drawer>
      </Space>
    </KonnectedPageShell>
  )
}

export default ExamDashboardResultsPage

===== END app/konnected/certifications/exam-dashboard-results/page.tsx =====


===== BEGIN app/konnected/certifications/exam-preparation/page.tsx =====
Ôªø// app/konnected/certifications/exam-preparation/page.tsx
'use client';

import React, { useMemo } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import {
  Alert,
  Button,
  Card,
  Col,
  List,
  Progress,
  Row,
  Statistic,
  Steps,
  Tabs,
  Tag,
  Typography,
  Skeleton,
  Space,
} from 'antd';
import {
  ArrowRightOutlined,
  CalendarOutlined,
  CheckCircleTwoTone,
  ClockCircleOutlined,
  FileSearchOutlined,
  FlagOutlined,
  PlayCircleOutlined,
  WarningTwoTone,
} from '@ant-design/icons';
import { useQuery } from '@tanstack/react-query';
import dayjs from 'dayjs';

import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import { get } from '@/services/_request';

const { Text } = Typography;
const { Step } = Steps;

const CERT_PASS_PERCENT = 80; // from CertifiKation spec
const QUIZ_RETRY_COOLDOWN_MIN = 30; // from CertifiKation spec

/**
 * Endpoint helper for the preparation plan of a given CertificationPath.
 * This is designed to be consistent with the other CertifiKation endpoints
 * used by exam registration and exam dashboard.
 *
 * IMPORTANT:
 * - we use a *relative* URL WITHOUT a leading "/" so that axios baseURL
 *   (NEXT_PUBLIC_API_BASE or "/api") is correctly applied.
 * - On the wire this becomes: /api/konnected/certifications/paths/:pathId/preparation-plan/
 */
const EXAM_PREPARATION_ENDPOINT = (pathId: string | number) =>
  `konnected/certifications/paths/${pathId}/preparation-plan/`;

type PrepModuleType = 'content' | 'practice_quiz' | 'project' | 'checkpoint';

type PrepModuleStatus = 'not_started' | 'in_progress' | 'completed';

interface PrepModule {
  id: string;
  title: string;
  type: PrepModuleType;
  status: PrepModuleStatus;
  progressPercent: number;
  estimatedMinutes?: number | null;
  lastTouchedAt?: string | null;
  isCriticalWeakness?: boolean;
}

interface FocusArea {
  id: string;
  label: string;
  description?: string | null;
  recommendedResourcesCount?: number | null;
}

interface ExamPreparationPathInfo {
  id: number | string;
  name: string;
  description?: string | null;
}

interface ExamPreparationExamInfo {
  targetDate?: string | null;
  recommendedStudyHours?: number | null;
  lastScorePercent?: number | null;
  lastResult?: 'pass' | 'fail' | null;
  lastAttemptAt?: string | null;
  attemptsUsed?: number | null;
  attemptsAllowed?: number | null;
  isCooldownActive?: boolean;
  cooldownEndsAt?: string | null;
  passPercent?: number | null;
  retryCooldownMinutes?: number | null;
}

interface ExamPreparationResponse {
  path?: ExamPreparationPathInfo | null;
  exam?: ExamPreparationExamInfo | null;
  overallProgressPercent?: number | null;
  modules?: PrepModule[] | null;
  focusAreas?: FocusArea[] | null;
}

function computeOverallProgress(modules: PrepModule[] | undefined | null): number {
  if (!modules || modules.length === 0) {
    return 0;
  }
  const sum = modules.reduce((acc, m) => acc + (m.progressPercent ?? 0), 0);
  return Math.round(sum / modules.length);
}

function computeStepIndex(progress: number): number {
  if (progress >= 90) return 3;
  if (progress >= 60) return 2;
  if (progress >= 30) return 1;
  return 0;
}

function getReadinessBadge(
  progress: number,
  lastScore: number | null | undefined,
  passPercent: number,
): { status: 'ready' | 'almost' | 'not_ready'; label: string; color: 'green' | 'gold' | 'red' } {
  if (lastScore != null && lastScore >= passPercent) {
    return { status: 'ready', label: 'Ready based on last score', color: 'green' };
  }
  if (progress >= passPercent - 10) {
    return { status: 'almost', label: 'Almost ready ‚Äì focus on weak areas', color: 'gold' };
  }
  return { status: 'not_ready', label: 'Not ready yet ‚Äì keep studying', color: 'red' };
}

async function fetchExamPreparation(pathId: string): Promise<ExamPreparationResponse> {
  return get<ExamPreparationResponse>(EXAM_PREPARATION_ENDPOINT(pathId));
}

export default function ExamPreparationPage(): JSX.Element {
  const router = useRouter();
  const searchParams = useSearchParams();

  const pathId = searchParams.get('pathId');
  const pathNameFromUrl = searchParams.get('pathName') || undefined;

  const { data, isLoading, error } = useQuery<ExamPreparationResponse>({
    queryKey: ['certs', 'exam-preparation', pathId],
    queryFn: () => fetchExamPreparation(pathId as string),
    enabled: !!pathId,
  });

  const modules: PrepModule[] = data?.modules ?? [];
  const focusAreas: FocusArea[] = data?.focusAreas ?? [];

  const overallProgress = useMemo(() => {
    return data?.overallProgressPercent != null
      ? Math.round(data.overallProgressPercent)
      : computeOverallProgress(modules);
  }, [data?.overallProgressPercent, modules]);

  const passPercent = data?.exam?.passPercent ?? CERT_PASS_PERCENT;
  const retryCooldownMinutes =
    data?.exam?.retryCooldownMinutes ?? QUIZ_RETRY_COOLDOWN_MIN;

  const lastScore = data?.exam?.lastScorePercent ?? null;
  const targetDate = data?.exam?.targetDate ?? null;
  const isCooldownActive = data?.exam?.isCooldownActive ?? false;
  const cooldownEndsAt = data?.exam?.cooldownEndsAt ?? null;

  const readiness = getReadinessBadge(overallProgress, lastScore, passPercent);
  const currentStepIndex = computeStepIndex(overallProgress);

  const recommendedStudyHours = data?.exam?.recommendedStudyHours ?? null;

  const effectivePathName =
    data?.path?.name ?? pathNameFromUrl ?? 'Exam Preparation';

  const handleGoToExamRegistration = () => {
    router.push('/konnected/certifications/exam-registration');
  };

  const handleGoToExamDashboard = () => {
    router.push('/konnected/certifications/exam-dashboard-results');
  };

  const handleStartPracticeExam = () => {
    // Future: plug into automated_evaluation ‚Äúpractice mode‚Äù endpoint / route
    router.push('/konnected/certifications/exam-dashboard-results');
  };

  const subtitle = (
    <>
      Get an at-a-glance view of your preparation for this certification path:
      study modules, focus areas, readiness vs. the {passPercent}% pass threshold,
      and next steps.
    </>
  );

  const renderModulesList = () => {
    if (!isLoading && modules.length === 0) {
      return (
        <Alert
          type="info"
          showIcon
          message="No study modules are defined yet."
          description="Once your CertificationPath is configured with learning units, they will appear here as a guided preparation plan."
        />
      );
    }

    if (isLoading) {
      return <Skeleton active paragraph={{ rows: 4 }} />;
    }

    return (
      <List
        itemLayout="horizontal"
        dataSource={modules}
        renderItem={(module) => (
          <List.Item
            actions={[
              <Button
                type="link"
                key="view"
                icon={<ArrowRightOutlined />}
                // Future: route to the actual learning unit detail, once available
                onClick={() => {
                  // eslint-disable-next-line no-console
                  console.log('Open module', module.id);
                }}
              >
                View module
              </Button>,
            ]}
          >
            <List.Item.Meta
              title={
                <Space size="small">
                  <span>{module.title}</span>
                  {module.status === 'completed' && (
                    <CheckCircleTwoTone twoToneColor="#52c41a" />
                  )}
                  {module.isCriticalWeakness && (
                    <Tag color="volcano" icon={<WarningTwoTone twoToneColor="#fa541c" />}>
                      Focus area
                    </Tag>
                  )}
                </Space>
              }
              description={
                <Space direction="vertical" size={2}>
                  <Space size="small" wrap>
                    <Tag>
                      {module.type === 'content'
                        ? 'Content'
                        : module.type === 'practice_quiz'
                        ? 'Practice quiz'
                        : module.type === 'project'
                        ? 'Project'
                        : 'Checkpoint'}
                    </Tag>
                    <Text type="secondary">
                      {module.status === 'completed'
                        ? 'Completed'
                        : module.status === 'in_progress'
                        ? `In progress ‚Äì ${module.progressPercent}%`
                        : 'Not started yet'}
                    </Text>
                    {module.estimatedMinutes != null && (
                      <Text type="secondary">
                        ‚Ä¢ ~{module.estimatedMinutes} min
                      </Text>
                    )}
                  </Space>
                  <Progress
                    percent={Math.round(module.progressPercent)}
                    size="small"
                    status={module.status === 'completed' ? 'success' : 'active'}
                  />
                  {module.lastTouchedAt && (
                    <Text type="secondary" style={{ fontSize: 12 }}>
                      Last worked on:{' '}
                      {dayjs(module.lastTouchedAt).format('MMM D, YYYY HH:mm')}
                    </Text>
                  )}
                </Space>
              }
            />
          </List.Item>
        )}
      />
    );
  };

  const renderFocusAreas = () => {
    if (!isLoading && focusAreas.length === 0) {
      return (
        <Alert
          type="info"
          showIcon
          message="No specific focus areas identified yet."
          description="Once you complete some evaluations, the system will highlight weak domains to prioritize in your study time."
        />
      );
    }

    if (isLoading) {
      return <Skeleton active paragraph={{ rows: 3 }} />;
    }

    return (
      <List
        dataSource={focusAreas}
        renderItem={(area) => (
          <List.Item>
            <List.Item.Meta
              title={
                <Space>
                  <FlagOutlined />
                  <span>{area.label}</span>
                </Space>
              }
              description={
                <>
                  {area.description && (
                    <Text type="secondary" style={{ display: 'block' }}>
                      {area.description}
                    </Text>
                  )}
                  {area.recommendedResourcesCount != null && (
                    <Text type="secondary" style={{ fontSize: 12 }}>
                      {area.recommendedResourcesCount} recommended resources
                      {area.recommendedResourcesCount === 1 ? '' : 's'} in Knowledge
                    </Text>
                  )}
                </>
              }
            />
          </List.Item>
        )}
      />
    );
  };

  const mainTabsItems = [
    {
      key: 'plan',
      label: 'Study plan & progress',
      children: (
        <Card variant="borderless">
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <div>
              <Text strong>Your overall preparation progress</Text>
              <Progress
                percent={overallProgress}
                status={overallProgress >= passPercent ? 'success' : 'active'}
              />
              <Text type="secondary" style={{ fontSize: 12 }}>
                Based on all study modules in this CertificationPath.
              </Text>
            </div>

            <div>
              <Text strong>Recommended sequence</Text>
              <Steps
                direction="vertical"
                size="small"
                current={currentStepIndex}
                style={{ marginTop: 8 }}
              >
                <Step
                  title="Study core content"
                  description="Work through required modules and lessons."
                />
                <Step
                  title="Complete practice activities"
                  description="Interactive exercises, quizzes, and projects."
                />
                <Step
                  title="Attempt a practice evaluation"
                  description={`Use automated_evaluation in ‚Äúpractice mode‚Äù to benchmark against ${passPercent}%.`}
                />
                <Step
                  title="Review feedback & focus areas"
                  description="Revisit weak domains before booking the official exam."
                />
              </Steps>
            </div>

            <Button
              type="primary"
              icon={<PlayCircleOutlined />}
              onClick={handleStartPracticeExam}
              disabled={isCooldownActive}
            >
              Start practice exam
            </Button>

            {isCooldownActive && cooldownEndsAt && (
              <Alert
                type="warning"
                showIcon
                message="Practice exam on cooldown"
                description={
                  <>
                    You recently attempted a practice evaluation. You can try again after{' '}
                    {dayjs(cooldownEndsAt).format('MMM D, YYYY HH:mm')} (cooldown{' '}
                    {retryCooldownMinutes} minutes).
                  </>
                }
              />
            )}
          </Space>
        </Card>
      ),
    },
    {
      key: 'focus',
      label: 'Focus areas',
      children: <Card variant="borderless">{renderFocusAreas()}</Card>,
    },
  ];

  const noPathSelected = !pathId && !data;

  return (
    <KonnectedPageShell
      title={effectivePathName}
      subtitle={subtitle}
      primaryAction={
        <Button
          type="primary"
          icon={<CalendarOutlined />}
          onClick={handleGoToExamRegistration}
        >
          Exam registration
        </Button>
      }
      secondaryActions={
        <Button
          icon={<FileSearchOutlined />}
          onClick={handleGoToExamDashboard}
        >
          Exam dashboard
        </Button>
      }
    >
      {noPathSelected && (
        <Alert
          type="info"
          showIcon
          style={{ marginBottom: 16 }}
          message="No certification path selected"
          description="Open this page from a specific Certification Program (e.g. from the Programs list) to see a tailored preparation plan."
        />
      )}

      {error && !noPathSelected && (
        <Alert
          type="error"
          showIcon
          style={{ marginBottom: 16 }}
          message="Unable to load your exam preparation data"
          description="Please try again in a moment. If the problem persists, contact an administrator."
        />
      )}

      <Row gutter={[24, 24]}>
        {/* Left: modules + plan */}
        <Col xs={24} lg={16}>
          <Card
            title={
              data?.path?.name
                ? `Study modules for: ${data.path.name}`
                : 'Study modules'
            }
            extra={
              <Tag color={readiness.color} icon={<FlagOutlined />}>
                {readiness.label}
              </Tag>
            }
            style={{ marginBottom: 24 }}
          >
            {renderModulesList()}
          </Card>

          <Tabs
            defaultActiveKey="plan"
            items={mainTabsItems}
            destroyInactiveTabPane={false}
          />
        </Col>

        {/* Right: metrics + focus summary */}
        <Col xs={24} lg={8}>
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <Card>
              {isLoading && pathId ? (
                <Skeleton active paragraph={{ rows: 3 }} />
              ) : (
                <>
                  <Row gutter={[16, 16]}>
                    <Col span={12}>
                      <Statistic
                        title="Overall progress"
                        value={overallProgress}
                        suffix="%"
                      />
                    </Col>
                    <Col span={12}>
                      <Statistic
                        title="Pass threshold"
                        value={passPercent}
                        suffix="%"
                      />
                    </Col>
                  </Row>

                  <Row gutter={[16, 16]} style={{ marginTop: 16 }}>
                    <Col span={12}>
                      <Statistic
                        title="Recommended study time"
                        value={
                          recommendedStudyHours != null
                            ? recommendedStudyHours
                            : '‚Äî'
                        }
                        suffix={recommendedStudyHours != null ? 'hrs' : undefined}
                        prefix={<ClockCircleOutlined />}
                      />
                    </Col>
                    <Col span={12}>
                      <Statistic
                        title="Retry cooldown"
                        value={retryCooldownMinutes}
                        suffix="min"
                        prefix={<ClockCircleOutlined />}
                      />
                    </Col>
                  </Row>

                  <div style={{ marginTop: 16 }}>
                    <Text type="secondary" style={{ display: 'block' }}>
                      Pass/fail uses a frozen threshold ({passPercent}%), and
                      failed attempts are throttled by a{' '}
                      {retryCooldownMinutes}-minute cooldown.
                    </Text>
                  </div>
                </>
              )}
            </Card>

            <Card title="Upcoming exam">
              {isLoading && pathId ? (
                <Skeleton active paragraph={{ rows: 2 }} />
              ) : targetDate ? (
                <>
                  <Space direction="vertical" size="small">
                    <Space>
                      <CalendarOutlined />
                      <Text strong>
                        {dayjs(targetDate).format('MMMM D, YYYY')}
                      </Text>
                    </Space>
                    <Text type="secondary">
                      Make sure your preparation progress and practice scores are
                      comfortably above {passPercent}% before this date.
                    </Text>
                  </Space>
                  <Button
                    type="link"
                    icon={<CalendarOutlined />}
                    style={{ marginTop: 12, paddingLeft: 0 }}
                    onClick={handleGoToExamRegistration}
                  >
                    Adjust exam session
                  </Button>
                </>
              ) : (
                <>
                  <Alert
                    type="info"
                    showIcon
                    message="No exam date scheduled"
                    description="Book a session to lock in your target exam date and align your study plan."
                  />
                  <Button
                    type="primary"
                    icon={<CalendarOutlined />}
                    style={{ marginTop: 12 }}
                    onClick={handleGoToExamRegistration}
                  >
                    Schedule exam
                  </Button>
                </>
              )}
            </Card>

            <Card title="Focus summary">
              {isLoading && pathId ? (
                <Skeleton active paragraph={{ rows: 3 }} />
              ) : (
                <>
                  {focusAreas.length > 0 ? (
                    <>
                      <Text>
                        You have {focusAreas.length} identified focus{' '}
                        {focusAreas.length === 1 ? 'area' : 'areas'} based on your
                        evaluations.
                      </Text>
                      <div style={{ marginTop: 12 }}>{renderFocusAreas()}</div>
                      <Button
                        type="link"
                        style={{ marginTop: 8, paddingLeft: 0 }}
                        onClick={handleGoToExamDashboard}
                      >
                        View detailed breakdown in Exam Dashboard
                      </Button>
                    </>
                  ) : (
                    <Text type="secondary">
                      Once you complete your first practice or official exam,
                      we will highlight weak domains and recommended topics
                      here.
                    </Text>
                  )}
                </>
              )}
            </Card>
          </Space>
        </Col>
      </Row>
    </KonnectedPageShell>
  );
}

===== END app/konnected/certifications/exam-preparation/page.tsx =====


===== BEGIN app/konnected/certifications/exam-registration/page.tsx =====
Ôªø// app/konnected/certifications/exam-registration/page.tsx
Ôªø'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useSearchParams } from 'next/navigation';
import {
  App as AntdApp,
  Alert,
  Button,
  Card,
  Checkbox,
  Empty,
  Form,
  Input,
  Result,
  Select,
  Space,
  Spin,
  Steps,
  Typography,
} from 'antd';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import PageContainer from '@/components/PageContainer';

const { Step } = Steps;
const { Option } = Select;
const { Paragraph, Text } = Typography;

/**
 * NOTE ABOUT ENDPOINTS
 *
 * These constants are aligned with the v14 backend spec:
 * - Certification paths:   /api/konnected/certifications/paths/
 * - Exam registrations:    /api/konnected/certifications/evaluations/
 * - Eligibility / sessions:
 *     /api/konnected/certifications/paths/:id/eligibility/
 *     /api/konnected/certifications/paths/:id/sessions/
 */
const EXAM_PATHS_ENDPOINT = '/api/konnected/certifications/paths/';
const EXAM_SESSIONS_ENDPOINT = (pathId: number | string) =>
  `/api/konnected/certifications/paths/${pathId}/sessions/`;
const EXAM_REGISTRATION_ENDPOINT = '/api/konnected/certifications/evaluations/';
const EXAM_ELIGIBILITY_ENDPOINT = (pathId: number | string) =>
  `/api/konnected/certifications/paths/${pathId}/eligibility/`;

/**
 * Domain types derived from CertifiKation & Knowledge specs + API schema.
 * Adjust the shapes to match your generated types from schema-endpoints.json.
 */
type CertificationPath = {
  id: number;
  name: string;
  description?: string;
  level?: string;
  tags?: string[];
  // Optional, may be provided by backend via aggregate / annotated fields
  already_passed?: boolean;
  cooldown_remaining_minutes?: number | null;
};

type ExamSession = {
  id: number;
  start_at: string; // ISO datetime
  end_at?: string | null;
  timezone?: string | null;
  modality?: string | null; // e.g. 'online', 'remote_proctored', 'in_person'
  location?: string | null;
  capacity?: number | null;
  seats_remaining?: number | null;
  registration_deadline?: string | null;
};

type ExamEligibility = {
  already_passed: boolean;
  cooldown_remaining_minutes: number;
};

interface ExamRegistrationFormValues {
  examPathId?: number;
  sessionId?: number;
  fullName?: string;
  agreeTerms?: boolean;
}

type StepKey = 0 | 1 | 2;

const steps: { key: StepKey; title: string; description?: string }[] = [
  { key: 0, title: 'Choose exam', description: 'Select the certification you want to attempt.' },
  {
    key: 1,
    title: 'Schedule & details',
    description: 'Pick an exam session and confirm your details.',
  },
  { key: 2, title: 'Confirm', description: 'Review and submit your registration.' },
];

const ExamRegistrationPageInner: React.FC = () => {
  const { message: messageApi } = AntdApp.useApp();
  const searchParams = useSearchParams();
  const [form] = Form.useForm<ExamRegistrationFormValues>();

  const [currentStep, setCurrentStep] = useState<StepKey>(0);
  const [paths, setPaths] = useState<CertificationPath[]>([]);
  const [pathsLoading, setPathsLoading] = useState<boolean>(false);
  const [pathsError, setPathsError] = useState<string | null>(null);

  const [sessions, setSessions] = useState<ExamSession[]>([]);
  const [sessionsLoading, setSessionsLoading] = useState<boolean>(false);
  const [sessionsError, setSessionsError] = useState<string | null>(null);

  const [eligibility, setEligibility] = useState<ExamEligibility | null>(null);
  const [eligibilityLoading, setEligibilityLoading] = useState<boolean>(false);

  const [submitting, setSubmitting] = useState<boolean>(false);
  const [registrationCompleted, setRegistrationCompleted] = useState<boolean>(false);

  /**
   * Load available certification paths (exams) on mount.
   */
  useEffect(() => {
    const fetchPaths = async () => {
      setPathsLoading(true);
      setPathsError(null);
      try {
        const res = await fetch(EXAM_PATHS_ENDPOINT, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
        });

        if (!res.ok) {
          throw new Error(`Failed to load certification programs (${res.status})`);
        }

        const data = (await res.json()) as CertificationPath[];
        setPaths(data);
      } catch (err: any) {
        const msg = err?.message ?? 'Failed to load certification programs.';
        setPathsError(msg);
        messageApi.error(msg);
      } finally {
        setPathsLoading(false);
      }
    };

    void fetchPaths();
  }, [messageApi]);

  // If the user came from the programs page with ?pathId=..., preselect it.
  const initialPathIdFromQuery = searchParams.get('pathId');
  useEffect(() => {
    if (!initialPathIdFromQuery) return;
    const numericId = Number(initialPathIdFromQuery);
    if (Number.isNaN(numericId)) return;
    if (!paths.length) return;

    const exists = paths.some((p) => p.id === numericId);
    if (!exists) return;

    const current = form.getFieldValue('examPathId');
    if (!current) {
      form.setFieldsValue({ examPathId: numericId });
    }
  }, [initialPathIdFromQuery, paths, form]);

  const selectedPathId = Form.useWatch('examPathId', form);
  const selectedSessionId = Form.useWatch('sessionId', form);
  const fullName = Form.useWatch('fullName', form);

  const selectedPath = useMemo(
    () => paths.find((p) => p.id === selectedPathId),
    [paths, selectedPathId],
  );
  const selectedSession = useMemo(
    () => sessions.find((s) => s.id === selectedSessionId),
    [sessions, selectedSessionId],
  );

  /**
   * When the selected path changes, load sessions and eligibility.
   * Both are optional server-side features; we treat 404 as "not implemented".
   * Also clear any previously selected session to avoid stale selections.
   */
  useEffect(() => {
    if (!selectedPathId) {
      setSessions([]);
      setEligibility(null);
      form.setFieldsValue({ sessionId: undefined });
      return;
    }

    // Reset session selection whenever the path changes.
    form.setFieldsValue({ sessionId: undefined });

    const fetchEligibility = async () => {
      setEligibilityLoading(true);
      try {
        const res = await fetch(EXAM_ELIGIBILITY_ENDPOINT(selectedPathId), {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
        });
        if (res.ok) {
          const data = (await res.json()) as ExamEligibility;
          setEligibility(data);
        } else if (res.status === 404) {
          // Eligibility endpoint not implemented yet; fall back to path fields.
          setEligibility(null);
        } else {
          throw new Error(`Failed to load eligibility (${res.status})`);
        }
      } catch {
        // Non-fatal: we can still continue with path-level info
        setEligibility(null);
      } finally {
        setEligibilityLoading(false);
      }
    };

    const fetchSessions = async () => {
      setSessionsLoading(true);
      setSessionsError(null);
      try {
        const res = await fetch(EXAM_SESSIONS_ENDPOINT(selectedPathId), {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
        });

        if (!res.ok) {
          throw new Error(`Failed to load exam sessions (${res.status})`);
        }

        const data = (await res.json()) as ExamSession[];
        setSessions(data);
      } catch (err: any) {
        const msg = err?.message ?? 'Failed to load exam sessions.';
        setSessionsError(msg);
        messageApi.error(msg);
      } finally {
        setSessionsLoading(false);
      }
    };

    void fetchEligibility();
    void fetchSessions();
  }, [selectedPathId, messageApi, form]);

  const isPathAlreadyPassed =
    eligibility?.already_passed ?? (selectedPath?.already_passed ?? false);
  const cooldownMinutes =
    eligibility?.cooldown_remaining_minutes ?? (selectedPath?.cooldown_remaining_minutes ?? 0);
  const isUnderCooldown = !!cooldownMinutes && cooldownMinutes > 0;

  const cannotRegisterForPath = isPathAlreadyPassed || isUnderCooldown;

  const handleNext = async () => {
    try {
      if (currentStep === 0) {
        await form.validateFields(['examPathId']);
      } else if (currentStep === 1) {
        await form.validateFields(['sessionId', 'fullName', 'agreeTerms']);
      }
      setCurrentStep((prev) => (prev + 1) as StepKey);
    } catch {
      // errors are displayed by antd Form
    }
  };

  const handlePrev = () => {
    setCurrentStep((prev) => (prev - 1) as StepKey);
  };

  const handleSubmit = async () => {
    try {
      await form.validateFields();
    } catch {
      return;
    }

    const values = form.getFieldsValue() as Required<ExamRegistrationFormValues>;

    if (!values.examPathId || !values.sessionId) {
      messageApi.error('Please select an exam and session before submitting.');
      return;
    }

    // Payload aligned with EvaluationViewSet.create:
    //   { path_id, session_id, full_name, agreed_terms }
    const payload = {
      path_id: values.examPathId,
      session_id: values.sessionId,
      full_name: values.fullName,
      agreed_terms: values.agreeTerms === true,
    };

    setSubmitting(true);
    try {
      const res = await fetch(EXAM_REGISTRATION_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(payload),
      });

      if (res.ok || res.status === 201) {
        setRegistrationCompleted(true);
        messageApi.success('Exam registration completed successfully.');
        return;
      }

      if (res.status === 409) {
        // Conflict: cooldown, already passed, capacity reached, etc.
        const errorBody = (await res.json().catch(() => null)) as any;
        const detail: string =
          errorBody?.detail ||
          errorBody?.message ||
          'You cannot register for this exam at the moment.';

        messageApi.error(detail);
        return;
      }

      const errorBody = (await res.json().catch(() => null)) as any;
      const detail: string =
        errorBody?.detail || errorBody?.message || 'Failed to complete registration.';
      messageApi.error(detail);
    } catch (err: any) {
      const msg = err?.message ?? 'Unexpected error while registering for the exam.';
      messageApi.error(msg);
    } finally {
      setSubmitting(false);
    }
  };

  const renderExamChoiceStep = () => {
    if (pathsLoading) {
      return (
        <div className="flex justify-center py-8">
          <Space>
            <Spin />
            <Text>Loading certification programs...</Text>
          </Space>
        </div>
      );
    }

    if (pathsError) {
      return (
        <Alert
          type="error"
          message="Unable to load certification programs"
          description={pathsError}
          showIcon
        />
      );
    }

    if (!paths.length) {
      return (
        <Empty
          description="No certification programs are available for registration at this time."
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        />
      );
    }

    return (
      <Space direction="vertical" size="large" className="w-full">
        <Form.Item
          name="examPathId"
          label="Certification exam"
          rules={[{ required: true, message: 'Please select a certification exam.' }]}
        >
          <Select
            placeholder="Select an exam to register for"
            optionFilterProp="children"
            showSearch
          >
            {paths.map((path) => (
              <Option key={path.id} value={path.id}>
                {path.name}
                {path.level ? ` ¬∑ ${path.level}` : ''}
              </Option>
            ))}
          </Select>
        </Form.Item>

        {selectedPath && (
          <Card title={selectedPath.name}>
            {selectedPath.description && <Paragraph>{selectedPath.description}</Paragraph>}
            {selectedPath.tags && selectedPath.tags.length > 0 && (
              <Paragraph>
                {selectedPath.tags.map((tag) => (
                  <Text key={tag} code className="mr-2">
                    {tag}
                  </Text>
                ))}
              </Paragraph>
            )}

            <Space direction="vertical" size="small" style={{ marginTop: 8 }}>
              {isPathAlreadyPassed && (
                <Alert
                  type="success"
                  message="You are already certified for this path."
                  description="Creating new attempts is not allowed because you already hold this certification."
                  showIcon
                />
              )}

              {isUnderCooldown && (
                <Alert
                  type="warning"
                  message="Retry cooldown active"
                  description={`You must wait ${cooldownMinutes} more minutes before registering another attempt for this exam.`}
                  showIcon
                />
              )}
            </Space>
          </Card>
        )}
      </Space>
    );
  };

  const renderScheduleStep = () => {
    if (!selectedPathId) {
      return (
        <Alert
          type="info"
          message="Select an exam first"
          description="Choose a certification exam in the previous step before picking a session."
          showIcon
        />
      );
    }

    return (
      <Space direction="vertical" size="large" className="w-full">
        {sessionsLoading && (
          <div className="flex justify-center py-4">
            <Space>
              <Spin />
              <Text>Loading exam sessions...</Text>
            </Space>
          </div>
        )}

        {sessionsError && (
          <Alert
            type="error"
            message="Unable to load exam sessions"
            description={sessionsError}
            showIcon
          />
        )}

        {!sessionsLoading && !sessionsError && sessions.length === 0 && (
          <Alert
            type="warning"
            message="No sessions available"
            description="There are currently no upcoming sessions for this exam. Please check back later or contact your administrator."
            showIcon
          />
        )}

        <Form.Item
          name="sessionId"
          label="Exam session"
          rules={[{ required: true, message: 'Please select an exam session.' }]}
        >
          <Select placeholder="Select a session" disabled={sessions.length === 0}>
            {sessions.map((session) => {
              const start = new Date(session.start_at);
              const end = session.end_at ? new Date(session.end_at) : null;
              const timeLabel = `${start.toLocaleString()}${
                end ? ` ‚Äì ${end.toLocaleTimeString()}` : ''
              }`;
              const seats =
                typeof session.seats_remaining === 'number'
                  ? `${session.seats_remaining} seats left`
                  : 'Capacity info unavailable';

              const labelParts = [
                timeLabel,
                session.modality ? ` ¬∑ ${session.modality}` : '',
                session.location ? ` ¬∑ ${session.location}` : '',
                ` ¬∑ ${seats}`,
              ];

              return (
                <Option key={session.id} value={session.id}>
                  {labelParts.join('')}
                </Option>
              );
            })}
          </Select>
        </Form.Item>

        <Form.Item
          name="fullName"
          label="Full name"
          rules={[{ required: true, message: 'Please enter your full name.' }]}
        >
          <Input placeholder="This will be used on your exam record and certificate" />
        </Form.Item>

        <Form.Item
          name="agreeTerms"
          valuePropName="checked"
          rules={[
            {
              validator: (_, value) =>
                value
                  ? Promise.resolve()
                  : Promise.reject(
                      new Error('You must agree to the exam policies to continue.'),
                    ),
            },
          ]}
        >
          <Checkbox>
            I confirm that I have read and agree to the exam terms, proctoring rules, and
            integrity policies.
          </Checkbox>
        </Form.Item>

        <Alert
          type="info"
          showIcon
          message="Before you register"
          description={
            <span>
              You will be able to view this exam and its status in your Exam Dashboard after
              registration. You must achieve at least <b>80%</b> to pass, and there is a{' '}
              <b>30-minute retry cooldown</b> if you fail an attempt.
            </span>
          }
        />
      </Space>
    );
  };

  const renderConfirmStep = () => {
    // Also guard on selectedSession to avoid crashes if sessions changed.
    if (!selectedPath || !selectedSessionId || !selectedSession) {
      return (
        <Alert
          type="info"
          message="Incomplete registration"
          description="Please select an exam and session in the previous steps before confirming."
          showIcon
        />
      );
    }

    const session = selectedSession;
    const start = new Date(session.start_at);
    const end = session.end_at ? new Date(session.end_at) : null;

    return (
      <Space direction="vertical" size="large" className="w-full">
        <Card title="Review your registration">
          <Space direction="vertical" size="middle">
            <div>
              <Text type="secondary">Certification exam</Text>
              <br />
              <Text strong>{selectedPath.name}</Text>
              {selectedPath.level && (
                <>
                  {' '}
                  <Text type="secondary">¬∑ {selectedPath.level}</Text>
                </>
              )}
            </div>

            <div>
              <Text type="secondary">Session</Text>
              <br />
              <Text strong>
                {start.toLocaleString()}
                {end && <> ‚Äì {end.toLocaleTimeString()}</>}
              </Text>
              {session.modality && (
                <>
                  <br />
                  <Text type="secondary">Mode: {session.modality}</Text>
                </>
              )}
              {session.location && (
                <>
                  <br />
                  <Text type="secondary">Location: {session.location}</Text>
                </>
              )}
            </div>

            <div>
              <Text type="secondary">Name on record</Text>
              <br />
              <Text strong>{fullName || 'Not provided'}</Text>
            </div>
          </Space>
        </Card>

        <Alert
          type="warning"
          showIcon
          message="Please confirm"
          description="Once you submit, this session will be reserved for you, subject to capacity and eligibility checks. You may need to contact support to change or cancel your booking."
        />
      </Space>
    );
  };

  const renderStepContent = () => {
    if (registrationCompleted) {
      return null;
    }

    switch (currentStep) {
      case 0:
        return renderExamChoiceStep();
      case 1:
        return renderScheduleStep();
      case 2:
        return renderConfirmStep();
      default:
        return null;
    }
  };

  const renderFooterButtons = () => {
    if (registrationCompleted) {
      return null;
    }

    const isFirstStep = currentStep === 0;
    const isLastStep = currentStep === steps.length - 1;

    const nextDisabled =
      currentStep === 0
        ? !selectedPathId || cannotRegisterForPath
        : currentStep === 1
        ? !selectedSessionId
        : false;

    return (
      <Space style={{ marginTop: 24 }}>
        {!isFirstStep && (
          <Button onClick={handlePrev} disabled={submitting}>
            Back
          </Button>
        )}
        {!isLastStep && (
          <Button
            type="primary"
            onClick={handleNext}
            disabled={nextDisabled || (currentStep === 0 && cannotRegisterForPath)}
          >
            Next
          </Button>
        )}
        {isLastStep && (
          <Button
            type="primary"
            onClick={handleSubmit}
            loading={submitting}
            disabled={cannotRegisterForPath}
          >
            Submit registration
          </Button>
        )}
      </Space>
    );
  };

  if (registrationCompleted) {
    return (
      <KonnectedPageShell
        title="Exam registration completed"
        subtitle="Your exam attempt has been scheduled. You can review your registrations and outcomes in the Exam Dashboard."
      >
        <PageContainer title="Exam registration completed">
          <Result
            status="success"
            title="Your exam registration is confirmed"
            subTitle="You will receive a confirmation with details by email. You can also review this exam under your Exam Dashboard."
            extra={
              <Space>
                <Button type="primary" href="/konnected/certifications/exam-dashboard-results">
                  Go to Exam Dashboard
                </Button>
                <Button href="/konnected/certifications/exam-preparation">
                  View preparation resources
                </Button>
              </Space>
            }
          />
        </PageContainer>
      </KonnectedPageShell>
    );
  }

  return (
    <KonnectedPageShell
      title="Register for an exam"
      subtitle="Choose a certification exam, pick a session, and confirm your registration."
    >
      <PageContainer title="Register for an exam">
        <Card>
          <Space direction="vertical" size="large" className="w-full">
            <div>
              <Steps current={currentStep} responsive>
                {steps.map((step) => (
                  <Step key={step.key} title={step.title} description={step.description} />
                ))}
              </Steps>
            </div>

            {(eligibilityLoading || pathsLoading) && (
              <Alert
                type="info"
                showIcon
                message="Loading exam options"
                description="We are loading the available certification programs and checking your eligibility."
              />
            )}

            <Form<ExamRegistrationFormValues> layout="vertical" form={form}>
              {renderStepContent()}
            </Form>

            {renderFooterButtons()}
          </Space>
        </Card>
      </PageContainer>
    </KonnectedPageShell>
  );
};

const ExamRegistrationPage: React.FC = () => (
  <AntdApp>
    <ExamRegistrationPageInner />
  </AntdApp>
);

export default ExamRegistrationPage;

===== END app/konnected/certifications/exam-registration/page.tsx =====


===== BEGIN app/konnected/community-discussions/active-threads/page.tsx =====
Ôªø// C:\MyCode\Konnaxionv14\frontend\app\konnected\community-discussions\active-threads\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Alert,
  Avatar,
  Badge,
  Button,
  Card,
  Empty,
  Input,
  List,
  Pagination,
  Select,
  Skeleton,
  Space,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  FireOutlined,
  MessageTwoTone,
  QuestionCircleOutlined,
  ReloadOutlined,
  SearchOutlined,
  TeamOutlined,
} from '@ant-design/icons';
import { useQuery } from '@tanstack/react-query';
import { api } from '@/shared/api';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text, Paragraph } = Typography;
const { Option } = Select;

// Real backend endpoints (joined with api baseURL)
const FORUM_TOPICS_ENDPOINT = 'forum-topics/';
const FORUM_POSTS_ENDPOINT = 'forum-posts/';

type TopicKind = 'question' | 'discussion';
type TopicStatus = 'open' | 'closed' | 'archived';

export interface ForumTopicSummary {
  id: string;
  title: string;
  category?: string | null;
  kind?: TopicKind | null; // question vs discussion
  status?: TopicStatus | null;
  tags?: string[];
  replies_count: number;
  participants_count?: number;
  last_activity_at: string;
  last_activity_by?: string | null;
  last_activity_snippet?: string | null;
  created_by_name?: string | null;
  created_by_avatar_url?: string | null;
  is_pinned?: boolean;
  is_unread?: boolean;
  linked_resource_title?: string | null; // if tied to a KnowledgeResource
}

interface ActiveThreadsResponse {
  results: ForumTopicSummary[];
  page: number;
  page_size: number;
  total: number;
}

// Shape returned by /api/forum-topics/
interface ForumTopicApi {
  id: number | string;
  title: string;
  category?: string | null;
  creator?: string | number | null;
  created_at: string;
  updated_at: string;
}

// Shape returned by /api/forum-posts/
interface ForumPostApi {
  id: number | string;
  topic: number | string;
  author?: string | number | null;
  content: string;
  created_at: string;
  updated_at: string;
}

/** Local UI state ‚Üí query params mapping (purely client-side) */
type TopicFilter = 'all' | 'questions' | 'discussions';
type SortOption = 'recent' | 'most_replies' | 'most_active';

function useActiveThreads(params: {
  page: number;
  pageSize: number;
  search: string;
  topicFilter: TopicFilter;
  sort: SortOption;
}) {
  const queryState = useMemo(
    () => ({
      page: params.page,
      pageSize: params.pageSize,
      search: params.search.trim().toLowerCase(),
      topicFilter: params.topicFilter,
      sort: params.sort,
    }),
    [params.page, params.pageSize, params.search, params.topicFilter, params.sort],
  );

  return useQuery<ActiveThreadsResponse, Error>({
    queryKey: ['konnected-active-threads', queryState],
    staleTime: 60_000,
    queryFn: async () => {
      // Fetch raw topics and posts from the real backend.
      const [topicsRes, postsRes] = await Promise.all([
        api.get<ForumTopicApi[]>(FORUM_TOPICS_ENDPOINT),
        api.get<ForumPostApi[]>(FORUM_POSTS_ENDPOINT),
      ]);

      const topics = topicsRes.data ?? [];
      const posts = postsRes.data ?? [];

      // Aggregate per-topic stats from posts.
      const perTopicStats = new Map<
        number,
        { replies: number; lastActivityAt: string; lastActivityBy?: string | null }
      >();

      for (const post of posts) {
        const topicIdNum = Number(post.topic);
        if (!Number.isFinite(topicIdNum)) continue;

        const current = perTopicStats.get(topicIdNum) ?? {
          replies: 0,
          lastActivityAt: '',
          lastActivityBy: undefined,
        };

        const candidateTs = post.updated_at || post.created_at;
        const candidateTime = new Date(candidateTs).getTime();
        const existingTime = new Date(current.lastActivityAt || 0).getTime();

        if (!Number.isNaN(candidateTime) && candidateTime >= existingTime) {
          current.lastActivityAt = candidateTs;
          current.lastActivityBy =
            post.author != null ? String(post.author) : current.lastActivityBy;
        }

        current.replies += 1;
        perTopicStats.set(topicIdNum, current);
      }

      // Build forum summaries from topics + aggregated stats.
      let summaries: ForumTopicSummary[] = topics.map((topic) => {
        const topicIdNum = Number(topic.id);
        const stats = Number.isFinite(topicIdNum)
          ? perTopicStats.get(topicIdNum as number)
          : undefined;

        const creatorName =
          topic.creator != null ? String(topic.creator) : undefined;

        const lastActivityAt =
          stats?.lastActivityAt || topic.updated_at || topic.created_at;

        const inferredKind: TopicKind =
          topic.title?.trim().endsWith('?') ? 'question' : 'discussion';

        return {
          id: String(topic.id),
          title: topic.title,
          category: topic.category ?? null,
          kind: inferredKind,
          status: 'open',
          tags: undefined,
          replies_count: stats?.replies ?? 0,
          participants_count: undefined,
          last_activity_at: lastActivityAt,
          last_activity_by: stats?.lastActivityBy ?? creatorName ?? null,
          last_activity_snippet: undefined,
          created_by_name: creatorName ?? null,
          created_by_avatar_url: null,
          is_pinned: false,
          is_unread: false,
          linked_resource_title: null,
        };
      });

      // Client-side search filter.
      if (queryState.search) {
        summaries = summaries.filter((t) => {
          const haystack = `${t.title} ${t.category ?? ''}`.toLowerCase();
          return haystack.includes(queryState.search);
        });
      }

      // Thread type filter based on inferred kind.
      if (queryState.topicFilter === 'questions') {
        summaries = summaries.filter((t) => t.kind === 'question');
      } else if (queryState.topicFilter === 'discussions') {
        summaries = summaries.filter((t) => t.kind === 'discussion');
      }

      // Sorting.
      summaries.sort((a, b) => {
        if (queryState.sort === 'most_replies') {
          return (b.replies_count ?? 0) - (a.replies_count ?? 0);
        }
        if (queryState.sort === 'most_active') {
          const aMetric = (a.participants_count ?? 0) || a.replies_count;
          const bMetric = (b.participants_count ?? 0) || b.replies_count;
          return bMetric - aMetric;
        }

        // Default: most recent activity.
        const aTime = new Date(a.last_activity_at).getTime();
        const bTime = new Date(b.last_activity_at).getTime();
        return (Number.isNaN(bTime) ? 0 : bTime) - (Number.isNaN(aTime) ? 0 : aTime);
      });

      const total = summaries.length;
      const startIndex = (queryState.page - 1) * queryState.pageSize;
      const endIndex = startIndex + queryState.pageSize;
      const pageResults = summaries.slice(startIndex, endIndex);

      return {
        results: pageResults,
        page: queryState.page,
        page_size: queryState.pageSize,
        total,
      };
    },
  });
}

export default function ActiveThreadsPage() {
  const router = useRouter();

  // Paging + filters
  const [page, setPage] = useState(1);
  const [pageSize] = useState(10);
  const [search, setSearch] = useState('');
  const [pendingSearch, setPendingSearch] = useState('');
  const [topicFilter, setTopicFilter] = useState<TopicFilter>('all');
  const [sort, setSort] = useState<SortOption>('recent');

  const { data, isLoading, isFetching, isError, error, refetch } = useActiveThreads({
    page,
    pageSize,
    search,
    topicFilter,
    sort,
  });

  const threads = (data?.results ?? []) as ForumTopicSummary[];
  const total = data?.total ?? 0;

  const hasResults = threads.length > 0;

  const headerPrimaryAction = (
    <Button
      type="primary"
      icon={<QuestionCircleOutlined />}
      onClick={() =>
        router.push('/konnected/community-discussions/start-new-discussion')
      }
    >
      Start new discussion
    </Button>
  );

  const headerSecondaryActions = (
    <Space>
      <Tooltip title="Refresh active threads">
        <Button icon={<ReloadOutlined />} onClick={() => refetch()} loading={isFetching} />
      </Tooltip>
    </Space>
  );

  const handleSearchSubmit = (value: string) => {
    setSearch(value.trim());
    setPage(1);
  };

  const handleClickThread = (topic: ForumTopicSummary) => {
    // NOTE: adjust route if your thread detail URL differs
    router.push(`/konnected/community-discussions/thread/${topic.id}`);
  };

  const renderHeaderFilters = () => (
    <Card style={{ marginBottom: 16 }}>
      <Space direction="vertical" style={{ width: '100%' }} size="middle">
        <Space style={{ width: '100%' }} wrap>
          <Input
            allowClear
            placeholder="Search by title, category, or keyword"
            prefix={<SearchOutlined />}
            value={pendingSearch}
            onChange={(e) => setPendingSearch(e.target.value)}
            onPressEnter={(e) =>
              handleSearchSubmit((e.target as HTMLInputElement).value)
            }
            style={{ maxWidth: 360 }}
          />
          <Button
            onClick={() => handleSearchSubmit(pendingSearch)}
            icon={<SearchOutlined />}
            type="default"
          >
            Search
          </Button>
        </Space>

        <Space wrap>
          <Space>
            <Text type="secondary">Thread type:</Text>
            <Select<TopicFilter>
              value={topicFilter}
              onChange={(val) => {
                setTopicFilter(val);
                setPage(1);
              }}
              style={{ width: 180 }}
            >
              <Option value="all">All threads</Option>
              <Option value="questions">Questions only</Option>
              <Option value="discussions">Open discussions</Option>
            </Select>
          </Space>

          <Space>
            <Text type="secondary">Sort by:</Text>
            <Select<SortOption>
              value={sort}
              onChange={(val) => {
                setSort(val);
                setPage(1);
              }}
              style={{ width: 200 }}
            >
              <Option value="recent">Most recent activity</Option>
              <Option value="most_replies">Most replies</Option>
              <Option value="most_active">Most participants</Option>
            </Select>
          </Space>
        </Space>

        <Paragraph type="secondary" style={{ marginBottom: 0 }}>
          Active Threads shows forum topics with recent replies and engagement across
          KonnectED‚Äôs knowledge forums. Use filters to focus on questions needing
          answers or heavily active thematic discussions.
        </Paragraph>
      </Space>
    </Card>
  );

  const renderListItemMeta = (item: ForumTopicSummary) => {
    const lastActivity = new Date(item.last_activity_at);

    return (
      <Space direction="vertical" style={{ width: '100%' }} size={4}>
        <Space wrap>
          {item.is_pinned && (
            <Tag color="gold">
              <FireOutlined style={{ marginRight: 4 }} />
              Pinned
            </Tag>
          )}
          {item.kind === 'question' && (
            <Tag color="blue">
              <QuestionCircleOutlined style={{ marginRight: 4 }} />
              Question
            </Tag>
          )}
          {item.category && <Tag>{item.category}</Tag>}
          {item.tags?.map((tag) => (
            <Tag key={tag} bordered={false}>
              {tag}
            </Tag>
          ))}
        </Space>

        <Space align="center" style={{ justifyContent: 'space-between', width: '100%' }}>
          <Space wrap>
            <Space>
              <MessageTwoTone />
              <Text strong>{item.replies_count}</Text>
              <Text type="secondary">replies</Text>
            </Space>
            {item.participants_count != null && (
              <Space>
                <TeamOutlined />
                <Text strong>{item.participants_count}</Text>
                <Text type="secondary">participants</Text>
              </Space>
            )}
          </Space>

          <Space wrap>
            {item.status && (
              <Tag
                color={
                  item.status === 'open'
                    ? 'green'
                    : item.status === 'closed'
                    ? 'default'
                    : 'red'
                }
              >
                {item.status === 'open'
                  ? 'Open'
                  : item.status === 'closed'
                  ? 'Closed'
                  : 'Archived'}
              </Tag>
            )}
            <Text type="secondary">
              Last activity{' '}
              {Number.isNaN(lastActivity.getTime())
                ? 'recently'
                : lastActivity.toLocaleString()}
              {item.last_activity_by ? ` ‚Ä¢ by ${item.last_activity_by}` : ''}
            </Text>
          </Space>
        </Space>

        {item.linked_resource_title && (
          <Text type="secondary">
            Linked resource: <strong>{item.linked_resource_title}</strong>
          </Text>
        )}

        {item.last_activity_snippet && (
          <Text type="secondary" ellipsis>
            ‚Äú{item.last_activity_snippet}‚Äù
          </Text>
        )}
      </Space>
    );
  };

  const renderList = () => {
    if (isLoading && !data) {
      // Skeleton list while first load
      return (
        <Card>
          <List
            itemLayout="vertical"
            dataSource={[1, 2, 3, 4, 5]}
            renderItem={(key) => (
              <List.Item key={key}>
                <Skeleton active avatar paragraph={{ rows: 2 }} />
              </List.Item>
            )}
          />
        </Card>
      );
    }

    if (isError) {
      return (
        <Alert
          type="error"
          message="Unable to load active threads"
          description={error?.message ?? 'An unexpected error occurred.'}
          showIcon
          action={
            <Button size="small" onClick={() => refetch()} icon={<ReloadOutlined />}>
              Retry
            </Button>
          }
          style={{ marginBottom: 16 }}
        />
      );
    }

    if (!hasResults) {
      return (
        <Card>
          <Empty
            image={Empty.PRESENTED_IMAGE_SIMPLE}
            description={
              <>
                <div>No active threads match your filters.</div>
                <div>
                  You can adjust filters or{' '}
                  <Button
                    type="link"
                    onClick={() =>
                      router.push(
                        '/konnected/community-discussions/start-new-discussion',
                      )
                    }
                  >
                    start a new discussion
                  </Button>
                  .
                </div>
              </>
            }
          />
        </Card>
      );
    }

    return (
      <Card>
        <List<ForumTopicSummary>
          itemLayout="vertical"
          dataSource={threads}
          rowKey={(item) => item.id}
          renderItem={(item) => (
            <List.Item
              key={item.id}
              style={{ cursor: 'pointer' }}
              onClick={() => handleClickThread(item)}
              actions={[
                <Space key="stats">
                  <MessageTwoTone />
                  <Text>{item.replies_count} replies</Text>
                  {item.participants_count != null && (
                    <>
                      <TeamOutlined />
                      <Text>{item.participants_count} participants</Text>
                    </>
                  )}
                </Space>,
              ]}
              extra={
                item.is_unread ? (
                  <Badge status="processing" text="New activity" />
                ) : undefined
              }
            >
              <List.Item.Meta
                avatar={
                  <Avatar src={item.created_by_avatar_url ?? undefined}>
                    {item.created_by_name?.charAt(0) ?? '?'}
                  </Avatar>
                }
                title={
                  <Space>
                    <Text strong>{item.title}</Text>
                    {item.is_pinned && (
                      <Tag color="gold" icon={<FireOutlined />}>
                        Pinned
                      </Tag>
                    )}
                  </Space>
                }
                description={
                  <Space
                    direction="vertical"
                    size={4}
                    style={{ width: '100%', marginTop: 4 }}
                  >
                    {item.created_by_name && (
                      <Text type="secondary">
                        Started by <strong>{item.created_by_name}</strong>
                      </Text>
                    )}
                    {renderListItemMeta(item)}
                  </Space>
                }
              />
            </List.Item>
          )}
        />

        <div style={{ marginTop: 16, textAlign: 'right' }}>
          <Pagination
            current={page}
            pageSize={pageSize}
            total={total}
            showSizeChanger={false}
            onChange={(p) => setPage(p)}
          />
        </div>
      </Card>
    );
  };

  return (
    <KonnectedPageShell
      title="Community Discussions ‚Äì Active Threads"
      subtitle="Subject-based forums for learners and educators. These threads show recent activity across KonnectED‚Äôs thematic forums."
      primaryAction={headerPrimaryAction}
      secondaryActions={headerSecondaryActions}
    >
      <Space direction="vertical" style={{ width: '100%' }} size="large">
        {renderHeaderFilters()}
        {renderList()}
      </Space>
    </KonnectedPageShell>
  );
}

===== END app/konnected/community-discussions/active-threads/page.tsx =====


===== BEGIN app/konnected/community-discussions/moderation/page.tsx =====
Ôªø'use client';

import React, { useMemo, useState } from 'react';
import type { ReactNode } from 'react';
import { useRequest } from 'ahooks';
import { ProTable } from '@ant-design/pro-components';
import type { ProColumns } from '@ant-design/pro-components';
import {
  Alert,
  App as AntdApp,
  Badge,
  Button,
  Drawer,
  Modal,
  Popconfirm,
  Space,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  CheckCircleOutlined,
  ExclamationCircleOutlined,
  EyeOutlined,
  ReloadOutlined,
  StopOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import { fetchModerationQueue, actOnReport } from '@/services/admin';

const { Text, Paragraph } = Typography;

type ModerationStatus = 'Pending' | 'Resolved' | 'Escalated';

type ModerationTargetType = 'topic' | 'post' | 'user';

type Severity = 'low' | 'medium' | 'high';

interface ModerationQueueItem {
  id: string;
  /** Post / Topic / User */
  targetType: ModerationTargetType;
  /** ID of the target (postId, topicId, userId, etc.) */
  targetId: string;
  /** Human-readable context, e.g. thread title */
  contextTitle?: string;
  /** Short preview of offending content */
  contentPreview?: string;
  /** Who authored the offending content */
  authorName?: string;
  authorId?: string;
  /** Who reported */
  reporterName?: string;
  reporterId?: string;
  /** Primary reason label */
  reason?: string;
  /** Free-text notes / message from reporter */
  reporterMessage?: string;
  /** Number of merged reports for same target */
  reportCount?: number;
  /** When the first report was created (ISO string) */
  createdAt?: string;
  /** When last action occurred (ISO string) */
  lastActionAt?: string;
  /** Current status in queue */
  status: ModerationStatus;
  /** Rough severity bucket */
  severity?: Severity;
}

/**
 * Adapt the existing admin moderation payload into the richer
 * ModerationQueueItem shape expected by the KonnectED UI.
 *
 * This is defensive: it works with the current minimal shape
 * (id, content, reporter, type, status) and can absorb future
 * backend fields with zero changes on the frontend.
 */
function adaptModerationItems(raw: unknown): ModerationQueueItem[] {
  const items = Array.isArray(raw)
    ? raw
    : Array.isArray((raw as any)?.items)
    ? (raw as any).items
    : [];

  return items.map((item: any): ModerationQueueItem => {
    const status: ModerationStatus =
      item.status === 'Resolved' || item.status === 'Escalated'
        ? item.status
        : 'Pending';

    // Basic heuristics to enrich from whatever the backend gives us
    const targetType: ModerationTargetType =
      (item.targetType as ModerationTargetType) ??
      (item.entityType as ModerationTargetType) ??
      'post';

    const severity: Severity =
      (item.severity as Severity) ??
      (item.priority as Severity) ??
      'medium';

    return {
      id: String(item.id),
      targetType,
      targetId: String(item.targetId ?? item.postId ?? item.topicId ?? item.userId ?? item.id),
      contextTitle: item.contextTitle ?? item.threadTitle ?? item.topicTitle,
      contentPreview: item.content ?? item.contentSnippet ?? item.preview,
      authorName: item.authorName ?? item.offenderName ?? item.user,
      authorId: item.authorId ?? item.offenderId,
      reporterName: item.reporterName ?? item.reporter,
      reporterId: item.reporterId,
      reason: item.type ?? item.reason,
      reporterMessage: item.message ?? item.notes,
      reportCount: item.reportCount ?? item.count ?? 1,
      createdAt: item.createdAt ?? item.created_at ?? item.timestamp,
      lastActionAt: item.lastActionAt ?? item.updated_at,
      status,
      severity,
    };
  });
}

export default function CommunityModerationPage(): JSX.Element {
  const [selectedRowKeys, setSelectedRowKeys] = useState<React.Key[]>([]);
  const [activeStatusFilter, setActiveStatusFilter] = useState<ModerationStatus | 'all'>('Pending');
  const [detailDrawerItem, setDetailDrawerItem] = useState<ModerationQueueItem | null>(null);
  const [globalActionLoading, setGlobalActionLoading] = useState(false);

  const { message } = AntdApp.useApp();

  const {
    data: rawData,
    loading,
    error,
    refresh,
  } = useRequest(fetchModerationQueue);

  const items: ModerationQueueItem[] = useMemo(
    () => adaptModerationItems(rawData),
    [rawData],
  );

  const filteredItems = useMemo(() => {
    if (activeStatusFilter === 'all') return items;
    return items.filter((item) => item.status === activeStatusFilter);
  }, [items, activeStatusFilter]);

  const unauthorized =
    (error as any)?.response?.status === 403 ||
    (error as any)?.status === 403;

  const onSingleAction = async (
    record: ModerationQueueItem,
    action: 'approve' | 'remove',
  ) => {
    try {
      setGlobalActionLoading(true);
      // actOnReport: remove = true => delete, false => keep
      const remove = action === 'remove';
      await actOnReport(record.id, remove);
      message.success(
        remove
          ? 'Content removed and report resolved.'
          : 'Content approved and report resolved.',
      );
      await refresh();
    } catch (e) {
      message.error('Unable to process moderation action. Please try again.');
    } finally {
      setGlobalActionLoading(false);
    }
  };

  const onBulkAction = async (action: 'approve' | 'remove') => {
    if (!selectedRowKeys.length) {
      message.info('Select at least one item to apply a bulk action.');
      return;
    }

    setGlobalActionLoading(true);
    try {
      const remove = action === 'remove';

      const promises = selectedRowKeys.map((id) =>
        actOnReport(String(id), remove).catch((err) => err),
      );

      const results = await Promise.all(promises);
      const failures = results.filter((r) => r instanceof Error);

      if (failures.length === 0) {
        message.success(
          remove
            ? 'Selected content removed and reports resolved.'
            : 'Selected content approved and reports resolved.',
        );
      } else if (failures.length === selectedRowKeys.length) {
        message.error('Bulk action failed for all selected items.');
      } else {
        message.warning(
          'Bulk action completed with some failures. Check the queue and retry if needed.',
        );
      }

      setSelectedRowKeys([]);
      await refresh();
    } catch {
      message.error('Unexpected error while processing bulk action.');
    } finally {
      setGlobalActionLoading(false);
    }
  };

  const severityTag = (severity?: Severity): ReactNode => {
    switch (severity) {
      case 'high':
        return (
          <Tag color="red" icon={<ExclamationCircleOutlined />}>
            High
          </Tag>
        );
      case 'low':
        return <Tag color="green">Low</Tag>;
      case 'medium':
      default:
        return <Tag color="gold">Medium</Tag>;
    }
  };

  const statusBadge = (status: ModerationStatus): ReactNode => {
    switch (status) {
      case 'Resolved':
        return <Badge status="success" text="Resolved" />;
      case 'Escalated':
        return <Badge status="warning" text="Escalated" />;
      case 'Pending':
      default:
        return <Badge status="processing" text="Pending" />;
    }
  };

  const targetTag = (record: ModerationQueueItem): ReactNode => {
    const label =
      record.targetType === 'topic'
        ? 'Topic'
        : record.targetType === 'user'
        ? 'User'
        : 'Post';

    return <Tag>{label}</Tag>;
  };

  const columns: ProColumns<ModerationQueueItem>[] = [
    {
      title: 'Content',
      dataIndex: 'contentPreview',
      width: 320,
      ellipsis: true,
      render: (_, record) => (
        <Space direction="vertical" size={2}>
          <Space size={6}>
            {targetTag(record)}
            {record.reason && <Tag>{record.reason}</Tag>}
          </Space>
          {record.contextTitle && (
            <Text strong ellipsis={{ tooltip: record.contextTitle }}>
              {record.contextTitle}
            </Text>
          )}
          {record.contentPreview && (
            <Text type="secondary" ellipsis={{ tooltip: record.contentPreview }}>
              {record.contentPreview}
            </Text>
          )}
          {record.reporterMessage && (
            <Text type="secondary" italic ellipsis={{ tooltip: record.reporterMessage }}>
              Reporter note: {record.reporterMessage}
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'People',
      dataIndex: 'authorName',
      width: 220,
      render: (_, record) => (
        <Space direction="vertical" size={2}>
          {record.authorName && (
            <Text>
              Author: <Text strong>{record.authorName}</Text>
            </Text>
          )}
          {record.reporterName && (
            <Text type="secondary">
              Reported by {record.reporterName}
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'Reports',
      dataIndex: 'reportCount',
      width: 120,
      align: 'center',
      render: (value, record) => (
        <Space direction="vertical" size={2}>
          <Badge
            count={value ?? 1}
            style={{ backgroundColor: '#722ed1' }}
            overflowCount={99}
          />
          {severityTag(record.severity)}
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      width: 140,
      render: (_, record) => statusBadge(record.status),
      filters: true,
      valueEnum: {
        Pending: { text: 'Pending' },
        Escalated: { text: 'Escalated' },
        Resolved: { text: 'Resolved' },
      },
    },
    {
      title: 'Timeline',
      dataIndex: 'createdAt',
      width: 220,
      render: (_, record) => (
        <Space direction="vertical" size={2}>
          {record.createdAt && (
            <Text type="secondary">
              Reported{' '}
              {new Date(record.createdAt).toLocaleString(undefined, {
                dateStyle: 'medium',
                timeStyle: 'short',
              })}
            </Text>
          )}
          {record.lastActionAt && (
            <Text type="secondary">
              Last action{' '}
              {new Date(record.lastActionAt).toLocaleString(undefined, {
                dateStyle: 'medium',
                timeStyle: 'short',
              })}
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 220,
      fixed: 'right',
      render: (_, record) => {
        const disabled = unauthorized || globalActionLoading || record.status === 'Resolved';

        return (
          <Space>
            <Tooltip title="Review full report details">
              <Button
                icon={<EyeOutlined />}
                size="small"
                onClick={() => setDetailDrawerItem(record)}
              />
            </Tooltip>

            <Tooltip title="Content is acceptable, resolve report">
              <Button
                size="small"
                icon={<CheckCircleOutlined />}
                type="default"
                disabled={disabled}
                onClick={() => onSingleAction(record, 'approve')}
              >
                Approve
              </Button>
            </Tooltip>

            <Popconfirm
              title="Remove content?"
              description="This will remove the content for everyone and resolve all associated reports."
              okText="Remove"
              okType="danger"
              icon={<ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />}
              disabled={disabled}
              onConfirm={() => onSingleAction(record, 'remove')}
            >
              <Tooltip title="Remove content and resolve report">
                <Button
                  size="small"
                  icon={<StopOutlined />}
                  danger
                  disabled={disabled}
                >
                  Remove
                </Button>
              </Tooltip>
            </Popconfirm>
          </Space>
        );
      },
    },
  ];

  const bulkActions = (
    <Space>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('Pending')}
        type={activeStatusFilter === 'Pending' ? 'primary' : 'default'}
      >
        Pending
      </Button>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('Escalated')}
        type={activeStatusFilter === 'Escalated' ? 'primary' : 'default'}
      >
        Escalated
      </Button>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('Resolved')}
        type={activeStatusFilter === 'Resolved' ? 'primary' : 'default'}
      >
        Resolved
      </Button>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('all')}
        type={activeStatusFilter === 'all' ? 'primary' : 'default'}
      >
        All
      </Button>
    </Space>
  );

  return (
    <KonnectedPageShell
      title="Community Moderation"
      subtitle="Review and act on reports for forum topics, posts, and users across KonnectED."
      primaryAction={
        <Button
          icon={<ReloadOutlined />}
          onClick={() => refresh()}
          loading={loading || globalActionLoading}
        >
          Refresh Queue
        </Button>
      }
      secondaryActions={bulkActions}
    >
      {unauthorized && (
        <Alert
          type="error"
          showIcon
          style={{ marginBottom: 16 }}
          message="You do not have permission to moderate community discussions."
          description="If you believe this is an error, contact your KonnectED administrator to be granted a moderator role."
        />
      )}

      {!unauthorized && (
        <Alert
          type="info"
          showIcon
          style={{ marginBottom: 16 }}
          message="Moderation guidelines"
          description={
            <>
              Approve content that aligns with your community guidelines, remove
              content that is harmful or off-topic, and escalate edge cases to
              your administrator. Bulk actions are available for high-volume
              periods.
            </>
          }
        />
      )}

      {error && !unauthorized && (
        <Alert
          type="error"
          showIcon
          style={{ marginBottom: 16 }}
          message="Unable to load moderation queue."
          description="Check your connection or try again. If the problem persists, the moderation service may be unavailable."
        />
      )}

      {items.length === 0 && !loading && !error && (
        <Alert
          type="success"
          showIcon
          style={{ marginBottom: 16 }}
          message="No open reports."
          description="Your community is all clear. New reports will show up here as they are created."
        />
      )}

      <ProTable<ModerationQueueItem>
        rowKey="id"
        search={false}
        options={false}
        loading={loading || globalActionLoading}
        columns={columns}
        dataSource={filteredItems}
        pagination={{
          pageSize: 10,
          showSizeChanger: true,
          showTotal: (total) => `${total} reports`,
        }}
        sticky
        rowSelection={{
          selectedRowKeys,
          onChange: setSelectedRowKeys,
        }}
        tableAlertRender={({ selectedRowKeys: keys }) => (
          <Space size={8}>
            <Text strong>{keys.length}</Text>
            <Text>selected</Text>
          </Space>
        )}
        tableAlertOptionRender={() => (
          <Space>
            <Tooltip title="Resolve and keep content">
              <Button
                size="small"
                icon={<CheckCircleOutlined />}
                disabled={!selectedRowKeys.length || unauthorized}
                onClick={() => onBulkAction('approve')}
              >
                Bulk approve
              </Button>
            </Tooltip>
            <Tooltip title="Remove content and resolve reports">
              <Popconfirm
                title="Remove selected content?"
                description="This will remove content for all selected reports and resolve them."
                okText="Remove"
                okType="danger"
                icon={<ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />}
                disabled={!selectedRowKeys.length || unauthorized}
                onConfirm={() => onBulkAction('remove')}
              >
                <Button
                  size="small"
                  danger
                  icon={<StopOutlined />}
                  disabled={!selectedRowKeys.length || unauthorized}
                >
                  Bulk remove
                </Button>
              </Popconfirm>
            </Tooltip>
          </Space>
        )}
        scroll={{ x: 1100 }}
      />

      <Drawer
        title="Report details"
        width={480}
        open={!!detailDrawerItem}
        onClose={() => setDetailDrawerItem(null)}
      >
        {detailDrawerItem && (
          <Space direction="vertical" style={{ width: '100%' }} size="middle">
            <Space>
              {targetTag(detailDrawerItem)}
              {severityTag(detailDrawerItem.severity)}
              {statusBadge(detailDrawerItem.status)}
              {detailDrawerItem.reason && <Tag>{detailDrawerItem.reason}</Tag>}
            </Space>

            {detailDrawerItem.contextTitle && (
              <div>
                <Text strong>Thread / context</Text>
                <Paragraph>{detailDrawerItem.contextTitle}</Paragraph>
              </div>
            )}

            {detailDrawerItem.contentPreview && (
              <div>
                <Text strong>Content preview</Text>
                <Paragraph>{detailDrawerItem.contentPreview}</Paragraph>
              </div>
            )}

            <div>
              <Text strong>People</Text>
              <Paragraph>
                {detailDrawerItem.authorName && (
                  <>
                    Author: <Text strong>{detailDrawerItem.authorName}</Text>
                    <br />
                  </>
                )}
                {detailDrawerItem.reporterName && (
                  <>
                    Reporter: <Text>{detailDrawerItem.reporterName}</Text>
                    <br />
                  </>
                )}
                {detailDrawerItem.reportCount && (
                  <>Reports merged: {detailDrawerItem.reportCount}</>
                )}
              </Paragraph>
            </div>

            {detailDrawerItem.reporterMessage && (
              <div>
                <Text strong>Reporter note</Text>
                <Paragraph>{detailDrawerItem.reporterMessage}</Paragraph>
              </div>
            )}

            <div>
              <Text strong>Timeline</Text>
              <Paragraph type="secondary">
                {detailDrawerItem.createdAt && (
                  <>
                    Reported:{' '}
                    {new Date(detailDrawerItem.createdAt).toLocaleString(
                      undefined,
                      { dateStyle: 'medium', timeStyle: 'short' },
                    )}
                    <br />
                  </>
                )}
                {detailDrawerItem.lastActionAt && (
                  <>
                    Last action:{' '}
                    {new Date(detailDrawerItem.lastActionAt).toLocaleString(
                      undefined,
                      { dateStyle: 'medium', timeStyle: 'short' },
                    )}
                  </>
                )}
              </Paragraph>
            </div>

            <Alert
              type="info"
              showIcon
              message="Next steps"
              description="Use the actions in the table to approve or remove this content. For complex cases, escalate through your admin tools or document decisions in your internal playbook."
            />
          </Space>
        )}
      </Drawer>

      <Modal
        open={false}
        footer={null}
        closable={false}
        destroyOnHidden
        // Reserved for future: escalation / mute / ban workflows
      />
    </KonnectedPageShell>
  );
}

// app/konnected/community-discussions/moderation/page.tsx

===== END app/konnected/community-discussions/moderation/page.tsx =====


===== BEGIN app/konnected/community-discussions/start-new-discussion/page.tsx =====
Ôªø// C:\MyCode\Konnaxionv14\frontend\app\konnected\community-discussions\start-new-discussion\page.tsx
'use client';

import React, { useState } from 'react';
import {
  Alert,
  Button,
  Card,
  Col,
  Form,
  Input,
  message as antdMessage,
  Row,
  Select,
  Space,
  Switch,
  Tag,
  Typography,
  Upload,
  Radio,
} from 'antd';
import type { FormProps } from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import { InfoCircleOutlined, MessageOutlined, QuestionCircleOutlined, UploadOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { TextArea } = Input;
const { Paragraph, Text } = Typography;

type ThreadType = 'question' | 'discussion';

type FormValues = {
  title: string;
  content?: string;
  category: string;
  threadType: ThreadType;
  tags?: string[];
  subscribeToReplies?: boolean;
  attachments?: UploadFile[];
};

type CreateBodies = {
  topic: {
    title: string;
    category: string;
  };
  initialPostContent?: string;
};

/**
 * Extracts a human-friendly error message from a DRF-style error response.
 */
async function extractBackendMessage(res: Response): Promise<string | undefined> {
  try {
    const data = (await res.json()) as any;
    if (typeof data?.detail === 'string') return data.detail;
    if (typeof data?.message === 'string') return data.message;
    if (typeof data?.error === 'string') return data.error;
  } catch {
    // ignore JSON parse errors
  }
  return undefined;
}

/**
 * Start New Discussion page for KonnectED ‚Üí Community Discussions.
 * Creates a ForumTopic, then (optionally) an initial ForumPost
 * using the real backend endpoints /api/forum-topics/ and /api/forum-posts/.
 */
export default function StartNewDiscussionPage(): JSX.Element {
  const [form] = Form.useForm<FormValues>();
  const router = useRouter();
  const [submitting, setSubmitting] = useState(false);

  const buildBodies = (values: FormValues): CreateBodies => {
    const trimmedTitle = values.title.trim();
    const trimmedContent = values.content?.trim();

    return {
      topic: {
        title: trimmedTitle,
        category: values.category,
      },
      initialPostContent: trimmedContent || undefined,
    };
  };

  const onFinish: FormProps<FormValues>['onFinish'] = async (values) => {
    setSubmitting(true);
    try {
      const { topic, initialPostContent } = buildBodies(values);

      // 1) Create the forum topic (thread) itself.
      const topicRes = await fetch('/api/forum-topics/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(topic),
      });

      if (!topicRes.ok) {
        const backendMessage =
          (await extractBackendMessage(topicRes)) ?? 'Unable to create discussion.';
        if (topicRes.status === 403) {
          antdMessage.error(
            backendMessage || 'You do not have permission to start a new discussion.',
          );
        } else if (topicRes.status === 429) {
          antdMessage.error(
            backendMessage ||
              'You have created too many discussions in a short time. Please try again later.',
          );
        } else {
          antdMessage.error(backendMessage);
        }
        return;
      }

      const createdTopic = (await topicRes.json()) as { id: number | string };

      // 2) Optionally create the initial post in the topic.
      if (initialPostContent) {
        const topicId = createdTopic?.id;
        if (topicId == null) {
          // Topic exists but we could not read its id ‚Äì log and continue.
          // eslint-disable-next-line no-console
          console.warn('Created topic without id in response payload.', createdTopic);
        } else {
          const postBody = {
            topic: Number(topicId),
            content: initialPostContent,
          };

          const postRes = await fetch('/api/forum-posts/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            credentials: 'include',
            body: JSON.stringify(postBody),
          });

          if (!postRes.ok) {
            const backendMessage =
              (await extractBackendMessage(postRes)) ??
              'Your topic was created, but the initial post could not be saved.';
            antdMessage.warning(backendMessage);
          }
        }
      }

      antdMessage.success('Discussion created successfully.');
      router.push('/konnected/community-discussions/active-threads');
    } catch (error) {
      // Network or unexpected error
      // eslint-disable-next-line no-console
      console.error('Error creating discussion', error);
      antdMessage.error('Something went wrong while creating the discussion. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  const onFinishFailed: FormProps<FormValues>['onFinishFailed'] = () => {
    antdMessage.error('Please fix the highlighted fields and try again.');
  };

  // Categories mapped to ForumTopic.category values. Adjust as needed.
  const CATEGORY_OPTIONS: { label: string; value: string }[] = [
    { label: 'Math', value: 'Math' },
    { label: 'Science', value: 'Science' },
    { label: 'General', value: 'General' },
  ];

  const TAG_SUGGESTIONS = ['Exam prep', 'Project help', 'Tips & tricks', 'Resources', 'Mentoring'];

  return (
    <KonnectedPageShell
      title="Start a New Discussion"
      subtitle={
        <span>
          Share a question or topic with the KonnectED community. Your post may be surfaced in learning
          paths and thematic forums.
        </span>
      }
    >
      <Row gutter={[24, 24]}>
        {/* Main form column */}
        <Col xs={24} md={16}>
          <Card>
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              <Alert
                type="info"
                showIcon
                icon={<InfoCircleOutlined />}
                message="Reminder: keep it constructive and on-topic"
                description={
                  <span>
                    Discussions are visible across teams. Content may be routed to moderators before
                    publication for low-trust accounts.
                  </span>
                }
              />

              <Form<FormValues>
                form={form}
                layout="vertical"
                onFinish={onFinish}
                onFinishFailed={onFinishFailed}
                initialValues={{
                  threadType: 'discussion',
                  subscribeToReplies: true,
                }}
              >
                {/* Title */}
                <Form.Item
                  label="Title"
                  name="title"
                  rules={[
                    { required: true, message: 'Please enter a title' },
                    { min: 10, message: 'The title should be at least 10 characters long.' },
                    { max: 150, message: 'The title should be at most 150 characters.' },
                    {
                      validator: (_, value) => {
                        if (typeof value === 'string' && !value.trim()) {
                          return Promise.reject(
                            new Error('The title cannot be empty or just spaces.'),
                          );
                        }
                        return Promise.resolve();
                      },
                    },
                  ]}
                >
                  <Input placeholder="e.g. How do we measure impact across teams in cross-faculty projects?" />
                </Form.Item>

                {/* Thread type */}
                <Form.Item
                  label="Type of thread"
                  name="threadType"
                  rules={[{ required: true, message: 'Please select the type of discussion.' }]}
                >
                  <Radio.Group>
                    <Radio.Button value="question">
                      <Space>
                        <QuestionCircleOutlined />
                        <span>Question (Q&amp;A)</span>
                      </Space>
                    </Radio.Button>
                    <Radio.Button value="discussion">
                      <Space>
                        <MessageOutlined />
                        <span>Open discussion</span>
                      </Space>
                    </Radio.Button>
                  </Radio.Group>
                </Form.Item>

                {/* Category */}
                <Form.Item
                  label="Category / subject area"
                  name="category"
                  rules={[{ required: true, message: 'Please select a category.' }]}
                >
                  <Select
                    placeholder="Select a category"
                    options={CATEGORY_OPTIONS}
                    allowClear
                    showSearch
                    optionFilterProp="label"
                  />
                </Form.Item>

                {/* Content */}
                <Form.Item
                  label="Content"
                  name="content"
                  rules={[
                    {
                      max: 5000,
                      message: 'The content is too long (max 5000 characters).',
                    },
                  ]}
                  extra="Provide enough context so that others can give meaningful answers or contributions."
                >
                  <TextArea
                    rows={6}
                    placeholder="Describe your question or topic. You can mention specific courses, projects, or resources‚Ä¶"
                    showCount
                    maxLength={5000}
                  />
                </Form.Item>

                {/* Tags */}
                <Form.Item
                  label="Tags"
                  name="tags"
                  tooltip="Use tags so your discussion can be surfaced in thematic forums and learning paths."
                >
                  <Select
                    mode="tags"
                    tokenSeparators={[',']}
                    placeholder="Add tags (press Enter to confirm)‚Ä¶"
                    options={TAG_SUGGESTIONS.map((t) => ({ label: t, value: t }))}
                  />
                </Form.Item>

                {/* Attachments */}
                <Form.Item
                  label="Attachments"
                  name="attachments"
                  valuePropName="fileList"
                  getValueFromEvent={(e: { fileList: UploadFile[] }) => e?.fileList}
                  extra="Attach optional supporting files (e.g. PDF instructions, slides)."
                >
                  <Upload.Dragger
                    multiple
                    beforeUpload={() => false} // prevent auto-upload; backend integration can be wired later
                    accept=".pdf,.doc,.docx,.ppt,.pptx,.png,.jpg,.jpeg"
                  >
                    <p className="ant-upload-drag-icon">
                      <UploadOutlined />
                    </p>
                    <p className="ant-upload-text">Click or drag files to this area to attach</p>
                    <p className="ant-upload-hint">
                      Files will be included with your initial post when supported.
                    </p>
                  </Upload.Dragger>
                </Form.Item>

                {/* Notification / subscription */}
                <Form.Item
                  label="Notify me about replies"
                  name="subscribeToReplies"
                  valuePropName="checked"
                  tooltip="You will receive notifications when someone replies or your post is updated."
                >
                  <Switch />
                </Form.Item>

                {/* Submit button */}
                <Form.Item>
                  <Space>
                    <Button type="primary" htmlType="submit" loading={submitting}>
                      Post discussion
                    </Button>
                    <Button
                      htmlType="button"
                      onClick={() =>
                        router.push('/konnected/community-discussions/active-threads')
                      }
                    >
                      Cancel
                    </Button>
                  </Space>
                </Form.Item>
              </Form>
            </Space>
          </Card>
        </Col>

        {/* Right-hand guidance / meta column */}
        <Col xs={24} md={8}>
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <Card title="Good discussion practices">
              <Space direction="vertical">
                <Text>
                  <Tag color="blue">Be specific</Tag> Clearly describe the context (course, team,
                  project, tool).
                </Text>
                <Text>
                  <Tag color="green">Show your attempt</Tag> For questions, explain what you already
                  tried or understood.
                </Text>
                <Text>
                  <Tag color="gold">Respect privacy</Tag> Avoid sharing sensitive personal or
                  institutional data.
                </Text>
                <Text>
                  <Tag color="purple">Use tags</Tag> Tags help link the discussion to Knowledge units
                  and learning paths.
                </Text>
              </Space>
            </Card>

            <Card title="Moderation and visibility">
              <Paragraph>
                Posts may be queued for moderation based on your trust level or if they match
                sensitive topics.
              </Paragraph>
              <Paragraph>
                If moderation is required, you&apos;ll see your topic as{' '}
                <Text strong>‚ÄúPending review‚Äù</Text> until a moderator approves it.
              </Paragraph>
              <Paragraph>
                You can later edit your post, close a question, or mark an answer as accepted from
                the thread detail page (when implemented).
              </Paragraph>
            </Card>
          </Space>
        </Col>
      </Row>
    </KonnectedPageShell>
  );
}

===== END app/konnected/community-discussions/start-new-discussion/page.tsx =====


===== BEGIN app/konnected/dashboard/page.tsx =====
Ôªø"use client";

import React from "react";
import { useQuery } from "@tanstack/react-query";
import {
  Alert,
  Avatar,
  Badge,
  Button,
  Col,
  Empty,
  List,
  Progress,
  Row,
  Skeleton,
  Space,
  Tabs,
  Tag,
  Tooltip,
  Typography,
} from "antd";
import {
  CheckCircleOutlined,
  ExclamationCircleOutlined,
  FileTextOutlined,
  LineChartOutlined,
  ReadOutlined,
  TeamOutlined,
} from "@ant-design/icons";
import {
  PageContainer,
  ProCard,
  StatisticCard,
} from "@ant-design/pro-components";
import KonnectedPageShell from "../KonnectedPageShell";

const { Text, Title } = Typography;

// ---------- Aggregated types used by the tiles ----------

type CertificationSummary = {
  activePaths: number;
  completedPaths: number;
  certificatesCount: number;
  upcomingEvaluations: number;
  pendingPeerValidations: number;
  nextEvaluationDate?: string | null;
};

type LearningResourceSummaryItem = {
  id: string;
  title: string;
  type: "article" | "video" | "lesson" | "quiz" | "dataset" | string;
  progressPercent?: number;
};

type LearningSummary = {
  startedCount: number;
  completedCount: number;
  averageProgressPercent: number;
  inProgress: LearningResourceSummaryItem[];
  recommended: LearningResourceSummaryItem[];
};

type LearningPathSummary = {
  myActivePaths: number;
  myCompletedPaths: number;
  myCurrentPathTitle?: string | null;
  myCurrentPathProgressPercent?: number | null;
  isEducator: boolean;
  managedPathsCount: number;
};

type CommunityTopicSummary = {
  id: string;
  title: string;
  lastActivity: string;
  unreadCount: number;
};

type CoCreationProjectSummary = {
  id: string;
  title: string;
  role: "owner" | "contributor" | "reviewer" | string;
  status: "draft" | "active" | "archived" | string;
};

type CommunitySummary = {
  activeThreadsCount: number;
  recentTopics: CommunityTopicSummary[];
  activeCoCreationProjects: CoCreationProjectSummary[];
};

type TeamSummaryItem = {
  id: string;
  name: string;
  /**
   * Optional if backend does not expose a member count yet.
   * When missing, we fall back to role‚Äëbased descriptions.
   */
  memberCount?: number;
  /**
   * Optional role of the current user in this team (owner, collaborator, mentor‚Ä¶).
   */
  role?: string;
};

type TeamsSummary = {
  myTeamsCount: number;
  teams: TeamSummaryItem[];
  nextTeamActivityTitle?: string | null;
  nextTeamActivityDate?: string | null;
};

type UsageSummary = {
  daysActiveLast30: number;
  resourcesCompletedLast30: number;
  certificationsEarnedLast30: number;
};

// ---------- Raw API types (simplified, based on your backend models) ----------

type ListResponse<T> = T[] | { results?: T[] };

type PortfolioApi = {
  id: number;
  title: string;
};

type KnowledgeResourceApi = {
  id: number;
  title: string;
  type?: string;
};

type LearningProgressApi = {
  id: number;
  resource: number | KnowledgeResourceApi;
  progress_percent: string | number;
  updated_at?: string;
};

type KnowledgeRecommendationApi = {
  id: number;
  resource: number | KnowledgeResourceApi;
};

type ForumTopicApi = {
  id: number;
  title: string;
  updated_at?: string;
};

type CoCreationProjectApi = {
  id: number;
  title: string;
  status: string;
};

type ProjectApi = {
  id: number;
  title: string;
};

type ProjectTeamApi = {
  id: number;
  project: number | ProjectApi;
  role?: string;
};

type CommunityDashboardUsageApi = {
  days_active_last_30?: number;
  resources_completed_last_30?: number;
  certifications_earned_last_30?: number;
};

// ---------- Generic helpers ----------

async function fetchJSON<T>(url: string): Promise<T> {
  const res = await fetch(url, { credentials: "include" });
  if (!res.ok) {
    throw new Error(`Failed to fetch ${url}: ${res.status}`);
  }
  return res.json() as Promise<T>;
}

async function fetchList<T>(url: string): Promise<T[]> {
  const data = await fetchJSON<ListResponse<T>>(url);
  if (Array.isArray(data)) return data;
  if (Array.isArray(data.results)) return data.results;
  return [];
}

function safeNumber(value: unknown): number {
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    const n = Number(value);
    return Number.isFinite(n) ? n : 0;
  }
  return 0;
}

function pickTopN<T>(items: T[], n: number): T[] {
  if (items.length <= n) return items;
  return items.slice(0, n);
}

// Knowledge resources endpoint can have slightly different prefixes in your codebase.
// This helper tries the most likely ones and returns the first that works.
async function fetchKnowledgeResourcesList(): Promise<KnowledgeResourceApi[]> {
  const candidates = [
    "/api/knowledge-resources/",
    "/api/knowledge/resources/",
    "/api/konnected/resources/",
  ] as const;

  for (const url of candidates) {
    try {
      const items = await fetchList<KnowledgeResourceApi>(url);
      // If the endpoint exists and responds, we use it even if empty.
      return items;
    } catch {
      // Try next candidate
    }
  }
  return [];
}

function getResourceIdFromProgress(item: LearningProgressApi): number | null {
  if (typeof item.resource === "number") return item.resource;
  if (
    item.resource &&
    typeof item.resource === "object" &&
    "id" in item.resource
  ) {
    return (item.resource as KnowledgeResourceApi).id;
  }
  return null;
}

function getResourceIdFromRecommendation(
  item: KnowledgeRecommendationApi
): number | null {
  if (typeof item.resource === "number") return item.resource;
  if (
    item.resource &&
    typeof item.resource === "object" &&
    "id" in item.resource
  ) {
    return (item.resource as KnowledgeResourceApi).id;
  }
  return null;
}

// ---------- Client‚Äëside aggregation functions (using real backend endpoints) ----------

async function buildCertificationSummary(): Promise<CertificationSummary> {
  // Uses portfolios + learning‚Äëprogress as real backing data.
  const [portfolios, progress] = await Promise.all([
    fetchList<PortfolioApi>("/api/portfolios/").catch(() => []),
    fetchList<LearningProgressApi>("/api/learning-progress/").catch(() => []),
  ]);

  const progressValues = progress.map((p) => safeNumber(p.progress_percent));
  const activePaths = progressValues.filter((v) => v > 0 && v < 100).length;
  const completedPaths = progressValues.filter((v) => v >= 100).length;

  return {
    activePaths,
    completedPaths,
    certificatesCount: portfolios.length,
    // These will become non‚Äëzero once you expose evaluation / peer‚Äëvalidation APIs
    upcomingEvaluations: 0,
    pendingPeerValidations: 0,
    nextEvaluationDate: null,
  };
}

async function buildLearningSummary(): Promise<LearningSummary> {
  const [progressRecords, resources, recommendations] = await Promise.all([
    fetchList<LearningProgressApi>("/api/learning-progress/").catch(() => []),
    fetchKnowledgeResourcesList().catch(() => []),
    fetchList<KnowledgeRecommendationApi>("/api/knowledge-recommendations/").catch(
      () => []
    ),
  ]);

  const resourceMap = new Map<number, KnowledgeResourceApi>();
  for (const r of resources) {
    resourceMap.set(r.id, r);
  }

  const progressValues = progressRecords.map((p) =>
    safeNumber(p.progress_percent)
  );
  const startedCount = progressRecords.length;
  const completedCount = progressValues.filter((v) => v >= 100).length;
  const averageProgressPercent =
    progressValues.length > 0
      ? progressValues.reduce((a, b) => a + b, 0) / progressValues.length
      : 0;

  const inProgressRecords = progressRecords.filter((p) => {
    const v = safeNumber(p.progress_percent);
    return v > 0 && v < 100;
  });

  const inProgress: LearningResourceSummaryItem[] = pickTopN(
    inProgressRecords,
    5
  ).map((p) => {
    const resId = getResourceIdFromProgress(p);
    const resource = resId != null ? resourceMap.get(resId) : undefined;
    const title =
      resource?.title ??
      (resId != null ? `Resource #${resId}` : `Progress #${p.id}`);
    const type =
      (resource?.type as LearningResourceSummaryItem["type"]) ?? "lesson";

    return {
      id: resId != null ? String(resId) : String(p.id),
      title,
      type,
      progressPercent: safeNumber(p.progress_percent),
    };
  });

  const recommended: LearningResourceSummaryItem[] = [];
  for (const rec of recommendations) {
    const resId = getResourceIdFromRecommendation(rec);
    if (resId == null) continue;
    const resource = resourceMap.get(resId);
    if (!resource) continue;

    recommended.push({
      id: String(resId),
      title: resource.title,
      type: (resource.type as LearningResourceSummaryItem["type"]) ?? "article",
    });

    if (recommended.length >= 5) break;
  }

  return {
    startedCount,
    completedCount,
    averageProgressPercent,
    inProgress,
    recommended,
  };
}

async function buildLearningPathSummary(): Promise<LearningPathSummary> {
  const [progressRecords, resources] = await Promise.all([
    fetchList<LearningProgressApi>("/api/learning-progress/").catch(() => []),
    fetchKnowledgeResourcesList().catch(() => []),
  ]);

  const resourceMap = new Map<number, KnowledgeResourceApi>();
  for (const r of resources) {
    resourceMap.set(r.id, r);
  }

  const progressWithValues = progressRecords.map((record) => ({
    record,
    value: safeNumber(record.progress_percent),
  }));

  const activeRecords = progressWithValues.filter(
    ({ value }) => value > 0 && value < 100
  );
  const completedRecords = progressWithValues.filter(
    ({ value }) => value >= 100
  );

  let currentTitle: string | null = null;
  let currentPercent: number | null = null;

  const sortedActive = [...activeRecords].sort((a, b) => b.value - a.value);
  const sortedAll = [...progressWithValues].sort((a, b) => b.value - a.value);
  const candidate = sortedActive[0] ?? sortedAll[0];

  if (candidate) {
    const resId = getResourceIdFromProgress(candidate.record);
    const resource = resId != null ? resourceMap.get(resId) : undefined;
    currentTitle =
      resource?.title ?? (resId != null ? `Resource #${resId}` : null);
    currentPercent = candidate.value;
  }

  return {
    myActivePaths: activeRecords.length,
    myCompletedPaths: completedRecords.length,
    myCurrentPathTitle: currentTitle,
    myCurrentPathProgressPercent: currentPercent,
    // These can be wired later to real educator / path‚Äëmanagement APIs.
    isEducator: false,
    managedPathsCount: 0,
  };
}

async function buildCommunitySummary(): Promise<CommunitySummary> {
  const [topics, coCreationProjects] = await Promise.all([
    fetchList<ForumTopicApi>("/api/forum-topics/").catch(() => []),
    fetchList<CoCreationProjectApi>("/api/co-creation-projects/").catch(
      () => []
    ),
  ]);

  const recentTopics: CommunityTopicSummary[] = pickTopN(
    topics.sort((a, b) => {
      const da = a.updated_at ? Date.parse(a.updated_at) : 0;
      const db = b.updated_at ? Date.parse(b.updated_at) : 0;
      return db - da;
    }),
    5
  ).map((t) => ({
    id: String(t.id),
    title: t.title,
    lastActivity: t.updated_at ?? "Recently",
    // Per‚Äëuser unread counts require a dedicated API; default to 0 for now.
    unreadCount: 0,
  }));

  const activeCoCreationProjects: CoCreationProjectSummary[] = pickTopN(
    coCreationProjects.filter((p) => p.status === "active"),
    5
  ).map((p) => ({
    id: String(p.id),
    title: p.title,
    status: p.status as CoCreationProjectSummary["status"],
    // Real role would come from a membership API; use a neutral default.
    role: "contributor",
  }));

  return {
    activeThreadsCount: topics.length,
    recentTopics,
    activeCoCreationProjects,
  };
}

async function buildTeamsSummary(): Promise<TeamsSummary> {
  // Project-team memberships + projects, as exposed by your API root.
  const [memberships, projects] = await Promise.all([
    fetchList<ProjectTeamApi>("/api/project-teams/").catch(() => []),
    fetchList<ProjectApi>("/api/projects/").catch(() => []),
  ]);

  const projectMap = new Map<number, ProjectApi>();
  for (const p of projects) {
    projectMap.set(p.id, p);
  }

  const teamsMap = new Map<number, TeamSummaryItem>();

  for (const membership of memberships) {
    const projId =
      typeof membership.project === "number"
        ? membership.project
        : membership.project?.id;
    if (!projId) continue;

    if (!teamsMap.has(projId)) {
      const project = projectMap.get(projId);
      teamsMap.set(projId, {
        id: String(projId),
        name: project?.title ?? `Project #${projId}`,
        role: membership.role,
      });
    }
  }

  const teams = Array.from(teamsMap.values());

  return {
    myTeamsCount: teams.length,
    teams,
    nextTeamActivityTitle: null,
    nextTeamActivityDate: null,
  };
}

async function buildUsageSummary(): Promise<UsageSummary> {
  // Prefer the real aggregated endpoint if available.
  try {
    const data = await fetchJSON<CommunityDashboardUsageApi>(
      "/api/community-dashboard/"
    );
    return {
      daysActiveLast30: data.days_active_last_30 ?? 0,
      resourcesCompletedLast30: data.resources_completed_last_30 ?? 0,
      certificationsEarnedLast30: data.certifications_earned_last_30 ?? 0,
    };
  } catch {
    // If the dashboard endpoint is not ready yet, fall back to zeros.
    return {
      daysActiveLast30: 0,
      resourcesCompletedLast30: 0,
      certificationsEarnedLast30: 0,
    };
  }
}

// ---------- Data hooks wired to the real aggregation helpers ----------

function useCertificationSummary() {
  return useQuery<CertificationSummary>({
    queryKey: ["konnected", "dashboard", "certificationSummary"],
    queryFn: buildCertificationSummary,
  });
}

function useLearningSummary() {
  return useQuery<LearningSummary>({
    queryKey: ["konnected", "dashboard", "learningSummary"],
    queryFn: buildLearningSummary,
  });
}

function useLearningPathSummary() {
  return useQuery<LearningPathSummary>({
    queryKey: ["konnected", "dashboard", "learningPathSummary"],
    queryFn: buildLearningPathSummary,
  });
}

function useCommunitySummary() {
  return useQuery<CommunitySummary>({
    queryKey: ["konnected", "dashboard", "communitySummary"],
    queryFn: buildCommunitySummary,
  });
}

function useTeamsSummary() {
  return useQuery<TeamsSummary>({
    queryKey: ["konnected", "dashboard", "teamsSummary"],
    queryFn: buildTeamsSummary,
  });
}

function useUsageSummary() {
  return useQuery<UsageSummary>({
    queryKey: ["konnected", "dashboard", "usageSummary"],
    queryFn: buildUsageSummary,
  });
}

// ---------- Tiles ----------

function CertificationsTile() {
  const { data, isLoading, isError } = useCertificationSummary();

  if (isLoading) {
    return (
      <ProCard title="Certifications" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Certifications"
        bordered
        extra={
          <Button
            type="link"
            href="/konnected/certifications/certification-programs"
          >
            View programs
          </Button>
        }
      >
        <Alert
          type="warning"
          showIcon
          message="Unable to load certification summary."
        />
      </ProCard>
    );
  }

  const hasAny =
    data.activePaths > 0 ||
    data.completedPaths > 0 ||
    data.certificatesCount > 0;

  return (
    <ProCard
      title="Certifications"
      bordered
      extra={
        <Space>
          <Button
            type="default"
            href="/konnected/certifications/exam-dashboard-results"
          >
            Exam results
          </Button>
          <Button
            type="primary"
            href="/konnected/certifications/certification-programs"
          >
            View programs
          </Button>
        </Space>
      }
    >
      {!hasAny ? (
        <Empty
          description="No certifications yet"
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        >
          <Button
            type="primary"
            href="/konnected/certifications/certification-programs"
          >
            Explore certification programs
          </Button>
        </Empty>
      ) : (
        <>
          <Space size="large" wrap>
            <StatisticCard
              statistic={{
                title: "Active paths",
                value: data.activePaths,
                prefix: <ReadOutlined />,
              }}
            />
            <StatisticCard
              statistic={{
                title: "Completed paths",
                value: data.completedPaths,
                prefix: <CheckCircleOutlined />,
              }}
            />
            <StatisticCard
              statistic={{
                title: "Certificates",
                value: data.certificatesCount,
                prefix: <FileTextOutlined />,
              }}
            />
          </Space>

          <Space style={{ marginTop: 16 }} direction="vertical">
            <Space size="large" wrap>
              <Space>
                <Text strong>Upcoming evaluations:</Text>
                <Badge count={data.upcomingEvaluations} />
              </Space>
              <Space>
                <Text strong>Pending peer validations:</Text>
                <Badge
                  count={data.pendingPeerValidations}
                  status={
                    data.pendingPeerValidations > 0 ? "warning" : "default"
                  }
                />
              </Space>
            </Space>
            {data.nextEvaluationDate && (
              <Text type="secondary">
                Next scheduled evaluation:{" "}
                <Text code>{data.nextEvaluationDate}</Text>
              </Text>
            )}
          </Space>
        </>
      )}
    </ProCard>
  );
}

function LearningTile() {
  const { data, isLoading, isError } = useLearningSummary();

  if (isLoading) {
    return (
      <ProCard title="Learning progress & recommendations" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Learning progress & recommendations"
        bordered
        extra={
          <Button type="link" href="/konnected/learning-library/browse-resources">
            Browse library
          </Button>
        }
      >
        <Alert
          type="warning"
          showIcon
          message="Unable to load learning summary."
        />
      </ProCard>
    );
  }

  const hasProgress =
    data.startedCount > 0 ||
    data.completedCount > 0 ||
    data.inProgress.length > 0;

  return (
    <ProCard
      title="Learning progress & recommendations"
      bordered
      extra={
        <Space>
          <Button
            type="default"
            href="/konnected/learning-library/recommended-resources"
          >
            Recommendations
          </Button>
          <Button
            type="primary"
            href="/konnected/learning-library/browse-resources"
          >
            Browse library
          </Button>
        </Space>
      }
    >
      <Row gutter={[16, 16]}>
        <Col xs={24} md={10}>
          <Space direction="vertical" size="middle" style={{ width: "100%" }}>
            <StatisticCard
              statistic={{
                title: "Resources started",
                value: data.startedCount,
                prefix: <ReadOutlined />,
              }}
            />
            <StatisticCard
              statistic={{
                title: "Resources completed",
                value: data.completedCount,
                prefix: <CheckCircleOutlined />,
              }}
            />
            <StatisticCard
              statistic={{
                title: "Average progress",
                value: Math.round(data.averageProgressPercent),
                suffix: "%",
                prefix: <LineChartOutlined />,
              }}
            />
          </Space>
        </Col>
        <Col xs={24} md={14}>
          {!hasProgress ? (
            <Empty
              image={Empty.PRESENTED_IMAGE_SIMPLE}
              description="No learning activity yet"
            >
              <Button
                type="primary"
                href="/konnected/learning-library/browse-resources"
              >
                Start learning
              </Button>
            </Empty>
          ) : (
            <Tabs
              defaultActiveKey="inProgress"
              items={[
                {
                  key: "inProgress",
                  label: "In progress",
                  children: (
                    <List
                      size="small"
                      dataSource={data.inProgress}
                      locale={{ emptyText: "No resources in progress" }}
                      renderItem={(item) => (
                        <List.Item
                          actions={[
                            typeof item.progressPercent === "number" ? (
                              <Tooltip
                                key="progress"
                                title={`${Math.round(
                                  item.progressPercent
                                )}% complete`}
                              >
                                <Progress
                                  percent={Math.round(item.progressPercent)}
                                  size="small"
                                  style={{ width: 120 }}
                                />
                              </Tooltip>
                            ) : null,
                            <Button
                              key="open"
                              type="link"
                              href={`/course/${encodeURIComponent(item.id)}`}
                            >
                              Open
                            </Button>,
                          ]}
                        >
                          <List.Item.Meta
                            title={
                              <Space>
                                <Text strong>{item.title}</Text>
                                <Tag>{item.type}</Tag>
                              </Space>
                            }
                          />
                        </List.Item>
                      )}
                    />
                  ),
                },
                {
                  key: "recommended",
                  label: "Recommended",
                  children: (
                    <List
                      size="small"
                      dataSource={data.recommended}
                      locale={{ emptyText: "No recommendations available" }}
                      renderItem={(item) => (
                        <List.Item
                          actions={[
                            <Button
                              key="start"
                              type="link"
                              href={`/course/${encodeURIComponent(item.id)}`}
                            >
                              Open
                            </Button>,
                          ]}
                        >
                          <List.Item.Meta
                            title={
                              <Space>
                                <Text strong>{item.title}</Text>
                                <Tag color="blue">Recommended</Tag>
                                <Tag>{item.type}</Tag>
                              </Space>
                            }
                          />
                        </List.Item>
                      )}
                    />
                  ),
                },
              ]}
            />
          )}
        </Col>
      </Row>
    </ProCard>
  );
}

function LearningPathsTile() {
  const { data, isLoading, isError } = useLearningPathSummary();

  if (isLoading) {
    return (
      <ProCard title="Learning paths" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Learning paths"
        bordered
        extra={
          <Button type="link" href="/konnected/learning-paths/my-learning-path">
            My learning paths
          </Button>
        }
      >
        <Alert type="warning" showIcon message="Unable to load learning paths." />
      </ProCard>
    );
  }

  const hasPaths =
    data.myActivePaths > 0 ||
    data.myCompletedPaths > 0 ||
    !!data.myCurrentPathTitle;

  return (
    <ProCard
      title="Learning paths"
      bordered
      extra={
        <Space>
          {data.isEducator && (
            <Button
              type="default"
              href="/konnected/learning-paths/manage-existing-paths"
            >
              Manage paths
            </Button>
          )}
          {data.isEducator && (
            <Button
              type="primary"
              href="/konnected/learning-paths/create-learning-path"
            >
              Create path
            </Button>
          )}
          {!data.isEducator && (
            <Button
              type="primary"
              href="/konnected/learning-paths/my-learning-path"
            >
              View my paths
            </Button>
          )}
        </Space>
      }
    >
      {!hasPaths ? (
        <Empty
          description="No learning paths yet"
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        >
          <Button
            type="primary"
            href="/konnected/learning-library/browse-resources"
          >
            Start from library
          </Button>
        </Empty>
      ) : (
        <Space direction="vertical" size="large" style={{ width: "100%" }}>
          <Space size="large" wrap>
            <StatisticCard
              statistic={{
                title: "My active paths",
                value: data.myActivePaths,
                prefix: <ReadOutlined />,
              }}
            />
            <StatisticCard
              statistic={{
                title: "Completed paths",
                value: data.myCompletedPaths,
                prefix: <CheckCircleOutlined />,
              }}
            />
            {data.isEducator && (
              <StatisticCard
                statistic={{
                  title: "Paths I manage",
                  value: data.managedPathsCount,
                  prefix: <FileTextOutlined />,
                }}
              />
            )}
          </Space>
          {data.myCurrentPathTitle && (
            <div>
              <Space align="center">
                <Text strong>Current path:</Text>
                <Text>{data.myCurrentPathTitle}</Text>
                <Badge status="processing" text="In progress" />
              </Space>
              {typeof data.myCurrentPathProgressPercent === "number" && (
                <div style={{ marginTop: 8 }}>
                  <Progress
                    percent={Math.round(data.myCurrentPathProgressPercent)}
                    status="active"
                  />
                </div>
              )}
            </div>
          )}
        </Space>
      )}
    </ProCard>
  );
}

function CommunityTile() {
  const { data, isLoading, isError } = useCommunitySummary();

  if (isLoading) {
    return (
      <ProCard title="Community & co-creation" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Community & co-creation"
        bordered
        extra={
          <Button type="link" href="/konnected/community-discussions/active-threads">
            View community
          </Button>
        }
      >
        <Alert
          type="warning"
          showIcon
          message="Unable to load community activity."
        />
      </ProCard>
    );
  }

  const hasAny =
    data.activeThreadsCount > 0 ||
    data.recentTopics.length > 0 ||
    data.activeCoCreationProjects.length > 0;

  return (
    <ProCard
      title="Community & co-creation"
      bordered
      extra={
        <Space>
          <Button
            type="default"
            href="/konnected/community-discussions/active-threads"
          >
            Active threads
          </Button>
          <Button
            type="primary"
            href="/konnected/community-discussions/start-new-discussion"
          >
            Start discussion
          </Button>
        </Space>
      }
    >
      {!hasAny ? (
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description="No community activity yet"
        >
          <Button
            type="primary"
            href="/konnected/community-discussions/start-new-discussion"
          >
            Start the first discussion
          </Button>
        </Empty>
      ) : (
        <Tabs
          defaultActiveKey="forums"
          items={[
            {
              key: "forums",
              label: "Forums",
              children: (
                <List
                  size="small"
                  dataSource={data.recentTopics}
                  locale={{ emptyText: "No recent topics" }}
                  renderItem={(topic) => (
                    <List.Item
                      actions={[
                        topic.unreadCount > 0 ? (
                          <Badge
                            key="unread"
                            count={topic.unreadCount}
                            style={{ backgroundColor: "#faad14" }}
                          />
                        ) : null,
                        <Button
                          key="open"
                          type="link"
                          href="/konnected/community-discussions/active-threads"
                        >
                          Open
                        </Button>,
                      ]}
                    >
                      <List.Item.Meta
                        avatar={<Avatar icon={<TeamOutlined />} />}
                        title={topic.title}
                        description={
                          <Text type="secondary">
                            Last activity: {topic.lastActivity}
                          </Text>
                        }
                      />
                    </List.Item>
                  )}
                />
              ),
            },
            {
              key: "coCreation",
              label: "Co-creation projects",
              children: (
                <List
                  size="small"
                  dataSource={data.activeCoCreationProjects}
                  locale={{ emptyText: "No active co-creation projects" }}
                  renderItem={(project) => (
                    <List.Item
                      actions={[
                        <Button
                          key="view"
                          type="link"
                          href="/konnected/community-discussions/active-threads"
                        >
                          Open
                        </Button>,
                      ]}
                    >
                      <List.Item.Meta
                        avatar={<Avatar icon={<FileTextOutlined />} />}
                        title={project.title}
                        description={
                          <Space>
                            <Tag color="green">{project.status}</Tag>
                            <Tag>{project.role}</Tag>
                          </Space>
                        }
                      />
                    </List.Item>
                  )}
                />
              ),
            },
          ]}
        />
      )}
    </ProCard>
  );
}

function TeamsTile() {
  const { data, isLoading, isError } = useTeamsSummary();

  if (isLoading) {
    return (
      <ProCard title="Teams & collaboration" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Teams & collaboration"
        bordered
        extra={
          <Button
            type="link"
            href="/konnected/teams-collaboration/team-builder"
          >
            Discover teams
          </Button>
        }
      >
        <Alert
          type="warning"
          showIcon
          message="Unable to load your teams."
        />
      </ProCard>
    );
  }

  const hasTeams = data.myTeamsCount > 0;

  return (
    <ProCard
      title="Teams & collaboration"
      bordered
      extra={
        <Space>
          <Button
            type="default"
            href="/konnected/teams-collaboration/project-workspaces"
          >
            Project workspaces
          </Button>
          <Button
            type="primary"
            href="/konnected/teams-collaboration/my-teams"
          >
            My teams
          </Button>
        </Space>
      }
    >
      {!hasTeams ? (
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description="You are not in any team yet"
        >
          <Button
            type="primary"
            href="/konnected/teams-collaboration/team-builder"
          >
            Discover teams
          </Button>
        </Empty>
      ) : (
        <>
          <Space size="large" wrap>
            <StatisticCard
              statistic={{
                title: "My teams",
                value: data.myTeamsCount,
                prefix: <TeamOutlined />,
              }}
            />
          </Space>
          {data.nextTeamActivityTitle && (
            <div style={{ marginTop: 16 }}>
              <Space>
                <Text strong>Next team activity:</Text>
                <Text>{data.nextTeamActivityTitle}</Text>
                {data.nextTeamActivityDate && (
                  <Tag icon={<LineChartOutlined />}>
                    {data.nextTeamActivityDate}
                  </Tag>
                )}
              </Space>
            </div>
          )}
          <List
            style={{ marginTop: 16 }}
            size="small"
            dataSource={data.teams}
            locale={{ emptyText: "No teams to display" }}
            renderItem={(team) => (
              <List.Item
                actions={[
                  <Button
                    key="open"
                    type="link"
                    href="/konnected/teams-collaboration/project-workspaces"
                  >
                    Open workspace
                  </Button>,
                ]}
              >
                <List.Item.Meta
                  avatar={
                    <Avatar.Group>
                      <Avatar icon={<TeamOutlined />} />
                    </Avatar.Group>
                  }
                  title={team.name}
                  description={
                    team.memberCount != null
                      ? `${team.memberCount} member${
                          team.memberCount === 1 ? "" : "s"
                        }`
                      : team.role
                      ? `Role: ${team.role}`
                      : "Team member"
                  }
                />
              </List.Item>
            )}
          />
        </>
      )}
    </ProCard>
  );
}

function UsageTile() {
  const { data, isLoading, isError } = useUsageSummary();

  if (isLoading) {
    return (
      <ProCard title="Your usage in KonnectED" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Your usage in KonnectED"
        bordered
        extra={
          <Tooltip title="Usage analytics provided by the Insights module">
            <ExclamationCircleOutlined />
          </Tooltip>
        }
      >
        <Alert
          type="info"
          showIcon
          message="Usage analytics are temporarily unavailable."
        />
      </ProCard>
    );
  }

  return (
    <ProCard
      title="Your usage in KonnectED"
      bordered
      extra={
        <Tooltip title="Usage analytics provided by the Insights module">
          <ExclamationCircleOutlined />
        </Tooltip>
      }
    >
      <Space size="large" wrap>
        <StatisticCard
          statistic={{
            title: "Active days (last 30)",
            value: data.daysActiveLast30,
            prefix: <LineChartOutlined />,
          }}
        />
        <StatisticCard
          statistic={{
            title: "Resources completed (last 30)",
            value: data.resourcesCompletedLast30,
            prefix: <ReadOutlined />,
          }}
        />
        <StatisticCard
          statistic={{
            title: "Certifications earned (last 30)",
            value: data.certificationsEarnedLast30,
            prefix: <CheckCircleOutlined />,
          }}
        />
      </Space>
    </ProCard>
  );
}

// ---------- Page ----------

export default function KonnectedDashboardPage() {
  return (
    <KonnectedPageShell
      title="KonnectED dashboard"
      subtitle="Overview of your certifications, learning, community, and teams."
      primaryAction={
        <Button
          type="primary"
          href="/konnected/learning-library/recommended-resources"
        >
          Continue learning
        </Button>
      }
      secondaryActions={
        <Space>
          <Button href="/konnected/certifications/certification-programs">
            Certifications
          </Button>
          <Button href="/konnected/learning-library/browse-resources">
            Library
          </Button>
        </Space>
      }
    >
      <PageContainer>
        <Row gutter={[16, 16]}>
          <Col xs={24} xl={16}>
            <CertificationsTile />
          </Col>
          <Col xs={24} xl={8}>
            <UsageTile />
          </Col>

          <Col xs={24} xl={16}>
            <LearningTile />
          </Col>
          <Col xs={24} xl={8}>
            <LearningPathsTile />
          </Col>

          <Col xs={24} xl={12}>
            <CommunityTile />
          </Col>
          <Col xs={24} xl={12}>
            <TeamsTile />
          </Col>
        </Row>
      </PageContainer>
    </KonnectedPageShell>
  );
}

===== END app/konnected/dashboard/page.tsx =====


===== BEGIN app/konnected/KonnectedPageShell.tsx =====
// app/konnected/KonnectedPageShell.tsx
'use client';

import React, { ReactNode } from 'react';
import { Typography, Space } from 'antd';

const { Title, Paragraph } = Typography;

export type KonnectedPageShellProps = {
  /** Main page title (big, H1-equivalent) */
  title: string;
  /** Optional subtitle / helper text under the title */
  subtitle?: ReactNode;
  /** Main CTA on the right (e.g. primary button) */
  primaryAction?: ReactNode;
  /** Secondary actions on the right (e.g. ghost buttons, filters) */
  secondaryActions?: ReactNode;
  /** Main page content */
  children: ReactNode;
};

/**
 * Central layout wrapper for KonnectED pages (Konnected segment).
 *
 * Usage rules:
 * - Do not render another top-level <h1> / Typography.Title outside this shell.
 * - Do not render breadcrumbs here (those belong to the global/MainLayout shell).
 * - All /konnected/* pages should use this for consistent padding & header.
 */
export default function KonnectedPageShell({
  title,
  subtitle,
  primaryAction,
  secondaryActions,
  children,
}: KonnectedPageShellProps): JSX.Element {
  const hasActions = Boolean(primaryAction || secondaryActions);

  return (
    <div className="container mx-auto p-5">
      {/* Header: title + subtitle + actions */}
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div className="min-w-0">
          <Title level={2} className="!mb-1">
            {title}
          </Title>
          {subtitle && (
            <Paragraph type="secondary" className="!mb-0">
              {subtitle}
            </Paragraph>
          )}
        </div>

        {hasActions && (
          <Space wrap>
            {secondaryActions}
            {primaryAction}
          </Space>
        )}
      </div>

      {/* Main content */}
      {children}
    </div>
  );
}

===== END app/konnected/KonnectedPageShell.tsx =====


===== BEGIN app/konnected/layout.tsx =====
// app/konnected/layout.tsx
'use client'

import type { ReactNode } from 'react'
import React, { Suspense, useEffect } from 'react'
import { Layout, Spin } from 'antd'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'

import MainLayout from '@/components/layout-components/MainLayout'

const { Content } = Layout

interface SegmentLayoutProps {
  children: ReactNode
}

/**
 * Inner shell that *defaults* the sidebar to "konnected" via ?sidebar=konnected
 * when the query param is missing.
 *
 * Important:
 * - If ?sidebar is already set (ekoh, ethikos, kreative, ‚Ä¶), it is respected.
 *   This lets the module switcher (LogoTitle) change suites even while you are
 *   on a /konnected/* URL.
 */
function KonnectedShell({ children }: SegmentLayoutProps) {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  useEffect(() => {
    const currentSidebar = searchParams.get('sidebar')

    // Only inject the default if the param is absent.
    // Do NOT override if the user explicitly chose another suite.
    if (currentSidebar !== null) return

    const params = new URLSearchParams(Array.from(searchParams.entries()))
    params.set('sidebar', 'konnected')

    router.replace(`${pathname}?${params.toString()}`)
  }, [router, pathname, searchParams])

  return <MainLayout>{children}</MainLayout>
}

/**
 * Segment layout for all /konnected/* pages.
 *
 * - Wraps content in MainLayout (global Ant Design layout + navigation).
 * - Provides an Ant Design‚Äìbased Suspense fallback while children load.
 * - Keeps page-level layout concerns in KonnectedPageShell (used by pages themselves).
 */
export default function SegmentLayout({ children }: SegmentLayoutProps) {
  return (
    <Suspense
      fallback={
        <Layout style={{ minHeight: '100vh' }}>
          <Content
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <Spin size="large" />
          </Content>
        </Layout>
      }
    >
      <KonnectedShell>{children}</KonnectedShell>
    </Suspense>
  )
}

===== END app/konnected/layout.tsx =====


===== BEGIN app/konnected/learning-library/browse-resources/page.tsx =====
// app/konnected/learning-library/browse-resources/page.tsx
'use client';

import React, { useCallback, useEffect, useMemo, useState } from 'react';
import axios from 'axios';
import { useRouter, useSearchParams } from 'next/navigation';
import {
  Row,
  Col,
  Card,
  Typography,
  Input,
  Select,
  Tag,
  Rate,
  Space,
  Table,
  Pagination,
  Button,
  Alert,
  Spin,
  message,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import {
  SearchOutlined,
  FilterOutlined,
  DownloadOutlined,
  ShareAltOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text } = Typography;
const { Search } = Input;

/* ------------------------------------------------------------------ */
/*  Domain types (aligned with KnowledgeResource + list API)          */
/* ------------------------------------------------------------------ */

type KnowledgeLevel = 'beginner' | 'intermediate' | 'advanced';

type SortOption = 'relevance' | 'newest' | 'popular' | 'shortest' | 'longest';

interface KnowledgeResource {
  id: string | number;
  title: string;
  description?: string;
  subject?: string;
  level?: KnowledgeLevel;
  language?: string;
  /** Canonical enum from Knowledge module (article, video, lesson, quiz, dataset, ‚Ä¶) */
  resource_type: string;
  average_rating?: number | null;
  tags?: string[];
  estimated_minutes?: number | null;
  is_offline_available?: boolean;
  user_progress_percent?: number | null;
  /** Backend-aligned extras (not all are rendered, but used for navigation) */
  url?: string | null;
  type?: string | null;
  author?: string | null;
  created_at?: string | null;
}

interface KnowledgeResourceListResponse {
  count?: number;
  results?: KnowledgeResource[];
  items?: KnowledgeResource[];
  total?: number;
}

interface KnowledgeMetadataResponse {
  subjects?: string[];
  levels?: KnowledgeLevel[];
  languages?: string[];
  resource_types?: string[];
}

/* Reasonable defaults based on the Knowledge module spec */
const DEFAULT_LEVELS: KnowledgeLevel[] = ['beginner', 'intermediate', 'advanced'];
const DEFAULT_RESOURCE_TYPES = ['article', 'video', 'lesson', 'quiz', 'dataset'];
const DEFAULT_LANGUAGES = ['English', 'French', 'Spanish', 'Other'];

/* ------------------------------------------------------------------ */
/*  API endpoints                                                      */
/*  - Aligned with DRF router: /api/konnected/resources/              */
/*  - Metadata endpoint is optional; call is non-blocking.            */
/* ------------------------------------------------------------------ */

const KNOWLEDGE_RESOURCES_ENDPOINT = '/api/konnected/resources/';
const KNOWLEDGE_METADATA_ENDPOINT = '/api/konnected/resources/metadata/';

interface FiltersState {
  query: string;
  subject?: string;
  level?: KnowledgeLevel;
  language?: string;
  resourceType?: string;
  sort: SortOption;
}

/* Map UI sort options to backend ordering query param */
function mapSortToOrdering(sort: SortOption): string | undefined {
  switch (sort) {
    case 'relevance':
      return '-search_score'; // typical search backend field
    case 'newest':
      return '-created_at';
    case 'popular':
      return '-popularity';
    case 'shortest':
      return 'estimated_minutes';
    case 'longest':
      return '-estimated_minutes';
    default:
      return undefined;
  }
}

function normalizeArray<T>(values: T[] | undefined, fallback: T[]): T[] {
  return values && values.length > 0 ? values : fallback;
}

/* ------------------------------------------------------------------ */
/*  Page component                                                     */
/* ------------------------------------------------------------------ */

export default function BrowseResourcesPage(): JSX.Element {
  const router = useRouter();
  const searchParams = useSearchParams();

  // Filters & pagination
  const [filters, setFilters] = useState<FiltersState>({
    query: '',
    sort: 'relevance',
  });
  const [page, setPage] = useState<number>(1);
  const [pageSize, setPageSize] = useState<number>(12);

  // Data
  const [resources, setResources] = useState<KnowledgeResource[]>([]);
  const [total, setTotal] = useState<number>(0);

  // Metadata for filters
  const [subjects, setSubjects] = useState<string[]>([]);
  const [levels, setLevels] = useState<KnowledgeLevel[]>(DEFAULT_LEVELS);
  const [languages, setLanguages] = useState<string[]>(DEFAULT_LANGUAGES);
  const [resourceTypes, setResourceTypes] = useState<string[]>(DEFAULT_RESOURCE_TYPES);

  // Loading / error states
  const [loading, setLoading] = useState<boolean>(false);
  const [loadingMeta, setLoadingMeta] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [exporting, setExporting] = useState<boolean>(false);
  const [sharing, setSharing] = useState<boolean>(false);

  /* ------------------------------------------------------------------ */
  /*  Query-string ‚Üî state sync (for "Share filters" links)             */
  /* ------------------------------------------------------------------ */

  useEffect(() => {
    if (!searchParams) return;

    const q = searchParams.get('q') ?? '';
    const subject = searchParams.get('subject') || undefined;
    const levelParam = searchParams.get('level') as KnowledgeLevel | null;
    const language = searchParams.get('language') || undefined;
    const resourceType = searchParams.get('resourceType') || undefined;
    const sortParam = searchParams.get('sort') as SortOption | null;

    const nextFilters: FiltersState = {
      query: q,
      subject,
      level:
        levelParam && (DEFAULT_LEVELS as readonly string[]).includes(levelParam)
          ? levelParam
          : undefined,
      language,
      resourceType,
      sort:
        sortParam && ['relevance', 'newest', 'popular', 'shortest', 'longest'].includes(sortParam)
          ? sortParam
          : 'relevance',
    };

    const urlPage = Number(searchParams.get('page') || '1');
    const urlPageSize = Number(searchParams.get('page_size') || '12');

    setFilters(nextFilters);
    if (!Number.isNaN(urlPage) && urlPage > 0) {
      setPage(urlPage);
    }
    if (!Number.isNaN(urlPageSize) && urlPageSize > 0) {
      setPageSize(urlPageSize);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams]);

  /* ------------------------------------------------------------------ */
  /*  Data fetching                                                      */
  /* ------------------------------------------------------------------ */

  const fetchResources = useCallback(
    async (overridePage?: number, overridePageSize?: number) => {
      setLoading(true);
      setError(null);

      const currentPage = overridePage ?? page;
      const currentPageSize = overridePageSize ?? pageSize;

      try {
        const params: Record<string, unknown> = {
          page: currentPage,
          page_size: currentPageSize,
        };

        if (filters.query) {
          params.search = filters.query;
        }
        if (filters.subject) {
          params.subject = filters.subject;
        }
        if (filters.level) {
          params.level = filters.level;
        }
        if (filters.language) {
          params.language = filters.language;
        }
        if (filters.resourceType) {
          params.resource_type = filters.resourceType;
        }

        const ordering = mapSortToOrdering(filters.sort);
        if (ordering) {
          params.ordering = ordering;
        }

        const response = await axios.get<KnowledgeResourceListResponse>(
          KNOWLEDGE_RESOURCES_ENDPOINT,
          { params },
        );

        const raw = response.data as unknown;
        let items: KnowledgeResource[] = [];
        let count = 0;

        if (Array.isArray(raw)) {
          items = raw as KnowledgeResource[];
          count = items.length;
        } else if (raw && typeof raw === 'object') {
          const obj = raw as KnowledgeResourceListResponse;
          const maybeResults =
            (Array.isArray(obj.results) && obj.results) ||
            (Array.isArray(obj.items) && obj.items) ||
            [];
          items = maybeResults;
          count =
            typeof obj.count === 'number'
              ? obj.count
              : typeof obj.total === 'number'
              ? obj.total
              : items.length;
        }

        setResources(items);
        setTotal(count);
      } catch (err) {
        const msg =
          err instanceof Error ? err.message : 'Unable to load knowledge resources.';
        setError(msg);
        setResources([]);
        setTotal(0);
      } finally {
        setLoading(false);
      }
    },
    [filters, page, pageSize],
  );

  const fetchMetadata = useCallback(async () => {
    setLoadingMeta(true);

    try {
      const response = await axios.get<KnowledgeMetadataResponse>(KNOWLEDGE_METADATA_ENDPOINT);
      const data = response.data ?? {};

      setSubjects(data.subjects ?? []);
      setLevels(normalizeArray(data.levels, DEFAULT_LEVELS));
      setLanguages(normalizeArray(data.languages, DEFAULT_LANGUAGES));
      setResourceTypes(normalizeArray(data.resource_types, DEFAULT_RESOURCE_TYPES));
    } catch {
      // Metadata is purely additive; failure should not block the main list.
      setSubjects([]);
      setLevels(DEFAULT_LEVELS);
      setLanguages(DEFAULT_LANGUAGES);
      setResourceTypes(DEFAULT_RESOURCE_TYPES);
    } finally {
      setLoadingMeta(false);
    }
  }, []);

  // Single effect: reacts to page / size / filters
  useEffect(() => {
    fetchResources(page, pageSize);
  }, [page, pageSize, fetchResources]);

  useEffect(() => {
    fetchMetadata();
  }, [fetchMetadata]);

  /* ------------------------------------------------------------------ */
  /*  Handlers                                                          */
  /* ------------------------------------------------------------------ */

  const handleSearch = (value: string) => {
    setPage(1);
    setFilters((prev) => ({
      ...prev,
      query: value.trim(),
    }));
  };

  const handleFilterChange =
    <K extends keyof FiltersState>(key: K) =>
    (value: FiltersState[K]) => {
      setPage(1);
      setFilters((prev) => ({
        ...prev,
        [key]: value,
      }));
    };

  const handleSortChange = (value: SortOption) => {
    setPage(1);
    setFilters((prev) => ({
      ...prev,
      sort: value,
    }));
  };

  const handleTableChangePage = (nextPage: number, nextPageSize?: number) => {
    setPage(nextPage);
    if (nextPageSize && nextPageSize !== pageSize) {
      setPageSize(nextPageSize);
    }
  };

  const handleOpenResource = (record: KnowledgeResource) => {
    // Prefer explicit URL from backend (can be external or internal).
    if (record.url) {
      const href = String(record.url);
      if (href.startsWith('http://') || href.startsWith('https://')) {
        window.open(href, '_blank', 'noopener,noreferrer');
      } else {
        router.push(href);
      }
      return;
    }

    // Fallback to course player route described in Knowledge module docs.
    const id = encodeURIComponent(String(record.id));
    router.push(`/course/${id}`);
  };

  const buildShareSearchParams = () => {
    const params = new URLSearchParams();

    if (filters.query) params.set('q', filters.query);
    if (filters.subject) params.set('subject', filters.subject);
    if (filters.level) params.set('level', filters.level);
    if (filters.language) params.set('language', filters.language);
    if (filters.resourceType) params.set('resourceType', filters.resourceType);
    if (filters.sort && filters.sort !== 'relevance') params.set('sort', filters.sort);

    if (page !== 1) params.set('page', String(page));
    if (pageSize !== 12) params.set('page_size', String(pageSize));

    return params;
  };

  const handleExportCurrentPage = async () => {
    if (!resources.length) {
      message.info('There are no resources to export for the current filters.');
      return;
    }

    try {
      setExporting(true);

      const header = [
        'id',
        'title',
        'subject',
        'level',
        'language',
        'resource_type',
        'average_rating',
        'estimated_minutes',
        'tags',
        'is_offline_available',
        'user_progress_percent',
      ];

      const rows = resources.map((r) => [
        r.id,
        r.title,
        r.subject ?? '',
        r.level ?? '',
        r.language ?? '',
        r.resource_type ?? '',
        r.average_rating ?? '',
        r.estimated_minutes ?? '',
        (r.tags ?? []).join('|'),
        r.is_offline_available ? 'yes' : 'no',
        r.user_progress_percent ?? '',
      ]);

      const encodeCell = (value: unknown): string => {
        const str =
          value === null || value === undefined ? '' : String(value);
        if (/[",\n]/.test(str)) {
          return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
      };

      const csv = [header, ...rows]
        .map((row) => row.map(encodeCell).join(','))
        .join('\n');

      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      link.href = url;
      link.download = `konnected-learning-library-${timestamp}.csv`;

      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      message.success('Exported current page of results as CSV.');
    } catch {
      message.error('Unable to export resources. Please try again.');
    } finally {
      setExporting(false);
    }
  };

  const handleShareFilters = async () => {
    try {
      setSharing(true);
      const params = buildShareSearchParams();
      const basePath = '/konnected/learning-library/browse-resources';
      const queryString = params.toString();
      const href = `${basePath}${queryString ? `?${queryString}` : ''}`;

      if (typeof window !== 'undefined') {
        const fullUrl = `${window.location.origin}${href}`;
        try {
          await navigator.clipboard.writeText(fullUrl);
          message.success('Link with current filters copied to your clipboard.');
        } catch {
          message.warning('Unable to copy link automatically. The URL has been updated instead.');
        }
      }

      router.push(href);
    } finally {
      setSharing(false);
    }
  };

  /* ------------------------------------------------------------------ */
  /*  Table columns                                                     */
  /* ------------------------------------------------------------------ */

  const columns: ColumnsType<KnowledgeResource> = useMemo(
    () => [
      {
        title: 'Title',
        dataIndex: 'title',
        key: 'title',
        render: (value: string, record) => (
          <Space direction="vertical" size={2}>
            <Button
              type="link"
              onClick={() => handleOpenResource(record)}
              style={{ padding: 0 }}
            >
              {value}
            </Button>
            {record.description && (
              <Text type="secondary" style={{ fontSize: 12 }}>
                {record.description}
              </Text>
            )}
          </Space>
        ),
      },
      {
        title: 'Subject',
        dataIndex: 'subject',
        key: 'subject',
        render: (value?: string) =>
          value ? (
            <Tag color="blue">{value}</Tag>
          ) : (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Not specified
            </Text>
          ),
      },
      {
        title: 'Type',
        dataIndex: 'resource_type',
        key: 'resource_type',
        render: (value: string) => (
          <Tag color="geekblue" style={{ textTransform: 'capitalize' }}>
            {value || 'other'}
          </Tag>
        ),
      },
      {
        title: 'Level',
        dataIndex: 'level',
        key: 'level',
        render: (value?: KnowledgeLevel) =>
          value ? (
            <Tag color="purple" style={{ textTransform: 'capitalize' }}>
              {value}
            </Tag>
          ) : (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Any level
            </Text>
          ),
      },
      {
        title: 'Language',
        dataIndex: 'language',
        key: 'language',
        render: (value?: string) =>
          value ? (
            <Tag color="cyan">{value}</Tag>
          ) : (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Not specified
            </Text>
          ),
      },
      {
        title: 'Rating',
        dataIndex: 'average_rating',
        key: 'average_rating',
        width: 150,
        render: (value?: number | null) =>
          value != null ? (
            <Space size={4}>
              <Rate disabled allowHalf defaultValue={value} />
              <Text type="secondary" style={{ fontSize: 12 }}>
                ({value.toFixed(1)})
              </Text>
            </Space>
          ) : (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Not rated yet
            </Text>
          ),
      },
      {
        title: 'Duration / min',
        dataIndex: 'estimated_minutes',
        key: 'estimated_minutes',
        width: 120,
        render: (value?: number | null) =>
          value != null ? (
            <Text>{value} min</Text>
          ) : (
            <Text type="secondary" style={{ fontSize: 12 }}>
              ‚Äî
            </Text>
          ),
      },
      {
        title: 'Progress',
        dataIndex: 'user_progress_percent',
        key: 'user_progress_percent',
        width: 120,
        render: (value?: number | null) =>
          value != null ? (
            <Text>{value}%</Text>
          ) : (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Not started
            </Text>
          ),
      },
      {
        title: 'Tags',
        dataIndex: 'tags',
        key: 'tags',
        render: (value?: string[]) =>
          value && value.length > 0 ? (
            <Space wrap size={4}>
              {value.map((tag) => (
                <Tag key={tag}>{tag}</Tag>
              ))}
            </Space>
          ) : (
            <Text type="secondary" style={{ fontSize: 12 }}>
              No tags
            </Text>
          ),
      },
      {
        title: 'Offline',
        dataIndex: 'is_offline_available',
        key: 'is_offline_available',
        width: 120,
        render: (value?: boolean) =>
          value ? (
            <Tag color="green">Available</Tag>
          ) : (
            <Tag>Online only</Tag>
          ),
      },
      {
        title: 'Actions',
        key: 'actions',
        fixed: 'right',
        width: 150,
        render: (_: unknown, record) => (
          <Space>
            <Button size="small" type="link" onClick={() => handleOpenResource(record)}>
              Open
            </Button>
            <Button
              size="small"
              icon={<DownloadOutlined />}
              disabled={!record.is_offline_available}
            >
              Offline
            </Button>
          </Space>
        ),
      },
    ],
    [handleOpenResource],
  );

  const hasResults = resources.length > 0;

  const filtersActive = useMemo(() => {
    const { query, subject, level, language, resourceType, sort } = filters;
    return Boolean(
      query || subject || level || language || resourceType || sort !== 'relevance',
    );
  }, [filters]);

  /* ------------------------------------------------------------------ */
  /*  Header actions                                                     */
  /* ------------------------------------------------------------------ */

  const headerPrimaryAction = (
    <Space>
      <Button
        icon={<DownloadOutlined />}
        onClick={handleExportCurrentPage}
        disabled={!hasResults}
        loading={exporting}
      >
        Export selection
      </Button>
      <Button
        icon={<ShareAltOutlined />}
        onClick={handleShareFilters}
        disabled={!hasResults && !filtersActive}
        loading={sharing}
      >
        Share filters
      </Button>
    </Space>
  );

  const headerSecondaryActions = (
    <Button
      icon={<FilterOutlined />}
      onClick={() => fetchResources(1, pageSize)}
      disabled={loading}
    >
      Refresh
    </Button>
  );

  /* ------------------------------------------------------------------ */
  /*  Render                                                            */
  /* ------------------------------------------------------------------ */

  return (
    <KonnectedPageShell
      title="Browse learning resources"
      subtitle="Explore the shared knowledge library and filter by subject, level, language, and more."
      primaryAction={headerPrimaryAction}
      secondaryActions={headerSecondaryActions}
    >
      <Row gutter={[16, 16]}>
        <Col span={24}>
          <Card>
            <Row gutter={[16, 16]} align="middle">
              <Col xs={24} md={10}>
                <Search
                  placeholder="Search by title or description"
                  allowClear
                  enterButton={<SearchOutlined />}
                  onSearch={handleSearch}
                />
              </Col>

              <Col xs={24} md={14}>
                <Row gutter={[8, 8]} justify="end">
                  <Col xs={24} sm={12} md={6}>
                    <Select
                      value={filters.subject}
                      onChange={handleFilterChange('subject')}
                      allowClear
                      placeholder="All subjects"
                      style={{ width: '100%' }}
                      options={subjects.map((s) => ({ label: s, value: s }))}
                    />
                  </Col>
                  <Col xs={24} sm={12} md={6}>
                    <Select
                      value={filters.level}
                      onChange={handleFilterChange('level')}
                      allowClear
                      placeholder="Any level"
                      style={{ width: '100%' }}
                      options={levels.map((lvl) => ({
                        label: lvl.charAt(0).toUpperCase() + lvl.slice(1),
                        value: lvl,
                      }))}
                    />
                  </Col>
                  <Col xs={24} sm={12} md={6}>
                    <Select
                      value={filters.language}
                      onChange={handleFilterChange('language')}
                      allowClear
                      placeholder="Any language"
                      style={{ width: '100%' }}
                      options={languages.map((lng) => ({ label: lng, value: lng }))}
                    />
                  </Col>
                  <Col xs={24} sm={12} md={6}>
                    <Select
                      value={filters.resourceType}
                      onChange={handleFilterChange('resourceType')}
                      allowClear
                      placeholder="All types"
                      style={{ width: '100%' }}
                      options={resourceTypes.map((t) => ({
                        label: t.charAt(0).toUpperCase() + t.slice(1),
                        value: t,
                      }))}
                    />
                  </Col>
                </Row>
              </Col>
            </Row>

            <Row
              style={{ marginTop: 16 }}
              justify="space-between"
              align="middle"
              gutter={[8, 8]}
            >
              <Col>
                {filtersActive ? (
                  <Text type="secondary">
                    <strong>Active filters:</strong>{' '}
                    {filters.query && (
                      <>
                        Search = <strong>"{filters.query}"</strong>{' '}
                      </>
                    )}
                    {filters.subject && (
                      <>
                        Subject = <strong>{filters.subject}</strong>{' '}
                      </>
                    )}
                    {filters.level && (
                      <>
                        Level = <strong>{filters.level}</strong>{' '}
                      </>
                    )}
                    {filters.language && (
                      <>
                        Language = <strong>{filters.language}</strong>{' '}
                      </>
                    )}
                    {filters.resourceType && (
                      <>
                        Type = <strong>{filters.resourceType}</strong>{' '}
                      </>
                    )}
                    {filters.sort !== 'relevance' && (
                      <>
                        Sort = <strong>{filters.sort}</strong>
                      </>
                    )}
                  </Text>
                ) : (
                  <Text type="secondary">
                    Use the search box and filters above to explore the knowledge library.
                  </Text>
                )}
              </Col>
              <Col>
                <Space align="center">
                  <Text type="secondary">Sort by</Text>
                  <Select<SortOption>
                    value={filters.sort}
                    onChange={handleSortChange}
                    style={{ width: 180 }}
                    options={[
                      { label: 'Best match', value: 'relevance' },
                      { label: 'Newest first', value: 'newest' },
                      { label: 'Most popular', value: 'popular' },
                      { label: 'Shortest duration', value: 'shortest' },
                      { label: 'Longest duration', value: 'longest' },
                    ]}
                  />
                  {loadingMeta && (
                    <Text type="secondary" style={{ fontSize: 12 }}>
                      Updating filter options‚Ä¶
                    </Text>
                  )}
                </Space>
              </Col>
            </Row>
          </Card>
        </Col>

        <Col span={24}>
          <Card
            title="Library results"
            extra={
              <Space>
                <Button
                  icon={<FilterOutlined />}
                  onClick={() => fetchResources(1, pageSize)}
                  disabled={loading}
                >
                  Refresh
                </Button>
              </Space>
            }
          >
            {error && (
              <Alert
                type="error"
                showIcon
                message="Unable to load resources"
                description={error}
                style={{ marginBottom: 16 }}
              />
            )}

            {loading && !hasResults ? (
              <Spin
                tip="Loading resources‚Ä¶"
                size="large"
                style={{
                  width: '100%',
                  minHeight: 200,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <div />
              </Spin>
            ) : (
              <>
                <Table<KnowledgeResource>
                  rowKey={(row) => row.id}
                  size="middle"
                  bordered
                  columns={columns}
                  dataSource={resources}
                  loading={loading}
                  pagination={false}
                  scroll={{ x: 1100 }}
                  locale={{
                    emptyText: (
                      <div style={{ padding: '24px 0' }}>
                        <Text type="secondary">
                          No resources match your filters yet. Try adjusting your search terms or
                          filter options.
                        </Text>
                      </div>
                    ),
                  }}
                />

                <div
                  style={{
                    marginTop: 16,
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    flexWrap: 'wrap',
                    gap: 12,
                  }}
                >
                  <Text type="secondary">
                    Page {page} of {Math.max(1, Math.ceil(total / pageSize))}
                  </Text>

                  <Pagination
                    current={page}
                    total={total}
                    pageSize={pageSize}
                    showSizeChanger
                    pageSizeOptions={['6', '12', '24', '48']}
                    showTotal={(t) => `${t} item${t === 1 ? '' : 's'}`}
                    onChange={handleTableChangePage}
                  />
                </div>
              </>
            )}
          </Card>
        </Col>
      </Row>
    </KonnectedPageShell>
  );
}

===== END app/konnected/learning-library/browse-resources/page.tsx =====


===== BEGIN app/konnected/learning-library/offline-content/page.tsx =====
// app/konnected/learning-library/offline-content/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import Head from 'next/head';
import {
  Row,
  Col,
  Card,
  Typography,
  Button,
  Tag,
  Progress,
  Table,
  Switch,
  Space,
  Modal,
  Form,
  Input,
  Select,
  Tooltip,
  Empty,
  Alert,
  Skeleton,
  App,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import { ProCard, StatisticCard } from '@ant-design/pro-components';
import {
  SyncOutlined,
  DeleteOutlined,
  PlusOutlined,
  WarningOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import api from '@/api';

const { Paragraph, Text } = Typography;
const { Option } = Select;
const { Statistic } = StatisticCard;

// ---- Domain types ---------------------------------------------------------

type OfflinePackageStatus = 'scheduled' | 'building' | 'ready' | 'failed';

interface OfflinePackage {
  id: number | string;
  name: string;
  description?: string;
  status: OfflinePackageStatus;
  itemCount: number;
  totalSizeMb: number;
  lastBuiltAt?: string | null;
  targetDeviceType?: 'laptop' | 'tablet' | 'usb' | 'other';
  autoSync?: boolean;
  // Optional: when a build is in progress
  buildProgressPercent?: number;
  lastErrorMessage?: string | null;
}

type ResourceType = 'article' | 'video' | 'lesson' | 'quiz' | 'dataset';

interface OfflineableResource {
  id: number | string;
  title: string;
  type: ResourceType;
  subject?: string;
  level?: string;
  language?: string;
  sizeMb?: number;
  offlineEligible: boolean;
  includedInPackages?: string[]; // package names / IDs for quick display
}

interface CreateOfflinePackagePayload {
  name: string;
  description?: string;
  targetDeviceType?: OfflinePackage['targetDeviceType'];
  maxSizeMb?: number;
  includeTypes?: ResourceType[];
  subjectFilter?: string;
  levelFilter?: string;
  languageFilter?: string;
}

// ---- API helpers ----------------------------------------------------------
// NOTE: Endpoint paths/response wrappers are inferred.
// Align them with schema-endpoints.json when wiring to the real backend.

// Use relative URLs so that NEXT_PUBLIC_API_BASE or "/api" baseURL applies
// consistently (see services/_request.ts and Global Parameter Reference).
const OFFLINE_PACKAGE_LIST_ENDPOINT = 'konnected/offline-packages/';
const OFFLINE_PACKAGE_DETAIL_ENDPOINT = (id: OfflinePackage['id']) =>
  `konnected/offline-packages/${id}/`;
const OFFLINE_PACKAGE_SYNC_ENDPOINT = (id: OfflinePackage['id']) =>
  `konnected/offline-packages/${id}/sync/`;

// Knowledge module (KonnectED) offline-eligible resources.
// We probe a small set of candidate endpoints to stay aligned with the v14
// Knowledge spec while the backend paths stabilise.
const OFFLINE_RESOURCES_ENDPOINTS: readonly string[] = [
  '/api/konnected/resources/',
  '/api/knowledge-resources/',
  '/api/knowledge/resources/',
];

function normalizeList<T>(raw: unknown): T[] {
  if (Array.isArray(raw)) return raw as T[];

  if (raw && typeof raw === 'object') {
    const obj = raw as { results?: unknown; items?: unknown };
    if (Array.isArray(obj.results)) return obj.results as T[];
    if (Array.isArray(obj.items)) return obj.items as T[];
  }

  return [];
}

// ---- Requests -------------------------------------------------------------

async function fetchOfflinePackages(): Promise<OfflinePackage[]> {
  // api.get already returns the data T (not AxiosResponse<T>)
  const raw = await api.get(OFFLINE_PACKAGE_LIST_ENDPOINT);
  return normalizeList<OfflinePackage>(raw);
}

async function createOfflinePackage(
  payload: CreateOfflinePackagePayload,
): Promise<void> {
  await api.post(OFFLINE_PACKAGE_LIST_ENDPOINT, payload);
}

async function deleteOfflinePackage(id: OfflinePackage['id']): Promise<void> {
  await api.delete(OFFLINE_PACKAGE_DETAIL_ENDPOINT(id));
}

async function syncOfflinePackage(id: OfflinePackage['id']): Promise<void> {
  await api.post(OFFLINE_PACKAGE_SYNC_ENDPOINT(id));
}

/**
 * Update a subset of package fields (currently autoSync).
 * This is wired to the "Auto sync" toggle in the table.
 */
async function updateOfflinePackage(
  id: OfflinePackage['id'],
  payload: Partial<Pick<OfflinePackage, 'autoSync'>>,
): Promise<OfflinePackage> {
  return api.patch<OfflinePackage>(OFFLINE_PACKAGE_DETAIL_ENDPOINT(id), payload);
}

async function fetchOfflineableResources(): Promise<OfflineableResource[]> {
  let lastError: unknown;

  for (const url of OFFLINE_RESOURCES_ENDPOINTS) {
    try {
      const res = await fetch(url, { credentials: 'include' });

      if (!res.ok) {
        lastError = new Error(
          `Offline resources endpoint ${url} returned ${res.status}`,
        );
        continue;
      }

      const json = await res.json();
      const rawItems = normalizeList<any>(json);

      const mapped: OfflineableResource[] = rawItems.map((raw) => {
        // Normalise type to the v14 CONTENT_TYPES_ALLOWED enum
        // ("article", "video", "lesson", "quiz", "dataset").
        const typeValue: string =
          (raw.type ??
            raw.resource_type ??
            raw.content_type ??
            'article') as string;

        const normalizedType = String(typeValue).toLowerCase();

        let type: ResourceType;
        if (
          normalizedType === 'article' ||
          normalizedType === 'video' ||
          normalizedType === 'lesson' ||
          normalizedType === 'quiz' ||
          normalizedType === 'dataset'
        ) {
          type = normalizedType as ResourceType;
        } else if (normalizedType === 'course' || normalizedType === 'module') {
          type = 'lesson';
        } else if (
          normalizedType === 'doc' ||
          normalizedType === 'document' ||
          normalizedType === 'file'
        ) {
          type = 'article';
        } else {
          type = 'article';
        }

        const sizeMb =
          typeof raw.sizeMb === 'number'
            ? raw.sizeMb
            : typeof raw.size_mb === 'number'
              ? raw.size_mb
              : typeof raw.bundle_size_mb === 'number'
                ? raw.bundle_size_mb
                : undefined;

        const offlineEligible = Boolean(
          raw.offlineEligible ??
            raw.offline_available ??
            raw.offlineAvailable ??
            raw.is_offline_available ??
            raw.can_be_offlined,
        );

        const includedInPackages: string[] | undefined =
          (raw.includedInPackages as string[] | undefined) ??
          (raw.packages as string[] | undefined) ??
          undefined;

        return {
          id: raw.id,
          title: raw.title ?? '',
          type,
          subject: raw.subject ?? raw.topic ?? raw.domain ?? undefined,
          level: raw.level ?? raw.difficulty ?? undefined,
          language: raw.language ?? raw.lang ?? undefined,
          sizeMb,
          offlineEligible,
          includedInPackages,
        };
      });

      return mapped;
    } catch (err) {
      lastError = err;
    }
  }

  if (lastError) {
    throw lastError instanceof Error
      ? lastError
      : new Error('Unable to load offlineable resources.');
  }

  // Fallback: no known endpoint responded; return empty list
  // so the rest of the UI still renders.
  return [];
}

// ---- Page -----------------------------------------------------------------

export default function OfflineContentPage(): JSX.Element {
  const { message, modal } = App.useApp();

  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [createForm] = Form.useForm<CreateOfflinePackagePayload>();

  const {
    data: packages,
    loading: loadingPackages,
    error: packagesError,
    refresh: refreshPackages,
  } = useRequest(fetchOfflinePackages);

  const {
    data: resources,
    loading: loadingResources,
    error: resourcesError,
    refresh: refreshResources,
  } = useRequest(fetchOfflineableResources);

  const { loading: creating, runAsync: runCreatePackage } = useRequest(
    createOfflinePackage,
    {
      manual: true,
    },
  );
  const { loading: deleting, runAsync: runDeletePackage } = useRequest(
    deleteOfflinePackage,
    {
      manual: true,
    },
  );
  const { loading: syncing, runAsync: runSyncPackage } = useRequest(
    syncOfflinePackage,
    {
      manual: true,
    },
  );
  const { loading: updatingPackage, runAsync: runUpdatePackage } = useRequest(
    updateOfflinePackage,
    {
      manual: true,
    },
  );

  const packageList = packages ?? [];
  const resourceList = resources ?? [];

  const stats = useMemo(() => {
    const totalPackages = packageList.length;
    const readyPackages = packageList.filter((p) => p.status === 'ready').length;
    const inProgressPackages = packageList.filter((p) =>
      ['scheduled', 'building'].includes(p.status),
    ).length;

    const totalSizeMb = packageList.reduce(
      (acc, p) => acc + (p.totalSizeMb || 0),
      0,
    );
    const eligibleResourcesCount = resourceList.filter(
      (r) => r.offlineEligible,
    ).length;

    return {
      totalPackages,
      readyPackages,
      inProgressPackages,
      totalSizeMb,
      eligibleResourcesCount,
    };
  }, [packageList, resourceList]);

  const columnsPackages: ColumnsType<OfflinePackage> = [
    {
      title: 'Package name',
      dataIndex: 'name',
      key: 'name',
      render: (name: string, record) => (
        <Space direction="vertical" size={0}>
          <Text strong>{name}</Text>
          {record.description && (
            <Text type="secondary" style={{ fontSize: 12 }}>
              {record.description}
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (status: OfflinePackageStatus, record) => {
        let color: 'processing' | 'success' | 'error' | 'default' = 'default';
        // Explicit string to avoid assigning "Scheduled"/"Ready" to OfflinePackageStatus
        let label: string = status;

        if (status === 'scheduled' || status === 'building') {
          color = 'processing';
          label = status === 'scheduled' ? 'Scheduled' : 'Building';
        } else if (status === 'ready') {
          color = 'success';
          label = 'Ready';
        } else if (status === 'failed') {
          color = 'error';
          label = 'Failed';
        }

        return (
          <Space direction="vertical" size={0}>
            <Tag color={color}>{label}</Tag>
            {typeof record.buildProgressPercent === 'number' && (
              <Progress
                percent={record.buildProgressPercent}
                size="small"
                style={{ width: 120 }}
              />
            )}
            {record.lastErrorMessage && (
              <Text type="danger" style={{ fontSize: 12 }}>
                {record.lastErrorMessage}
              </Text>
            )}
          </Space>
        );
      },
    },
    {
      title: 'Items',
      dataIndex: 'itemCount',
      key: 'itemCount',
      render: (value: number) => <Text>{value ?? 0}</Text>,
    },
    {
      title: 'Size',
      dataIndex: 'totalSizeMb',
      key: 'totalSizeMb',
      render: (value: number) => <Text>{(value ?? 0).toFixed(1)} MB</Text>,
    },
    {
      title: 'Target device',
      dataIndex: 'targetDeviceType',
      key: 'targetDeviceType',
      render: (value?: OfflinePackage['targetDeviceType']) => (
        <Text type="secondary" style={{ textTransform: 'capitalize' }}>
          {value || 'Not specified'}
        </Text>
      ),
    },
    {
      title: 'Auto sync',
      dataIndex: 'autoSync',
      key: 'autoSync',
      render: (value: boolean | undefined, record) => (
        <Switch
          checked={Boolean(value)}
          size="small"
          loading={updatingPackage}
          onChange={async (checked) => {
            try {
              await runUpdatePackage(record.id, { autoSync: checked });
              message.success(
                checked
                  ? 'Package enrolled in the weekly offline build.'
                  : 'Package removed from the automatic offline build.',
              );
              refreshPackages();
            } catch (err) {
              const msg =
                err instanceof Error
                  ? err.message
                  : 'Failed to update auto-sync setting.';
              message.error(msg);
            }
          }}
        />
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_, record) => (
        <Space>
          <Button
            icon={<SyncOutlined />}
            size="small"
            loading={syncing}
            onClick={() => handleSyncPackage(record)}
            disabled={record.status === 'building'}
          >
            Sync now
          </Button>
          <Button
            icon={<DeleteOutlined />}
            size="small"
            danger
            loading={deleting}
            onClick={() => handleDeletePackage(record)}
          >
            Delete
          </Button>
        </Space>
      ),
    },
  ];

  const columnsResources: ColumnsType<OfflineableResource> = [
    {
      title: 'Title',
      dataIndex: 'title',
      key: 'title',
      render: (value: string, record) => (
        <Space direction="vertical" size={0}>
          <Text>{value}</Text>
          <Space size={4} wrap>
            {record.subject && <Tag color="blue">{record.subject}</Tag>}
            {record.level && <Tag color="purple">{record.level}</Tag>}
            {record.language && <Tag>{record.language}</Tag>}
          </Space>
        </Space>
      ),
    },
    {
      title: 'Type',
      dataIndex: 'type',
      key: 'type',
      render: (value: ResourceType) => (
        <Tag color="geekblue" style={{ textTransform: 'capitalize' }}>
          {value}
        </Tag>
      ),
    },
    {
      title: 'Size (MB)',
      dataIndex: 'sizeMb',
      key: 'sizeMb',
      render: (value?: number) => (
        <Text>{value != null ? value.toFixed(1) : 'N/A'}</Text>
      ),
    },
    {
      title: 'Offline status',
      dataIndex: 'offlineEligible',
      key: 'offlineEligible',
      render: (value: boolean) =>
        value ? (
          <Tag color="green">Eligible</Tag>
        ) : (
          <Tag color="default">Online only</Tag>
        ),
    },
    {
      title: 'Included in packages',
      dataIndex: 'includedInPackages',
      key: 'includedInPackages',
      render: (packages?: string[]) =>
        packages && packages.length ? (
          <Space size={[4, 4]} wrap>
            {packages.map((name) => (
              <Tag key={name}>{name}</Tag>
            ))}
          </Space>
        ) : (
          <Text type="secondary" style={{ fontSize: 12 }}>
            Not yet packaged
          </Text>
        ),
    },
  ];

  const handleCreatePackage = async (values: CreateOfflinePackagePayload) => {
    try {
      await runCreatePackage(values);
      message.success(
        'Offline package created. It will appear here once builds start.',
      );
      setIsCreateModalOpen(false);
      createForm.resetFields();
      refreshPackages();
    } catch (err) {
      const msg =
        err instanceof Error
          ? err.message
          : 'Failed to create offline package.';
      message.error(msg);
    }
  };

  const handleDeletePackage = async (pkg: OfflinePackage) => {
    modal.confirm({
      title: 'Delete offline package',
      content: `Are you sure you want to delete "${pkg.name}"? This will not remove already synced data from devices.`,
      okText: 'Delete',
      okButtonProps: { danger: true, loading: deleting },
      onOk: async () => {
        try {
          await runDeletePackage(pkg.id);
          message.success('Offline package deleted.');
          refreshPackages();
        } catch (err) {
          const msg =
            err instanceof Error
              ? err.message
              : 'Failed to delete offline package.';
          message.error(msg);
        }
      },
    });
  };

  const handleSyncPackage = async (pkg: OfflinePackage) => {
    try {
      await runSyncPackage(pkg.id);
      message.success('Sync request submitted.');
      refreshPackages();
    } catch (err) {
      const msg =
        err instanceof Error ? err.message : 'Failed to trigger sync.';
      message.error(msg);
    }
  };

  return (
    <>
      <Head>
        <title>Offline content ‚Äì KonnectED</title>
      </Head>

      <KonnectedPageShell
        title="Offline content packages"
        subtitle="Prepare resource bundles for low-connectivity environments (e.g. schools, field teams, community centers)."
        primaryAction={
          <Button
            type="primary"
            icon={<PlusOutlined />}
            onClick={() => setIsCreateModalOpen(true)}
          >
            New offline package
          </Button>
        }
      >
        <Row gutter={[16, 16]}>
          <Col xs={24} lg={10}>
            <ProCard title="Offline packages overview" bordered>
              <Space direction="vertical" size="large" style={{ width: '100%' }}>
                <Statistic title="Total packages" value={stats.totalPackages} />
                <Space size="large">
                  <StatisticCard
                    statistic={{
                      title: 'Ready',
                      value: stats.readyPackages,
                    }}
                  />
                  <StatisticCard
                    statistic={{
                      title: 'In progress',
                      value: stats.inProgressPackages,
                    }}
                  />
                </Space>
                <Statistic
                  title="Total storage (MB)"
                  value={stats.totalSizeMb.toFixed(1)}
                />
                <Statistic
                  title="Resources eligible for offline"
                  value={stats.eligibleResourcesCount}
                />
              </Space>
            </ProCard>

            {(packagesError || resourcesError) && (
              <Alert
                type="warning"
                showIcon
                style={{ marginTop: 16 }}
                message="Some offline APIs may not be fully wired yet"
                description="Offline package management and resource eligibility depend on KonnectED‚Äôs Knowledge backend. Once all endpoints are live, this page will display real-time data."
              />
            )}
          </Col>

          <Col xs={24} lg={14}>
            <Card
              title="Offline packages"
              extra={
                <Button
                  icon={<SyncOutlined />}
                  onClick={() => {
                    refreshPackages();
                    refreshResources();
                  }}
                  loading={loadingPackages || loadingResources}
                >
                  Refresh
                </Button>
              }
            >
              {loadingPackages ? (
                <Skeleton active />
              ) : packageList.length === 0 ? (
                <Empty
                  description={
                    <Space direction="vertical">
                      <Text>No offline packages yet.</Text>
                      <Text type="secondary">
                        Create a package to bundle resources for offline
                        deployment to devices.
                      </Text>
                    </Space>
                  }
                />
              ) : (
                <Table<OfflinePackage>
                  rowKey={(record) => String(record.id)}
                  columns={columnsPackages}
                  dataSource={packageList}
                  pagination={false}
                />
              )}
            </Card>

            <Card title="Candidate resources for offline" style={{ marginTop: 16 }}>
              {loadingResources ? (
                <Skeleton active />
              ) : resourceList.length === 0 ? (
                <Empty
                  image={Empty.PRESENTED_IMAGE_SIMPLE}
                  description="No resources available for offline packaging yet."
                />
              ) : (
                <Table<OfflineableResource>
                  rowKey={(record) => String(record.id)}
                  columns={columnsResources}
                  dataSource={resourceList}
                  size="small"
                  pagination={{ pageSize: 8 }}
                />
              )}
            </Card>
          </Col>
        </Row>

        {/* Creation modal */}
        <Modal
          title="New offline package"
          open={isCreateModalOpen}
          onCancel={() => setIsCreateModalOpen(false)}
          destroyOnClose
          okText="Create package"
          okButtonProps={{ loading: creating }}
          onOk={() => createForm.submit()}
        >
          <Paragraph type="secondary" style={{ marginBottom: 16 }}>
            Select filters and constraints for this offline bundle. The backend
            will resolve concrete resources and schedule builds according to the
            global offline cron.
          </Paragraph>

          <Form<CreateOfflinePackagePayload>
            form={createForm}
            layout="vertical"
            onFinish={handleCreatePackage}
            initialValues={{
              targetDeviceType: 'laptop',
              maxSizeMb: 2048,
              includeTypes: ['article', 'video', 'lesson'],
            }}
          >
            <Form.Item
              label="Package name"
              name="name"
              rules={[{ required: true, message: 'Please enter a package name.' }]}
            >
              <Input placeholder="e.g. Robotics basics ‚Äì offline pack for School A" />
            </Form.Item>

            <Form.Item label="Description" name="description">
              <Input.TextArea
                rows={3}
                placeholder="Short description for administrators and field teams."
              />
            </Form.Item>

            <Form.Item label="Target device type" name="targetDeviceType">
              <Select>
                <Option value="laptop">Laptop / desktop (lab PCs)</Option>
                <Option value="tablet">Tablet devices</Option>
                <Option value="usb">USB drive / external media</Option>
                <Option value="other">Other / mixed devices</Option>
              </Select>
            </Form.Item>

            <Form.Item
              label={
                <Space>
                  Maximum bundle size (MB)
                  <Tooltip title="Helps avoid exceeding storage on low-spec devices. Backend enforces final limits.">
                    <WarningOutlined />
                  </Tooltip>
                </Space>
              }
              name="maxSizeMb"
              rules={[
                {
                  type: 'number',
                  transform: (v) => (v === '' ? undefined : Number(v)),
                  min: 0,
                  message: 'Please enter a valid size in MB.',
                },
              ]}
            >
              <Input placeholder="e.g. 2048" type="number" min={0} />
            </Form.Item>

            <Form.Item label="Include resource types" name="includeTypes">
              <Select mode="multiple" placeholder="Select one or more types">
                <Option value="article">Articles</Option>
                <Option value="video">Videos</Option>
                <Option value="lesson">Lessons</Option>
                <Option value="quiz">Quizzes</Option>
                <Option value="dataset">Datasets</Option>
              </Select>
            </Form.Item>

            <Form.Item label="Subject filter" name="subjectFilter">
              <Input placeholder="Optional subject filter, e.g. Robotics" />
            </Form.Item>

            <Form.Item label="Level filter" name="levelFilter">
              <Input placeholder="Optional level filter, e.g. Beginner" />
            </Form.Item>

            <Form.Item label="Language filter" name="languageFilter">
              <Input placeholder="Optional language filter, e.g. en, fr" />
            </Form.Item>
          </Form>
        </Modal>
      </KonnectedPageShell>
    </>
  );
}

===== END app/konnected/learning-library/offline-content/page.tsx =====


===== BEGIN app/konnected/learning-library/recommended-resources/page.tsx =====
// app/konnected/learning-library/recommended-resources/page.tsx
'use client';

import React, { useCallback, useEffect, useMemo, useState } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/navigation';
import {
  Alert,
  Button,
  Card,
  Col,
  Empty,
  List,
  Progress,
  Row,
  Skeleton,
  Space,
  Tag,
  Typography,
  message,
} from 'antd';
import {
  ReloadOutlined,
  SettingOutlined,
  LikeOutlined,
  DislikeOutlined,
  StarFilled,
  ArrowRightOutlined,
  BookOutlined,
  FireOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text } = Typography;

type ResourceType = 'article' | 'video' | 'lesson' | 'quiz' | 'dataset';

interface KnowledgeResource {
  id: string;
  title: string;
  summary: string;
  subject?: string;
  level?: 'Beginner' | 'Intermediate' | 'Advanced';
  language?: string;
  type: ResourceType;
  tags?: string[];
  estimatedDurationMinutes?: number;
  // e.g. /course/[slug] or /konnected/learning-library/resource/[id]
  viewerUrl?: string;
  // Whether this resource is available in offline bundles
  offlineAvailable?: boolean;
  // Optional label if this resource is part of a learning path / certification
  partOfPathTitle?: string;
}

interface LearningProgress {
  resourceId: string;
  progressPercent: number; // 0..100
  lastTouchedAt?: string;
}

type RecommendationSource = 'ml' | 'editorial' | 'trend';

interface KnowledgeRecommendationItem {
  recommendationId: string;
  score?: number;
  reason?: string;
  recommendedAt: string;
  source?: RecommendationSource;
  resource: KnowledgeResource;
  progress?: LearningProgress;
}

interface RecommendationsResponse {
  results: KnowledgeRecommendationItem[];
  count: number;
}

/* ------------------------------------------------------------------ */
/*  Helpers to normalize API responses                                */
/* ------------------------------------------------------------------ */

function normalizeList<T = unknown>(raw: unknown): { items: T[]; count?: number } {
  if (Array.isArray(raw)) {
    return { items: raw as T[] };
  }

  if (raw && typeof raw === 'object') {
    const obj = raw as { results?: unknown; items?: unknown; count?: number };
    const items =
      (Array.isArray(obj.results) && (obj.results as T[])) ||
      (Array.isArray(obj.items) && (obj.items as T[])) ||
      [];
    return { items, count: typeof obj.count === 'number' ? obj.count : undefined };
  }

  return { items: [] };
}

async function fetchJson(url: string): Promise<unknown> {
  const res = await fetch(url, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include',
  });

  if (!res.ok) {
    throw new Error(`Request failed (${res.status})`);
  }

  return res.json();
}

// Simple numeric normalizer to cope with string/number fields from the API
function safeNumber(value: unknown): number {
  if (typeof value === 'number') return value;
  if (typeof value === 'string') {
    const n = Number(value);
    return Number.isFinite(n) ? n : 0;
  }
  return 0;
}

function normalizeRecommendations(raw: unknown): RecommendationsResponse {
  const { items, count } = normalizeList<any>(raw);

  const mapped: KnowledgeRecommendationItem[] = items.map(
    (row: any, index: number) => {
      // Support both:
      // - Recommendations API with row.resource, row.progress, row.score, row.reason...
      // - Plain knowledge resources list where row itself is the resource.
      const resourceRaw = row.resource ?? row;
      const id = resourceRaw.id ?? row.id ?? index;

      const rawType = (resourceRaw.type ?? resourceRaw.resource_type ?? 'article') as string;
      const normalizedType: ResourceType =
        rawType === 'doc'
          ? 'article'
          : rawType === 'course'
          ? 'lesson'
          : (['article', 'video', 'lesson', 'quiz', 'dataset'] as const).includes(
              rawType as ResourceType,
            )
          ? (rawType as ResourceType)
          : 'article';

      const resource: KnowledgeResource = {
        id: String(id),
        title: resourceRaw.title ?? 'Untitled resource',
        summary: resourceRaw.summary ?? resourceRaw.description ?? '',
        subject: resourceRaw.subject ?? undefined,
        level: resourceRaw.level ?? undefined,
        language: resourceRaw.language ?? undefined,
        type: normalizedType,
        tags: resourceRaw.tags ?? resourceRaw.keywords ?? [],
        estimatedDurationMinutes:
          resourceRaw.estimatedDurationMinutes ??
          resourceRaw.estimated_minutes ??
          resourceRaw.estimated_duration_minutes ??
          undefined,
        viewerUrl: resourceRaw.viewerUrl ?? resourceRaw.url ?? undefined,
        offlineAvailable: Boolean(
          resourceRaw.offlineAvailable ??
            resourceRaw.is_offline_available ??
            resourceRaw.offlineEligible ??
            resourceRaw.offline_eligible,
        ),
        partOfPathTitle:
          resourceRaw.partOfPathTitle ??
          resourceRaw.path_title ??
          resourceRaw.path_label ??
          undefined,
      };

      const progressSource = row.progress ?? resourceRaw.progress;
      let progress: LearningProgress | undefined;
      if (progressSource) {
        const rawPercent =
          progressSource.progressPercent ?? progressSource.progress_percent;
        const percent = Math.max(0, Math.min(100, safeNumber(rawPercent)));

        progress = {
          resourceId: String(id),
          progressPercent: percent,
          lastTouchedAt:
            progressSource.lastTouchedAt ?? progressSource.last_touched_at,
        };
      }

      const rawScore = row.score ?? row.relevance_score;

      return {
        recommendationId: String(row.id ?? `rec-${id}`),
        score: typeof rawScore === 'number' ? rawScore : undefined,
        reason: typeof row.reason === 'string' ? row.reason : undefined,
        recommendedAt:
          row.recommendedAt ??
          row.recommended_at ??
          resourceRaw.created_at ??
          new Date().toISOString(),
        source: row.source as RecommendationSource | undefined,
        resource,
        progress,
      };
    },
  );

  return {
    results: mapped,
    count: typeof count === 'number' ? count : mapped.length,
  };
}

/**
 * Strategy:
 * 1. Try the dedicated /api/knowledge-recommendations/ endpoint (when wired).
 * 2. Fall back to the main KnowledgeResource list. To stay robust against
 *    backend refactors, we try the known path variants used across v14:
 *      - /api/knowledge-resources/
 *      - /api/knowledge/resources/
 *      - /api/konnected/resources/  (current DRF router)
 */
async function fetchRecommendations(): Promise<RecommendationsResponse> {
  // 1) Dedicated recommendations endpoint
  try {
    const raw = await fetchJson('/api/knowledge-recommendations/');
    return normalizeRecommendations(raw);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn(
      'Falling back to KnowledgeResource list for recommendations',
      err,
    );
  }

  // 2) Fallback: generic knowledge resources list
  const fallbackEndpoints = [
    '/api/knowledge-resources/',
    '/api/knowledge/resources/',
    '/api/konnected/resources/',
  ];

  for (const url of fallbackEndpoints) {
    try {
      const rawFallback = await fetchJson(url);
      return normalizeRecommendations(rawFallback);
    } catch {
      // try next variant
    }
  }

  throw new Error('Unable to load knowledge resources from any endpoint.');
}

/**
 * Optional: send feedback so the ML layer can learn.
 * For now this is best-effort; failures are non-blocking for the UI.
 */
async function sendRecommendationFeedback(
  item: KnowledgeRecommendationItem,
  feedback: 'like' | 'dislike',
): Promise<void> {
  try {
    await fetch('/api/knowledge-recommendations/feedback/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify({
        recommendationId: item.recommendationId,
        resourceId: item.resource.id,
        feedback,
      }),
    });
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn('Failed to send recommendation feedback', err);
  }
}

/* ------------------------------------------------------------------ */
/*  Page component                                                     */
/* ------------------------------------------------------------------ */

export default function RecommendedResourcesPage(): JSX.Element {
  const router = useRouter();

  const [recommendations, setRecommendations] = useState<KnowledgeRecommendationItem[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [hasLoadedOnce, setHasLoadedOnce] = useState<boolean>(false);
  const [likeInFlightIds, setLikeInFlightIds] = useState<Set<string>>(new Set());

  const hasRecommendations = recommendations.length > 0;

  const sortedRecommendations = useMemo(
    () =>
      [...recommendations].sort((a, b) => {
        if (typeof a.score === 'number' && typeof b.score === 'number') {
          return b.score - a.score;
        }

        return (
          new Date(b.recommendedAt).getTime() -
          new Date(a.recommendedAt).getTime()
        );
      }),
    [recommendations],
  );

  const handleReload = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const data = await fetchRecommendations();
      setRecommendations(data.results);
      setHasLoadedOnce(true);

      if (!data.results.length) {
        message.info(
          'No personalized recommendations yet. Try completing a few lessons or rating resources.',
        );
      }
    } catch (err) {
      const msg =
        err instanceof Error
          ? err.message
          : 'Unable to load recommendations right now.';
      setError(msg);

      if (!hasLoadedOnce) {
        // Soft fallback: try to use cached sample data from localStorage if present
        try {
          const cached = window.localStorage.getItem(
            'konnected:sample:knowledge-recommendations',
          );
          if (cached) {
            const parsed = JSON.parse(cached) as unknown;
            const normalized = normalizeRecommendations(parsed);
            setRecommendations(normalized.results);
          }
        } catch {
          // ignore
        }
      }
    } finally {
      setLoading(false);
    }
  }, [hasLoadedOnce]);

  useEffect(() => {
    void handleReload();
  }, [handleReload]);

  const handleViewResource = (item: KnowledgeRecommendationItem) => {
    const href =
      item.resource.viewerUrl ??
      `/konnected/learning-library/resource/${encodeURIComponent(
        item.resource.id,
      )}`;

    router.push(href);
  };

  const handleFeedback = async (
    item: KnowledgeRecommendationItem,
    feedback: 'like' | 'dislike',
  ) => {
    const key = `${item.recommendationId}:${feedback}`;

    setLikeInFlightIds((prev) => {
      const next = new Set(prev);
      next.add(key);
      return next;
    });

    try {
      await sendRecommendationFeedback(item, feedback);
      message.success(
        feedback === 'like'
          ? 'Thanks! We will show you more content like this.'
          : 'We will show you this type of content less often.',
      );
    } catch (err) {
      const msg =
        err instanceof Error
          ? err.message
          : 'Could not send feedback. Please try again later.';
      message.error(msg);
    } finally {
      setLikeInFlightIds((prev) => {
        const next = new Set(prev);
        next.delete(key);
        return next;
      });
    }
  };

  const renderHeaderTags = () => (
    <Space size={[8, 8]} wrap>
      <Tag icon={<StarFilled />} color="gold">
        Personalized
      </Tag>
      <Tag icon={<BookOutlined />} color="geekblue">
        Knowledge Library
      </Tag>
      <Tag icon={<FireOutlined />} color="volcano">
        Early prototype
      </Tag>
    </Space>
  );

  return (
    <>
      <Head>
        <title>Recommended resources ‚Äì KonnectED</title>
      </Head>

      <KonnectedPageShell
        title="Recommended resources"
        subtitle="Personalized learning suggestions based on your activity in the KonnectED Knowledge Library."
        primaryAction={
          <Button
            icon={<ReloadOutlined />}
            onClick={() => void handleReload()}
            loading={loading}
          >
            Refresh recommendations
          </Button>
        }
        secondaryActions={
          <Space>
            <Button
              icon={<BookOutlined />}
              onClick={() =>
                router.push('/konnected/learning-library/browse-resources')
              }
            >
              Browse library
            </Button>
            <Button icon={<SettingOutlined />} disabled>
              Recommendation settings
            </Button>
          </Space>
        }
      >
        <Row gutter={[16, 16]}>
          <Col xs={24} lg={16}>
            <Card
              title={
                <Space size={8} align="center">
                  <span>Recommended for you</span>
                  {renderHeaderTags()}
                </Space>
              }
            >
              {error && (
                <Alert
                  type="warning"
                  showIcon
                  style={{ marginBottom: 16 }}
                  message="We couldn't load live recommendations."
                  description={
                    <span>
                      {error}{' '}
                      <Text type="secondary">
                        If this keeps happening, the personalized recommendation
                        API for KonnectED may not be wired yet. In that case we
                        will fall back to generic library suggestions.
                      </Text>
                    </span>
                  }
                />
              )}

              {!hasRecommendations && loading && (
                <div
                  style={{
                    minHeight: 200,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}
                >
                  <Skeleton active paragraph={{ rows: 4 }} />
                </div>
              )}

              {!loading && !hasRecommendations && !error && (
                <Empty
                  description={
                    <Space direction="vertical" size={4}>
                      <span>No recommendations yet.</span>
                      <Text type="secondary">
                        Start a learning path or complete a few resources so we
                        can tailor suggestions to you.
                      </Text>
                    </Space>
                  }
                />
              )}

              {hasRecommendations && (
                <List
                  itemLayout="vertical"
                  dataSource={sortedRecommendations}
                  renderItem={(rec) => (
                    <List.Item
                      key={rec.recommendationId}
                      actions={[
                        <Space key="actions" size={8}>
                          <Button
                            type="link"
                            icon={<ArrowRightOutlined />}
                            onClick={() => handleViewResource(rec)}
                          >
                            Open
                          </Button>
                          <Button
                            type="text"
                            icon={<LikeOutlined />}
                            loading={likeInFlightIds.has(
                              `${rec.recommendationId}:like`,
                            )}
                            onClick={() => handleFeedback(rec, 'like')}
                          >
                            Helpful
                          </Button>
                          <Button
                            type="text"
                            icon={<DislikeOutlined />}
                            loading={likeInFlightIds.has(
                              `${rec.recommendationId}:dislike`,
                            )}
                            onClick={() => handleFeedback(rec, 'dislike')}
                          >
                            Not for me
                          </Button>
                        </Space>,
                      ]}
                    >
                      <List.Item.Meta
                        title={
                          <Space direction="vertical" size={0}>
                            <Space size={8} wrap>
                              <Text strong>{rec.resource.title}</Text>
                              {rec.resource.type && (
                                <Tag
                                  color="geekblue"
                                  style={{ textTransform: 'capitalize' }}
                                >
                                  {rec.resource.type}
                                </Tag>
                              )}
                              {rec.resource.level && (
                                <Tag color="purple">{rec.resource.level}</Tag>
                              )}
                              {rec.resource.subject && (
                                <Tag color="blue">{rec.resource.subject}</Tag>
                              )}
                              {rec.source && (
                                <Tag>
                                  {rec.source === 'ml'
                                    ? 'Suggested by AI'
                                    : rec.source === 'editorial'
                                    ? 'Curator pick'
                                    : 'Trending'}
                                </Tag>
                              )}
                            </Space>
                            {rec.reason && (
                              <Text type="secondary" style={{ fontSize: 12 }}>
                                {rec.reason}
                              </Text>
                            )}
                          </Space>
                        }
                        description={
                          <Space
                            direction="vertical"
                            size={4}
                            style={{ width: '100%' }}
                          >
                            {rec.resource.summary && (
                              <Text>{rec.resource.summary}</Text>
                            )}
                            <Space size={[8, 8]} wrap>
                              {rec.resource.language && (
                                <Tag>{rec.resource.language}</Tag>
                              )}
                              {rec.resource.tags?.map((tag) => (
                                <Tag key={tag}>{tag}</Tag>
                              ))}
                              {rec.resource.estimatedDurationMinutes != null && (
                                <Tag>
                                  ‚âà {rec.resource.estimatedDurationMinutes} min
                                </Tag>
                              )}
                              {rec.resource.offlineAvailable && (
                                <Tag color="green">Offline available</Tag>
                              )}
                              {rec.resource.partOfPathTitle && (
                                <Tag color="magenta">
                                  Part of{' '}
                                  <Text strong>
                                    {rec.resource.partOfPathTitle}
                                  </Text>
                                </Tag>
                              )}
                            </Space>
                            <Row gutter={16}>
                              <Col xs={24} sm={12}>
                                {rec.progress ? (
                                  <Space
                                    direction="vertical"
                                    size={2}
                                    style={{ width: '100%' }}
                                  >
                                    <Text
                                      type="secondary"
                                      style={{ fontSize: 12 }}
                                    >
                                      Your progress
                                    </Text>
                                    <Progress
                                      percent={rec.progress.progressPercent}
                                      size="small"
                                      status={
                                        rec.progress.progressPercent === 100
                                          ? 'success'
                                          : 'active'
                                      }
                                    />
                                    {rec.progress.lastTouchedAt && (
                                      <Text
                                        type="secondary"
                                        style={{ fontSize: 12 }}
                                      >
                                        Last activity:{' '}
                                        {new Date(
                                          rec.progress.lastTouchedAt,
                                        ).toLocaleString()}
                                      </Text>
                                    )}
                                  </Space>
                                ) : (
                                  <Text
                                    type="secondary"
                                    style={{ fontSize: 12 }}
                                  >
                                    You have not started this resource yet.
                                  </Text>
                                )}
                              </Col>
                              <Col xs={24} sm={12}>
                                <Space
                                  direction="vertical"
                                  size={2}
                                  style={{ width: '100%' }}
                                >
                                  {typeof rec.score === 'number' && (
                                    <Text
                                      type="secondary"
                                      style={{ fontSize: 12 }}
                                    >
                                      Relevance score:{' '}
                                      <Text strong>
                                        {(rec.score * 100).toFixed(0)}%
                                      </Text>
                                    </Text>
                                  )}
                                  <Text
                                    type="secondary"
                                    style={{ fontSize: 12 }}
                                  >
                                    Recommended on:{' '}
                                    {new Date(
                                      rec.recommendedAt,
                                    ).toLocaleDateString()}
                                  </Text>
                                </Space>
                              </Col>
                            </Row>
                          </Space>
                        }
                      />
                    </List.Item>
                  )}
                />
              )}
            </Card>
          </Col>

          <Col xs={24} lg={8}>
            <Space direction="vertical" size={16} style={{ width: '100%' }}>
              <Card title="How these recommendations work">
                <Space direction="vertical" size={4}>
                  <Text>
                    KonnectED recommendations are an early prototype. They will
                    eventually use your learning paths, progress, and Ekoh score
                    to tailor suggestions.
                  </Text>
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    For now, recommendations may rely on simple heuristics like
                    subject matches, language preferences, and popularity.
                  </Text>
                </Space>
              </Card>

              <Card title="Tips to improve recommendations">
                <List
                  size="small"
                  dataSource={[
                    'Complete or mark a few lessons as done.',
                    'Rate or leave feedback on resources.',
                    'Join a learning path and follow it for a while.',
                    'Try content in your preferred language first.',
                  ]}
                  renderItem={(tip) => <List.Item>{tip}</List.Item>}
                />
              </Card>

              <Card title="KonnectED tips & summary">
                <Space direction="vertical" size={4} style={{ width: '100%' }}>
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    Looking for a more structured experience?
                  </Text>
                  <Button
                    type="primary"
                    icon={<BookOutlined />}
                    onClick={() =>
                      router.push('/konnected/learning-paths/my-learning-path')
                    }
                  >
                    Go to my learning paths
                  </Button>
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    Or browse curated learning paths and certification programs
                    from the main dashboard.
                  </Text>
                </Space>
              </Card>
            </Space>
          </Col>
        </Row>
      </KonnectedPageShell>
    </>
  );
}

===== END app/konnected/learning-library/recommended-resources/page.tsx =====


===== BEGIN app/konnected/learning-library/search-filters/page.tsx =====
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Alert,
  Button,
  Card,
  Col,
  DatePicker,
  Form,
  Input,
  Row,
  Select,
  Space,
  Table,
  Tag,
  Typography,
} from 'antd';
import type { ColumnsType, TableProps } from 'antd/es/table';
import { SearchOutlined, FilterOutlined, ReloadOutlined } from '@ant-design/icons';
import dayjs from 'dayjs';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { RangePicker } = DatePicker;
const { Text } = Typography;
const { Search } = Input;
const { Option } = Select;

type KnowledgeContentType = 'article' | 'video' | 'lesson' | 'quiz' | 'dataset';

interface KnowledgeResource {
  id: number | string;
  title: string;
  type: KnowledgeContentType | string;
  url?: string | null;
  subject?: string | null;
  level?: string | null;
  language?: string | null;
  created_at?: string | null;
  tags?: string[] | null;
}

interface KnowledgeSearchResponse {
  count: number;
  results: KnowledgeResource[];
}

interface SearchFormValues {
  q?: string;
  types?: KnowledgeContentType[];
  subjects?: string[];
  levels?: string[];
  languages?: string[];
  createdAt?: [dayjs.Dayjs, dayjs.Dayjs];
}

interface QueryState {
  q?: string;
  types?: KnowledgeContentType[];
  subjects?: string[];
  levels?: string[];
  languages?: string[];
  created_from?: string;
  created_to?: string;
  page: number;
  page_size: number;
}

const DEFAULT_PAGE_SIZE = 10;

const CONTENT_TYPES: KnowledgeContentType[] = [
  'article',
  'video',
  'lesson',
  'quiz',
  'dataset',
];

// Seed taxonomies for now; can be driven by backend dictionaries later
const SUBJECT_OPTIONS = [
  'AI & Data',
  'Sustainability & Climate',
  'Healthcare & Wellbeing',
  'Civic Innovation',
  'Education & Skills',
  'Design & Creativity',
];

const LEVEL_OPTIONS = ['Beginner', 'Intermediate', 'Advanced'];

const LANGUAGE_OPTIONS = ['English', 'French', 'Spanish', 'Other'];

// Existing backend uses a list endpoint for KnowledgeResource.
// We support the main variants used elsewhere in the app and pick
// the first one that responds.
const KNOWLEDGE_SEARCH_ENDPOINTS = [
  '/api/knowledge-resources/',
  '/api/knowledge/resources/',
  '/api/konnected/resources/',
] as const;

type RawKnowledgeSearchResponse =
  | KnowledgeResource[]
  | {
      results?: KnowledgeResource[];
      items?: KnowledgeResource[];
      count?: number;
      total?: number;
    };

function normalizeSearchResponse(raw: RawKnowledgeSearchResponse): KnowledgeSearchResponse {
  if (Array.isArray(raw)) {
    return {
      count: raw.length,
      results: raw,
    };
  }

  const obj = raw ?? {};
  const anyObj = obj as any;

  const results: KnowledgeResource[] =
    (Array.isArray(anyObj.results) && anyObj.results) ||
    (Array.isArray(anyObj.items) && anyObj.items) ||
    [];

  const count: number =
    typeof anyObj.count === 'number'
      ? anyObj.count
      : typeof anyObj.total === 'number'
        ? anyObj.total
        : results.length;

  return { count, results };
}

async function searchKnowledgeResources(query: QueryState): Promise<KnowledgeSearchResponse> {
  const params = new URLSearchParams();

  // Text search: support both v14-style `q` and DRF SearchFilter's `search`
  if (query.q) {
    params.set('q', query.q);
    params.set('search', query.q);
  }

  if (query.types && query.types.length > 0) {
    // Primary v14 param
    params.set('type', query.types.join(','));
    // Optional legacy alias used in some views
    params.set('resource_type', query.types.join(','));
  }

  if (query.subjects && query.subjects.length > 0) {
    params.set('subject', query.subjects.join(','));
  }
  if (query.levels && query.levels.length > 0) {
    params.set('level', query.levels.join(','));
  }
  if (query.languages && query.languages.length > 0) {
    params.set('language', query.languages.join(','));
  }
  if (query.created_from) {
    params.set('created_from', query.created_from);
  }
  if (query.created_to) {
    params.set('created_to', query.created_to);
  }

  params.set('page', String(query.page));
  params.set('page_size', String(query.page_size));

  const qs = params.toString();
  let lastError: unknown;

  for (const base of KNOWLEDGE_SEARCH_ENDPOINTS) {
    const url = qs ? `${base}?${qs}` : base;

    try {
      const res = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
      });

      // For 404/405 we try the next candidate; for other codes we surface the error.
      if (!res.ok) {
        if (res.status === 404 || res.status === 405) {
          lastError = new Error(`Knowledge search endpoint not available at ${base} (${res.status})`);
          continue;
        }

        const body = await res.text().catch(() => '');
        throw new Error(body || `Knowledge search failed with status ${res.status}`);
      }

      const json = (await res.json()) as RawKnowledgeSearchResponse;
      return normalizeSearchResponse(json);
    } catch (err) {
      lastError = err;
      // Try next candidate
    }
  }

  const message =
    lastError instanceof Error
      ? lastError.message
      : 'Unable to reach any knowledge search endpoint.';
  throw new Error(message);
}

export default function KonnectedKnowledgeSearchFiltersPage(): JSX.Element {
  const router = useRouter();
  const [form] = Form.useForm<SearchFormValues>();

  const [resources, setResources] = useState<KnowledgeResource[]>([]);
  const [total, setTotal] = useState<number>(0);
  const [page, setPage] = useState<number>(1);
  const [pageSize, setPageSize] = useState<number>(DEFAULT_PAGE_SIZE);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const columns: ColumnsType<KnowledgeResource> = useMemo(
    () => [
      {
        title: 'Title',
        dataIndex: 'title',
        key: 'title',
        render: (value, record) => {
          const href = record.url || '#';
          const isClickable = Boolean(record.url);
          return (
            <Space direction="vertical" size={0}>
              {isClickable ? (
                <a
                  href={href as string}
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  {value}
                </a>
              ) : (
                <Text strong>{value}</Text>
              )}
              <Space size="small" wrap>
                {record.subject && <Tag color="blue">{record.subject}</Tag>}
                {record.level && <Tag color="purple">{record.level}</Tag>}
                {record.language && <Tag color="geekblue">{record.language}</Tag>}
              </Space>
            </Space>
          );
        },
      },
      {
        title: 'Type',
        dataIndex: 'type',
        key: 'type',
        width: 140,
        render: (value: KnowledgeResource['type']) => (
          <Tag>{String(value ?? '').toUpperCase() || 'UNKNOWN'}</Tag>
        ),
      },
      {
        title: 'Tags',
        dataIndex: 'tags',
        key: 'tags',
        width: 220,
        render: (tags?: string[] | null) =>
          tags && tags.length > 0 ? (
            <Space size="small" wrap>
              {tags.map((tag) => (
                <Tag key={tag}>{tag}</Tag>
              ))}
            </Space>
          ) : (
            <Text type="secondary" style={{ fontSize: 12 }}>
              No tags
            </Text>
          ),
      },
      {
        title: 'Added',
        dataIndex: 'created_at',
        key: 'created_at',
        width: 140,
        render: (value?: string | null) =>
          value ? (
            <Text>{dayjs(value).format('YYYY-MM-DD')}</Text>
          ) : (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Unknown
            </Text>
          ),
      },
      {
        title: 'Actions',
        key: 'actions',
        fixed: 'right',
        width: 160,
        render: (_: unknown, record) => (
          <Space>
            {record.url && (
              <Button
                type="link"
                size="small"
                onClick={() => {
                  window.open(record.url as string, '_blank', 'noopener');
                }}
              >
                Open
              </Button>
            )}
            <Button
              size="small"
              onClick={() =>
                router.push(`/konnected/learning-library/resource/${record.id}`)
              }
            >
              View details
            </Button>
          </Space>
        ),
      },
    ],
    [router],
  );

  const runSearch = async (overridePage?: number, overridePageSize?: number) => {
    const formValues = form.getFieldsValue();

    const pageToUse = overridePage ?? page;
    const pageSizeToUse = overridePageSize ?? pageSize;

    const query: QueryState = {
      q: formValues.q?.trim() || undefined,
      types: formValues.types,
      subjects: formValues.subjects,
      levels: formValues.levels,
      languages: formValues.languages,
      created_from: formValues.createdAt?.[0]
        ? formValues.createdAt[0].startOf('day').toISOString()
        : undefined,
      created_to: formValues.createdAt?.[1]
        ? formValues.createdAt[1].endOf('day').toISOString()
        : undefined,
      page: pageToUse,
      page_size: pageSizeToUse,
    };

    setLoading(true);
    setError(null);

    try {
      const response = await searchKnowledgeResources(query);
      setResources(response.results || []);
      setTotal(response.count ?? response.results.length);
      setPage(pageToUse);
      setPageSize(pageSizeToUse);
    } catch (e) {
      const message =
        e instanceof Error ? e.message : 'Unexpected error during search';
      setError(message);
      setResources([]);
      setTotal(0);
    } finally {
      setLoading(false);
    }
  };

  const onFinish = () => {
    // Reset to first page when filters change
    void runSearch(1, pageSize);
  };

  const handleQuickSearch = (value: string) => {
    form.setFieldsValue({ q: value });
    void runSearch(1, pageSize);
  };

  const handleResetFilters = () => {
    form.resetFields();
    void runSearch(1, DEFAULT_PAGE_SIZE);
  };

  const handleTableChange: TableProps<KnowledgeResource>['onChange'] = (
    pagination,
  ) => {
    const nextPage = pagination.current || 1;
    const nextPageSize = pagination.pageSize || DEFAULT_PAGE_SIZE;
    void runSearch(nextPage, nextPageSize);
  };

  useEffect(() => {
    // Initial search on mount with default filters
    void runSearch(1, DEFAULT_PAGE_SIZE);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Compute active filters on each render so the Reset button state stays in sync
  const filterValues = form.getFieldsValue();
  const hasActiveFilters = Boolean(
    filterValues.q ||
      (filterValues.types && filterValues.types.length > 0) ||
      (filterValues.subjects && filterValues.subjects.length > 0) ||
      (filterValues.levels && filterValues.levels.length > 0) ||
      (filterValues.languages && filterValues.languages.length > 0) ||
      (filterValues.createdAt &&
        Array.isArray(filterValues.createdAt) &&
        filterValues.createdAt[0] &&
        filterValues.createdAt[1]),
  );

  const secondaryActions = (
    <Space>
      <Search
        placeholder="Quick search by title or description"
        allowClear
        enterButton={<SearchOutlined />}
        onSearch={handleQuickSearch}
        style={{ width: 280 }}
      />
      <Button
        icon={<ReloadOutlined />}
        onClick={handleResetFilters}
        disabled={!hasActiveFilters}
      >
        Reset filters
      </Button>
    </Space>
  );

  const primaryAction = (
    <Button
      type="primary"
      icon={<FilterOutlined />}
      onClick={() => void runSearch(page, pageSize)}
    >
      Apply filters
    </Button>
  );

  return (
    <KonnectedPageShell
      title="Search the Learning Library"
      subtitle="Run advanced searches across Knowledge resources using full-text and structured filters."
      primaryAction={primaryAction}
      secondaryActions={secondaryActions}
    >
      <Card style={{ marginBottom: 16 }}>
        <Form<SearchFormValues> form={form} layout="vertical" onFinish={onFinish}>
          <Row gutter={[16, 16]}>
            <Col xs={24} md={12} lg={8}>
              <Form.Item
                label="Keywords"
                name="q"
                tooltip="Searches over title and description using the PostgreSQL full-text backend."
              >
                <Input
                  placeholder="e.g. data visualization, climate, robotics"
                  prefix={<SearchOutlined />}
                  allowClear
                />
              </Form.Item>
            </Col>

            <Col xs={24} md={12} lg={8}>
              <Form.Item label="Content type" name="types">
                <Select
                  mode="multiple"
                  allowClear
                  placeholder="Select content types"
                >
                  {CONTENT_TYPES.map((t) => (
                    <Option key={t} value={t}>
                      {t.charAt(0).toUpperCase() + t.slice(1)}
                    </Option>
                  ))}
                </Select>
              </Form.Item>
            </Col>

            <Col xs={24} md={12} lg={8}>
              <Form.Item label="Subjects" name="subjects">
                <Select
                  mode="multiple"
                  allowClear
                  placeholder="Filter by subject or theme"
                >
                  {SUBJECT_OPTIONS.map((s) => (
                    <Option key={s} value={s}>
                      {s}
                    </Option>
                  ))}
                </Select>
              </Form.Item>
            </Col>
          </Row>

          <Row gutter={[16, 16]}>
            <Col xs={24} md={12} lg={8}>
              <Form.Item label="Level" name="levels">
                <Select
                  mode="multiple"
                  allowClear
                  placeholder="Beginner, Intermediate, Advanced"
                >
                  {LEVEL_OPTIONS.map((l) => (
                    <Option key={l} value={l}>
                      {l}
                    </Option>
                  ))}
                </Select>
              </Form.Item>
            </Col>

            <Col xs={24} md={12} lg={8}>
              <Form.Item label="Language" name="languages">
                <Select
                  mode="multiple"
                  allowClear
                  placeholder="Resource language"
                >
                  {LANGUAGE_OPTIONS.map((lang) => (
                    <Option key={lang} value={lang}>
                      {lang}
                    </Option>
                  ))}
                </Select>
              </Form.Item>
            </Col>

            <Col xs={24} md={12} lg={8}>
              <Form.Item label="Added to library" name="createdAt">
                <RangePicker style={{ width: '100%' }} allowEmpty={[true, true]} />
              </Form.Item>
            </Col>
          </Row>

          <Row justify="end">
            <Col>
              <Space>
                <Button onClick={handleResetFilters}>Clear all</Button>
                <Button
                  type="primary"
                  icon={<SearchOutlined />}
                  htmlType="submit"
                >
                  Search
                </Button>
              </Space>
            </Col>
          </Row>
        </Form>
      </Card>

      {error && (
        <Alert
          type="error"
          showIcon
          message="Unable to run search"
          description={error}
          style={{ marginBottom: 16 }}
        />
      )}

      <Card>
        <Space direction="vertical" style={{ width: '100%' }} size="large">
          <Space
            style={{ width: '100%', justifyContent: 'space-between' }}
          >
            <Text type="secondary">
              {loading
                ? 'Searching‚Ä¶'
                : `Showing ${resources.length} of ${total} result${
                    total === 1 ? '' : 's'
                  }`}
            </Text>
          </Space>

          <Table<KnowledgeResource>
            rowKey={(record) => String(record.id)}
            columns={columns}
            dataSource={resources}
            loading={loading}
            onChange={handleTableChange}
            pagination={{
              current: page,
              total,
              pageSize,
              showSizeChanger: true,
              pageSizeOptions: [10, 20, 50],
              showTotal: (t, range) =>
                `${range[0]}‚Äì${range[1]} of ${t} resources`,
            }}
            locale={{
              emptyText: loading
                ? 'Loading resources‚Ä¶'
                : 'No resources match your current filters.',
            }}
            scroll={{ x: 900 }}
            bordered
            size="middle"
          />
        </Space>
      </Card>
    </KonnectedPageShell>
  );
}

===== END app/konnected/learning-library/search-filters/page.tsx =====


===== BEGIN app/konnected/learning-paths/create-learning-path/page.tsx =====
"use client";

import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  Alert,
  Button,
  Drawer,
  Empty,
  Input,
  Select,
  Space,
  Spin,
  Table,
  Tag,
  Typography,
  message,
} from "antd";
import type { ColumnsType } from "antd/es/table";
import type { Key } from "react";
import {
  PageContainer,
  ProCard,
  ProDescriptions,
  ProFormDependency,
  ProFormInstance,
  ProFormList,
  ProFormSelect,
  ProFormText,
  ProFormTextArea,
  StepsForm,
} from "@ant-design/pro-components";
import KonnectedPageShell from "../../KonnectedPageShell";

const { Title, Paragraph } = Typography;
const { Search } = Input;

const API_BASE = process.env.NEXT_PUBLIC_API_BASE ?? "";

type LearningPathStatus = "draft" | "published";

type LearningPathStepForm = {
  title: string;
  type: "lesson" | "quiz" | "assignment";
  objective?: string;
  resourceIds?: number[];
};

type LearningPathFormValues = {
  name: string;
  description: string;
  difficulty: "Beginner" | "Intermediate" | "Advanced";
  tags?: string[];
  steps?: LearningPathStepForm[];
};

type KnowledgeResource = {
  id: number;
  title: string;
  type: "article" | "video" | "lesson" | "quiz" | "dataset";
  author?: string | null;
  subject?: string | null;
  estimated_duration_minutes?: number | null;
};

type ResourceSearchParams = {
  q?: string;
  type?: KnowledgeResource["type"] | "all";
};

type ErrorResponse = {
  detail?: string;
};

type KnowledgeResourceListResponse =
  | KnowledgeResource[]
  | {
      results?: KnowledgeResource[];
    };

const buildUrl = (path: string) => {
  if (API_BASE) return `${API_BASE}${path}`;
  return path;
};

async function createLearningPath(
  values: LearningPathFormValues,
  status: LearningPathStatus
) {
  const response = await fetch(buildUrl("/api/konnected/learning-paths/"), {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      name: values.name,
      description: values.description,
      difficulty: values.difficulty,
      tags: values.tags ?? [],
      status,
      steps: (values.steps ?? []).map((step, index) => ({
        order: index + 1,
        title: step.title,
        type: step.type,
        objective: step.objective,
        resource_ids: step.resourceIds ?? [],
      })),
    }),
  });

  if (!response.ok) {
    let detail = "Failed to save learning path.";
    try {
      const data = (await response.json()) as ErrorResponse;
      if (typeof data.detail === "string") detail = data.detail;
      // If backend returns field-level errors, you could handle them here as well.
    } catch {
      // ignore JSON parse errors
    }
    throw new Error(detail);
  }

  return response.json().catch(() => null);
}

async function fetchKnowledgeResources(
  params: ResourceSearchParams
): Promise<KnowledgeResource[]> {
  const search = new URLSearchParams();
  if (params.q) search.set("q", params.q);
  if (params.type && params.type !== "all") search.set("type", params.type);

  const response = await fetch(
    buildUrl(`/api/knowledge/resources/${search.toString() ? `?${search}` : ""}`)
  );

  if (!response.ok) {
    throw new Error("Failed to load resources.");
  }

  const data = (await response.json()) as KnowledgeResourceListResponse;

  if (Array.isArray(data)) return data as KnowledgeResource[];
  if (Array.isArray(data.results)) return data.results as KnowledgeResource[];
  return [];
}

const CONTENT_TYPE_OPTIONS: {
  label: string;
  value: ResourceSearchParams["type"];
}[] = [
  { label: "All types", value: "all" },
  { label: "Articles", value: "article" },
  { label: "Videos", value: "video" },
  { label: "Lessons", value: "lesson" },
  { label: "Quizzes", value: "quiz" },
  { label: "Datasets", value: "dataset" },
];

const difficultyOptions = [
  { label: "Beginner", value: "Beginner" },
  { label: "Intermediate", value: "Intermediate" },
  { label: "Advanced", value: "Advanced" },
];

const stepTypeOptions = [
  { label: "Lesson", value: "lesson" },
  { label: "Quiz", value: "quiz" },
  { label: "Assignment", value: "assignment" },
];

const CreateLearningPathPage: React.FC = () => {
  const formRef = useRef<ProFormInstance<LearningPathFormValues>>();
  const [submitMode, setSubmitMode] = useState<LearningPathStatus>("draft");
  const [submitting, setSubmitting] = useState(false);

  const [resourceDrawerOpen, setResourceDrawerOpen] = useState(false);
  const [resourceDrawerStepIndex, setResourceDrawerStepIndex] = useState<
    number | null
  >(null);
  const [resourceSearchParams, setResourceSearchParams] =
    useState<ResourceSearchParams>({});
  const [resourcesLoading, setResourcesLoading] = useState(false);
  const [resources, setResources] = useState<KnowledgeResource[]>([]);
  const [selectedResourceIds, setSelectedResourceIds] = useState<Key[]>([]);

  const openResourceDrawer = useCallback((stepIndex: number) => {
    setResourceDrawerStepIndex(stepIndex);

    const steps = formRef.current?.getFieldValue("steps") as
      | LearningPathStepForm[]
      | undefined;

    if (steps && steps[stepIndex]?.resourceIds?.length) {
      setSelectedResourceIds(steps[stepIndex].resourceIds as Key[]);
    } else {
      setSelectedResourceIds([]);
    }

    // Initial fetch
    setResourcesLoading(true);
    fetchKnowledgeResources({})
      .then(setResources)
      .catch((err) => {
        message.error(err.message || "Failed to load resources.");
        setResources([]);
      })
      .finally(() => setResourcesLoading(false));

    setResourceDrawerOpen(true);
  }, []);

  const closeResourceDrawer = () => {
    setResourceDrawerOpen(false);
    setResourceDrawerStepIndex(null);
  };

  const handleResourceSearch = useCallback(
    (q?: string) => {
      const nextParams: ResourceSearchParams = {
        ...resourceSearchParams,
        q: q || undefined,
      };
      setResourceSearchParams(nextParams);

      setResourcesLoading(true);
      fetchKnowledgeResources(nextParams)
        .then(setResources)
        .catch((err) => {
          message.error(err.message || "Failed to load resources.");
          setResources([]);
        })
        .finally(() => setResourcesLoading(false));
    },
    [resourceSearchParams]
  );

  const handleResourceTypeChange = (
    type: ResourceSearchParams["type"]
  ): void => {
    const nextParams: ResourceSearchParams = {
      ...resourceSearchParams,
      type,
    };
    setResourceSearchParams(nextParams);

    setResourcesLoading(true);
    fetchKnowledgeResources(nextParams)
      .then(setResources)
      .catch((err) => {
        message.error(err.message || "Failed to load resources.");
        setResources([]);
      })
      .finally(() => setResourcesLoading(false));
  };

  const handleResourceDrawerOk = () => {
    if (resourceDrawerStepIndex == null) {
      closeResourceDrawer();
      return;
    }

    const currentSteps =
      (formRef.current?.getFieldValue("steps") as LearningPathStepForm[]) ?? [];

    const updatedSteps = currentSteps.map((step, index) =>
      index === resourceDrawerStepIndex
        ? { ...step, resourceIds: selectedResourceIds as number[] }
        : step
    );

    formRef.current?.setFieldsValue({ steps: updatedSteps });
    closeResourceDrawer();
  };

  const resourceColumns: ColumnsType<KnowledgeResource> = useMemo(
    () => [
      {
        title: "Title",
        dataIndex: "title",
        key: "title",
      },
      {
        title: "Type",
        dataIndex: "type",
        key: "type",
        render: (value) => <Tag>{value}</Tag>,
      },
      {
        title: "Author",
        dataIndex: "author",
        key: "author",
        render: (value) => value || "‚Äî",
      },
      {
        title: "Subject",
        dataIndex: "subject",
        key: "subject",
        render: (value) => value || "‚Äî",
      },
      {
        title: "Estimated time",
        dataIndex: "estimated_duration_minutes",
        key: "estimated_duration_minutes",
        render: (value) => (value ? `${value} min` : "‚Äî"),
      },
    ],
    []
  );

  const handleFinish = async (values: LearningPathFormValues) => {
    // Additional client-side publish-time rules:
    if (submitMode === "published") {
      if (!values.steps || values.steps.length === 0) {
        message.error("You must add at least one step before publishing.");
        return false;
      }

      const missingResources = values.steps.some(
        (step) => !step.resourceIds || step.resourceIds.length === 0
      );
      if (missingResources) {
        message.error(
          "Each step must have at least one resource attached before publishing."
        );
        return false;
      }
    }

    setSubmitting(true);
    try {
      await createLearningPath(values, submitMode);
      message.success(
        submitMode === "published"
          ? "Learning path published."
          : "Learning path saved as draft."
      );
      return true;
    } catch (error: any) {
      message.error(error?.message || "Failed to save learning path.");
      return false;
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <KonnectedPageShell
      title="Create learning path"
      subtitle="Author a structured sequence of resources that learners can follow."
      primaryAction={null}
    >
      <PageContainer>
        <ProCard>
          <Alert
            type="info"
            showIcon
            style={{ marginBottom: 16 }}
            message="Use this wizard to define metadata, steps, and resources for a new learning path. You can save it as a draft or publish it when complete."
          />

          <StepsForm<LearningPathFormValues>
            formRef={formRef}
            onFinish={handleFinish}
            submitter={{
              render: (props) => {
                const { onSubmit, onPre } = props;
                return [
                  <Button
                    key="pre"
                    onClick={() => {
                      onPre?.();
                    }}
                  >
                    Previous
                  </Button>,
                  <Button
                    key="save-draft"
                    onClick={() => {
                      setSubmitMode("draft");
                      onSubmit?.();
                    }}
                    loading={submitting}
                  >
                    Save draft
                  </Button>,
                  <Button
                    key="publish"
                    type="primary"
                    onClick={() => {
                      setSubmitMode("published");
                      onSubmit?.();
                    }}
                    loading={submitting}
                  >
                    Publish
                  </Button>,
                ];
              },
            }}
          >
            <StepsForm.StepForm<LearningPathFormValues>
              name="basic"
              title="Basics"
            >
              <ProFormText
                name="name"
                label="Path name"
                placeholder="e.g. Web fundamentals for new team members"
                rules={[
                  { required: true, message: "Please enter a path name." },
                  {
                    min: 4,
                    message: "Name should be at least 4 characters long.",
                  },
                ]}
              />
              <ProFormTextArea
                name="description"
                label="Description"
                placeholder="Describe who this path is for and what it covers."
                fieldProps={{ autoSize: { minRows: 3, maxRows: 6 } }}
                rules={[
                  {
                    required: true,
                    message: "Please enter a description.",
                  },
                  {
                    min: 20,
                    message:
                      "Description should be at least 20 characters long.",
                  },
                ]}
              />
              <ProFormSelect
                name="difficulty"
                label="Difficulty"
                options={difficultyOptions}
                placeholder="Select difficulty level"
                rules={[
                  { required: true, message: "Please select a difficulty." },
                ]}
              />
              <ProFormSelect
                name="tags"
                label="Tags"
                mode="tags"
                placeholder="Add tags (optional)"
                fieldProps={{ tokenSeparators: [","] }}
              />
            </StepsForm.StepForm>

            <StepsForm.StepForm<LearningPathFormValues>
              name="steps"
              title="Steps"
            >
              <ProFormList
                name="steps"
                label="Path steps"
                creatorButtonProps={{
                  position: "bottom",
                  creatorButtonText: "Add step",
                }}
                rules={[
                  {
                    validator: async (_, value) => {
                      if (!value || value.length === 0) {
                        throw new Error(
                          "You must add at least one step to the path."
                        );
                      }
                    },
                  },
                ]}
              >
                {(field, index) => (
                  <ProCard
                    bordered
                    style={{ marginBottom: 8 }}
                    title={`Step ${index + 1}`}
                  >
                    <ProFormText
                      name={[field.name, "title"]}
                      label="Step title"
                      placeholder="e.g. Introduction to HTML & CSS"
                      rules={[
                        {
                          required: true,
                          message: "Please enter a step title.",
                        },
                      ]}
                    />
                    <ProFormSelect
                      name={[field.name, "type"]}
                      label="Step type"
                      options={stepTypeOptions}
                      rules={[
                        {
                          required: true,
                          message: "Please select a step type.",
                        },
                      ]}
                    />
                    <ProFormTextArea
                      name={[field.name, "objective"]}
                      label="Learning objective"
                      placeholder="What should learners be able to do after this step?"
                      fieldProps={{
                        autoSize: { minRows: 2, maxRows: 4 },
                      }}
                    />
                  </ProCard>
                )}
              </ProFormList>
            </StepsForm.StepForm>

            <StepsForm.StepForm<LearningPathFormValues>
              name="resources"
              title="Resources"
            >
              <ProFormDependency name={["steps"]}>
                {({ steps }) => {
                  const stepList = (steps as LearningPathStepForm[]) ?? [];
                  if (!stepList.length) {
                    return (
                      <Alert
                        type="warning"
                        showIcon
                        message="You need to create at least one step in the previous step before attaching resources."
                      />
                    );
                  }

                  return (
                    <>
                      <Paragraph>
                        Attach one or more library resources to each step. You
                        can still save as a draft without completing all
                        attachments, but every step must have at least one
                        resource before publishing.
                      </Paragraph>

                      <Space direction="vertical" style={{ width: "100%" }}>
                        {stepList.map((step, index) => (
                          <ProCard
                            key={index}
                            bordered
                            title={`Step ${index + 1}: ${
                              step.title || "Untitled"
                            }`}
                            extra={
                              <Button
                                onClick={() => openResourceDrawer(index)}
                                size="small"
                              >
                                Select resources
                              </Button>
                            }
                          >
                            {step.resourceIds && step.resourceIds.length > 0 ? (
                              <Space wrap>
                                {step.resourceIds.map((id) => (
                                  <Tag key={id}>{`Resource #${id}`}</Tag>
                                ))}
                              </Space>
                            ) : (
                              <Paragraph type="secondary">
                                No resources attached yet.
                              </Paragraph>
                            )}
                          </ProCard>
                        ))}
                      </Space>
                    </>
                  );
                }}
              </ProFormDependency>
            </StepsForm.StepForm>

            <StepsForm.StepForm<LearningPathFormValues>
              name="review"
              title="Review & publish"
            >
              <ProFormDependency
                name={["name", "description", "difficulty", "tags", "steps"]}
              >
                {({ name, description, difficulty, tags, steps }) => {
                  const stepList = (steps as LearningPathStepForm[]) ?? [];

                  return (
                    <Space direction="vertical" style={{ width: "100%" }}>
                      <ProDescriptions
                        column={1}
                        title="Path summary"
                        dataSource={{
                          name,
                          description,
                          difficulty,
                          tags,
                        }}
                      >
                        <ProDescriptions.Item label="Name" dataIndex="name" />
                        <ProDescriptions.Item
                          label="Description"
                          dataIndex="description"
                        />
                        <ProDescriptions.Item
                          label="Difficulty"
                          dataIndex="difficulty"
                        />
                        <ProDescriptions.Item
                          label="Tags"
                          dataIndex="tags"
                          render={(_, record) => {
                            const value = (record as {
                              tags?: string[];
                            }).tags;

                            return value && value.length ? (
                              <Space wrap>
                                {value.map((t) => (
                                  <Tag key={t}>{t}</Tag>
                                ))}
                              </Space>
                            ) : (
                              <span>‚Äî</span>
                            );
                          }}
                        />
                      </ProDescriptions>

                      <ProCard title="Steps" bordered>
                        {stepList.length === 0 ? (
                          <Paragraph type="secondary">
                            No steps defined yet.
                          </Paragraph>
                        ) : (
                          <Space direction="vertical" style={{ width: "100%" }}>
                            {stepList.map((step, index) => (
                              <ProCard
                                key={index}
                                bordered
                                title={`Step ${index + 1}: ${
                                  step.title || "Untitled"
                                }`}
                              >
                                <Paragraph>
                                  <strong>Type:</strong> {step.type}
                                </Paragraph>
                                {step.objective && (
                                  <Paragraph>
                                    <strong>Objective:</strong>{" "}
                                    {step.objective}
                                  </Paragraph>
                                )}
                                <Paragraph>
                                  <strong>Resources:</strong>{" "}
                                  {step.resourceIds &&
                                  step.resourceIds.length > 0 ? (
                                    <Space wrap>
                                      {step.resourceIds.map((id) => (
                                        <Tag key={id}>{`Resource #${id}`}</Tag>
                                      ))}
                                    </Space>
                                  ) : (
                                    <span>None</span>
                                  )}
                                </Paragraph>
                              </ProCard>
                            ))}
                          </Space>
                        )}
                      </ProCard>

                      {submitMode === "published" && (
                        <Alert
                          type="warning"
                          showIcon
                          message="Publishing will make this path visible to eligible learners. Make sure steps and resources are complete."
                        />
                      )}
                    </Space>
                  );
                }}
              </ProFormDependency>
            </StepsForm.StepForm>
          </StepsForm>
        </ProCard>
      </PageContainer>

      <Drawer
        title="Select resources"
        width={720}
        open={resourceDrawerOpen}
        onClose={closeResourceDrawer}
        destroyOnClose
        extra={
          <Space>
            <Button onClick={closeResourceDrawer}>Cancel</Button>
            <Button type="primary" onClick={handleResourceDrawerOk}>
              Attach selected
            </Button>
          </Space>
        }
      >
        <Space style={{ marginBottom: 16 }} wrap>
          <Search
            placeholder="Search resources"
            allowClear
            onSearch={(value) => handleResourceSearch(value || undefined)}
            style={{ width: 260 }}
          />
          <Select
            style={{ width: 200 }}
            defaultValue="all"
            options={CONTENT_TYPE_OPTIONS}
            onChange={(value) =>
              handleResourceTypeChange(value as ResourceSearchParams["type"])
            }
          />
        </Space>

        {resourcesLoading ? (
          <Spin />
        ) : resources.length === 0 ? (
          <Empty description="No resources found." />
        ) : (
          <Table<KnowledgeResource>
            rowKey="id"
            dataSource={resources}
            columns={resourceColumns}
            rowSelection={{
              selectedRowKeys: selectedResourceIds,
              onChange: (keys) => setSelectedResourceIds(keys),
            }}
            pagination={{ pageSize: 10 }}
          />
        )}
      </Drawer>
    </KonnectedPageShell>
  );
};

export default CreateLearningPathPage;

===== END app/konnected/learning-paths/create-learning-path/page.tsx =====


===== BEGIN app/konnected/learning-paths/manage-existing-paths/page.tsx =====
Ôªø'use client';

import React, { useRef, useState } from 'react';
import Link from 'next/link';
import type { ActionType, ProColumns } from '@ant-design/pro-components';
import { ProTable } from '@ant-design/pro-components';
import {
  Button,
  Empty,
  Form,
  Input,
  Modal,
  Select,
  Space,
  Tag,
  Typography,
  message,
} from 'antd';
import {
  DeleteOutlined,
  EditOutlined,
  PlusOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Paragraph, Text } = Typography;
const { Option } = Select;

const API_BASE = '/api/konnected/learning-paths'; // Adjust to match your backend

type LearningPathStatus = 'draft' | 'published' | 'archived';

type Difficulty = 'Beginner' | 'Intermediate' | 'Advanced';

export interface LearningPath {
  id: string | number;
  /** Display name of the path (maps to CertificationPath.name / LearningPath.title) */
  name: string;
  /** Optional long description */
  description?: string;
  /** Difficulty band for filtering in UI only (optional in backend) */
  difficulty?: Difficulty;
  /** Subject or topic grouping (STEM, Civics, etc.) */
  subject?: string;
  /** Human-friendly owner label (instructor or admin) */
  owner_name?: string;
  owner_id?: string | number;
  /** Tag labels for search/filter (optional) */
  tags?: string[];
  /** Draft / Published / Archived */
  status: LearningPathStatus;
  /** ISO timestamps (may come from DB or view) */
  created_at?: string;
  updated_at?: string;
  published_at?: string | null;
  /** Learners currently enrolled or who completed this path */
  learners_count?: number;
  /** Count of steps/modules in the path */
  modules_count?: number;
}

type TableQueryParams = {
  current?: number;
  pageSize?: number;
  status?: LearningPathStatus;
  owner?: string;
  subject?: string;
  keyword?: string;
  created_from?: string;
  created_to?: string;
};

type EditFormValues = {
  name: string;
  description?: string;
  difficulty?: Difficulty;
  subject?: string;
  status: LearningPathStatus;
};

type LearningPathListResponse = {
  results?: LearningPath[];
  items?: LearningPath[];
  count?: number;
  total?: number;
};

async function listLearningPaths(params: TableQueryParams) {
  const searchParams = new URLSearchParams();

  if (params.current) searchParams.set('page', String(params.current));
  if (params.pageSize) searchParams.set('page_size', String(params.pageSize));
  if (params.status) searchParams.set('status', params.status);
  if (params.owner) searchParams.set('owner', params.owner);
  if (params.subject) searchParams.set('subject', params.subject);
  if (params.keyword) searchParams.set('search', params.keyword);
  if (params.created_from) searchParams.set('created_from', params.created_from);
  if (params.created_to) searchParams.set('created_to', params.created_to);

  const res = await fetch(
    `${API_BASE}?${searchParams.toString()}`,
    { credentials: 'include' },
  );

  if (!res.ok) {
    throw new Error('Failed to load learning paths.');
  }

  // Support both { results, count } and { items, total } shapes
  const json = (await res.json()) as LearningPathListResponse;
  const data = (json.results ?? json.items ?? []) ?? [];
  const total = json.count ?? json.total ?? data.length;

  return { data, total };
}

async function updateLearningPath(id: string | number, payload: Partial<LearningPath>) {
  const res = await fetch(`${API_BASE}/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify(payload),
  });

  if (!res.ok) {
    throw new Error('Failed to update learning path.');
  }

  return res.json();
}

async function archiveLearningPath(id: string | number) {
  const res = await fetch(`${API_BASE}/${id}/archive`, {
    method: 'POST',
    credentials: 'include',
  });

  if (!res.ok) {
    throw new Error('Failed to archive learning path.');
  }
}

async function deleteLearningPath(id: string | number) {
  const res = await fetch(`${API_BASE}/${id}`, {
    method: 'DELETE',
    credentials: 'include',
  });

  if (!res.ok) {
    throw new Error('Failed to delete learning path.');
  }
}

function renderStatusTag(status: LearningPathStatus): React.ReactNode {
  const label =
    status === 'draft'
      ? 'Draft'
      : status === 'published'
      ? 'Published'
      : 'Archived';

  const color =
    status === 'published' ? 'green' : status === 'draft' ? 'gold' : 'default';

  return <Tag color={color}>{label}</Tag>;
}

function formatDate(iso?: string): string {
  if (!iso) return '‚Äî';
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) return '‚Äî';
  return date.toLocaleDateString();
}

export default function ManageExistingPathsPage(): JSX.Element {
  const actionRef = useRef<ActionType>();
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [editSubmitting, setEditSubmitting] = useState(false);
  const [editingPath, setEditingPath] = useState<LearningPath | null>(null);
  const [editForm] = Form.useForm<EditFormValues>();

  const openEditModal = (record: LearningPath) => {
    setEditingPath(record);
    editForm.setFieldsValue({
      name: record.name,
      description: record.description,
      difficulty: record.difficulty,
      subject: record.subject,
      status: record.status,
    });
    setEditModalOpen(true);
  };

  const handleEditSubmit = async () => {
    try {
      const values = await editForm.validateFields();
      if (!editingPath) return;

      setEditSubmitting(true);
      await updateLearningPath(editingPath.id, values);
      message.success('Learning path updated.');
      setEditModalOpen(false);
      setEditingPath(null);
      editForm.resetFields();
      actionRef.current?.reload();
    } catch (err: any) {
      // Ignore validation errors (they‚Äôre already shown by antd)
      if (err?.errorFields) return;
      message.error(err?.message || 'Failed to update learning path.');
    } finally {
      setEditSubmitting(false);
    }
  };

  const confirmArchive = (record: LearningPath) => {
    Modal.confirm({
      title: 'Archive this learning path?',
      content:
        'Learners will no longer see this path in recommendations, but historical progress may remain visible.',
      okText: 'Archive',
      onOk: async () => {
        try {
          await archiveLearningPath(record.id);
          message.success('Learning path archived.');
          actionRef.current?.reload();
        } catch (err: any) {
          message.error(err?.message || 'Failed to archive learning path.');
        }
      },
    });
  };

  const confirmDelete = (record: LearningPath) => {
    Modal.confirm({
      title: 'Delete this learning path?',
      content:
        'This action cannot be undone. If learners are still attached, prefer archiving instead of deleting.',
      okText: 'Delete',
      okButtonProps: { danger: true },
      onOk: async () => {
        try {
          await deleteLearningPath(record.id);
          message.success('Learning path deleted.');
          actionRef.current?.reload();
        } catch (err: any) {
          message.error(err?.message || 'Failed to delete learning path.');
        }
      },
    });
  };

  const columns: ProColumns<LearningPath>[] = [
    {
      title: 'Path',
      dataIndex: 'name',
      key: 'name',
      ellipsis: true,
      render: (dom, record) => (
        <Link href={`/konnected/learning-paths/manage-existing-paths/${record.id}`}>
          {dom}
        </Link>
      ),
    },
    {
      title: 'Subject',
      dataIndex: 'subject',
      key: 'subject',
      ellipsis: true,
      search: {
        transform: (value: string) => ({ subject: value }),
      },
    },
    {
      title: 'Owner',
      dataIndex: 'owner_name',
      key: 'owner_name',
      ellipsis: true,
      render: (dom) => dom ?? '‚Äî',
      search: {
        transform: (value: string) => ({ owner: value }),
      },
    },
    {
      title: 'Difficulty',
      dataIndex: 'difficulty',
      key: 'difficulty',
      valueType: 'select',
      valueEnum: {
        Beginner: { text: 'Beginner' },
        Intermediate: { text: 'Intermediate' },
        Advanced: { text: 'Advanced' },
      },
      render: (_, record) => record.difficulty || '‚Äî',
    },
    {
      title: 'Modules',
      dataIndex: 'modules_count',
      key: 'modules_count',
      width: 110,
      align: 'right',
      render: (dom) => (dom ?? '‚Äî'),
      search: false,
    },
    {
      title: 'Learners',
      dataIndex: 'learners_count',
      key: 'learners_count',
      width: 120,
      align: 'right',
      render: (dom) => (dom ?? 0),
      search: false,
    },
    {
      title: 'Created',
      dataIndex: 'created_at',
      key: 'created_at',
      valueType: 'date',
      width: 140,
      render: (_, record) => formatDate(record.created_at),
      search: false,
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      valueType: 'select',
      width: 130,
      valueEnum: {
        draft: { text: 'Draft' },
        published: { text: 'Published' },
        archived: { text: 'Archived' },
      },
      render: (_, record) => renderStatusTag(record.status),
    },
    {
      title: 'Created between',
      dataIndex: 'created_at_range',
      hideInTable: true,
      valueType: 'dateRange',
      search: {
        transform: (value: [string, string]) => ({
          created_from: value[0],
          created_to: value[1],
        }),
      },
    },
    {
      title: 'Keyword',
      dataIndex: 'keyword',
      hideInTable: true,
      renderFormItem: () => (
        <Input placeholder="Search by title, description, tags‚Ä¶" allowClear />
      ),
      search: {
        transform: (value: string) => ({ keyword: value }),
      },
    },
    {
      title: 'Actions',
      key: 'actions',
      fixed: 'right',
      width: 220,
      valueType: 'option',
      render: (_, record) => {
        const canEdit = record.status !== 'archived';
        const canArchive = record.status !== 'archived';
        const canDelete = record.status === 'draft';

        return (
          <Space size="small">
            <Button type="link" onClick={() => openEditModal(record)} disabled={!canEdit}>
              <EditOutlined /> Edit
            </Button>
            <Button
              type="link"
              onClick={() => confirmArchive(record)}
              disabled={!canArchive}
            >
              Archive
            </Button>
            <Button
              type="link"
              danger
              onClick={() => confirmDelete(record)}
              disabled={!canDelete}
            >
              <DeleteOutlined /> Delete
            </Button>
          </Space>
        );
      },
    },
  ];

  return (
    <KonnectedPageShell
      title="Manage Learning Paths"
      subtitle={
        <Paragraph style={{ marginBottom: 0 }}>
          Review, edit, archive or delete existing learning paths. Published paths
          are visible to learners and may already have active enrollments.
        </Paragraph>
      }
      primaryAction={
        <Link href="/konnected/learning-paths/create-learning-path">
          <Button type="primary" icon={<PlusOutlined />}>
            Create Path
          </Button>
        </Link>
      }
    >
      <ProTable<LearningPath, TableQueryParams>
        rowKey="id"
        actionRef={actionRef}
        columns={columns}
        pagination={{
          pageSize: 10,
          showSizeChanger: true,
          showTotal: (total) => `${total} learning paths`,
        }}
        search={{
          labelWidth: 120,
        }}
        locale={{
          emptyText: (
            <Empty description="No learning paths found.">
              <Link href="/konnected/learning-paths/create-learning-path">
                <Button type="primary" icon={<PlusOutlined />}>
                  Create New Path
                </Button>
              </Link>
            </Empty>
          ),
        }}
        toolBarRender={() => [
          <Text type="secondary" key="hint">
            Filter by owner, subject, status or date to narrow down large catalogs.
          </Text>,
        ]}
        request={async (params) => {
          try {
            const { data, total } = await listLearningPaths({
              current: params.current,
              pageSize: params.pageSize,
              status: params.status as LearningPathStatus | undefined,
              owner: params.owner as string | undefined,
              subject: params.subject as string | undefined,
              keyword: params.keyword as string | undefined,
              created_from: (params as TableQueryParams).created_from,
              created_to: (params as TableQueryParams).created_to,
            });

            return {
              data,
              total,
              success: true,
            };
          } catch (err: any) {
            message.error(err?.message || 'Failed to load learning paths.');
            return {
              data: [],
              total: 0,
              success: false,
            };
          }
        }}
      />

      <Modal
        title={
          editingPath
            ? `Edit learning path ‚Äì ${editingPath.name}`
            : 'Edit learning path'
        }
        open={editModalOpen}
        onOk={handleEditSubmit}
        confirmLoading={editSubmitting}
        onCancel={() => {
          setEditModalOpen(false);
          setEditingPath(null);
          editForm.resetFields();
        }}
        destroyOnClose
      >
        <Form<EditFormValues> form={editForm} layout="vertical">
          <Form.Item
            label="Path name"
            name="name"
            rules={[{ required: true, message: 'Please enter a path name.' }]}
          >
            <Input placeholder="e.g. Intro to Sustainability for Team Leads" />
          </Form.Item>

          <Form.Item label="Description" name="description">
            <Input.TextArea
              rows={3}
              placeholder="Short summary of who this path is for and what it covers."
            />
          </Form.Item>

          <Form.Item label="Difficulty" name="difficulty">
            <Select allowClear placeholder="Select difficulty">
              <Option value="Beginner">Beginner</Option>
              <Option value="Intermediate">Intermediate</Option>
              <Option value="Advanced">Advanced</Option>
            </Select>
          </Form.Item>

          <Form.Item label="Subject / Domain" name="subject">
            <Input placeholder="e.g. AI Ethics, Public Health, Civic Engagement" />
          </Form.Item>

          <Form.Item
            label="Status"
            name="status"
            rules={[{ required: true, message: 'Please select a status.' }]}
          >
            <Select>
              <Option value="draft">Draft</Option>
              <Option value="published">Published</Option>
              <Option value="archived">Archived</Option>
            </Select>
          </Form.Item>
        </Form>
      </Modal>
    </KonnectedPageShell>
  );
}

===== END app/konnected/learning-paths/manage-existing-paths/page.tsx =====


===== BEGIN app/konnected/learning-paths/my-learning-path/page.tsx =====
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Alert,
  App as AntdApp,
  Button,
  Card,
  Col,
  Empty,
  Progress,
  Row,
  Skeleton,
  Space,
  Tabs,
  Tag,
  Typography,
  Select,
} from 'antd';
import type { TabsProps } from 'antd';
import { ClockCircleOutlined, PlayCircleOutlined } from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text, Paragraph, Title } = Typography;
const { Option } = Select;

type LearningPathStatus = 'active' | 'completed' | 'archived';

type Level = 'Beginner' | 'Intermediate' | 'Advanced';

interface LearningPathProgress {
  completedItems: number;
  totalItems: number;
  percentage: number;
  lastActivityAt?: string;
}

interface LearningPath {
  id: string;
  title: string;
  description: string;
  level?: Level;
  tags?: string[];
  estimatedMinutes?: number;
  status: LearningPathStatus;
  progress: LearningPathProgress;
  startedAt?: string;
  completedAt?: string | null;
  // Optional link to the next resource in the path
  nextResourceHref?: string;
  nextResourceLabel?: string;
}

type TabKey = 'active' | 'completed' | 'all';
type SortKey = 'recent' | 'progress' | 'title';

/**
 * Fallback mock data so the page stays functional even without the backend.
 * Replace this with real API data once endpoints are wired.
 */
const MOCK_LEARNING_PATHS: LearningPath[] = [
  {
    id: 'lp-beginner-web',
    title: 'Beginner Web Development',
    description:
      'A structured path introducing HTML, CSS, and JavaScript fundamentals for first-time learners.',
    level: 'Beginner',
    tags: ['Web', 'Foundations', 'HTML/CSS/JS'],
    estimatedMinutes: 360,
    status: 'active',
    progress: {
      completedItems: 3,
      totalItems: 5,
      percentage: 60,
      lastActivityAt: '2025-01-05T15:30:00Z',
    },
    startedAt: '2025-01-01T09:00:00Z',
    completedAt: null,
    nextResourceHref:
      '/konnected/learning-library/browse-resources?pathId=lp-beginner-web',
    nextResourceLabel: 'Continue with CSS Layouts',
  },
  {
    id: 'lp-ai-ethics',
    title: 'AI & Ethics',
    description:
      'Explore responsible AI design, bias mitigation, and governance frameworks across industries.',
    level: 'Intermediate',
    tags: ['AI', 'Ethics', 'Governance'],
    estimatedMinutes: 420,
    status: 'active',
    progress: {
      completedItems: 1,
      totalItems: 6,
      percentage: 17,
      lastActivityAt: '2025-01-03T10:15:00Z',
    },
    startedAt: '2025-01-02T11:00:00Z',
    completedAt: null,
    nextResourceHref:
      '/konnected/learning-library/browse-resources?pathId=lp-ai-ethics',
    nextResourceLabel: 'Resume: What is Responsible AI?',
  },
  {
    id: 'lp-sustainability',
    title: 'Sustainability & Impact Projects',
    description:
      'A curated sequence of resources to design, measure, and communicate sustainability projects.',
    level: 'Advanced',
    tags: ['Sustainability', 'Impact', 'Measurement'],
    estimatedMinutes: 540,
    status: 'completed',
    progress: {
      completedItems: 8,
      totalItems: 8,
      percentage: 100,
      lastActivityAt: '2024-12-20T16:00:00Z',
    },
    startedAt: '2024-11-15T09:00:00Z',
    completedAt: '2024-12-20T16:00:00Z',
    nextResourceHref:
      '/konnected/learning-library/recommended-resources?fromPath=lp-sustainability',
    nextResourceLabel: 'Go to recommended follow-ups',
  },
];

function safeRandomId() {
  if (
    typeof crypto !== 'undefined' &&
    typeof crypto.randomUUID === 'function'
  ) {
    return crypto.randomUUID();
  }
  return `lp-${Math.random().toString(36).slice(2)}`;
}

function normalizeLearningPath(raw: any): LearningPath {
  const totalItems =
    raw?.progress?.totalItems ??
    raw?.totalItems ??
    raw?.modulesCount ??
    raw?.resourcesCount ??
    0;
  const completedItems =
    raw?.progress?.completedItems ??
    raw?.completedItems ??
    raw?.completedModules ??
    0;
  const percentage =
    raw?.progress?.percentage ??
    (totalItems > 0 ? Math.round((completedItems / totalItems) * 100) : 0);

  const status: LearningPathStatus =
    raw?.status && ['active', 'completed', 'archived'].includes(raw.status)
      ? raw.status
      : percentage === 100
      ? 'completed'
      : 'active';

  const rawId = raw?.id ?? raw?.learning_path_id ?? raw?.slug ?? safeRandomId();

  return {
    id: String(rawId),
    title: raw.title ?? raw.name ?? 'Untitled learning path',
    description: raw.description ?? raw.summary ?? '',
    level: raw.level as Level | undefined,
    tags: raw.tags ?? raw.tagList ?? [],
    estimatedMinutes:
      raw.estimatedMinutes ?? raw.estimated_duration_minutes ?? undefined,
    status,
    progress: {
      completedItems,
      totalItems,
      percentage,
      lastActivityAt:
        raw.progress?.lastActivityAt ??
        raw.progress?.last_activity_at ??
        raw.lastActivityAt ??
        raw.last_activity_at ??
        raw.updatedAt ??
        raw.updated_at,
    },
    startedAt: raw.startedAt ?? raw.started_at,
    completedAt: raw.completedAt ?? raw.completed_at ?? null,
    nextResourceHref:
      raw.nextResourceHref ??
      raw.next_resource_href ??
      (typeof window !== 'undefined' && raw.id
        ? `/konnected/learning-library/browse-resources?pathId=${raw.id}`
        : undefined),
    nextResourceLabel:
      raw.nextResourceLabel ?? raw.next_resource_label ?? undefined,
  };
}

type MyLearningPathsApiResponse = {
  items?: unknown[];
  results?: unknown[];
};

type FetchResult = {
  data: LearningPath[];
  error: Error | null;
};

/**
 * Fetches learning paths for the current learner.
 * Always resolves; on any failure it returns mock data plus an Error.
 */
async function fetchMyLearningPaths(): Promise<FetchResult> {
  try {
    const res = await fetch('/api/konnected/learning-paths/my', {
      method: 'GET',
      cache: 'no-store',
    });

    // Treat 404 as "backend not wired yet" ‚Äì use mocks but surface a warning.
    if (res.status === 404) {
      const error = new Error('Learning paths API not available yet (404).');
      // eslint-disable-next-line no-console
      console.warn(error.message);
      return { data: MOCK_LEARNING_PATHS, error };
    }

    if (!res.ok) {
      const error = new Error(`Failed to load learning paths (${res.status}).`);
      // eslint-disable-next-line no-console
      console.error(error);
      return { data: MOCK_LEARNING_PATHS, error };
    }

    const json = (await res.json()) as MyLearningPathsApiResponse | unknown[];

    const rawList: unknown[] = Array.isArray(json)
      ? json
      : (json.items ?? json.results ?? []);

    if (!Array.isArray(rawList) || rawList.length === 0) {
      return { data: MOCK_LEARNING_PATHS, error: null };
    }

    return {
      data: rawList.map((item) => normalizeLearningPath(item)),
      error: null,
    };
  } catch (err) {
    const error =
      err instanceof Error
        ? err
        : new Error('Unable to load your learning paths right now.');
    // eslint-disable-next-line no-console
    console.error('Error fetching learning paths', err);
    return { data: MOCK_LEARNING_PATHS, error };
  }
}

export default function MyLearningPathsPage(): JSX.Element {
  const router = useRouter();
  const { message } = AntdApp.useApp();

  const [paths, setPaths] = useState<LearningPath[] | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<TabKey>('active');
  const [sortKey, setSortKey] = useState<SortKey>('recent');

  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      setLoading(true);
      setError(null);

      const { data, error: loadError } = await fetchMyLearningPaths();

      if (cancelled) return;

      setPaths(data);
      if (loadError) {
        setError(loadError.message);
      }
      setLoading(false);
    };

    void load();

    return () => {
      cancelled = true;
    };
  }, []);

  const handleTabChange: TabsProps['onChange'] = (key) => {
    setActiveTab(key as TabKey);
  };

  const handleSortChange = (value: SortKey) => {
    setSortKey(value);
  };

  const handleResume = (path: LearningPath) => {
    const href =
      path.nextResourceHref ??
      `/konnected/learning-library/browse-resources?pathId=${path.id}`;
    router.push(href);
  };

  const handleMarkComplete = (pathId: string) => {
    // TODO: POST /api/konnected/learning-paths/{id}/complete (mark learner path as complete)
    setPaths((prev) =>
      (prev ?? []).map((p) =>
        p.id === pathId
          ? {
              ...p,
              status: 'completed',
              completedAt: new Date().toISOString(),
              progress: {
                ...p.progress,
                completedItems: p.progress.totalItems,
                percentage: 100,
              },
            }
          : p,
      ),
    );
    message.success('Learning path marked as completed.');
  };

  const handleLeavePath = (pathId: string) => {
    // TODO: POST /api/konnected/learning-paths/{id}/leave (leave learning path)
    setPaths((prev) => (prev ?? []).filter((p) => p.id !== pathId));
    message.success('Learning path removed from your list.');
  };

  const handleBrowseCatalog = () => {
    router.push('/konnected/learning-library/browse-resources');
  };

  const stats = useMemo(() => {
    if (!paths || paths.length === 0) {
      return {
        total: 0,
        active: 0,
        completed: 0,
        avgCompletion: 0,
      };
    }

    const total = paths.length;
    const active = paths.filter((p) => p.status === 'active').length;
    const completed = paths.filter((p) => p.status === 'completed').length;
    const avgCompletion = Math.round(
      paths.reduce((sum, p) => sum + (p.progress?.percentage ?? 0), 0) /
        Math.max(total, 1),
    );

    return { total, active, completed, avgCompletion };
  }, [paths]);

  const filteredAndSortedPaths: LearningPath[] = useMemo(() => {
    if (!paths) return [];

    let filtered = paths;

    if (activeTab === 'active') {
      filtered = filtered.filter((p) => p.status === 'active');
    } else if (activeTab === 'completed') {
      filtered = filtered.filter((p) => p.status === 'completed');
    } else if (activeTab === 'all') {
      filtered = filtered.filter((p) => p.status !== 'archived');
    }

    const sorted = [...filtered].sort((a, b) => {
      if (sortKey === 'title') {
        return a.title.localeCompare(b.title);
      }

      if (sortKey === 'progress') {
        return (b.progress?.percentage ?? 0) - (a.progress?.percentage ?? 0);
      }

      // 'recent' (default) ‚Äì use last activity or started date
      const aDate =
        a.progress?.lastActivityAt ??
        a.completedAt ??
        a.startedAt ??
        '1970-01-01';
      const bDate =
        b.progress?.lastActivityAt ??
        b.completedAt ??
        b.startedAt ??
        '1970-01-01';
      return new Date(bDate).getTime() - new Date(aDate).getTime();
    });

    return sorted;
  }, [paths, activeTab, sortKey]);

  const hasAnyPaths = (paths?.length ?? 0) > 0;
  const activeCount = paths?.filter((p) => p.status === 'active').length ?? 0;
  const completedCount =
    paths?.filter((p) => p.status === 'completed').length ?? 0;

  const tabsItems: TabsProps['items'] = [
    {
      key: 'active',
      label: `Active (${activeCount})`,
    },
    {
      key: 'completed',
      label: `Completed (${completedCount})`,
    },
    {
      key: 'all',
      label: `All (${paths?.length ?? 0})`,
    },
  ];

  return (
    <KonnectedPageShell
      title="My Learning Paths"
      subtitle="Track your in-progress and completed learning paths across the KonnectED Knowledge Library."
      primaryAction={
        <Button type="primary" onClick={handleBrowseCatalog}>
          Browse new learning paths
        </Button>
      }
      secondaryActions={
        <Space>
          <Text type="secondary">Sort by</Text>
          <Select<SortKey>
            value={sortKey}
            size="small"
            style={{ width: 160 }}
            onChange={handleSortChange}
          >
            <Option value="recent">Most recent activity</Option>
            <Option value="progress">Highest completion</Option>
            <Option value="title">Title (A‚ÄìZ)</Option>
          </Select>
        </Space>
      }
    >
      {/* Top summary cards */}
      <Row gutter={[16, 16]} style={{ marginBottom: 24 }}>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Space direction="vertical" size={4}>
              <Text type="secondary">Active paths</Text>
              <Title level={3} style={{ margin: 0 }}>
                {stats.active}
              </Title>
            </Space>
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Space direction="vertical" size={4}>
              <Text type="secondary">Completed paths</Text>
              <Title level={3} style={{ margin: 0 }}>
                {stats.completed}
              </Title>
            </Space>
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Space direction="vertical" size={4}>
              <Text type="secondary">Total enrolled</Text>
              <Title level={3} style={{ margin: 0 }}>
                {stats.total}
              </Title>
            </Space>
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Space direction="vertical" size={4} style={{ width: '100%' }}>
              <Text type="secondary">Average completion</Text>
              <Progress
                percent={stats.avgCompletion}
                size="small"
                status={stats.avgCompletion === 100 ? 'success' : 'active'}
              />
            </Space>
          </Card>
        </Col>
      </Row>

      {error && (
        <Alert
          type="warning"
          showIcon
          closable
          style={{ marginBottom: 16 }}
          message="Unable to fully sync with the learning backend."
          description={
            <span>
              Showing locally cached / mock data for now. Once the KonnectED
              Learning Paths API is wired, this page will refresh
              automatically.
            </span>
          }
        />
      )}

      {/* Empty state when there is nothing at all */}
      {!loading && !hasAnyPaths && (
        <Card>
          <Empty
            description="You are not enrolled in any learning paths yet."
            image={Empty.PRESENTED_IMAGE_SIMPLE}
          >
            <Space direction="vertical">
              <Button type="primary" onClick={handleBrowseCatalog}>
                Explore the Knowledge Library
              </Button>
              <Text type="secondary">
                Browse curated learning paths or assemble your own from
                KonnectED resources.
              </Text>
            </Space>
          </Empty>
        </Card>
      )}

      {/* Tabs + list */}
      {hasAnyPaths && (
        <>
          <Tabs
            items={tabsItems}
            activeKey={activeTab}
            onChange={handleTabChange}
            style={{ marginBottom: 16 }}
          />

          {loading ? (
            <Row gutter={[16, 16]}>
              {Array.from({ length: 3 }).map((_, idx) => (
                <Col xs={24} md={12} lg={8} key={idx}>
                  <Card>
                    <Skeleton active paragraph={{ rows: 4 }} />
                  </Card>
                </Col>
              ))}
            </Row>
          ) : filteredAndSortedPaths.length === 0 ? (
            <Card>
              <Empty
                description={
                  activeTab === 'active'
                    ? 'No active learning paths in this view.'
                    : activeTab === 'completed'
                    ? 'You have not completed any learning paths yet.'
                    : 'No learning paths match the current filters.'
                }
              >
                {activeTab === 'active' && completedCount > 0 && (
                  <Text type="secondary">
                    You do have completed paths ‚Äì switch to the
                    &quot;Completed&quot; tab to review them.
                  </Text>
                )}
                {activeTab === 'completed' && activeCount > 0 && (
                  <Text type="secondary">
                    You still have active paths in progress ‚Äì check the
                    &quot;Active&quot; tab to resume.
                  </Text>
                )}
                {stats.total === 0 && (
                  <Space direction="vertical" style={{ marginTop: 8 }}>
                    <Button type="primary" onClick={handleBrowseCatalog}>
                      Explore the Knowledge Library
                    </Button>
                  </Space>
                )}
              </Empty>
            </Card>
          ) : (
            <Row gutter={[16, 16]}>
              {filteredAndSortedPaths.map((path) => {
                const minutes = path.estimatedMinutes ?? 0;
                const hours = minutes / 60;
                const isCompleted = path.status === 'completed';
                const progress = path.progress?.percentage ?? 0;

                return (
                  <Col xs={24} md={12} lg={8} key={path.id}>
                    <Card
                      hoverable
                      title={
                        <Space>
                          <span>{path.title}</span>
                          {path.level && <Tag color="blue">{path.level}</Tag>}
                          {isCompleted && (
                            <Tag color="green">Completed</Tag>
                          )}
                        </Space>
                      }
                      extra={
                        path.progress?.lastActivityAt ? (
                          <Space size={4}>
                            <ClockCircleOutlined />
                            <Text type="secondary">
                              Last activity{' '}
                              {new Date(
                                path.progress.lastActivityAt,
                              ).toLocaleDateString()}
                            </Text>
                          </Space>
                        ) : null
                      }
                      actions={[
                        <Button
                          key="resume"
                          type="primary"
                          icon={<PlayCircleOutlined />}
                          onClick={() => handleResume(path)}
                        >
                          {isCompleted ? 'Review path' : 'Resume'}
                        </Button>,
                        !isCompleted && (
                          <Button
                            key="complete"
                            type="default"
                            onClick={() => handleMarkComplete(path.id)}
                          >
                            Mark complete
                          </Button>
                        ),
                        <Button
                          key="leave"
                          type="link"
                          danger
                          onClick={() => handleLeavePath(path.id)}
                        >
                          Leave path
                        </Button>,
                      ].filter(Boolean)}
                    >
                      <Space
                        direction="vertical"
                        size="small"
                        style={{ width: '100%' }}
                      >
                        {path.description && (
                          <Paragraph
                            type="secondary"
                            ellipsis={{ rows: 3 }}
                            style={{ marginBottom: 8 }}
                          >
                            {path.description}
                          </Paragraph>
                        )}

                        {path.tags && path.tags.length > 0 && (
                          <Space wrap style={{ marginBottom: 4 }}>
                            {path.tags.map((tag) => (
                              <Tag key={tag}>{tag}</Tag>
                            ))}
                          </Space>
                        )}

                        <Space
                          direction="vertical"
                          style={{ width: '100%', marginTop: 4 }}
                        >
                          <Space
                            align="center"
                            style={{
                              width: '100%',
                              justifyContent: 'space-between',
                            }}
                          >
                            <Text type="secondary">
                              {path.progress?.completedItems ?? 0} of{' '}
                              {path.progress?.totalItems ?? 0} items completed
                            </Text>
                            {minutes > 0 && (
                              <Text type="secondary">
                                ~
                                {hours >= 1
                                  ? `${hours.toFixed(1)} h`
                                  : `${minutes} min`}{' '}
                                total
                              </Text>
                            )}
                          </Space>
                          <Progress
                            percent={progress}
                            status={isCompleted ? 'success' : 'active'}
                            size="small"
                          />
                        </Space>
                      </Space>
                    </Card>
                  </Col>
                );
              })}
            </Row>
          )}
        </>
      )}
    </KonnectedPageShell>
  );
}

===== END app/konnected/learning-paths/my-learning-path/page.tsx =====


===== BEGIN app/konnected/teams-collaboration/activity-planner/page.tsx =====
// app/konnected/teams-collaboration/activity-planner/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import type { CalendarProps } from 'antd';
import {
  Calendar,
  Modal,
  Form,
  DatePicker,
  TimePicker,
  Input,
  Button,
  List,
  Select,
  Typography,
  Row,
  Col,
  Card,
  Tag,
  Divider,
  message,
} from 'antd';
import { PlusOutlined } from '@ant-design/icons';
import dayjs, { Dayjs } from 'dayjs';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Title, Text, Paragraph } = Typography;

/** Domain types */
type ActivityType = 'Workshop' | 'Check-in' | 'Live Session' | 'Async Sprint';

interface ActivityEvent {
  id: string;
  title: string;
  description: string;
  /** Stored as Dayjs (AntD v5 default) */
  dateTime: Dayjs;
  owner: string;
  team: string;
  activityType?: ActivityType;
  /** Optional linkage to other KonnectED sub-modules */
  linkedLearningPathLabel?: string;
  linkedResourceLabel?: string;
}

interface ActivityFormValues {
  eventTitle: string;
  eventDescription?: string;
  eventDate?: Dayjs | null;
  eventTime?: Dayjs | null;
  team?: string;
  owner?: string;
  activityType?: ActivityType;
  linkedLearningPathLabel?: string;
  linkedResourceLabel?: string;
}

/** Team list for filter and form */
const teamOptions = ['All', 'Alpha Innovators', 'Beta Coders', 'Gamma Team'] as const;

/** Activity type options (team learning & collaboration) */
const ACTIVITY_TYPE_OPTIONS: ActivityType[] = [
  'Workshop',
  'Check-in',
  'Live Session',
  'Async Sprint',
];

/** Some sample learning paths / resources labels (UI-only for now) */
const LEARNING_PATH_OPTIONS = [
  'Onboarding to KonnectED',
  'AI Literacy Starter',
  'Leadership Essentials',
];

const RESOURCE_OPTIONS = [
  'Knowledge: ‚ÄúIntro to Robotics‚Äù',
  'Knowledge: ‚ÄúImpact Evaluation Basics‚Äù',
  'Knowledge: ‚ÄúTeam Collaboration Best Practices‚Äù',
];

export default function ActivityPlannerPage(): JSX.Element {
  /** Initial mocked events ‚Äì replace with API data later */
  const [events, setEvents] = useState<ActivityEvent[]>([
    {
      id: 'evt1',
      title: 'Team Onboarding Workshop',
      description:
        'Kick-off session for new members, reviewing our current learning path and workspace norms.',
      dateTime: dayjs().add(2, 'day').hour(10).minute(0),
      owner: 'Alice',
      team: 'Alpha Innovators',
      activityType: 'Workshop',
      linkedLearningPathLabel: 'Onboarding to KonnectED',
    },
    {
      id: 'evt2',
      title: 'Sprint Learning Check-in',
      description:
        'Short sync on what we learned this sprint and which resources to bookmark in Knowledge.',
      dateTime: dayjs().add(4, 'day').hour(9).minute(30),
      owner: 'Bob',
      team: 'Beta Coders',
      activityType: 'Check-in',
      linkedResourceLabel: 'Knowledge: ‚ÄúTeam Collaboration Best Practices‚Äù',
    },
  ]);

  const [selectedTeam, setSelectedTeam] = useState<string>('All');
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [preSelectedDate, setPreSelectedDate] = useState<Dayjs | null>(null);

  const [form] = Form.useForm<ActivityFormValues>();

  /** Filtering by team */
  const filteredEvents = useMemo(
    () =>
      selectedTeam === 'All'
        ? events
        : events.filter((evt) => evt.team === selectedTeam),
    [events, selectedTeam],
  );

  /** Upcoming list, sorted by date/time */
  const upcomingEvents = useMemo(
    () =>
      [...filteredEvents]
        .filter((evt) => evt.dateTime.isAfter(dayjs().subtract(1, 'day')))
        .sort((a, b) => a.dateTime.valueOf() - b.dateTime.valueOf()),
    [filteredEvents],
  );

  /** AntD v5: use `cellRender` for date cells to show small markers */
  const cellRender: CalendarProps<Dayjs>['cellRender'] = (value, info) => {
    if (info.type !== 'date') return info.originNode;
    const listData = events.filter((evt) => evt.dateTime.isSame(value, 'day'));
    if (!listData.length) return info.originNode;

    return (
      <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
        {listData.slice(0, 3).map((item) => (
          <li key={item.id} style={{ marginBottom: 2 }}>
            <Text style={{ fontSize: 10 }} ellipsis>
              {item.title}
            </Text>
          </li>
        ))}
        {listData.length > 3 && (
          <li>
            <Text type="secondary" style={{ fontSize: 10 }}>
              +{listData.length - 3} more
            </Text>
          </li>
        )}
      </ul>
    );
  };

  /** Calendar selection uses Dayjs in AntD v5 */
  const handleDateSelect = (value: Dayjs) => {
    setPreSelectedDate(value);
    // preset only the date; time stays empty until user picks it
    form.setFieldsValue({ eventDate: value });
    setModalVisible(true);
  };

  /** Add new activity (currently client-side only) */
  const handleAddEvent = (values: ActivityFormValues) => {
    if (!values.eventDate || !values.eventTime || !values.team || !values.owner) {
      message.error('Please fill in all required fields.');
      return;
    }

    const mergedDateTime = values.eventDate
      .hour(values.eventTime.hour())
      .minute(values.eventTime.minute());

    const newEvent: ActivityEvent = {
      id: `evt-${Date.now()}`,
      title: values.eventTitle,
      description: values.eventDescription ?? '',
      dateTime: mergedDateTime,
      owner: values.owner,
      team: values.team,
      activityType: values.activityType,
      linkedLearningPathLabel: values.linkedLearningPathLabel,
      linkedResourceLabel: values.linkedResourceLabel,
    };

    setEvents((prev) => [...prev, newEvent]);
    setModalVisible(false);
    form.resetFields();
    setPreSelectedDate(null);
    message.success('Activity added to the team calendar.');
  };

  const handleDeleteEvent = (id: string) => {
    setEvents((prev) => prev.filter((evt) => evt.id !== id));
    message.success('Activity removed.');
  };

  const handleOpenModalEmpty = () => {
    setPreSelectedDate(null);
    form.resetFields();
    setModalVisible(true);
  };

  const modalTitle = preSelectedDate
    ? `Add Activity on ${preSelectedDate.format('YYYY-MM-DD')}`
    : 'Add New Activity';

  return (
    <KonnectedPageShell
      title="Activity Planner"
      subtitle={
        <span>
          Plan team learning sessions, workshops, and collaborative check-ins, and optionally link
          them to Learning Paths or Knowledge resources.
        </span>
      }
      primaryAction={
        <Button type="primary" icon={<PlusOutlined />} onClick={handleOpenModalEmpty}>
          Add Activity
        </Button>
      }
      secondaryActions={
        <Select
          value={selectedTeam}
          style={{ minWidth: 180 }}
          onChange={setSelectedTeam}
          options={teamOptions.map((t) => ({ label: t, value: t }))}
        />
      }
    >
      <Row gutter={[24, 24]}>
        <Col xs={24} lg={16}>
          <Card
            title="Team Activity Calendar"
            extra={
              <Text type="secondary">
                Click a date to schedule a new session for a team.
              </Text>
            }
            bordered
          >
            <Calendar
              fullscreen
              onSelect={handleDateSelect}
              cellRender={cellRender}
            />
          </Card>
        </Col>

        <Col xs={24} lg={8}>
          <Card bordered>
            <Title level={4} style={{ marginBottom: 8 }}>
              Upcoming Activities
            </Title>
            <Paragraph type="secondary" style={{ marginBottom: 16 }}>
              Showing activities for{' '}
              <Text strong>{selectedTeam === 'All' ? 'all teams' : selectedTeam}</Text>.
            </Paragraph>

            <List
              size="small"
              dataSource={upcomingEvents}
              locale={{
                emptyText: 'No planned activities yet. Use ‚ÄúAdd Activity‚Äù to get started.',
              }}
              renderItem={(item) => (
                <List.Item
                  key={item.id}
                  actions={[
                    <Button
                      key="delete"
                      danger
                      size="small"
                      onClick={() => handleDeleteEvent(item.id)}
                    >
                      Delete
                    </Button>,
                  ]}
                >
                  <List.Item.Meta
                    title={
                      <span>
                        {item.title}{' '}
                        {item.activityType && <Tag color="blue">{item.activityType}</Tag>}
                      </span>
                    }
                    description={
                      <div>
                        <div>
                          <Text strong>
                            {item.dateTime.format('YYYY-MM-DD HH:mm')}
                          </Text>
                        </div>
                        <div>
                          <Text type="secondary">
                            Team: {item.team} ‚Ä¢ Owner: {item.owner}
                          </Text>
                        </div>
                        {(item.linkedLearningPathLabel || item.linkedResourceLabel) && (
                          <div style={{ marginTop: 4 }}>
                            {item.linkedLearningPathLabel && (
                              <Tag color="green">
                                Path: {item.linkedLearningPathLabel}
                              </Tag>
                            )}
                            {item.linkedResourceLabel && (
                              <Tag color="purple">
                                Resource: {item.linkedResourceLabel}
                              </Tag>
                            )}
                          </div>
                        )}
                        {item.description && (
                          <div style={{ marginTop: 4 }}>
                            <Text>{item.description}</Text>
                          </div>
                        )}
                      </div>
                    }
                  />
                </List.Item>
              )}
            />

            <Divider />

            <Text type="secondary">
              Tip: You can later wire this planner to real team data, Learning Paths, and Knowledge
              resources so that attendance and completion stats feed into analytics.
            </Text>
          </Card>
        </Col>
      </Row>

      <Modal
        title={modalTitle}
        open={modalVisible}
        onCancel={() => {
          setModalVisible(false);
          form.resetFields();
          setPreSelectedDate(null);
        }}
        footer={null}
        destroyOnClose
      >
        <Form<ActivityFormValues> form={form} layout="vertical" onFinish={handleAddEvent}>
          <Form.Item
            label="Activity Title"
            name="eventTitle"
            rules={[{ required: true, message: 'Please enter the activity title.' }]}
          >
            <Input placeholder="e.g. Sprint Learning Check-in" />
          </Form.Item>

          <Form.Item label="Description" name="eventDescription">
            <Input.TextArea
              rows={3}
              placeholder="What is the team expected to do or learn during this activity?"
            />
          </Form.Item>

          <Row gutter={12}>
            <Col span={12}>
              <Form.Item
                label="Date"
                name="eventDate"
                rules={[{ required: true, message: 'Please select a date.' }]}
              >
                <DatePicker style={{ width: '100%' }} />
              </Form.Item>
            </Col>
            <Col span={12}>
              <Form.Item
                label="Time"
                name="eventTime"
                rules={[{ required: true, message: 'Please select a time.' }]}
              >
                <TimePicker style={{ width: '100%' }} format="HH:mm" />
              </Form.Item>
            </Col>
          </Row>

          <Form.Item
            label="Team"
            name="team"
            rules={[{ required: true, message: 'Please select a team.' }]}
            initialValue={teamOptions[1]}
          >
            <Select
              options={teamOptions
                .filter((t) => t !== 'All')
                .map((t) => ({ value: t, label: t }))}
            />
          </Form.Item>

          <Form.Item label="Activity Type" name="activityType">
            <Select
              placeholder="Select an activity type"
              allowClear
              options={ACTIVITY_TYPE_OPTIONS.map((t) => ({ label: t, value: t }))}
            />
          </Form.Item>

          <Form.Item
            label="Owner"
            name="owner"
            rules={[{ required: true, message: 'Please enter the owner.' }]}
          >
            <Input placeholder="e.g. Team lead or facilitator name" />
          </Form.Item>

          <Form.Item label="Linked Learning Path (optional)" name="linkedLearningPathLabel">
            <Select
              placeholder="Link to a Learning Path"
              allowClear
              options={LEARNING_PATH_OPTIONS.map((label) => ({ label, value: label }))}
            />
          </Form.Item>

          <Form.Item label="Linked Knowledge Resource (optional)" name="linkedResourceLabel">
            <Select
              placeholder="Link to a Knowledge resource"
              allowClear
              options={RESOURCE_OPTIONS.map((label) => ({ label, value: label }))}
            />
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" block icon={<PlusOutlined />}>
              Add Activity
            </Button>
          </Form.Item>
        </Form>
      </Modal>
    </KonnectedPageShell>
  );
}

===== END app/konnected/teams-collaboration/activity-planner/page.tsx =====


===== BEGIN app/konnected/teams-collaboration/my-teams/page.tsx =====
Ôªø// app/konnected/teams-collaboration/my-teams/page.tsx
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  App,
  Avatar,
  Alert,
  Button,
  Col,
  Dropdown,
  Empty,
  Input,
  List,
  Row,
  Select,
  Space,
  Switch,
  Table,
  Tag,
  Typography,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import type { MenuProps, TableProps } from 'antd';
import {
  DownOutlined,
  TeamOutlined,
  UsergroupAddOutlined,
  PlusOutlined,
  ProjectOutlined,
  CalendarOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text, Paragraph } = Typography;
const { Search } = Input;
const { Option } = Select;

type TeamRole = 'owner' | 'admin' | 'member' | 'observer';
type MembershipStatus = 'active' | 'invited' | 'request_pending';

interface TeamMember {
  id: string;
  name: string;
  role: string;
}

// Aligned with backend MyTeams API contract (v14 spec)
interface MyTeamsApiTeam {
  id: string;
  name: string;
  project_title?: string | null;
  membership_role: TeamRole;
  membership_status?: MembershipStatus;
  members_count?: number;
  is_restricted?: boolean;
  recent_activity?: string[];
  members_preview?: TeamMember[];
}

interface TeamRow {
  key: string;
  teamId: string;
  teamName: string;
  projectName: string;
  userRole: TeamRole;
  membershipStatus: MembershipStatus;
  membersCount: number;
  isRestricted: boolean;
  roster: TeamMember[];
  recentActivity: string[];
}

// Backend endpoints as per v14 spec
const MY_TEAMS_ENDPOINT = '/api/konnected/teams/my-teams';
const LEAVE_TEAM_ENDPOINT = (teamId: string) =>
  `/api/konnected/teams/${encodeURIComponent(teamId)}/leave`;

/**
 * Normalizes API payload (array or { items }) into table rows.
 */
function mapToRows(payload: unknown): TeamRow[] {
  const rawItems: MyTeamsApiTeam[] = Array.isArray(payload)
    ? (payload as MyTeamsApiTeam[])
    : (payload as { items?: MyTeamsApiTeam[] })?.items ?? [];

  return rawItems.map((t) => {
    const roster = t.members_preview ?? ([] as TeamMember[]);

    return {
      key: t.id,
      teamId: t.id,
      teamName: t.name,
      projectName: t.project_title ?? '‚Äî',
      userRole: t.membership_role,
      membershipStatus: t.membership_status ?? 'active',
      membersCount: t.members_count ?? roster.length,
      isRestricted: Boolean(t.is_restricted),
      roster,
      recentActivity: t.recent_activity ?? [],
    };
  });
}

export default function MyTeamsPage(): JSX.Element {
  const router = useRouter();
  const { message } = App.useApp();

  const [loading, setLoading] = useState<boolean>(true);
  const [reloadFlag, setReloadFlag] = useState<number>(0);
  const [error, setError] = useState<string | null>(null);

  const [selectedTeamKeys, setSelectedTeamKeys] = useState<React.Key[]>([]);
  const [data, setData] = useState<TeamRow[]>([]);

  const [searchText, setSearchText] = useState('');
  const [roleFilter, setRoleFilter] = useState<'all' | TeamRole>('all');
  const [statusFilter, setStatusFilter] =
    useState<'all' | MembershipStatus>('all');
  const [restrictedOnly, setRestrictedOnly] = useState(false);

  const [leavingTeamId, setLeavingTeamId] = useState<string | null>(null);

  // --- Load teams from backend ------------------------------------------------
  useEffect(() => {
    let cancelled = false;

    async function loadTeams() {
      setLoading(true);
      setError(null);

      try {
        const res = await fetch(MY_TEAMS_ENDPOINT, {
          credentials: 'include',
          cache: 'no-store',
        });

        // Treat a 404 as "endpoint not wired yet / no teams" and degrade gracefully
        if (res.status === 404) {
          if (!cancelled) {
            setData([]);
          }
          return;
        }

        if (!res.ok) {
          throw new Error(`HTTP ${res.status} ${res.statusText}`);
        }

        const json = await res.json();
        if (!cancelled) {
          const rows = mapToRows(json);
          setData(rows);
        }
      } catch (err) {
        if (!cancelled) {
          // eslint-disable-next-line no-console
          console.error('Failed to load teams', err);
          setError('Unable to load your teams right now. Please try again later.');
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }

    void loadTeams();

    return () => {
      cancelled = true;
    };
  }, [reloadFlag]);

  // --- Actions ----------------------------------------------------------------

  const handleLeaveTeam = async (team: TeamRow) => {
    if (team.userRole === 'owner') {
      message.warning(
        'You are the owner of this team. Transfer ownership before leaving.',
      );
      return;
    }

    setLeavingTeamId(team.teamId);
    try {
      const res = await fetch(LEAVE_TEAM_ENDPOINT(team.teamId), {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!res.ok) {
        throw new Error(`HTTP ${res.status} ${res.statusText}`);
      }

      message.success(`You left ${team.teamName}.`);
      setData((prev) => prev.filter((row) => row.teamId !== team.teamId));
      setSelectedTeamKeys((prev) => prev.filter((key) => key !== team.key));
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Failed to leave team', err);
      message.error('Could not leave the team. Please try again.');
    } finally {
      setLeavingTeamId(null);
    }
  };

  const handleViewTeam = (team: TeamRow) => {
    router.push(
      `/konnected/teams-collaboration/my-teams/${encodeURIComponent(
        team.teamId,
      )}`,
    );
  };

  const handleInviteMembers = (team: TeamRow) => {
    router.push(
      `/konnected/teams-collaboration/team-builder?teamId=${encodeURIComponent(
        team.teamId,
      )}&mode=invite`,
    );
  };

  // --- Filters & derived data -------------------------------------------------

  const filteredData = useMemo(() => {
    return data.filter((row) => {
      if (searchText) {
        const q = searchText.toLowerCase();
        const matchesName =
          row.teamName.toLowerCase().includes(q) ||
          row.projectName.toLowerCase().includes(q);
        if (!matchesName) return false;
      }

      if (roleFilter !== 'all' && row.userRole !== roleFilter) {
        return false;
      }

      if (statusFilter !== 'all' && row.membershipStatus !== statusFilter) {
        return false;
      }

      if (restrictedOnly && !row.isRestricted) {
        return false;
      }

      return true;
    });
  }, [data, searchText, roleFilter, statusFilter, restrictedOnly]);

  const sortedData = useMemo(
    () => [...filteredData].sort((a, b) => a.teamName.localeCompare(b.teamName)),
    [filteredData],
  );

  const totalTeams = data.length;
  const ownerAdminCount = data.filter(
    (t) => t.userRole === 'owner' || t.userRole === 'admin',
  ).length;
  const restrictedCount = data.filter((t) => t.isRestricted).length;

  const rowSelection: TableProps<TeamRow>['rowSelection'] = {
    selectedRowKeys: selectedTeamKeys,
    onChange: (keys) => setSelectedTeamKeys(keys as React.Key[]),
  };

  const columns: ColumnsType<TeamRow> = [
    {
      title: 'Team',
      dataIndex: 'teamName',
      key: 'teamName',
      render: (value: string, record) => (
        <Space direction="vertical" size={0}>
          <Text strong>{value}</Text>
          <Text type="secondary">ID: {record.teamId}</Text>
        </Space>
      ),
    },
    {
      title: 'Project',
      dataIndex: 'projectName',
      key: 'projectName',
      ellipsis: true,
      render: (value: string) => <Text>{value}</Text>,
    },
    {
      title: 'My role',
      dataIndex: 'userRole',
      key: 'userRole',
      width: 140,
      render: (role: TeamRole) => {
        let color: string | undefined;
        switch (role) {
          case 'owner':
            color = 'gold';
            break;
          case 'admin':
            color = 'blue';
            break;
          case 'member':
            color = 'green';
            break;
          case 'observer':
            color = 'default';
            break;
          default:
            color = 'default';
        }
        return <Tag color={color}>{role}</Tag>;
      },
    },
    {
      title: 'Members',
      dataIndex: 'roster',
      key: 'roster',
      width: 260,
      render: (_: TeamMember[], record) => {
        const preview = record.roster.slice(0, 3);
        return preview.length ? (
          <List
            dataSource={preview}
            renderItem={(m: TeamMember) => (
              <List.Item style={{ paddingInline: 0 }} key={m.id}>
                <List.Item.Meta
                  avatar={<Avatar>{m.name.charAt(0)}</Avatar>}
                  title={<Text>{m.name}</Text>}
                  description={<Text type="secondary">{m.role}</Text>}
                />
              </List.Item>
            )}
          />
        ) : (
          <Text type="secondary">Members not loaded</Text>
        );
      },
    },
    {
      title: 'Recent activity',
      dataIndex: 'recentActivity',
      key: 'recentActivity',
      width: 260,
      render: (activities: string[]) =>
        activities.length ? (
          <List
            size="small"
            dataSource={activities.slice(0, 3)}
            renderItem={(msg) => (
              <List.Item style={{ paddingInline: 0 }}>{msg}</List.Item>
            )}
          />
        ) : (
          <Text type="secondary">No recent activity</Text>
        ),
      responsive: ['lg'],
    },
    {
      title: 'Status',
      dataIndex: 'membershipStatus',
      key: 'membershipStatus',
      width: 140,
      render: (status: MembershipStatus) => {
        switch (status) {
          case 'active':
            return <Tag color="green">Active</Tag>;
          case 'invited':
            return <Tag color="blue">Invitation</Tag>;
          case 'request_pending':
            return <Tag color="orange">Request pending</Tag>;
          default:
            return <Tag>Unknown</Tag>;
        }
      },
    },
    {
      title: 'Access',
      dataIndex: 'isRestricted',
      key: 'isRestricted',
      width: 120,
      render: (isRestricted: boolean) =>
        isRestricted ? (
          <Tag color="volcano">Restricted</Tag>
        ) : (
          <Tag color="default">Open</Tag>
        ),
      responsive: ['md'],
    },
    {
      title: 'Actions',
      key: 'actions',
      fixed: 'right',
      width: 160,
      render: (_: unknown, record) => {
        const items: MenuProps['items'] = [
          { key: 'view', label: 'Open team' },
          { key: 'invite', label: 'Invite members' },
          { type: 'divider' },
          {
            key: 'leave',
            danger: true,
            label: 'Leave team',
          },
        ];

        const onMenuClick: MenuProps['onClick'] = ({ key }) => {
          switch (key) {
            case 'view':
              handleViewTeam(record);
              break;
            case 'invite':
              handleInviteMembers(record);
              break;
            case 'leave':
              void handleLeaveTeam(record);
              break;
            default:
              break;
          }
        };

        const isLeaving = leavingTeamId === record.teamId;

        return (
          <Dropdown
            menu={{ items, onClick: onMenuClick }}
            trigger={['click']}
            disabled={isLeaving}
          >
            <Button loading={isLeaving}>
              Actions <DownOutlined />
            </Button>
          </Dropdown>
        );
      },
    },
  ];

  const headerSecondaryActions = (
    <Space>
      <Button
        icon={<ProjectOutlined />}
        onClick={() =>
          router.push('/konnected/teams-collaboration/project-workspaces')
        }
      >
        Project workspaces
      </Button>
      <Button
        icon={<CalendarOutlined />}
        onClick={() =>
          router.push('/konnected/teams-collaboration/activity-planner')
        }
      >
        Activity planner
      </Button>
    </Space>
  );

  const headerPrimaryAction = (
    <Button
      type="primary"
      icon={<PlusOutlined />}
      onClick={() =>
        router.push('/konnected/teams-collaboration/team-builder')
      }
    >
      Create or join a team
    </Button>
  );

  const hasRows = sortedData.length > 0;

  return (
    <KonnectedPageShell
      title="My Teams"
      subtitle={
        <span>
          Manage the collaboration teams you are part of in KonnectED. View
          membership, recent activity, and jump into workspaces.
        </span>
      }
      primaryAction={headerPrimaryAction}
      secondaryActions={headerSecondaryActions}
    >
      <Row gutter={[16, 16]} style={{ marginBottom: 16 }}>
        <Col xs={24} sm={8}>
          <Space direction="vertical" size={0}>
            <Text type="secondary">Total teams</Text>
            <Text strong>
              <TeamOutlined style={{ marginRight: 4 }} />
              {totalTeams}
            </Text>
          </Space>
        </Col>
        <Col xs={24} sm={8}>
          <Space direction="vertical" size={0}>
            <Text type="secondary">Teams you own/admin</Text>
            <Text strong>{ownerAdminCount}</Text>
          </Space>
        </Col>
        <Col xs={24} sm={8}>
          <Space direction="vertical" size={0}>
            <Text type="secondary">Restricted teams</Text>
            <Text strong>{restrictedCount}</Text>
          </Space>
        </Col>
      </Row>

      <Row gutter={[16, 16]} style={{ marginBottom: 16 }}>
        <Col xs={24} md={10}>
          <Search
            placeholder="Search by team or project name"
            allowClear
            value={searchText}
            onChange={(e) => setSearchText(e.target.value)}
            onSearch={(value) => setSearchText(value)}
          />
        </Col>
        <Col xs={12} md={6}>
          <Select<'all' | TeamRole>
            style={{ width: '100%' }}
            value={roleFilter}
            onChange={(val) => setRoleFilter(val)}
          >
            <Option value="all">All roles</Option>
            <Option value="owner">Owner</Option>
            <Option value="admin">Admin</Option>
            <Option value="member">Member</Option>
            <Option value="observer">Observer</Option>
          </Select>
        </Col>
        <Col xs={12} md={6}>
          <Select<'all' | MembershipStatus>
            style={{ width: '100%' }}
            value={statusFilter}
            onChange={(val) => setStatusFilter(val)}
          >
            <Option value="all">All membership states</Option>
            <Option value="active">Active</Option>
            <Option value="invited">Invitations</Option>
            <Option value="request_pending">Requests pending</Option>
          </Select>
        </Col>
        <Col xs={24} md={2}>
          <Space>
            <Switch
              checked={restrictedOnly}
              onChange={(checked) => setRestrictedOnly(checked)}
            />
            <Text type="secondary">Restricted only</Text>
          </Space>
        </Col>
      </Row>

      {error && (
        <Alert
          type="error"
          message="Unable to load your teams"
          description={
            <>
              <Paragraph style={{ marginBottom: 8 }}>{error}</Paragraph>
              <Button size="small" onClick={() => setReloadFlag((n) => n + 1)}>
                Retry
              </Button>
            </>
          }
          showIcon
          style={{ marginBottom: 16 }}
        />
      )}

      {!loading && !error && !hasRows ? (
        <Empty
          description="You are not part of any team yet."
          style={{ padding: '40px 0' }}
        >
          <Space>
            <Button
              type="primary"
              icon={<PlusOutlined />}
              onClick={() =>
                router.push('/konnected/teams-collaboration/team-builder')
              }
            >
              Create or join a team
            </Button>
            <Button
              icon={<ProjectOutlined />}
              onClick={() =>
                router.push('/konnected/teams-collaboration/project-workspaces')
              }
            >
              Browse project workspaces
            </Button>
          </Space>
        </Empty>
      ) : (
        <Table<TeamRow>
          rowKey="key"
          size="middle"
          bordered
          loading={loading}
          columns={columns}
          dataSource={sortedData}
          rowSelection={rowSelection}
          pagination={{ pageSize: 8, showSizeChanger: false }}
          scroll={{ x: 1000 }}
        />
      )}
    </KonnectedPageShell>
  );
}

===== END app/konnected/teams-collaboration/my-teams/page.tsx =====


===== BEGIN app/konnected/teams-collaboration/project-workspaces/page.tsx =====
// app/konnected/teams-collaboration/project-workspaces/page.tsx
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Button,
  Card,
  Col,
  Dropdown,
  Empty,
  Input,
  message as antdMessage,
  Row,
  Select,
  Space,
  Spin,
  Statistic,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import type { MenuProps } from 'antd';
import {
  ArrowRightOutlined,
  DownOutlined,
  ProjectOutlined,
  TeamOutlined,
} from '@ant-design/icons';
import { Table } from 'antd';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import api from '@/api';

const { Text } = Typography;
const { Search } = Input;
const { Option } = Select;

type WorkspaceVisibility = 'open' | 'team-only' | 'restricted';

/**
 * Row used by the UI.
 * Currently backed directly by keenKonnect Projects from the backend.
 * Team-related fields are left empty until KonnectED teams APIs are wired.
 */
export interface ProjectWorkspaceRow {
  id: string;
  projectId: string;
  teamId: string;

  projectTitle: string;
  teamName: string;

  /** e.g. "Active", "Planning", "Completed", "Archived" */
  status: string;

  /** e.g. "Owner", "Contributor", "Viewer" */
  userRole: string;

  /** true = workspace available in keenKonnect */
  isWorkspaceLaunched: boolean;

  /** last activity timestamp (ISO) */
  lastActivityAt?: string | null;

  /** membership / presence */
  totalMembers?: number | null;
  onlineMembers?: number | null;

  /** linked KonnectED resources (future) */
  linkedKnowledgeCount?: number | null;
  linkedCertificationsCount?: number | null;

  /** access rules as resolved for current user */
  visibility?: WorkspaceVisibility;
  canEnter?: boolean;
  canManage?: boolean;
  canArchive?: boolean;
}

/** Shape of /api/keenkonnect/projects/ from the Django backend */
interface ProjectApi {
  id: number;
  creator: string;
  title: string;
  description: string;
  category: string;
  status: string;
  created_at: string;
  updated_at: string;
  tags: number[];
}

/** Shape of /api/users/me/ */
interface CurrentUserApi {
  username: string;
  name: string;
  url: string;
}

type StatusFilterValue = 'all' | 'active' | 'planning' | 'completed' | 'archived';
type OwnershipFilterValue = 'all' | 'owner' | 'member';

function getStatusTagColor(status: string): string {
  const normalized = status.toLowerCase();
  if (normalized.includes('active')) return 'green';
  if (normalized.includes('plan')) return 'blue';
  if (normalized.includes('complete')) return 'geekblue';
  if (normalized.includes('hold')) return 'orange';
  if (normalized.includes('archiv')) return 'default';
  return 'default';
}

function formatLastActivity(iso?: string | null): string {
  if (!iso) return 'N/A';
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) return 'N/A';
  return date.toLocaleString();
}

/**
 * Map backend project.status codes to human-readable workspace status labels.
 * This keeps the filters ("Active", "Planning", etc.) working.
 */
function mapProjectStatusToLabel(statusCode: string): string {
  const code = (statusCode ?? '').toLowerCase();
  if (code === 'idea') return 'Planning';
  if (code === 'progress' || code === 'in_progress') return 'Active';
  if (code === 'completed' || code === 'done') return 'Completed';
  if (code === 'validated') return 'Completed';
  if (code === 'archived') return 'Archived';
  return statusCode || 'Active';
}

/**
 * Build a workspace row purely from real backend data.
 * Team-related info is left empty until ProjectTeam/KonnectED teams APIs exist.
 */
function buildWorkspaceRow(
  project: ProjectApi,
  currentUsername: string | null,
): ProjectWorkspaceRow {
  const statusLabel = mapProjectStatusToLabel(project.status);
  const isOwner = currentUsername != null && project.creator === currentUsername;

  return {
    id: String(project.id),
    projectId: String(project.id),
    // No explicit team model wired yet ‚Üí keep empty, rendered as "‚Äî" in the UI
    teamId: '',
    teamName: '',
    projectTitle: project.title,
    status: statusLabel,
    userRole: isOwner ? 'Owner' : 'Member',
    isWorkspaceLaunched: true,
    lastActivityAt: project.updated_at || project.created_at,
    totalMembers: null,
    onlineMembers: null,
    linkedKnowledgeCount: null,
    linkedCertificationsCount: null,
    visibility: 'open',
    canEnter: true,
    canManage: isOwner,
    canArchive: isOwner,
  };
}

export default function KonnectedProjectWorkspacesPage(): JSX.Element {
  const router = useRouter();

  const [messageApi, contextHolder] = antdMessage.useMessage();

  const [loading, setLoading] = useState<boolean>(false);
  const [rows, setRows] = useState<ProjectWorkspaceRow[]>([]);
  const [total, setTotal] = useState<number>(0);

  const [searchText, setSearchText] = useState<string>('');
  const [statusFilter, setStatusFilter] = useState<StatusFilterValue>('all');
  const [ownershipFilter, setOwnershipFilter] =
    useState<OwnershipFilterValue>('all');
  const [teamFilter, setTeamFilter] = useState<string | 'all'>('all');

  // --- Fetch data from backend (real /api endpoints) -------------------------

  useEffect(() => {
    let isMounted = true;

    async function fetchWorkspaces() {
      try {
        setLoading(true);

        let currentUsername: string | null = null;

        // Try to resolve current user, but do not fail the page if this call fails.
        try {
          const me = await api.get<CurrentUserApi>('users/me/');
          currentUsername = me?.username ?? null;
        } catch {
          currentUsername = null;
        }

        // KeenKonnect projects list ‚Üí /api/keenkonnect/projects/
        const projects = await api.get<ProjectApi[]>('keenkonnect/projects/');

        if (!isMounted) return;

        const mapped = (projects ?? []).map((p) =>
          buildWorkspaceRow(p, currentUsername),
        );

        setRows(mapped);
        setTotal(mapped.length);
      } catch (error) {
        if (!isMounted) return;
        // eslint-disable-next-line no-console
        console.error('Failed to load project workspaces', error);
        messageApi.error(
          'Unable to load project workspaces. Please try again later.',
        );
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    }

    void fetchWorkspaces();

    return () => {
      isMounted = false;
    };
  }, [messageApi]);

  // --- Derived filters & stats -----------------------------------------------

  const teamOptions = useMemo(() => {
    const uniqueTeams = Array.from(
      new Set(rows.map((r) => r.teamName).filter(Boolean)),
    );
    return uniqueTeams.sort();
  }, [rows]);

  const filteredRows = useMemo(
    () =>
      rows.filter((row) => {
        // text search on project + team
        if (searchText.trim()) {
          const needle = searchText.toLowerCase();
          const haystack = `${row.projectTitle} ${row.teamName}`.toLowerCase();
          if (!haystack.includes(needle)) {
            return false;
          }
        }

        // status filter ‚Äì approximate mapping based on label
        if (statusFilter !== 'all') {
          const normalized = row.status.toLowerCase();
          switch (statusFilter) {
            case 'active':
              if (!normalized.includes('active')) return false;
              break;
            case 'planning':
              if (!normalized.includes('plan')) return false;
              break;
            case 'completed':
              if (!normalized.includes('complete')) return false;
              break;
            case 'archived':
              if (!normalized.includes('archiv')) return false;
              break;
            default:
              break;
          }
        }

        // ownership filter ‚Äì role derived from backend creator vs current user
        if (ownershipFilter !== 'all') {
          const role = (row.userRole || '').toLowerCase();
          if (ownershipFilter === 'owner') {
            if (!role.includes('owner') && !role.includes('lead')) return false;
          }
          if (ownershipFilter === 'member') {
            if (role.includes('owner') || role.includes('lead')) return false;
          }
        }

        // team filter
        if (teamFilter !== 'all' && row.teamName !== teamFilter) {
          return false;
        }

        return true;
      }),
    [rows, searchText, statusFilter, ownershipFilter, teamFilter],
  );

  const totalActive = useMemo(
    () =>
      rows.filter((r) => r.status.toLowerCase().includes('active')).length,
    [rows],
  );

  const totalOwned = useMemo(
    () =>
      rows.filter((r) => {
        const role = (r.userRole || '').toLowerCase();
        return role.includes('owner') || role.includes('lead');
      }).length,
    [rows],
  );

  // --- Navigation helpers -----------------------------------------------------

  const goToWorkspace = (row: ProjectWorkspaceRow) => {
    if (row.canEnter === false) {
      messageApi.warning('You do not have permission to enter this workspace.');
      return;
    }

    router.push(
      `/keenkonnect/projects/project-workspace?projectId=${row.projectId}`,
    );
  };

  const goToTeam = (row: ProjectWorkspaceRow) => {
    router.push('/konnected/teams-collaboration/my-teams');
  };

  const handleArchiveWorkspace = (row: ProjectWorkspaceRow) => {
    if (!row.canArchive) {
      messageApi.warning('You do not have permission to archive this workspace.');
      return;
    }
    // TODO: plug to a real archive endpoint when implemented (e.g. PATCH /projects/{id}/archive/)
    messageApi.info(
      `Archive action would be sent for workspace "${row.projectTitle}".`,
    );
  };

  // --- Table columns ----------------------------------------------------------

  const columns: ColumnsType<ProjectWorkspaceRow> = [
    {
      title: 'Project Workspace',
      dataIndex: 'projectTitle',
      key: 'projectTitle',
      width: 280,
      render: (value: string, row) => (
        <Space direction="vertical" size={0}>
          <Space>
            <ProjectOutlined />
            <Text strong>{value}</Text>
          </Space>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Project ID: {row.projectId}
          </Text>
        </Space>
      ),
    },
    {
      title: 'Team',
      dataIndex: 'teamName',
      key: 'teamName',
      width: 200,
      render: (teamName: string, row) => {
        const name = teamName || '‚Äî';
        const idLabel = row.teamId || '‚Äî';
        return (
          <Space direction="vertical" size={0}>
            <Space>
              <TeamOutlined />
              <Text>{name}</Text>
            </Space>
            <Text type="secondary" style={{ fontSize: 12 }}>
              Team ID: {idLabel}
            </Text>
          </Space>
        );
      },
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      width: 120,
      render: (status: string) => (
        <Tag color={getStatusTagColor(status)}>{status}</Tag>
      ),
    },
    {
      title: 'Your role',
      dataIndex: 'userRole',
      key: 'userRole',
      width: 140,
      render: (role: string) => <Tag>{role || 'Member'}</Tag>,
    },
    {
      title: 'Members',
      key: 'members',
      width: 130,
      render: (_: unknown, row) => {
        const totalMembers = row.totalMembers ?? 0;
        const onlineMembers = row.onlineMembers ?? 0;
        return (
          <Tooltip title="Online / total members in this workspace">
            <Text>
              {onlineMembers}/{totalMembers} online
            </Text>
          </Tooltip>
        );
      },
    },
    {
      title: 'Linked learning',
      key: 'linked',
      width: 180,
      render: (_: unknown, row) => (
        <Space direction="vertical" size={2}>
          <Text style={{ fontSize: 12 }}>
            Knowledge items:{' '}
            <Text strong>{row.linkedKnowledgeCount ?? 0}</Text>
          </Text>
          <Text style={{ fontSize: 12 }}>
            Certifications:{' '}
            <Text strong>{row.linkedCertificationsCount ?? 0}</Text>
          </Text>
        </Space>
      ),
    },
    {
      title: 'Last activity',
      dataIndex: 'lastActivityAt',
      key: 'lastActivityAt',
      width: 160,
      render: (value?: string | null) => (
        <Text style={{ fontSize: 12 }}>{formatLastActivity(value)}</Text>
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      fixed: 'right',
      width: 210,
      render: (_: unknown, row) => {
        const primaryDisabled = row.canEnter === false;
        const primaryLabel =
          row.isWorkspaceLaunched && !primaryDisabled
            ? 'Open workspace'
            : row.isWorkspaceLaunched && primaryDisabled
              ? 'View only'
              : 'Launch workspace';

        const items: MenuProps['items'] = [
          {
            key: 'view-team',
            label: 'View team',
            onClick: () => goToTeam(row),
          },
          {
            key: 'archive',
            disabled: !row.canArchive,
            label: row.canArchive ? (
              <span>Archive workspace</span>
            ) : (
              <span style={{ opacity: 0.65 }}>Archive (no permission)</span>
            ),
            onClick: () => handleArchiveWorkspace(row),
          },
        ];

        return (
          <Space>
            <Button
              type="primary"
              size="small"
              disabled={primaryDisabled}
              icon={<ArrowRightOutlined />}
              onClick={() => goToWorkspace(row)}
            >
              {primaryLabel}
            </Button>

            <Dropdown
              menu={{ items }}
              trigger={['click']}
              placement="bottomRight"
            >
              <Button size="small" icon={<DownOutlined />}>
                More
              </Button>
            </Dropdown>
          </Space>
        );
      },
    },
  ];

  // --- Render -----------------------------------------------------------------

  const hasData = filteredRows.length > 0;

  return (
    <KonnectedPageShell
      title="Project Workspaces"
      subtitle={
        <span>
          Bridge your keenKonnect project workspaces with KonnectED learning
          activities for each team.
        </span>
      }
      primaryAction={
        <Button
          type="primary"
          onClick={() =>
            router.push('/keenkonnect/projects/create-new-project')
          }
        >
          Start a new project
        </Button>
      }
      secondaryActions={
        <Button
          onClick={() =>
            router.push('/konnected/teams-collaboration/my-teams')
          }
        >
          Manage teams
        </Button>
      }
    >
      {contextHolder}

      {/* Top KPIs */}
      <Row gutter={[16, 16]} style={{ marginBottom: 16 }}>
        <Col xs={24} sm={8}>
          <Card>
            <Statistic
              title="Total project workspaces"
              value={total}
              suffix="linked"
            />
          </Card>
        </Col>
        <Col xs={24} sm={8}>
          <Card>
            <Statistic
              title="Active workspaces"
              value={totalActive}
              valueStyle={{ color: '#52c41a' }}
            />
          </Card>
        </Col>
        <Col xs={24} sm={8}>
          <Card>
            <Statistic title="Workspaces you own" value={totalOwned} />
          </Card>
        </Col>
      </Row>

      {/* Filters */}
      <Card style={{ marginBottom: 16 }}>
        <Row gutter={[16, 16]} align="middle">
          <Col xs={24} md={10}>
            <Search
              placeholder="Search by project or team"
              allowClear
              onSearch={(value) => setSearchText(value)}
              onChange={(e) => setSearchText(e.target.value)}
            />
          </Col>

          <Col xs={24} sm={8} md={4}>
            <Text type="secondary" style={{ display: 'block', marginBottom: 4 }}>
              Status
            </Text>
            <Select<StatusFilterValue>
              value={statusFilter}
              onChange={(value) => setStatusFilter(value)}
              style={{ width: '100%' }}
            >
              <Option value="all">All statuses</Option>
              <Option value="active">Active</Option>
              <Option value="planning">Planning</Option>
              <Option value="completed">Completed</Option>
              <Option value="archived">Archived</Option>
            </Select>
          </Col>

          <Col xs={24} sm={8} md={4}>
            <Text type="secondary" style={{ display: 'block', marginBottom: 4 }}>
              Ownership
            </Text>
            <Select<OwnershipFilterValue>
              value={ownershipFilter}
              onChange={(value) => setOwnershipFilter(value)}
              style={{ width: '100%' }}
            >
              <Option value="all">All memberships</Option>
              <Option value="owner">Owned by me</Option>
              <Option value="member">Where I collaborate</Option>
            </Select>
          </Col>

          <Col xs={24} sm={8} md={6}>
            <Text type="secondary" style={{ display: 'block', marginBottom: 4 }}>
              Team
            </Text>
            <Select<string | 'all'>
              value={teamFilter}
              onChange={(value) => setTeamFilter(value)}
              style={{ width: '100%' }}
              allowClear={false}
            >
              <Option value="all">All teams</Option>
              {teamOptions.map((team) => (
                <Option key={team} value={team}>
                  {team}
                </Option>
              ))}
            </Select>
          </Col>
        </Row>
      </Card>

      {/* Table */}
      <Card>
        {loading ? (
          <div style={{ padding: 32, textAlign: 'center' }}>
            <Spin />
          </div>
        ) : (
          <Table<ProjectWorkspaceRow>
            rowKey={(row) => row.id}
            columns={columns}
            dataSource={filteredRows}
            size="middle"
            bordered
            scroll={{ x: 1000 }}
            pagination={{
              pageSize: 10,
              showSizeChanger: false,
            }}
            locale={{
              emptyText: hasData ? (
                <Empty description="No workspaces match the current filters." />
              ) : (
                <Empty description="No project workspaces linked to your teams yet." />
              ),
            }}
          />
        )}
      </Card>
    </KonnectedPageShell>
  );
}

===== END app/konnected/teams-collaboration/project-workspaces/page.tsx =====


===== BEGIN app/konnected/teams-collaboration/team-builder/page.tsx =====
// app/konnected/teams-collaboration/team-builder/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Card,
  Table,
  Tag,
  Space,
  Button,
  Typography,
  message as antdMessage,
  Form,
  Input,
  Select,
  Switch,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import {
  UserOutlined,
  UserAddOutlined,
  MailOutlined,
  TeamOutlined,
  ExclamationCircleOutlined,
} from '@ant-design/icons';
import {
  StepsForm,
  ProFormText,
  ProFormTextArea,
  ProFormSwitch,
} from '@ant-design/pro-components';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Paragraph, Text } = Typography;
const { Option } = Select;

/**
 * Domain types
 */
type TeamRole = 'leader' | 'coordinator' | 'member';

interface TeamInfo {
  name: string;
  description?: string;
  isOpenJoin?: boolean;
}

interface TeamMember {
  key: string;
  email: string;
  role: TeamRole;
  responsibilityArea?: string;
}

/**
 * API payloads (front-end representation)
 * You will likely need to align these with your real OpenAPI / backend models.
 */
interface CreateTeamPayload {
  name: string;
  description?: string;
  isOpenJoin?: boolean;
  members: {
    email: string;
    role: TeamRole;
    responsibilityArea?: string;
  }[];
}

interface CreateTeamResponse {
  id: string;
  slug?: string;
}

/**
 * Helpers
 */
const normalizeEmail = (value: string): string => value.trim().toLowerCase();

const TEAM_ROLE_LABEL: Record<TeamRole, string> = {
  leader: 'Team leader',
  coordinator: 'Coordinator',
  member: 'Member',
};

/**
 * API call (isolate endpoint here to make it easy to wire to your real backend).
 *
 * TODO: adjust URL & shape to your real OpenAPI (schema-endpoints).
 * For example, this might be:
 *   POST /api/konnected/teams
 *   or POST /api/project-teams
 */
async function createTeamApi(payload: CreateTeamPayload): Promise<CreateTeamResponse> {
  const response = await fetch('/api/konnected/teams', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });

  if (response.status === 403) {
    throw new Error('PERMISSION_DENIED');
  }

  if (!response.ok) {
    // Try to surface backend validation errors if possible
    let details: unknown;
    try {
      details = await response.json();
    } catch {
      // ignore
    }
    const error = new Error('SERVER_ERROR');
    (error as any).details = details;
    throw error;
  }

  return (await response.json()) as CreateTeamResponse;
}

/**
 * Members table columns
 */
const useMemberColumns = (
  onRemove: (key: string) => void,
): ColumnsType<TeamMember> => [
  {
    title: 'Member',
    dataIndex: 'email',
    key: 'email',
    render: (email: string) => (
      <Space>
        <MailOutlined />
        <span>{email}</span>
      </Space>
    ),
  },
  {
    title: 'Role',
    dataIndex: 'role',
    key: 'role',
    render: (role: TeamRole) => {
      const color =
        role === 'leader' ? 'gold' : role === 'coordinator' ? 'processing' : 'default';
      return <Tag color={color}>{TEAM_ROLE_LABEL[role]}</Tag>;
    },
  },
  {
    title: 'Responsibility area',
    dataIndex: 'responsibilityArea',
    key: 'responsibilityArea',
    ellipsis: true,
    render: (value?: string) => value || <Text type="secondary">Not specified</Text>,
  },
  {
    title: 'Actions',
    key: 'actions',
    width: 120,
    render: (_: unknown, record: TeamMember) => (
      <Button danger size="small" onClick={() => onRemove(record.key)}>
        Remove
      </Button>
    ),
  },
];

export default function TeamBuilderPage(): JSX.Element {
  const router = useRouter();

  /**
   * Step 1 ‚Äì team info
   */
  const [teamInfo, setTeamInfo] = useState<TeamInfo | null>(null);

  /**
   * Step 2 ‚Äì members
   */
  const [members, setMembers] = useState<TeamMember[]>([]);

  // Draft row for the ‚Äúadd member‚Äù mini-form
  const [memberForm] = Form.useForm<{
    email: string;
    role: TeamRole;
    responsibilityArea?: string;
  }>();

  /**
   * Submitting / global loading
   */
  const [submitting, setSubmitting] = useState(false);

  /**
   * Derived data
   */
  const isValidForSubmit = useMemo(() => {
    return Boolean(teamInfo && teamInfo.name && members.length > 0);
  }, [teamInfo, members]);

  const handleAddMember = async () => {
    try {
      const values = await memberForm.validateFields();
      const email = normalizeEmail(values.email);

      if (members.some((m) => m.email === email)) {
        antdMessage.warning('This email is already in the team.');
        return;
      }

      const newMember: TeamMember = {
        key: `${Date.now()}-${email}`,
        email,
        role: values.role,
        responsibilityArea: values.responsibilityArea?.trim() || undefined,
      };

      setMembers((prev) => [...prev, newMember]);
      memberForm.resetFields();
    } catch {
      // Validation error, do nothing (ProForm already shows messages)
    }
  };

  const handleRemoveMember = (key: string) => {
    setMembers((prev) => prev.filter((m) => m.key !== key));
  };

  const memberColumns = useMemberColumns(handleRemoveMember);

  /**
   * Global submit ‚Äì called when last step is submitted.
   */
  const handleFinish = async (): Promise<boolean> => {
    if (!teamInfo) {
      antdMessage.error('Please complete team information first.');
      return false;
    }
    if (!members.length) {
      antdMessage.error('Please add at least one member to the team.');
      return false;
    }

    const payload: CreateTeamPayload = {
      name: teamInfo.name.trim(),
      description: teamInfo.description?.trim() || undefined,
      isOpenJoin: teamInfo.isOpenJoin ?? false,
      members: members.map((member) => ({
        email: member.email,
        role: member.role,
        responsibilityArea: member.responsibilityArea,
      })),
    };

    try {
      setSubmitting(true);
      const created = await createTeamApi(payload);
      antdMessage.success('Team created successfully.');
      // Redirect to ‚ÄúMy teams‚Äù or to the created team if you have a slug
      if (created.slug) {
        router.push(`/konnected/teams-collaboration/my-teams/${created.slug}`);
      } else {
        router.push('/konnected/teams-collaboration/my-teams');
      }
      return true;
    } catch (err) {
      const error = err as Error & { details?: any };
      if (error.message === 'PERMISSION_DENIED') {
        antdMessage.error(
          'You do not have permission to create teams. Please contact an administrator.',
        );
      } else if (error.details?.code === 'TEAM_NAME_ALREADY_EXISTS') {
        antdMessage.error('A team with this name already exists. Please pick another name.');
      } else {
        antdMessage.error('Could not create the team. Please try again or contact support.');
      }
      return false;
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <KonnectedPageShell
      title="Team Builder"
      subtitle={
        <span>
          Configure a collaboration-ready team for KonnectED: define the team, assign roles, and
          confirm membership before you start collaborating.
        </span>
      }
      primaryAction={
        <Button
          type="primary"
          icon={<TeamOutlined />}
          disabled={!isValidForSubmit || submitting}
          onClick={handleFinish}
        >
          Create team
        </Button>
      }
      secondaryActions={
        <Text type="secondary">
          <UserOutlined /> You will be automatically added as a member.
        </Text>
      }
    >
      <Card>
        <StepsForm
          onFinish={handleFinish}
          formProps={{ layout: 'vertical' }}
          submitter={{
            submitButtonProps: {
              loading: submitting,
            },
            searchConfig: {
              submitText: 'Create team',
            },
          }}
        >
          {/* Step 1 ‚Äì Team information */}
          <StepsForm.StepForm<TeamInfo>
            name="teamInfo"
            title="Team details"
            onFinish={async (values) => {
              const trimmedName = values.name?.trim();
              if (!trimmedName) {
                antdMessage.error('Team name is required.');
                return false;
              }
              setTeamInfo({
                name: trimmedName,
                description: values.description?.trim() || undefined,
                isOpenJoin: values.isOpenJoin ?? false,
              });
              return true;
            }}
          >
            <Paragraph type="secondary" style={{ marginBottom: 16 }}>
              Give your team a clear identity and choose whether new members can request to join.
            </Paragraph>

            <ProFormText
              name="name"
              label="Team name"
              placeholder="e.g. Robotics Innovation Squad"
              rules={[
                { required: true, message: 'Please enter a team name.' },
                { min: 3, message: 'Name should be at least 3 characters long.' },
              ]}
              fieldProps={{
                maxLength: 120,
                showCount: true,
              }}
            />

            <ProFormTextArea
              name="description"
              label="Team description"
              placeholder="Briefly describe the team‚Äôs purpose, focus areas, and who should join."
              fieldProps={{
                rows: 4,
                maxLength: 500,
                showCount: true,
              }}
            />

            <ProFormSwitch
              name="isOpenJoin"
              label="Allow join requests"
              tooltip="If enabled, learners can send join requests which team leaders can approve."
            />
          </StepsForm.StepForm>

          {/* Step 2 ‚Äì Members & roles */}
          <StepsForm.StepForm
            name="members"
            title="Members & roles"
            onFinish={async () => {
              if (!members.length) {
                antdMessage.error('Add at least one member to continue.');
                return false;
              }
              return true;
            }}
          >
            <Paragraph type="secondary" style={{ marginBottom: 16 }}>
              Add core team members now. You can invite more people later from ‚ÄúMy teams‚Äù.
            </Paragraph>

            {/* Add-member mini-form */}
            <Card
              size="small"
              style={{ marginBottom: 24 }}
              title={
                <Space>
                  <UserAddOutlined />
                  <span>Add member</span>
                </Space>
              }
            >
              <Form
                form={memberForm}
                layout="vertical"
                initialValues={{
                  role: 'member' as TeamRole,
                }}
              >
                <Form.Item
                  label="Email"
                  name="email"
                  rules={[
                    { required: true, message: 'Please enter an email address.' },
                    { type: 'email', message: 'Please enter a valid email address.' },
                  ]}
                >
                  <Input
                    prefix={<MailOutlined />}
                    placeholder="member@example.org"
                    autoComplete="off"
                  />
                </Form.Item>

                <Form.Item label="Role" name="role" rules={[{ required: true }]}>
                  <Select>
                    <Option value="leader">Team leader</Option>
                    <Option value="coordinator">Coordinator</Option>
                    <Option value="member">Member</Option>
                  </Select>
                </Form.Item>

                <Form.Item label="Responsibility area" name="responsibilityArea">
                  <Input placeholder="e.g. Impact tracking, facilitation, content curation" />
                </Form.Item>

                <Form.Item>
                  <Space>
                    <Button type="primary" onClick={handleAddMember}>
                      Add to team
                    </Button>
                    <Text type="secondary">
                      You can adjust roles later from ‚ÄúMy teams‚Äù.
                    </Text>
                  </Space>
                </Form.Item>
              </Form>
            </Card>

            {/* Members table */}
            <Table<TeamMember>
              rowKey="key"
              size="middle"
              bordered
              columns={memberColumns}
              dataSource={members}
              pagination={false}
              locale={{
                emptyText: 'No members added yet.',
              }}
            />
          </StepsForm.StepForm>

          {/* Step 3 ‚Äì Review & confirm */}
          <StepsForm.StepForm name="review" title="Review & confirm">
            <Paragraph style={{ marginBottom: 16 }}>
              Review your team configuration before creating it. You can still adjust details later
              in ‚ÄúMy teams‚Äù.
            </Paragraph>

            <Card size="small" style={{ marginBottom: 24 }} title="Team summary">
              {teamInfo ? (
                <>
                  <Paragraph>
                    <Text strong>Name:</Text> {teamInfo.name}
                  </Paragraph>
                  <Paragraph>
                    <Text strong>Description:</Text>{' '}
                    {teamInfo.description || <Text type="secondary">Not provided</Text>}
                  </Paragraph>
                  <Paragraph>
                    <Text strong>Join policy:</Text>{' '}
                    {teamInfo.isOpenJoin ? (
                      <Tag color="success">Requests allowed</Tag>
                    ) : (
                      <Tag>Invite-only</Tag>
                    )}
                  </Paragraph>
                </>
              ) : (
                <Paragraph type="secondary">
                  Team information is incomplete. Go back to the first step to fill it in.
                </Paragraph>
              )}
            </Card>

            <Card
              size="small"
              style={{ marginBottom: 24 }}
              title={`Members (${members.length})`}
            >
              {members.length ? (
                <Table<TeamMember>
                  rowKey="key"
                  size="small"
                  bordered
                  columns={memberColumns}
                  dataSource={members}
                  pagination={false}
                />
              ) : (
                <Paragraph type="secondary">No members added yet.</Paragraph>
              )}
            </Card>

            <Card
              size="small"
              type="inner"
              title={
                <Space>
                  <ExclamationCircleOutlined />
                  <span>Before you create the team</span>
                </Space>
              }
            >
              <ul className="list-disc pl-5">
                <li>You will be added as a member of the team automatically.</li>
                <li>
                  Team leaders can manage roles, approve join requests (if enabled), and archive
                  the team.
                </li>
                <li>
                  You can always modify membership later from{' '}
                  <Text strong>Teams Collaboration ‚Üí My teams</Text>.
                </li>
              </ul>
            </Card>
          </StepsForm.StepForm>
        </StepsForm>
      </Card>
    </KonnectedPageShell>
  );
}

===== END app/konnected/teams-collaboration/team-builder/page.tsx =====


===== BEGIN app/konsensus/page.tsx =====
// app/konsensus/page.tsx
import { Suspense } from 'react';
import MainLayout from '@/components/layout-components/MainLayout';
import { PollPage } from '@/modules/konsensus/pages';

/**
 * /konsensus ‚Äì Konsensus Center entry route.
 * Wraps the Konsensus poll page in the global MainLayout and
 * provides a Suspense boundary for hooks like useSearchParams.
 */
export default function KonsensusPage() {
  return (
    <Suspense fallback={null}>
      <MainLayout>
        <PollPage />
      </MainLayout>
    </Suspense>
  );
}

===== END app/konsensus/page.tsx =====


===== BEGIN app/kreative/collaborative-spaces/find-spaces/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import {
  Row,
  Col,
  Card,
  Input,
  Select,
  Button,
  Modal,
  Pagination,
  Space,
  Typography,
  message as antdMessage,
} from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Text } = Typography;
const { Option } = Select;

type Discipline = 'Art' | 'Music' | 'Writing' | 'Technology' | 'Other';
type JoinType = 'open' | 'invite-only';
type DisciplineFilter = Discipline | 'All';
type JoinTypeFilter = JoinType | 'All';

interface CollaborativeSpace {
  id: string;
  name: string;
  description: string;
  discipline: Discipline;
  memberCount: number;
  joinType: JoinType;
  createdAt: string; // ISO date
}

// Demo data
const dummySpaces: CollaborativeSpace[] = [
  {
    id: '1',
    name: 'Urban Art Collective',
    description: 'A community for street artists and mural enthusiasts.',
    discipline: 'Art',
    memberCount: 35,
    joinType: 'open',
    createdAt: '2025-11-15T10:00:00Z',
  },
  {
    id: '2',
    name: 'Indie Music Makers',
    description: 'Join to collaborate on original music projects and recordings.',
    discipline: 'Music',
    memberCount: 50,
    joinType: 'invite-only',
    createdAt: '2025-11-20T14:30:00Z',
  },
  {
    id: '3',
    name: 'Writers‚Äô Lounge',
    description:
      'A space for writers to share ideas, get feedback, and find collaborators.',
    discipline: 'Writing',
    memberCount: 25,
    joinType: 'open',
    createdAt: '2025-11-18T09:15:00Z',
  },
  {
    id: '4',
    name: 'Tech & Art Fusion',
    description:
      'Where creativity meets innovation: join us to build interactive art installations.',
    discipline: 'Technology',
    memberCount: 18,
    joinType: 'invite-only',
    createdAt: '2025-11-22T11:45:00Z',
  },
];

export default function FindSpacesPage(): JSX.Element {
  const router = useRouter();

  // Filters, tri, pagination
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedDiscipline, setSelectedDiscipline] =
    useState<DisciplineFilter>('All');
  const [selectedJoinType, setSelectedJoinType] =
    useState<JoinTypeFilter>('All');
  const [sortOption, setSortOption] =
    useState<'mostActive' | 'newest'>('mostActive');
  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 4;

  // Modal d‚Äôinvitation
  const [joinModalVisible, setJoinModalVisible] = useState(false);
  const [selectedSpace, setSelectedSpace] = useState<CollaborativeSpace | null>(
    null,
  );

  // Filtre + tri
  const filteredSpaces = useMemo(() => {
    let spaces = dummySpaces;

    if (selectedDiscipline !== 'All') {
      spaces = spaces.filter((s) => s.discipline === selectedDiscipline);
    }
    if (selectedJoinType !== 'All') {
      spaces = spaces.filter((s) => s.joinType === selectedJoinType);
    }
    if (searchQuery.trim() !== '') {
      const q = searchQuery.toLowerCase();
      spaces = spaces.filter(
        (s) =>
          s.name.toLowerCase().includes(q) ||
          s.description.toLowerCase().includes(q),
      );
    }

    if (sortOption === 'newest') {
      // copie pour √©viter la mutation
      return [...spaces].sort(
        (a, b) =>
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
      );
    }
    // proxy d‚Äôactivit√© = memberCount
    return [...spaces].sort((a, b) => b.memberCount - a.memberCount);
  }, [searchQuery, selectedDiscipline, selectedJoinType, sortOption]);

  // Pagination
  const paginatedSpaces = useMemo(() => {
    const start = (currentPage - 1) * pageSize;
    return filteredSpaces.slice(start, start + pageSize);
  }, [filteredSpaces, currentPage]);

  // Actions
  function handleJoin(space: CollaborativeSpace) {
    if (space.joinType === 'open') {
      antdMessage.success(`You have joined "${space.name}"!`);
      router.push(`/kreative/collaborative-spaces/${space.id}`);
      return;
    }
    setSelectedSpace(space);
    setJoinModalVisible(true);
  }

  function confirmJoinRequest() {
    if (selectedSpace) {
      antdMessage.success(
        `Your request to join "${selectedSpace.name}" has been sent.`,
      );
    }
    setJoinModalVisible(false);
    setSelectedSpace(null);
  }

  return (
    <PageContainer title="Find Spaces">
      <Space direction="vertical" style={{ width: '100%', marginBottom: 24 }} size="large">
        <Space wrap>
          <Input
            placeholder="Search spaces..."
            prefix={<SearchOutlined />}
            value={searchQuery}
            onChange={(e) => {
              setSearchQuery(e.target.value);
              setCurrentPage(1);
            }}
            style={{ width: 300 }}
          />

          <Select
            value={selectedDiscipline}
            onChange={(v) => {
              setSelectedDiscipline(v as DisciplineFilter);
              setCurrentPage(1);
            }}
            style={{ width: 180 }}
          >
            <Option value="All">All Disciplines</Option>
            <Option value="Art">Art</Option>
            <Option value="Music">Music</Option>
            <Option value="Writing">Writing</Option>
            <Option value="Technology">Technology</Option>
            <Option value="Other">Other</Option>
          </Select>

          <Select
            value={selectedJoinType}
            onChange={(v) => {
              setSelectedJoinType(v as JoinTypeFilter);
              setCurrentPage(1);
            }}
            style={{ width: 180 }}
          >
            <Option value="All">All Join Types</Option>
            <Option value="open">Open</Option>
            <Option value="invite-only">Invite-Only</Option>
          </Select>

          <Select
            value={sortOption}
            onChange={(v) => {
              setSortOption(v as 'mostActive' | 'newest');
              setCurrentPage(1);
            }}
            style={{ width: 180 }}
          >
            <Option value="mostActive">Most Active</Option>
            <Option value="newest">Newest</Option>
          </Select>
        </Space>
      </Space>

      <Row gutter={[24, 24]}>
        {paginatedSpaces.map((space) => (
          <Col key={space.id} xs={24} sm={12} md={8}>
            <Card
              hoverable
              title={space.name}
              extra={<Text type="secondary">{space.memberCount} Members</Text>}
              actions={[
                <Button
                  key="join"
                  type="primary"
                  onClick={(e) => {
                    e.stopPropagation();
                    handleJoin(space);
                  }}
                >
                  {space.joinType === 'open' ? 'Join' : 'Request to Join'}
                </Button>,
              ]}
              onClick={() =>
                router.push(`/kreative/collaborative-spaces/${space.id}`)
              }
            >
              <Card.Meta description={<Text>{space.description}</Text>} />
              <div style={{ marginTop: 12 }}>
                <Text strong>Discipline:</Text> <Text>{space.discipline}</Text>
                <br />
                <Text strong>Status:</Text>{' '}
                <Text>{space.joinType === 'open' ? 'Open' : 'Invite-Only'}</Text>
              </div>
            </Card>
          </Col>
        ))}
      </Row>

      <div style={{ textAlign: 'center', marginTop: 24 }}>
        <Pagination
          current={currentPage}
          pageSize={pageSize}
          total={filteredSpaces.length}
          onChange={(page) => setCurrentPage(page)}
        />
      </div>

      <Modal
        title="Request to Join Space"
        open={joinModalVisible}
        onOk={confirmJoinRequest}
        onCancel={() => setJoinModalVisible(false)}
        okText="Send Request"
        cancelText="Cancel"
      >
        {selectedSpace && (
          <p>
            Do you want to send a join request for the space:{' '}
            <strong>{selectedSpace.name}</strong>?
          </p>
        )}
      </Modal>
    </PageContainer>
  );
}

===== END app/kreative/collaborative-spaces/find-spaces/page.tsx =====


===== BEGIN app/kreative/collaborative-spaces/my-spaces/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\collaborative-spaces\my-spaces\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import {
  List,
  Button,
  Input,
  Select,
  Badge,
  Avatar,
  Space,
  Row,
  Col,
  Typography,
  Empty,
} from 'antd';
import { TeamOutlined, PlusOutlined, SearchOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { Title, Text } = Typography;

// Collaborative space model
interface CollaborativeSpace {
  id: string;
  name: string;
  topic: string;
  membersCount: number;
  category: 'Studio' | 'Club' | 'Community';
  unreadCount: number;
}

// Demo data
const dummySpaces: CollaborativeSpace[] = [
  {
    id: '1',
    name: 'Creative Studio Alpha',
    topic: 'Graphic Design & Illustration',
    membersCount: 12,
    category: 'Studio',
    unreadCount: 3,
  },
  {
    id: '2',
    name: 'Music Club Beta',
    topic: 'Indie & Electronic Music',
    membersCount: 20,
    category: 'Club',
    unreadCount: 0,
  },
  {
    id: '3',
    name: 'Writers Community Gamma',
    topic: 'Creative Writing & Storytelling',
    membersCount: 15,
    category: 'Community',
    unreadCount: 5,
  },
];

export default function MySpacesPage(): JSX.Element {
  const router = useRouter();

  const [selectedCategory, setSelectedCategory] = useState<string>('All');
  const [searchQuery, setSearchQuery] = useState<string>('');

  const filteredSpaces = useMemo<CollaborativeSpace[]>(() => {
    let spaces = dummySpaces;

    if (selectedCategory !== 'All') {
      spaces = spaces.filter((s) => s.category === selectedCategory);
    }

    if (searchQuery.trim() !== '') {
      const q = searchQuery.toLowerCase();
      spaces = spaces.filter(
        (s) =>
          s.name.toLowerCase().includes(q) ||
          s.topic.toLowerCase().includes(q),
      );
    }

    return spaces;
  }, [selectedCategory, searchQuery]);

  const enterSpace = (id: string) => {
    router.push(`/kreative/collaborative-spaces/${id}`);
  };

  const hasSpaces = filteredSpaces.length > 0;

  return (
    <KreativePageShell
      title="My Spaces"
      subtitle="Spaces you‚Äôve joined or created across the Kreative collaborative hub."
      primaryAction={
        <Button
          type="primary"
          icon={<PlusOutlined />}
          onClick={() =>
            router.push('/kreative/collaborative-spaces/start-new-space')
          }
        >
          Start a New Space
        </Button>
      }
    >
      <Row
        justify="space-between"
        align="middle"
        style={{ marginBottom: 24 }}
      >
        <Col>
          <Space wrap>
            <Input
              placeholder="Search spaces..."
              prefix={<SearchOutlined />}
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              style={{ width: 300 }}
              allowClear
            />
            <Select
              value={selectedCategory}
              onChange={(value: string) => setSelectedCategory(value)}
              style={{ width: 200 }}
              options={[
                { value: 'All', label: 'All Categories' },
                { value: 'Studio', label: 'Studio' },
                { value: 'Club', label: 'Club' },
                { value: 'Community', label: 'Community' },
              ]}
            />
          </Space>
        </Col>
      </Row>

      {hasSpaces ? (
        <List<CollaborativeSpace>
          itemLayout="horizontal"
          dataSource={filteredSpaces}
          renderItem={(space) => (
            <List.Item
              key={space.id}
              actions={[
                <Button
                  key="enter"
                  type="primary"
                  onClick={() => enterSpace(space.id)}
                >
                  Enter Space
                </Button>,
              ]}
            >
              <List.Item.Meta
                avatar={
                  space.unreadCount > 0 ? (
                    <Badge count={space.unreadCount} offset={[-5, 5]}>
                      <Avatar size="large" icon={<TeamOutlined />} />
                    </Badge>
                  ) : (
                    <Avatar size="large" icon={<TeamOutlined />} />
                  )
                }
                title={
                  <Title level={4} style={{ margin: 0 }}>
                    {space.name}
                  </Title>
                }
                description={
                  <Space direction="vertical" size={0}>
                    <Text strong>Topic:</Text>
                    <Text>{space.topic}</Text>
                    <Text strong>Members:</Text>
                    <Text>{space.membersCount}</Text>
                  </Space>
                }
              />
            </List.Item>
          )}
        />
      ) : (
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description="You‚Äôre not part of any spaces yet. Start a new one or explore available spaces."
        />
      )}
    </KreativePageShell>
  );
}

===== END app/kreative/collaborative-spaces/my-spaces/page.tsx =====


===== BEGIN app/kreative/collaborative-spaces/start-new-space/page.tsx =====
// app/kreative/collaborative-spaces/start-new-space/page.tsx
'use client';

import React, { useState } from 'react';
import {
  Form,
  Input,
  Select,
  Radio,
  Button,
  Upload,
  Space,
  Typography,
  message as antdMessage,
} from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import { UploadOutlined, PlusOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { TextArea } = Input;
const { Option } = Select;
const { Paragraph } = Typography;

type PrivacyOption = 'Public' | 'Private';

interface InvitedMemberField {
  email: string;
}

interface StartNewSpaceFormValues {
  name: string;
  description: string;
  category: string;
  privacy: PrivacyOption;
  invitedMembers?: InvitedMemberField[];
  banner?: UploadFile[];
}

// Minimal type for Upload onChange (keeps us away from implicit any)
type UploadChangeParamLite = {
  fileList: UploadFile[];
};

export default function StartNewSpacePage(): JSX.Element {
  const [form] = Form.useForm<StartNewSpaceFormValues>();
  const router = useRouter();
  const [fileList, setFileList] = useState<UploadFile[]>([]);

  const handleFileChange = (info: UploadChangeParamLite) => {
    setFileList(info.fileList);
  };

  const onFinish = (values: StartNewSpaceFormValues) => {
    const spaceData = {
      ...values,
      banner: fileList,
    };

    // TODO: replace with real API call
    // await api.createSpace(spaceData)

    // eslint-disable-next-line no-console
    console.log('New Space Data:', spaceData);
    antdMessage.success('Your new space has been created successfully!');
    router.push('/kreative/collaborative-spaces/my-spaces');
  };

  return (
    <PageContainer title="Start a New Space">
      <Paragraph type="secondary" style={{ marginBottom: 24 }}>
        Define your collaborative space so others can discover and join the right context.
      </Paragraph>

      <Form<StartNewSpaceFormValues>
        form={form}
        layout="vertical"
        onFinish={onFinish}
        initialValues={{ privacy: 'Public', category: 'Art Study Group' }}
      >
        {/* Space Name */}
        <Form.Item
          label="Space Name"
          name="name"
          rules={[{ required: true, message: 'Please enter a space name.' }]}
        >
          <Input placeholder="Enter the name of your space" />
        </Form.Item>

        {/* Description / Purpose */}
        <Form.Item
          label="Description / Purpose"
          name="description"
          rules={[{ required: true, message: 'Please provide a description for your space.' }]}
        >
          <TextArea rows={5} placeholder="Describe the purpose and vision of your space" />
        </Form.Item>

        {/* Category / Type */}
        <Form.Item
          label="Category / Type"
          name="category"
          rules={[{ required: true, message: 'Please select a category.' }]}
        >
          <Select placeholder="Select a category">
            <Option value="Art Study Group">Art Study Group</Option>
            <Option value="Music Jam Session">Music Jam Session</Option>
            <Option value="Creative Writing Circle">Creative Writing Circle</Option>
            <Option value="Digital Innovation Hub">Digital Innovation Hub</Option>
          </Select>
        </Form.Item>

        {/* Privacy Setting */}
        <Form.Item
          label="Privacy Setting"
          name="privacy"
          rules={[{ required: true, message: 'Please choose a privacy setting.' }]}
        >
          <Radio.Group>
            <Radio value="Public">Public (Anyone can join)</Radio>
            <Radio value="Private">Private (Invite Only)</Radio>
          </Radio.Group>
        </Form.Item>

        {/* Invite Initial Members (only when Private) */}
        <Form.Item shouldUpdate={(prev, cur) => prev.privacy !== cur.privacy}>
          {({ getFieldValue }) =>
            getFieldValue('privacy') === 'Private' ? (
              <Form.List name="invitedMembers">
                {(fields, { add, remove }) => (
                  <>
                    <Space direction="vertical" style={{ width: '100%' }}>
                      {fields.map((field) => (
                        <Space key={field.key} align="baseline">
                          <Form.Item
                            {...field}
                            name={[field.name, 'email']}
                            rules={[
                              { required: true, message: 'Please enter an email address.' },
                              { type: 'email', message: 'Please enter a valid email address.' },
                            ]}
                          >
                            <Input placeholder="Enter member email" />
                          </Form.Item>
                          <Button type="link" onClick={() => remove(field.name)}>
                            Remove
                          </Button>
                        </Space>
                      ))}
                      <Form.Item>
                        <Button type="dashed" onClick={() => add()} icon={<PlusOutlined />}>
                          Invite Member
                        </Button>
                      </Form.Item>
                    </Space>
                  </>
                )}
              </Form.List>
            ) : null
          }
        </Form.Item>

        {/* Space Banner or Icon Upload */}
        <Form.Item label="Space Icon / Banner Image" name="banner">
          <Upload
            beforeUpload={() => false} // prevent auto-upload
            fileList={fileList}
            onChange={handleFileChange}
            accept="image/*"
          >
            <Button icon={<UploadOutlined />}>Upload Image</Button>
          </Upload>
        </Form.Item>

        {/* Submit Button */}
        <Form.Item>
          <Button type="primary" htmlType="submit">
            Create Space
          </Button>
        </Form.Item>
      </Form>
    </PageContainer>
  );
}

===== END app/kreative/collaborative-spaces/start-new-space/page.tsx =====


===== BEGIN app/kreative/community-showcases/featured-projects/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\featured-projects\page.tsx
'use client';

import React, { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import {
  Card,
  Row,
  Col,
  Input,
  Select,
  Modal,
  Pagination,
  Typography,
  Badge,
  Space,
  Button,
} from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import PageContainer from '@/components/PageContainer';

const { Title, Text, Paragraph } = Typography;

interface Project {
  id: string;
  title: string;
  description: string;
  creator: string;
  coverImage: string;
  category: string;
}

const dummyProjects: Project[] = [
  {
    id: '1',
    title: 'Project Sunrise',
    description:
      'An inspiring project that captures the beauty of dawn with innovative photo techniques and a vivid color palette.',
    creator: 'Alice Johnson',
    coverImage: 'https://via.placeholder.com/400x300.png?text=Project+Sunrise',
    category: 'Photography',
  },
  {
    id: '2',
    title: 'Digital Dreamscape',
    description:
      'A surreal digital art piece combining abstract concepts with vibrant colors to evoke emotion.',
    creator: 'Bob Smith',
    coverImage: 'https://via.placeholder.com/400x300.png?text=Digital+Dreamscape',
    category: 'Digital Art',
  },
  {
    id: '3',
    title: 'Urban Poetry',
    description:
      'A mixed-media project blending urban photography with spoken word performance, reimagining cityscapes in a poetic light.',
    creator: 'Carol Lee',
    coverImage: 'https://via.placeholder.com/400x300.png?text=Urban+Poetry',
    category: 'Mixed Media',
  },
  {
    id: '4',
    title: 'Vintage Revival',
    description:
      'A creative reinterpretation of vintage art styles merged with modern design sensibilities.',
    creator: 'David Kim',
    coverImage: 'https://via.placeholder.com/400x300.png?text=Vintage+Revival',
    category: 'Painting',
  },
];

export default function FeaturedProjectsPage(): JSX.Element {
  const router = useRouter();

  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedCategory, setSelectedCategory] = useState<string>('All');
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [selectedProject, setSelectedProject] = useState<Project | null>(null);

  // Pagination
  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 4;

  // Filters
  const filteredProjects = useMemo(() => {
    let projects = dummyProjects;
    if (selectedCategory !== 'All') {
      projects = projects.filter((project) => project.category === selectedCategory);
    }
    if (searchQuery.trim() !== '') {
      const q = searchQuery.toLowerCase();
      projects = projects.filter(
        (project) =>
          project.title.toLowerCase().includes(q) ||
          project.description.toLowerCase().includes(q),
      );
    }
    return projects;
  }, [searchQuery, selectedCategory]);

  const paginatedProjects = useMemo(() => {
    const start = (currentPage - 1) * pageSize;
    return filteredProjects.slice(start, start + pageSize);
  }, [filteredProjects, currentPage]);

  const openModal = (project: Project) => {
    setSelectedProject(project);
    setModalVisible(true);
  };

  const closeModal = () => {
    setModalVisible(false);
    setSelectedProject(null);
  };

  return (
    <PageContainer title="Featured Projects">
      {/* Filters */}
      <Space wrap style={{ marginBottom: 24 }}>
        <Input
          placeholder="Search projects."
          prefix={<SearchOutlined />}
          value={searchQuery}
          onChange={(e) => {
            setSearchQuery(e.target.value);
            setCurrentPage(1);
          }}
          style={{ width: 300 }}
        />

        <Select
          value={selectedCategory}
          onChange={(value) => {
            setSelectedCategory(value);
            setCurrentPage(1);
          }}
          style={{ width: 220 }}
          options={[
            { value: 'All', label: 'All Categories' },
            { value: 'Photography', label: 'Photography' },
            { value: 'Digital Art', label: 'Digital Art' },
            { value: 'Mixed Media', label: 'Mixed Media' },
            { value: 'Painting', label: 'Painting' },
          ]}
        />
      </Space>

      {/* Grid */}
      <Row gutter={[24, 24]}>
        {paginatedProjects.map((project) => (
          <Col key={project.id} xs={24} sm={12} md={8} lg={6}>
            <Badge.Ribbon text="Featured" color="red">
              <Card
                hoverable
                cover={
                  <img
                    alt={project.title}
                    src={project.coverImage}
                    style={{ height: 200, objectFit: 'cover' }}
                  />
                }
                onClick={() => openModal(project)}
              >
                <Card.Meta
                  title={project.title}
                  description={
                    <>
                      <Paragraph className="line-clamp-2" style={{ marginBottom: 8 }}>
                        {project.description}
                      </Paragraph>
                      <Text type="secondary">By {project.creator}</Text>
                    </>
                  }
                />
              </Card>
            </Badge.Ribbon>
          </Col>
        ))}
      </Row>

      {/* Pagination */}
      <div style={{ textAlign: 'center', marginTop: 24 }}>
        <Pagination
          current={currentPage}
          pageSize={pageSize}
          total={filteredProjects.length}
          onChange={(page) => setCurrentPage(page)}
        />
      </div>

      {/* Modal */}
      <Modal open={modalVisible} onCancel={closeModal} footer={null} width={800}>
        {selectedProject && (
          <div>
            <img
              alt={selectedProject.title}
              src={selectedProject.coverImage}
              style={{ width: '100%', maxHeight: 400, objectFit: 'cover' }}
            />
            <div style={{ marginTop: 16 }}>
              <Title level={3}>{selectedProject.title}</Title>
              <Text type="secondary">By {selectedProject.creator}</Text>
              <p style={{ marginTop: 12 }}>{selectedProject.description}</p>
              <Button
                type="primary"
                onClick={() =>
                  router.push(
                    `/kreative/community-showcases/featured-projects/${selectedProject.id}`,
                  )
                }
              >
                View Details
              </Button>
            </div>
          </div>
        )}
      </Modal>

      {/* simple 2-line clamp */}
      <style jsx>{`
        .line-clamp-2 {
          display: -webkit-box;
          -webkit-line-clamp: 2;
          -webkit-box-orient: vertical;
          overflow: hidden;
        }
      `}</style>
    </PageContainer>
  );
}

===== END app/kreative/community-showcases/featured-projects/page.tsx =====


===== BEGIN app/kreative/community-showcases/submit-to-showcase/page.tsx =====
// File: app/kreative/community-showcases/submit-to-showcase/page.tsx
'use client';

import React, { useState } from 'react';
import { Form, Input, Select, Button, Modal, message as antdMessage } from 'antd';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { TextArea } = Input;

type FormValues = {
  title: string;
  category: string;
  description: string;
  link?: string;
  tags?: string[];
};

export default function SubmitToShowcasePage(): JSX.Element {
  const [form] = Form.useForm<FormValues>();
  const router = useRouter();
  const [submitting, setSubmitting] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);

  const categories = [
    { label: 'Art', value: 'art' },
    { label: 'Design', value: 'design' },
    { label: 'Photography', value: 'photography' },
    { label: 'Music', value: 'music' },
  ];

  const onFinish = async (values: FormValues) => {
    setSubmitting(true);
    try {
      // TODO: plug into backend API when available (e.g. POST /api/showcases)
      // await fetch('/api/showcases', { method: 'POST', body: JSON.stringify(values) });

      antdMessage.success('Submission received');
      setModalVisible(true);
    } catch (e) {
      antdMessage.error("Une erreur est survenue lors de l'envoi.");
    } finally {
      setSubmitting(false);
    }
  };

  const onCancel = () => router.back();

  return (
    <KreativePageShell
      title="Submit to Showcase"
      subtitle="Share a project you‚Äôre proud of with the Kreative community showcase."
    >
      <Form<FormValues>
        form={form}
        layout="vertical"
        onFinish={onFinish}
        name="submitToShowcaseForm"
      >
        <Form.Item
          label="Project title"
          name="title"
          rules={[{ required: true, message: 'Please enter a title' }]}
        >
          <Input placeholder="e.g. Konnaxion Visualizer" allowClear />
        </Form.Item>

        <Form.Item
          label="Category"
          name="category"
          rules={[{ required: true, message: 'Please choose a category' }]}
        >
          <Select
            placeholder="Select a category"
            options={categories}
            showSearch
            filterOption={(input, option) =>
              (option?.label as string)
                .toLowerCase()
                .includes(input.toLowerCase())
            }
          />
        </Form.Item>

        <Form.Item
          label="Description"
          name="description"
          rules={[{ required: true, message: 'Please add a short description' }]}
        >
          <TextArea
            rows={5}
            placeholder="What is this project about?"
            allowClear
          />
        </Form.Item>

        <Form.Item label="Reference link (optional)" name="link">
          <Input placeholder="https://‚Ä¶" allowClear type="url" />
        </Form.Item>

        <Form.Item label="Tags (optional)" name="tags">
          <Select
            mode="tags"
            placeholder="Add tags"
            tokenSeparators={[',']}
            options={[]}
          />
        </Form.Item>

        <Form.Item style={{ marginTop: 16 }}>
          <Button onClick={onCancel} style={{ marginRight: 8 }}>
            Cancel
          </Button>
          <Button type="primary" htmlType="submit" loading={submitting}>
            Submit
          </Button>
        </Form.Item>
      </Form>

      <Modal
        open={modalVisible}
        onOk={() => {
          setModalVisible(false);
          router.push('/kreative/community-showcases');
        }}
        onCancel={() => setModalVisible(false)}
        okText="Ok"
        cancelButtonProps={{ style: { display: 'none' } }}
      >
        <p>
          Your project has been submitted for review. Moderators will evaluate
          your submission shortly.
        </p>
      </Modal>
    </KreativePageShell>
  );
}

===== END app/kreative/community-showcases/submit-to-showcase/page.tsx =====


===== BEGIN app/kreative/community-showcases/top-creators/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\top-creators\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { Table, Avatar, Select, Typography, Space, Button } from 'antd';
import type { ColumnsType } from 'antd/es/table';
import { TrophyOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { Title, Text } = Typography;

type TimeFrame = 'all-time' | 'this-month';

interface Creator {
  id: string;
  name: string;
  avatar: string;
  contributions: number;
  specialty: string;
}

const creatorsData: Creator[] = [
  {
    id: '1',
    name: 'Alice Johnson',
    avatar: 'https://via.placeholder.com/80.png?text=A',
    contributions: 125,
    specialty: 'Digital Art',
  },
  {
    id: '2',
    name: 'Bob Smith',
    avatar: 'https://via.placeholder.com/80.png?text=B',
    contributions: 110,
    specialty: 'Photography',
  },
  {
    id: '3',
    name: 'Carol Lee',
    avatar: 'https://via.placeholder.com/80.png?text=C',
    contributions: 105,
    specialty: 'Mixed Media',
  },
  {
    id: '4',
    name: 'David Kim',
    avatar: 'https://via.placeholder.com/80.png?text=D',
    contributions: 95,
    specialty: 'Painting',
  },
  {
    id: '5',
    name: 'Eva Martinez',
    avatar: 'https://via.placeholder.com/80.png?text=E',
    contributions: 88,
    specialty: 'Illustration',
  },
];

export default function TopCreatorsPage(): JSX.Element {
  const router = useRouter();
  const [timeFrame, setTimeFrame] = useState<TimeFrame>('all-time');

  const data = useMemo<Creator[]>(() => {
    return timeFrame === 'this-month' ? creatorsData.slice(0, 3) : creatorsData;
  }, [timeFrame]);

  const columns: ColumnsType<Creator> = [
    {
      title: 'Rank',
      key: 'rank',
      width: 80,
      render: (_value, _record, index) =>
        index < 3 ? (
          <TrophyOutlined style={{ fontSize: 20, color: '#faad14' }} />
        ) : (
          <Text>{index + 1}</Text>
        ),
    },
    {
      title: 'Creator',
      key: 'creator',
      width: 250,
      render: (_value, record) => (
        <Space>
          <Avatar src={record.avatar} />
          <Button
            type="link"
            onClick={() => router.push(`/kreative/profile/${record.id}`)}
          >
            {record.name}
          </Button>
        </Space>
      ),
    },
    {
      title: 'Contributions',
      dataIndex: 'contributions',
      key: 'contributions',
      width: 150,
      render: (value: number) => <Text>{value}</Text>,
    },
    {
      title: 'Specialty',
      dataIndex: 'specialty',
      key: 'specialty',
    },
  ];

  const timeframeSelector = (
    <Space>
      <Text strong>Filter by timeframe:</Text>
      <Select
        value={timeFrame}
        onChange={(value: TimeFrame) => setTimeFrame(value)}
        style={{ width: 180 }}
        options={[
          { value: 'all-time', label: 'All Time' },
          { value: 'this-month', label: 'This Month' },
        ]}
      />
    </Space>
  );

  return (
    <KreativePageShell
      title="Top Creators"
      subtitle="Leaderboard of creators with the most contributions across community showcases."
      secondaryActions={timeframeSelector}
    >
      <Space direction="vertical" size="middle" style={{ width: '100%' }}>
        <Title level={4} style={{ margin: 0 }}>
          Leaderboard
        </Title>

        <Table<Creator>
          columns={columns}
          dataSource={data}
          rowKey="id"
          pagination={{ pageSize: 5 }}
        />
      </Space>
    </KreativePageShell>
  );
}

===== END app/kreative/community-showcases/top-creators/page.tsx =====


===== BEGIN app/kreative/creative-hub/explore-ideas/page.tsx =====
'use client';

// File: C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\explore-ideas\page.tsx

import React, { useMemo, useState } from 'react';
import {
  Row,
  Col,
  Card,
  Input,
  Select,
  Typography,
  Space,
  Pagination,
  Button,
} from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { Title, Text, Paragraph } = Typography;

type Domain = 'Art' | 'Music' | 'Writing';
type SortOpt = 'newest' | 'popular';
type CategoryFilter = 'All' | Domain;

interface CreativeIdea {
  id: string;
  title: string;
  excerpt: string;
  author: string;
  domain: Domain;
  thumbnail: string;
  date: string; // ISO date
  popularity: number;
}

const creativeIdeasData: CreativeIdea[] = [
  {
    id: '1',
    title: 'The Beauty of Minimalism',
    excerpt: 'Exploring the art of less is more in design and creative expression.',
    author: 'Alice Martin',
    domain: 'Art',
    thumbnail: 'https://via.placeholder.com/300x200.png?text=Minimalism',
    date: '2025-11-20T10:00:00Z',
    popularity: 87,
  },
  {
    id: '2',
    title: 'Soundscapes: Music and Emotion',
    excerpt: 'How different chord progressions evoke specific emotional responses.',
    author: 'Brian Chen',
    domain: 'Music',
    thumbnail: 'https://via.placeholder.com/300x200.png?text=Soundscapes',
    date: '2025-11-18T14:30:00Z',
    popularity: 73,
  },
  {
    id: '3',
    title: 'Writing with Constraints',
    excerpt: 'Using constraints like lipograms to spark creativity.',
    author: 'Caroline Dupont',
    domain: 'Writing',
    thumbnail: 'https://via.placeholder.com/300x200.png?text=Constraints',
    date: '2025-11-15T09:00:00Z',
    popularity: 55,
  },
  {
    id: '4',
    title: 'Color Theory Basics',
    excerpt: 'Understanding complementary and analogous color schemes.',
    author: 'David Lopez',
    domain: 'Art',
    thumbnail: 'https://via.placeholder.com/300x200.png?text=Color+Theory',
    date: '2025-11-10T11:45:00Z',
    popularity: 61,
  },
];

export default function ExploreIdeasPage(): JSX.Element {
  const router = useRouter();

  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedCategory, setSelectedCategory] =
    useState<CategoryFilter>('All');
  const [sortOption, setSortOption] = useState<SortOpt>('newest');

  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 9;

  const filteredIdeas = useMemo<CreativeIdea[]>(() => {
    let ideas = [...creativeIdeasData];

    if (selectedCategory !== 'All') {
      ideas = ideas.filter((idea) => idea.domain === selectedCategory);
    }

    const q = searchQuery.trim().toLowerCase();
    if (q) {
      ideas = ideas.filter(
        (idea) =>
          idea.title.toLowerCase().includes(q) ||
          idea.excerpt.toLowerCase().includes(q),
      );
    }

    ideas =
      sortOption === 'newest'
        ? ideas.sort(
            (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime(),
          )
        : ideas.sort((a, b) => b.popularity - a.popularity);

    return ideas;
  }, [searchQuery, selectedCategory, sortOption]);

  const paginatedIdeas = useMemo<CreativeIdea[]>(() => {
    const startIndex = (currentPage - 1) * pageSize;
    return filteredIdeas.slice(startIndex, startIndex + pageSize);
  }, [filteredIdeas, currentPage]);

  const handleCardClick = (idea: CreativeIdea) => {
    router.push(`/kreative/creative-hub/idea/${idea.id}`);
  };

  return (
    <KreativePageShell
      title="Explore Ideas"
      subtitle="Browse curated prompts and articles across creative domains."
      primaryAction={
        <Button
          type="primary"
          onClick={() =>
            router.push('/kreative/idea-incubator/create-new-idea')
          }
        >
          Create New Idea
        </Button>
      }
    >
      <Space direction="vertical" size="middle" style={{ width: '100%' }}>
        <Space wrap>
          <Input
            placeholder="Search ideas"
            prefix={<SearchOutlined />}
            value={searchQuery}
            onChange={(e) => {
              setSearchQuery(e.target.value);
              setCurrentPage(1);
            }}
            style={{ width: 300 }}
            allowClear
          />

          <Select<CategoryFilter>
            value={selectedCategory}
            onChange={(value) => {
              setSelectedCategory(value);
              setCurrentPage(1);
            }}
            options={[
              { value: 'All', label: 'All Domains' },
              { value: 'Art', label: 'Art' },
              { value: 'Music', label: 'Music' },
              { value: 'Writing', label: 'Writing' },
            ]}
            style={{ width: 180 }}
          />

          <Select<SortOpt>
            value={sortOption}
            onChange={(value) => {
              setSortOption(value);
              setCurrentPage(1);
            }}
            options={[
              { value: 'newest', label: 'Newest' },
              { value: 'popular', label: 'Most Popular' },
            ]}
            style={{ width: 180 }}
          />
        </Space>

        <Row gutter={[24, 24]}>
          {paginatedIdeas.map((idea) => (
            <Col key={idea.id} xs={24} sm={12} md={8}>
              <Card
                hoverable
                cover={
                  <img
                    alt={idea.title}
                    src={idea.thumbnail}
                    style={{ height: 160, objectFit: 'cover' }}
                  />
                }
                onClick={() => handleCardClick(idea)}
              >
                <Title
                  level={4}
                  className="clamp-1"
                  style={{ marginBottom: 8 }}
                >
                  {idea.title}
                </Title>

                <Paragraph
                  className="clamp-2"
                  type="secondary"
                  style={{ marginBottom: 12 }}
                >
                  {idea.excerpt}
                </Paragraph>

                <Text strong>By: </Text>
                <Text>{idea.author}</Text>
              </Card>
            </Col>
          ))}
        </Row>

        <div style={{ textAlign: 'center', marginTop: 24 }}>
          <Pagination
            current={currentPage}
            pageSize={pageSize}
            total={filteredIdeas.length}
            onChange={(page) => setCurrentPage(page)}
            showSizeChanger={false}
          />
        </div>
      </Space>

      <style jsx>{`
        .clamp-1 {
          overflow: hidden;
          white-space: nowrap;
          text-overflow: ellipsis;
        }
        .clamp-2 {
          display: -webkit-box;
          -webkit-line-clamp: 2;
          -webkit-box-orient: vertical;
          overflow: hidden;
        }
      `}</style>
    </KreativePageShell>
  );
}

===== END app/kreative/creative-hub/explore-ideas/page.tsx =====


===== BEGIN app/kreative/creative-hub/inspiration-gallery/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\inspiration-gallery\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import {
  Row,
  Col,
  Card,
  Modal,
  Pagination,
  Tabs,
  Button,
  Typography,
  Space,
} from 'antd';
import { HeartOutlined, HeartFilled } from '@ant-design/icons';
import PageContainer from '@/components/PageContainer';

const { Title, Text, Paragraph } = Typography;

type Category = 'All' | 'Photography' | 'Painting' | 'Digital Art';

interface CreativeWork {
  id: string;
  title: string;
  description: string;
  creator: string;
  category: Exclude<Category, 'All'>;
  imageUrl: string;
  likes: number;
  liked?: boolean;
}

// Dummy data for the gallery
const dummyWorks: CreativeWork[] = [
  {
    id: '1',
    title: 'Sunset Overdrive',
    description: 'A breathtaking view of the sunset captured in high resolution.',
    creator: 'Alice Johnson',
    category: 'Photography',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Sunset',
    likes: 34,
    liked: false,
  },
  {
    id: '2',
    title: 'Abstract Colors',
    description: 'A vibrant abstract painting exploring the interplay of color.',
    creator: 'Bob Smith',
    category: 'Painting',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Abstract+Painting',
    likes: 58,
    liked: false,
  },
  {
    id: '3',
    title: 'Digital Dreams',
    description: 'A surreal piece of digital art mixing technology and imagination.',
    creator: 'Carla Gomez',
    category: 'Digital Art',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Digital+Art',
    likes: 72,
    liked: false,
  },
  {
    id: '4',
    title: 'City Reflections',
    description: 'A dramatic urban photograph showcasing reflections on wet streets.',
    creator: 'David Lee',
    category: 'Photography',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=City+Reflections',
    likes: 43,
    liked: false,
  },
  {
    id: '5',
    title: 'Impressionist Waves',
    description: 'An impressionist painting capturing the movement of ocean waves.',
    creator: 'Eva Martinez',
    category: 'Painting',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Impressionist+Waves',
    likes: 66,
    liked: false,
  },
  {
    id: '6',
    title: 'Virtual Reality',
    description: 'An innovative digital artwork blending real and virtual elements.',
    creator: 'Felix Zhang',
    category: 'Digital Art',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Virtual+Reality',
    likes: 51,
    liked: false,
  },
];

export default function InspirationGalleryPage(): JSX.Element {
  // State for category filtering, pagination, Modal, and works.
  const [selectedCategory, setSelectedCategory] = useState<Category>('All');
  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 6;
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [selectedWork, setSelectedWork] = useState<CreativeWork | null>(null);
  const [works, setWorks] = useState<CreativeWork[]>(dummyWorks);

  // Tabs (AntD v5) items
  const tabItems = useMemo(
    () => [
      { key: 'All', label: 'All' },
      { key: 'Photography', label: 'Photography' },
      { key: 'Painting', label: 'Painting' },
      { key: 'Digital Art', label: 'Digital Art' },
    ],
    [],
  );

  // Filter works based on selected category.
  const filteredWorks = useMemo(() => {
    if (selectedCategory === 'All') return works;
    return works.filter((work) => work.category === selectedCategory);
  }, [selectedCategory, works]);

  // Paginate the filtered works.
  const paginatedWorks = useMemo(() => {
    const startIndex = (currentPage - 1) * pageSize;
    return filteredWorks.slice(startIndex, startIndex + pageSize);
  }, [filteredWorks, currentPage]);

  // Handle like toggle.
  const toggleLike = (id: string): void => {
    setWorks((prev) =>
      prev.map((w) =>
        w.id === id ? { ...w, liked: !w.liked, likes: w.liked ? w.likes - 1 : w.likes + 1 } : w,
      ),
    );
  };

  // Open Modal for work details.
  const openWorkModal = (work: CreativeWork): void => {
    setSelectedWork(work);
    setModalVisible(true);
  };

  // Close the details Modal.
  const closeModal = (): void => {
    setModalVisible(false);
    setSelectedWork(null);
  };

  return (
    <PageContainer title="Inspiration Gallery">
      {/* Category Filter (AntD v5 Tabs API) */}
      <Tabs
        activeKey={selectedCategory}
        onChange={(key) => {
          setSelectedCategory(key as Category);
          setCurrentPage(1);
        }}
        type="card"
        items={tabItems}
        style={{ marginBottom: 24 }}
      />

      {/* Gallery Grid */}
      <Row gutter={[16, 16]}>
        {paginatedWorks.map((work) => (
          <Col key={work.id} xs={24} sm={12} md={8}>
            <Card
              hoverable
              cover={
                <img
                  alt={work.title}
                  src={work.imageUrl}
                  style={{ height: 200, objectFit: 'cover' }}
                />
              }
              actions={[
                <Button
                  key="like"
                  type="text"
                  onClick={(e) => {
                    e.stopPropagation();
                    toggleLike(work.id);
                  }}
                >
                  {work.liked ? (
                    <HeartFilled style={{ color: 'red', fontSize: 18 }} />
                  ) : (
                    <HeartOutlined style={{ fontSize: 18 }} />
                  )}
                  <Text style={{ marginLeft: 4 }}>{work.likes}</Text>
                </Button>,
              ]}
              onClick={() => openWorkModal(work)}
            >
              <Card.Meta
                title={work.title}
                description={
                  <>
                    <Text>{work.creator}</Text>
                    <br />
                    {/* Replace ellipsis={{}} with CSS line clamp */}
                    <Paragraph type="secondary" className="lineClamp2">
                      {work.description}
                    </Paragraph>
                  </>
                }
              />
            </Card>
          </Col>
        ))}
      </Row>

      {/* Pagination */}
      <div style={{ textAlign: 'center', marginTop: 24 }}>
        <Pagination
          current={currentPage}
          pageSize={pageSize}
          total={filteredWorks.length}
          onChange={(page) => setCurrentPage(page)}
        />
      </div>

      {/* Modal for work details */}
      <Modal open={modalVisible} footer={null} onCancel={closeModal} width={800}>
        {selectedWork && (
          <>
            <img
              alt={selectedWork.title}
              src={selectedWork.imageUrl}
              style={{ width: '100%', maxHeight: 400, objectFit: 'contain' }}
            />
            <div style={{ marginTop: 16 }}>
              <Title level={3}>{selectedWork.title}</Title>
              <Text strong>By: </Text>
              <Text>{selectedWork.creator}</Text>
              <p style={{ marginTop: 12 }}>{selectedWork.description}</p>
              <Space>
                <Button type="text" onClick={() => toggleLike(selectedWork.id)}>
                  {selectedWork.liked ? (
                    <HeartFilled style={{ color: 'red', fontSize: 20 }} />
                  ) : (
                    <HeartOutlined style={{ fontSize: 20 }} />
                  )}
                  <Text style={{ marginLeft: 4 }}>{selectedWork.likes} Likes</Text>
                </Button>
              </Space>
            </div>
          </>
        )}
      </Modal>

      <style jsx>{`
        /* Multi-line clamp to replace AntD ellipsis { rows } */
        .lineClamp2 {
          display: -webkit-box;
          -webkit-line-clamp: 2;
          -webkit-box-orient: vertical;
          overflow: hidden;
        }
      `}</style>
    </PageContainer>
  );
}

===== END app/kreative/creative-hub/inspiration-gallery/page.tsx =====


===== BEGIN app/kreative/creative-hub/submit-creative-work/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\submit-creative-work\page.tsx
'use client';

import React, { useState } from 'react';
import {
  Form,
  Input,
  Button,
  Upload,
  Select,
  message as antdMessage,
  Alert,
} from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import { UploadOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

type CreativeWorkFormValues = {
  title: string;
  description: string;
  category: string;
  credits?: string;
  creativeFile: UploadFile[];
};

// Type minimal utile pour le onChange d'Upload (√©vite implicit any)
type UploadChangeParamLite = {
  fileList: UploadFile[];
};

export default function SubmitCreativeWorkPage(): JSX.Element {
  const [form] = Form.useForm<CreativeWorkFormValues>();
  const [fileList, setFileList] = useState<UploadFile[]>([]);
  const router = useRouter();

  const handleUploadChange = (info: UploadChangeParamLite) => {
    setFileList(info.fileList);
  };

  // Normalise l'√©v√®nement Upload pour AntD Form
  const normFile = (e: UploadChangeParamLite | UploadFile[]) => {
    if (Array.isArray(e)) return e;
    return e?.fileList ?? [];
  };

  const onFinish = async (values: CreativeWorkFormValues) => {
    if (!fileList.length) {
      antdMessage.error('Veuillez joindre au moins un fichier.');
      return;
    }
    try {
      // TODO: remplacer par l'appel API r√©el d‚Äôenvoi
      // await api.submitCreativeWork(values, fileList)
      antdMessage.success('Cr√©ation envoy√©e avec succ√®s !');
      router.push('/kreative/dashboard');
    } catch {
      antdMessage.error("Erreur lors de l'envoi. R√©essayez.");
    }
  };

  return (
    <KreativePageShell
      title="Submit Creative Work"
      subtitle="Share your creative work with the community."
    >
      <Alert
        type="info"
        showIcon
        style={{ marginBottom: 16 }}
        message="Partagez votre travail cr√©atif avec la communaut√©."
      />

      <Form<CreativeWorkFormValues> layout="vertical" form={form} onFinish={onFinish}>
        <Form.Item
          label="Title"
          name="title"
          rules={[{ required: true, message: 'Please enter a title' }]}
        >
          <Input placeholder="e.g., Generative sculpture series" />
        </Form.Item>

        <Form.Item
          label="Description"
          name="description"
          rules={[{ required: true, message: 'Please add a description' }]}
        >
          <Input.TextArea rows={4} placeholder="What did you make? How? Why?" />
        </Form.Item>

        <Form.Item
          label="Category"
          name="category"
          rules={[{ required: true, message: 'Please pick a category' }]}
        >
          <Select placeholder="Choose one">
            <Select.Option value="art">Art</Select.Option>
            <Select.Option value="design">Design</Select.Option>
            <Select.Option value="music">Music</Select.Option>
            <Select.Option value="other">Other</Select.Option>
          </Select>
        </Form.Item>

        <Form.Item
          label="Upload"
          name="creativeFile"
          valuePropName="fileList"
          getValueFromEvent={normFile}
          rules={[
            {
              validator: (_, value: UploadFile[]) =>
                value && value.length
                  ? Promise.resolve()
                  : Promise.reject(new Error('Please attach at least one file')),
            },
          ]}
        >
          <Upload
            beforeUpload={() => false} // emp√™che l‚Äôupload auto, on laisse le form g√©rer
            multiple
            onChange={handleUploadChange}
            fileList={fileList}
          >
            <Button icon={<UploadOutlined />}>Select file(s)</Button>
          </Upload>
        </Form.Item>

        <Form.Item label="Credits" name="credits">
          <Input placeholder="Collaborators, references, tools‚Ä¶" />
        </Form.Item>

        <Form.Item>
          <Button type="primary" htmlType="submit">
            Submit
          </Button>
        </Form.Item>
      </Form>
    </KreativePageShell>
  );
}

===== END app/kreative/creative-hub/submit-creative-work/page.tsx =====


===== BEGIN app/kreative/dashboard/page.tsx =====
// app/kreative/dashboard/page.tsx
'use client';

import React from 'react';
import {
  Card,
  Avatar,
  Button,
  Carousel,
  List,
  Row,
  Col,
  Typography,
  Space,
} from 'antd';
import {
  PictureOutlined,
  BulbOutlined,
  UploadOutlined,
} from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { Title, Text } = Typography;

// Base URL for the backend API (used for media files)
const API_BASE =
  process.env.NEXT_PUBLIC_API_BASE ?? 'http://localhost:8000';

type QuickLink = {
  title: string;
  icon: React.ReactNode;
  href: string;
};

/** Featured Project */
const featuredProject = {
  title: 'Dreamscape: A Visual Journey',
  imageUrl: `${API_BASE}/media/kreative/artworks/artwork_0.png`,
};

/** Inspiration Gallery (carousel) */
const inspirationGallery = [
  {
    id: '1',
    imageUrl: `${API_BASE}/media/kreative/artworks/artwork_0.png`,
  },
  {
    id: '2',
    imageUrl: `${API_BASE}/media/kreative/artworks/artwork_1.png`,
  },
  {
    id: '3',
    imageUrl: `${API_BASE}/media/kreative/artworks/artwork_2.png`,
  },
  {
    id: '4',
    imageUrl: `${API_BASE}/media/kreative/artworks/default_profile.png`,
  },
];

/** Top Creator */
const topCreator = {
  name: 'Sophia Rivera',
  avatar: `${API_BASE}/media/kreative/artworks/default_profile.png`,
  stats: '48 Projects ¬∑ 1200 Likes',
};

/** Quick Links (wired to existing Kreative routes) */
const quickLinks: QuickLink[] = [
  {
    title: 'Explore Ideas',
    icon: <BulbOutlined style={{ fontSize: 24 }} />,
    href: '/kreative/creative-hub/explore-ideas',
  },
  {
    title: 'Submit Work',
    icon: <UploadOutlined style={{ fontSize: 24 }} />,
    href: '/kreative/creative-hub/submit-creative-work',
  },
  {
    title: 'View Gallery',
    icon: <PictureOutlined style={{ fontSize: 24 }} />,
    href: '/kreative/creative-hub/inspiration-gallery',
  },
];

/** Recent Activity */
const recentActivities = [
  {
    id: 'a1',
    text: 'User John submitted a new Art piece in Photography',
    time: '2 hours ago',
  },
  {
    id: 'a2',
    text: 'User Emma started a new idea: ‚ÄúUrban Sketching‚Äù',
    time: '5 hours ago',
  },
  {
    id: 'a3',
    text: 'User Liam commented on ‚ÄúDreamscape: A Visual Journey‚Äù',
    time: '1 day ago',
  },
  {
    id: 'a4',
    text: 'User Olivia liked a work in Digital Art',
    time: '2 days ago',
  },
];

export default function KreativeDashboardPage(): JSX.Element {
  const router = useRouter();

  return (
    <KreativePageShell title="Kreative Dashboard">
      <Row gutter={[24, 24]}>
        {/* Featured Project Highlight */}
        <Col xs={24} md={16}>
          <Card
            hoverable
            cover={
              <img
                alt="Featured Project"
                src={featuredProject.imageUrl}
                style={{ objectFit: 'cover' }}
              />
            }
          >
            <Title level={3}>{featuredProject.title}</Title>
          </Card>
        </Col>

        {/* Top Creator Spotlight */}
        <Col xs={24} md={8}>
          <Card>
            <Space
              direction="vertical"
              align="center"
              style={{ width: '100%' }}
            >
              <Avatar size={80} src={topCreator.avatar} />
              <Title level={4} style={{ margin: 0 }}>
                {topCreator.name}
              </Title>
              <Text type="secondary">{topCreator.stats}</Text>
            </Space>
          </Card>
        </Col>
      </Row>

      <Row gutter={[24, 24]} style={{ marginTop: 24 }}>
        {/* Inspiration Gallery Preview */}
        <Col xs={24} md={16}>
          <Card title="Inspiration Gallery Preview">
            <Carousel autoplay dotPosition="bottom">
              {inspirationGallery.map((item) => (
                <div key={item.id}>
                  <img
                    alt={`Art ${item.id}`}
                    src={item.imageUrl}
                    style={{
                      width: '100%',
                      height: 300,
                      objectFit: 'cover',
                    }}
                  />
                </div>
              ))}
            </Carousel>
          </Card>
        </Col>

        {/* Quick Links */}
        <Col xs={24} md={8}>
          <Card title="Quick Links">
            <Space
              direction="vertical"
              size="middle"
              style={{ width: '100%' }}
            >
              {quickLinks.map((link) => (
                <Button
                  key={link.title}
                  type="primary"
                  block
                  icon={link.icon}
                  onClick={() => router.push(link.href)}
                >
                  {link.title}
                </Button>
              ))}
            </Space>
          </Card>
        </Col>
      </Row>

      {/* Recent Activity Feed */}
      <Row gutter={[24, 24]} style={{ marginTop: 24 }}>
        <Col xs={24}>
          <Card title="Recent Activity">
            <List
              itemLayout="horizontal"
              dataSource={recentActivities}
              renderItem={(item) => (
                <List.Item>
                  <List.Item.Meta
                    title={item.text}
                    description={item.time}
                  />
                </List.Item>
              )}
            />
          </Card>
        </Col>
      </Row>
    </KreativePageShell>
  );
}

===== END app/kreative/dashboard/page.tsx =====


===== BEGIN app/kreative/idea-incubator/collaborate-on-ideas/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import { List, Button, Badge, Input, Select, Space, Typography } from 'antd';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Title, Text } = Typography;

interface Idea {
  id: string;
  title: string;
  status: 'Seeking Collaboration' | 'In Progress';
  dateCreated: string; // YYYY-MM-DD
  newActivity: boolean;
}

const dummyIdeas: Idea[] = [
  {
    id: '1',
    title: 'Revolutionary App Concept',
    status: 'Seeking Collaboration',
    dateCreated: '2025-11-20',
    newActivity: true,
  },
  {
    id: '2',
    title: 'Sustainable Energy Initiative',
    status: 'In Progress',
    dateCreated: '2025-10-15',
    newActivity: false,
  },
  {
    id: '3',
    title: 'Urban Gardening Project',
    status: 'Seeking Collaboration',
    dateCreated: '2025-11-01',
    newActivity: true,
  },
];

type StatusFilter = 'All' | Idea['status'];

export default function CollaborateOnIdeasPage(): JSX.Element {
  const router = useRouter();

  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedStatus, setSelectedStatus] = useState<StatusFilter>('All');

  const filteredIdeas = useMemo<Idea[]>(() => {
    let ideas = dummyIdeas;
    if (selectedStatus !== 'All') {
      ideas = ideas.filter((idea) => idea.status === selectedStatus);
    }
    if (searchQuery.trim() !== '') {
      const q = searchQuery.toLowerCase();
      ideas = ideas.filter((idea) => idea.title.toLowerCase().includes(q));
    }
    return ideas;
  }, [searchQuery, selectedStatus]);

  return (
    <PageContainer title="Collaborate on Ideas">
      <Space direction="vertical" size="middle" style={{ width: '100%', marginBottom: 24 }}>
        <Space>
          <Input
            placeholder="Search by title..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            style={{ width: 300 }}
            allowClear
          />
          <Select<StatusFilter>
            value={selectedStatus}
            onChange={(value) => setSelectedStatus(value)}
            style={{ width: 220 }}
            options={[
              { value: 'All', label: 'All Status' },
              { value: 'Seeking Collaboration', label: 'Seeking Collaboration' },
              { value: 'In Progress', label: 'In Progress' },
            ]}
          />
        </Space>
      </Space>

      <List
        itemLayout="vertical"
        dataSource={filteredIdeas}
        renderItem={(idea) => (
          <List.Item
            key={idea.id}
            actions={[
              <Button
                key="edit"
                type="primary"
                onClick={() => router.push(`/kreative/idea-incubator/edit/${idea.id}`)}
              >
                Edit
              </Button>,
              <Button
                key="view"
                onClick={() => router.push(`/kreative/idea-incubator/view/${idea.id}`)}
              >
                View
              </Button>,
            ]}
          >
            <List.Item.Meta
              title={
                <Space>
                  {idea.newActivity && (
                    <Badge count="New" style={{ backgroundColor: '#52c41a' }} />
                  )}
                  <Title level={4} style={{ margin: 0 }}>
                    {idea.title}
                  </Title>
                </Space>
              }
              description={
                <>
                  <Text type="secondary">Status: {idea.status}</Text>
                  <br />
                  <Text type="secondary">Created on: {idea.dateCreated}</Text>
                </>
              }
            />
          </List.Item>
        )}
      />
    </PageContainer>
  );
}

===== END app/kreative/idea-incubator/collaborate-on-ideas/page.tsx =====


===== BEGIN app/kreative/idea-incubator/create-new-idea/page.tsx =====
'use client';

import React from 'react';
import { Form, Input, Select, Button, message as antdMessage } from 'antd';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';
// Note: MainLayout import removed because the /kreative layout handles the layout wrapper.

const { TextArea } = Input;
const { Option } = Select;

const CreateNewIdea: React.FC = () => {
  const [form] = Form.useForm();
  const router = useRouter();

  // Handler for form submission.
  const onFinish = (values: any) => {
    console.log('Submitted Idea:', values);
    antdMessage.success('Votre id√©e a √©t√© soumise avec succ√®s‚ÄØ!');
    // Redirect to the "My Ideas" page after submitting.
    router.push('/kreative/idea-incubator/my-ideas');
  };

  return (
    <PageContainer title="Create New Idea">
      <Form form={form} layout="vertical" onFinish={onFinish}>
        {/* Title Field */}
        <Form.Item
          label="Title of Idea"
          name="title"
          rules={[{ required: true, message: 'Veuillez saisir le titre de votre id√©e.' }]}
        >
          <Input placeholder="Enter title of your idea" />
        </Form.Item>

        {/* Detailed Description Field */}
        <Form.Item
          label="Detailed Description"
          name="description"
          rules={[{ required: true, message: 'Veuillez saisir une description d√©taill√©e de votre id√©e.' }]}
        >
          <TextArea
            rows={6}
            placeholder="Explain your idea, including the problem it solves or your vision"
          />
        </Form.Item>

        {/* Category / Field Selector */}
        <Form.Item
          label="Category / Field"
          name="category"
          rules={[{ required: true, message: 'Veuillez s√©lectionner une cat√©gorie.' }]}
        >
          <Select placeholder="Select a category">
            <Option value="Technology">Technology</Option>
            <Option value="Art">Art</Option>
            <Option value="Education">Education</Option>
            <Option value="Health">Health</Option>
            <Option value="Environment">Environment</Option>
          </Select>
        </Form.Item>

        {/* (Optional) Resources Needed / Skills Required - omitted for now */}

        {/* Submit Button */}
        <Form.Item>
          <Button type="primary" htmlType="submit">
            Submit Idea
          </Button>
        </Form.Item>
      </Form>
    </PageContainer>
  );
};

export default CreateNewIdea;

===== END app/kreative/idea-incubator/create-new-idea/page.tsx =====


===== BEGIN app/kreative/idea-incubator/my-ideas/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\idea-incubator\my-ideas\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { Badge, Button, Input, List, Select, Space, Typography } from 'antd';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Title, Text } = Typography;

type IdeaStatus = 'Seeking Collaboration' | 'In Progress';
type StatusFilter = 'All' | IdeaStatus;

interface Idea {
  id: string;
  title: string;
  status: IdeaStatus;
  dateCreated: string; // YYYY-MM-DD
  newActivity: boolean;
}

const dummyIdeas: Idea[] = [
  {
    id: '1',
    title: 'Revolutionary App Concept',
    status: 'Seeking Collaboration',
    dateCreated: '2025-11-20',
    newActivity: true,
  },
  {
    id: '2',
    title: 'Sustainable Energy Initiative',
    status: 'In Progress',
    dateCreated: '2025-10-15',
    newActivity: false,
  },
  {
    id: '3',
    title: 'Urban Gardening Project',
    status: 'Seeking Collaboration',
    dateCreated: '2025-11-01',
    newActivity: true,
  },
];

export default function MyIdeasPage(): JSX.Element {
  const router = useRouter();

  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedStatus, setSelectedStatus] = useState<StatusFilter>('All');

  const filteredIdeas = useMemo<Idea[]>(() => {
    let ideas = dummyIdeas;
    if (selectedStatus !== 'All') {
      ideas = ideas.filter((idea) => idea.status === selectedStatus);
    }
    if (searchQuery.trim()) {
      const q = searchQuery.toLowerCase();
      ideas = ideas.filter((idea) => idea.title.toLowerCase().includes(q));
    }
    return ideas;
  }, [searchQuery, selectedStatus]);

  return (
    <PageContainer title="My Ideas">
      <Space direction="vertical" size="middle" style={{ width: '100%', marginBottom: 24 }}>
        <Space>
          <Input
            placeholder="Search by title."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            style={{ width: 300 }}
            allowClear
          />
          <Select<StatusFilter>
            value={selectedStatus}
            onChange={(value) => setSelectedStatus(value)}
            style={{ width: 220 }}
            options={[
              { value: 'All', label: 'All Status' },
              { value: 'Seeking Collaboration', label: 'Seeking Collaboration' },
              { value: 'In Progress', label: 'In Progress' },
            ]}
          />
        </Space>
      </Space>

      <List<Idea>
        itemLayout="vertical"
        dataSource={filteredIdeas}
        renderItem={(idea) => (
          <List.Item
            key={idea.id}
            actions={[
              <Button
                key="edit"
                type="primary"
                onClick={() => router.push(`/kreative/idea-incubator/edit/${idea.id}`)}
              >
                Edit
              </Button>,
              <Button
                key="view"
                onClick={() => router.push(`/kreative/idea-incubator/view/${idea.id}`)}
              >
                View
              </Button>,
            ]}
          >
            <List.Item.Meta
              title={
                <Space>
                  {idea.newActivity && (
                    <Badge count="New" style={{ backgroundColor: '#52c41a' }} />
                  )}
                  <Title level={4} style={{ margin: 0 }}>
                    {idea.title}
                  </Title>
                </Space>
              }
              description={
                <>
                  <Text type="secondary">Status: {idea.status}</Text>
                  <br />
                  <Text type="secondary">Created on: {idea.dateCreated}</Text>
                </>
              }
            />
          </List.Item>
        )}
      />
    </PageContainer>
  );
}

===== END app/kreative/idea-incubator/my-ideas/page.tsx =====


===== BEGIN app/kreative/kreativePageShell.tsx =====
'use client';

import React, { ReactNode } from 'react';
import { Typography, Space } from 'antd';

const { Title, Paragraph } = Typography;

type KreativePageShellProps = {
  /** Main page title (no extra <h1> in the page) */
  title: string;
  /** Optional subtitle / helper text under the title */
  subtitle?: string;
  /** Primary action on the right (e.g. main CTA button) */
  primaryAction?: ReactNode;
  /** Secondary actions on the right (e.g. ghost buttons, filters) */
  secondaryActions?: ReactNode;
  /** Main page content */
  children: ReactNode;
};

/**
 * Central layout wrapper for Kreative pages.
 *
 * Usage rules:
 * - Pas de gros <h1> / Title suppl√©mentaire dans les pages elles‚Äëm√™mes.
 * - Pas de fil d‚ÄôAriane ici (utiliser celui du layout global si besoin).
 * - Toutes les pages Kreative devraient utiliser ce shell pour garder
 *   le m√™me padding, la m√™me hi√©rarchie de titres, etc.
 */
export default function KreativePageShell({
  title,
  subtitle,
  primaryAction,
  secondaryActions,
  children,
}: KreativePageShellProps): JSX.Element {
  const hasActions = Boolean(primaryAction || secondaryActions);

  return (
    <div className="container mx-auto p-5">
      {/* Header */}
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div>
          <Title level={2} style={{ marginBottom: subtitle ? 4 : 0 }}>
            {title}
          </Title>
          {subtitle && (
            <Paragraph type="secondary" style={{ marginBottom: 0 }}>
              {subtitle}
            </Paragraph>
          )}
        </div>

        {hasActions && (
          <Space wrap>
            {secondaryActions}
            {primaryAction}
          </Space>
        )}
      </div>

      {/* Main content */}
      <div>{children}</div>
    </div>
  );
}

===== END app/kreative/kreativePageShell.tsx =====


===== BEGIN app/kreative/layout.tsx =====
import React, { Suspense } from 'react'
import MainLayout from '@/components/layout-components/MainLayout'

export default function SegmentLayout({ children }: { children: React.ReactNode }) {
  return (
    <Suspense fallback={null}>
      <MainLayout>{children}</MainLayout>
    </Suspense>
  )
}
===== END app/kreative/layout.tsx =====


===== BEGIN app/layout.tsx =====
// app/layout.tsx
import '@/styles/tailwind.css'                // ‚Üê global Tailwind + reset AntD
import { ThemeProvider } from '@/context/ThemeContext'
import QueryProvider from '@/shared/QueryProvider'
import "../src/dayjs-setup"
import AuthProvider from './providers/AuthProvider'
import '@ant-design/v5-patch-for-react-19';


export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <ThemeProvider>
          <QueryProvider>
            <AuthProvider>
              {children}
            </AuthProvider>
          </QueryProvider>
        </ThemeProvider>
      </body>
    </html>
  )
}

===== END app/layout.tsx =====


===== BEGIN app/page.tsx =====
// app/page.tsx
import PageContainer from "@/components/PageContainer";

export const metadata = {
  title: "Accueil",
  description: "Point d‚Äôentr√©e",
};

export default function Page() {
  return (
    <PageContainer title="Accueil">
      <p>Bienvenue. Cette page affiche uniquement le PageContainer et son contenu.</p>
    </PageContainer>
  );
}

===== END app/page.tsx =====


===== BEGIN app/providers/AuthProvider.tsx =====
// app/providers/AuthProvider.tsx
'use client';

import React from 'react';

/**
 * Auth provider wrapper for App Router.
 * No SDK import needed ‚Äî Auth0 sessions are handled by middleware.
 */
export default function AuthProvider({ children }: { children: React.ReactNode }) {
  return <>{children}</>;
}

===== END app/providers/AuthProvider.tsx =====

