===== TOC (158 fichiers) =====
1. C:\MyCode\Konnaxionv14\frontend\modules\admin\components\index.ts
2. C:\MyCode\Konnaxionv14\frontend\modules\admin\components\ModerationQueue.tsx
3. C:\MyCode\Konnaxionv14\frontend\modules\admin\components\UserStats.tsx
4. C:\MyCode\Konnaxionv14\frontend\modules\admin\hooks\index.ts
5. C:\MyCode\Konnaxionv14\frontend\modules\admin\hooks\useModeration.ts
6. C:\MyCode\Konnaxionv14\frontend\modules\admin\hooks\useModeration.ts.bak
7. C:\MyCode\Konnaxionv14\frontend\modules\admin\hooks\useStats.ts
8. C:\MyCode\Konnaxionv14\frontend\modules\admin\pages\AdminConsole.tsx
9. C:\MyCode\Konnaxionv14\frontend\modules\admin\pages\index.ts
10. C:\MyCode\Konnaxionv14\frontend\modules\concatv3.py
11. C:\MyCode\Konnaxionv14\frontend\modules\ekoh\achievements-badges\earned-badges-display\components\CommonWidget\page.tsx
12. C:\MyCode\Konnaxionv14\frontend\modules\ekoh\dashboard\components\CommonWidget\page.tsx
13. C:\MyCode\Konnaxionv14\frontend\modules\ekoh\expertise-areas\view-current-expertise\components\CommonWidget\page.tsx
14. C:\MyCode\Konnaxionv14\frontend\modules\ekoh\overview-analytics\current-ekoh-score\components\CommonWidget\page.tsx
15. C:\MyCode\Konnaxionv14\frontend\modules\ekoh\voting-influence\current-voting-weight\components\CommonWidget\page.tsx
16. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\admin\audit\page.tsx
17. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\admin\moderation\page.tsx
18. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\admin\roles\page.tsx
19. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\decide\elite\page.tsx
20. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\decide\methodology\page.tsx
21. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\decide\public\page.tsx
22. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\decide\results\page.tsx
23. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\deliberate\[topic]\page.tsx
24. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\deliberate\elite\page.tsx
25. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\deliberate\guidelines\page.tsx
26. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\impact\feedback\page.tsx
27. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\impact\outcomes\page.tsx
28. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\impact\tracker\page.tsx
29. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\learn\changelog\page.tsx
30. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\learn\glossary\page.tsx
31. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\learn\guides\page.tsx
32. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\pulse\health\page.tsx
33. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\pulse\live\page.tsx
34. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\pulse\overview\page.tsx
35. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\pulse\trends\page.tsx
36. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\trust\badges\page.tsx
37. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\trust\credentials\page.tsx
38. C:\MyCode\Konnaxionv14\frontend\modules\ethikos\trust\profile\page.tsx
39. C:\MyCode\Konnaxionv14\frontend\modules\global\components\AppShell.tsx
40. C:\MyCode\Konnaxionv14\frontend\modules\global\components\GlobalSearchBar.tsx
41. C:\MyCode\Konnaxionv14\frontend\modules\global\components\index.ts
42. C:\MyCode\Konnaxionv14\frontend\modules\global\hooks\index.ts
43. C:\MyCode\Konnaxionv14\frontend\modules\global\hooks\useGlobalSearch.ts
44. C:\MyCode\Konnaxionv14\frontend\modules\global\pages\index.ts
45. C:\MyCode\Konnaxionv14\frontend\modules\global\pages\MyWork.tsx
46. C:\MyCode\Konnaxionv14\frontend\modules\global\pages\Search.tsx
47. C:\MyCode\Konnaxionv14\frontend\modules\insights\components\__stories__\SmartVoteChart.stories.tsx
48. C:\MyCode\Konnaxionv14\frontend\modules\insights\components\DomainHeatMap.tsx
49. C:\MyCode\Konnaxionv14\frontend\modules\insights\components\ErrorRateSparkline.tsx
50. C:\MyCode\Konnaxionv14\frontend\modules\insights\components\ExportCSVButton.tsx
51. C:\MyCode\Konnaxionv14\frontend\modules\insights\components\index.ts
52. C:\MyCode\Konnaxionv14\frontend\modules\insights\components\LatencySLOGauge.tsx
53. C:\MyCode\Konnaxionv14\frontend\modules\insights\components\SmartVoteChart.tsx
54. C:\MyCode\Konnaxionv14\frontend\modules\insights\components\TimeRangePicker.tsx
55. C:\MyCode\Konnaxionv14\frontend\modules\insights\components\UsageBigNumbers.tsx
56. C:\MyCode\Konnaxionv14\frontend\modules\insights\hooks\__tests__\useReport.test.tsx
57. C:\MyCode\Konnaxionv14\frontend\modules\insights\hooks\index.ts
58. C:\MyCode\Konnaxionv14\frontend\modules\insights\hooks\useReport.ts
59. C:\MyCode\Konnaxionv14\frontend\modules\insights\hooks\useReportStream.ts
60. C:\MyCode\Konnaxionv14\frontend\modules\insights\pages\CustomBuilderPage.tsx
61. C:\MyCode\Konnaxionv14\frontend\modules\insights\pages\index.ts
62. C:\MyCode\Konnaxionv14\frontend\modules\insights\pages\InsightsHomePage.tsx
63. C:\MyCode\Konnaxionv14\frontend\modules\insights\pages\PerfDashboard.tsx
64. C:\MyCode\Konnaxionv14\frontend\modules\insights\pages\SmartVoteDashboard.tsx
65. C:\MyCode\Konnaxionv14\frontend\modules\insights\pages\UsageDashboard.tsx
66. C:\MyCode\Konnaxionv14\frontend\modules\insights\types\liveReportState.ts
67. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\ai-team-matching\find-teams\components\CommonWidget\page.tsx
68. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\ai-team-matching\match-preferences\components\CommonWidget\page.tsx
69. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\ai-team-matching\my-matches\components\CommonWidget\page.tsx
70. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\dashboard\components\CommonWidget\page.tsx
71. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\knowledge\browse-repository\components\CommonWidget\page.tsx
72. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\knowledge\document-management\components\CommonWidget\page.tsx
73. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\knowledge\search-filter-documents\components\CommonWidget\page.tsx
74. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\knowledge\upload-new-document\components\CommonWidget\page.tsx
75. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\projects\browse-projects\components\CommonWidget\page.tsx
76. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\projects\create-new-project\components\CommonWidget\page.tsx
77. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\projects\my-projects\components\CommonWidget\page.tsx
78. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\projects\project-workspace\components\CommonWidget\page.tsx
79. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\sustainability-impact\submit-impact-reports\components\CommonWidget\page.tsx
80. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\sustainability-impact\sustainability-dashboard\components\CommonWidget\page.tsx
81. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\sustainability-impact\track-project-impact\components\CommonWidget\page.tsx
82. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\user-reputation\account-preferences\components\CommonWidget\page.tsx
83. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\user-reputation\manage-expertise-areas\components\CommonWidget\page.tsx
84. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\user-reputation\view-reputation-ekoh\components\CommonWidget\page.tsx
85. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\workspaces\browse-available-workspaces\components\CommonWidget\page.tsx
86. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\workspaces\launch-new-workspace\components\CommonWidget\page.tsx
87. C:\MyCode\Konnaxionv14\frontend\modules\keenkonnect\workspaces\my-workspaces\components\CommonWidget\page.tsx
88. C:\MyCode\Konnaxionv14\frontend\modules\konnected\certifications\certification-programs\components\CommonWidget\page.tsx
89. C:\MyCode\Konnaxionv14\frontend\modules\konnected\certifications\exam-dashboard-results\components\CommonWidget\page.tsx
90. C:\MyCode\Konnaxionv14\frontend\modules\konnected\certifications\exam-preparation\components\CommonWidget\page.tsx
91. C:\MyCode\Konnaxionv14\frontend\modules\konnected\certifications\exam-registration\components\CommonWidget\page.tsx
92. C:\MyCode\Konnaxionv14\frontend\modules\konnected\community-discussions\active-threads\components\CommonWidget\page.tsx
93. C:\MyCode\Konnaxionv14\frontend\modules\konnected\community-discussions\moderation\components\CommonWidget\page.tsx
94. C:\MyCode\Konnaxionv14\frontend\modules\konnected\community-discussions\start-new-discussion\components\CommonWidget\page.tsx
95. C:\MyCode\Konnaxionv14\frontend\modules\konnected\dashboard\components\CommonWidget\page.tsx
96. C:\MyCode\Konnaxionv14\frontend\modules\konnected\learning-library\browse-resources\components\CommonWidget\page.tsx
97. C:\MyCode\Konnaxionv14\frontend\modules\konnected\learning-library\offline-content\components\CommonWidget\page.tsx
98. C:\MyCode\Konnaxionv14\frontend\modules\konnected\learning-library\recommended-resources\components\CommonWidget\page.tsx
99. C:\MyCode\Konnaxionv14\frontend\modules\konnected\learning-library\search-filters\components\CommonWidget\page.tsx
100. C:\MyCode\Konnaxionv14\frontend\modules\konnected\learning-paths\create-learning-path\components\CommonWidget\page.tsx
101. C:\MyCode\Konnaxionv14\frontend\modules\konnected\learning-paths\manage-existing-paths\components\CommonWidget\page.tsx
102. C:\MyCode\Konnaxionv14\frontend\modules\konnected\learning-paths\my-learning-path\components\CommonWidget\page.tsx
103. C:\MyCode\Konnaxionv14\frontend\modules\konnected\teams-collaboration\activity-planner\components\CommonWidget\page.tsx
104. C:\MyCode\Konnaxionv14\frontend\modules\konnected\teams-collaboration\my-teams\components\CommonWidget\page.tsx
105. C:\MyCode\Konnaxionv14\frontend\modules\konnected\teams-collaboration\project-workspaces\components\CommonWidget\page.tsx
106. C:\MyCode\Konnaxionv14\frontend\modules\konnected\teams-collaboration\team-builder\components\CommonWidget\page.tsx
107. C:\MyCode\Konnaxionv14\frontend\modules\konsensus\components\index.ts
108. C:\MyCode\Konnaxionv14\frontend\modules\konsensus\components\PollBarChart.tsx
109. C:\MyCode\Konnaxionv14\frontend\modules\konsensus\components\VoteButtons.tsx
110. C:\MyCode\Konnaxionv14\frontend\modules\konsensus\hooks\index.ts
111. C:\MyCode\Konnaxionv14\frontend\modules\konsensus\hooks\useLivePoll.ts
112. C:\MyCode\Konnaxionv14\frontend\modules\konsensus\hooks\usePoll.ts
113. C:\MyCode\Konnaxionv14\frontend\modules\konsensus\pages\index.ts
114. C:\MyCode\Konnaxionv14\frontend\modules\konsensus\pages\PollPage.tsx
115. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\components\ConsultationForm.tsx
116. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\components\ConsultationList.tsx
117. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\components\ConsultationVotePanel.tsx
118. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\components\ImpactTimeline.tsx
119. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\components\index.ts
120. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\components\ResultsChart.tsx
121. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\components\ResultsDashboard.tsx
122. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\components\SuggestionBoard.tsx
123. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\components\SuggestionsBoard.tsx
124. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\hooks\index.ts
125. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\hooks\useConsultation.ts
126. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\hooks\useConsultationResults.ts
127. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\hooks\useConsultations.ts
128. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\hooks\useConsultationVote.ts
129. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\hooks\useImpact.ts
130. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\hooks\useSuggestions.ts
131. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\pages\ConsultationDetailPage.tsx
132. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\pages\ConsultationHub.tsx
133. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\pages\ConsultationsHomePage.tsx
134. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\pages\index.ts
135. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\pages\ResultsPage.tsx
136. C:\MyCode\Konnaxionv14\frontend\modules\konsultations\pages\SuggestionPage.tsx
137. C:\MyCode\Konnaxionv14\frontend\modules\kontact\components\index.ts
138. C:\MyCode\Konnaxionv14\frontend\modules\kontact\components\OpportunityList.tsx
139. C:\MyCode\Konnaxionv14\frontend\modules\kontact\components\ProfileCard.tsx
140. C:\MyCode\Konnaxionv14\frontend\modules\kontact\hooks\index.ts
141. C:\MyCode\Konnaxionv14\frontend\modules\kontact\hooks\useOpportunities.ts
142. C:\MyCode\Konnaxionv14\frontend\modules\kontact\hooks\useProfiles.ts
143. C:\MyCode\Konnaxionv14\frontend\modules\kontact\pages\ConnectCenter.tsx
144. C:\MyCode\Konnaxionv14\frontend\modules\kontact\pages\index.ts
145. C:\MyCode\Konnaxionv14\frontend\modules\kontact\pages\PublicProfile.tsx
146. C:\MyCode\Konnaxionv14\frontend\modules\kreative\collaborative-spaces\find-spaces\components\CommonWidget\page.tsx
147. C:\MyCode\Konnaxionv14\frontend\modules\kreative\collaborative-spaces\my-spaces\components\CommonWidget\page.tsx
148. C:\MyCode\Konnaxionv14\frontend\modules\kreative\collaborative-spaces\start-new-space\components\CommonWidget\page.tsx
149. C:\MyCode\Konnaxionv14\frontend\modules\kreative\community-showcases\featured-projects\components\CommonWidget\page.tsx
150. C:\MyCode\Konnaxionv14\frontend\modules\kreative\community-showcases\submit-to-showcase\components\CommonWidget\page.tsx
151. C:\MyCode\Konnaxionv14\frontend\modules\kreative\community-showcases\top-creators\components\CommonWidget\page.tsx
152. C:\MyCode\Konnaxionv14\frontend\modules\kreative\creative-hub\explore-ideas\components\CommonWidget\page.tsx
153. C:\MyCode\Konnaxionv14\frontend\modules\kreative\creative-hub\inspiration-gallery\components\CommonWidget\page.tsx
154. C:\MyCode\Konnaxionv14\frontend\modules\kreative\creative-hub\submit-creative-work\components\CommonWidget\page.tsx
155. C:\MyCode\Konnaxionv14\frontend\modules\kreative\dashboard\components\CommonWidget\page.tsx
156. C:\MyCode\Konnaxionv14\frontend\modules\kreative\idea-incubator\collaborate-on-ideas\components\CommonWidget\page.tsx
157. C:\MyCode\Konnaxionv14\frontend\modules\kreative\idea-incubator\create-new-idea\components\CommonWidget\page.tsx
158. C:\MyCode\Konnaxionv14\frontend\modules\kreative\idea-incubator\my-ideas\components\CommonWidget\page.tsx
===== END TOC =====


===== BEGIN modules/admin/components/index.ts =====
﻿export { default as ModerationQueue } from "./ModerationQueue";
export { default as UserStats       } from "./UserStats";

===== END modules/admin/components/index.ts =====


===== BEGIN modules/admin/components/ModerationQueue.tsx =====
﻿"use client";
import React from "react";
import { Card, List, Spin, Alert, Tag } from "antd";
import useModeration, { ModerationItem } from "@/admin/hooks/useModeration";

function ModerationQueue() {
  const { data, isLoading, isError, error } = useModeration();

  if (isLoading) return <Spin />;
  if (isError) return <Alert message={error.message} type="error" />;

  return (
    <Card title="Moderation Queue" style={{ marginTop: 16 }}>
      <List<ModerationItem>
        itemLayout="vertical"
        dataSource={data}
        renderItem={(item) => (
          <List.Item key={item.id}>
            <List.Item.Meta
              title={
                <>
                  <Tag>{item.type}</Tag> by {item.userId}
                </>
              }
              description={new Date(item.createdAt).toLocaleString()}
            />
            <p>{item.content}</p>
            <p>
              <strong>Reason:</strong> {item.reason}
            </p>
          </List.Item>
        )}
      />
    </Card>
  );
}

export default ModerationQueue;

===== END modules/admin/components/ModerationQueue.tsx =====


===== BEGIN modules/admin/components/UserStats.tsx =====
"use client";
import React from "react";
import { Card, Descriptions, Spin, Alert } from "antd";
import useStats from "@/admin/hooks/useStats";

export default function UserStats() {
  const { data, isLoading, isError, error } = useStats();
  if (isLoading) return <Spin />;
  if (isError)   return <Alert message={error.message} type="error" />;
  if (!data)     return null;                         // TS18048 safe‑guard

  return (
    <Card title="User Statistics">
      <Descriptions column={1}>
        <Descriptions.Item label="Total users">{data.totalUsers}</Descriptions.Item>
        <Descriptions.Item label="Active users">{data.activeUsers}</Descriptions.Item>
        {data.newUsers != null && (
          <Descriptions.Item label="New users (24 h)">
            {data.newUsers}
          </Descriptions.Item>
        )}
      </Descriptions>
    </Card>
  );
}

===== END modules/admin/components/UserStats.tsx =====


===== BEGIN modules/admin/hooks/index.ts =====
﻿export { default as useModeration } from "./useModeration";
export { default as useStats       } from "./useStats";

===== END modules/admin/hooks/index.ts =====


===== BEGIN modules/admin/hooks/useModeration.ts =====
﻿import { useQuery } from "@tanstack/react-query";
import { api } from "@/shared/api";

export interface ModerationItem {
  id: string;
  type: string;
  content: string;
  reason: string;
  userId: string;
  createdAt: string;
}

export default function useModeration() {
  return useQuery<ModerationItem[], Error>({
    queryKey: ["admin-moderation"],
    queryFn: async () =>
      (await api.get<ModerationItem[]>("/api/admin/moderation")).data,
    staleTime: 2 * 60_000,
    retry: 1,
  });
}

===== END modules/admin/hooks/useModeration.ts =====


===== BEGIN modules/admin/hooks/useModeration.ts.bak =====
﻿import { useQuery } from "@tanstack/react-query";
import { api } from "@/shared/api";

export interface ModerationItem {
  id: string;
  type: string;
  content: string;
  reason: string;
  userId: string;
  createdAt: string;
}

export default function useModeration() {
  return useQuery<ModerationItem[], Error>({
    queryKey: ["admin-moderation"],
    queryFn: async () =>
      (await api.get<ModerationItem[]>("/admin/moderation")).data,
    staleTime: 2 * 60_000,
    retry: 1,
  });
}

===== END modules/admin/hooks/useModeration.ts.bak =====


===== BEGIN modules/admin/hooks/useStats.ts =====
﻿import { useQuery } from "@tanstack/react-query";
import { api } from "@/shared/api";

export interface AdminStats {
  totalUsers: number;
  activeUsers: number;
  newUsers?: number;
}

export default function useStats() {
  return useQuery<AdminStats, Error>({
    queryKey: ["admin-stats"],
    queryFn: async () => (await api.get<AdminStats>("/api/admin/stats")).data,
    staleTime: 5 * 60_000,
    retry: 1,
  });
}

===== END modules/admin/hooks/useStats.ts =====


===== BEGIN modules/admin/pages/AdminConsole.tsx =====
"use client";
import React from "react";
import AppShell from "@/global/components/AppShell";
import { ModerationQueue, UserStats } from "@/admin/components";

export default function AdminConsole() {
  return (
    <AppShell>
      <main className="container mx-auto p-8">
        <h1 className="text-2xl font-bold mb-6">Admin Console</h1>
        <div className="grid gap-6 md:grid-cols-2">
          <UserStats />
          <ModerationQueue />
        </div>
      </main>
    </AppShell>
  );
}

===== END modules/admin/pages/AdminConsole.tsx =====


===== BEGIN modules/admin/pages/index.ts =====
export { default as AdminConsole } from './AdminConsole';

===== END modules/admin/pages/index.ts =====


===== BEGIN modules/concatv3.py =====
#!/usr/bin/env python3
"""
Concatène tous les fichiers texte du dossier du script et de ses sous-dossiers.
Par défaut, écrit le résultat dans "Code_<nom_dossier>_<YYYYMMDD_HHMMSS>.txt" à la racine du script.
"""

from __future__ import annotations
import argparse
import fnmatch
import os
from pathlib import Path
from typing import Set, List, Optional
from datetime import datetime

DEFAULT_EXTS: Set[str] = {
    ".tx", ".md", ".markdown",
    ".json", ".yaml", ".yml", ".xml", ".toml", ".ini", ".cfg", ".conf", ".properties",
    ".html", ".htm", ".css", ".scss", ".less",
    ".js", ".jsx", ".ts", ".tsx", ".mjs", ".cjs",
    ".py", ".pyi", ".ipynb",
    ".java", ".kt", ".swift", ".rb", ".php", ".go", ".rs",
    ".c", ".h", ".cpp", ".cc", ".hpp", ".cs",
    ".sql",
    ".sh", ".bash", ".zsh", ".fish", ".ps1", ".bat",
    ".tex", ".bib",
    ".graphql", ".gql",
    ".gradle",
    ".pl", ".lua", ".r",
    ".env",
}

NAMES_WITHOUT_EXT: Set[str] = {
    "Dockerfile", "Makefile", "CMakeLists.txt",
    ".gitignore", ".gitattributes", ".editorconfig",
    "Procfile", "Gemfile", "requirements.txt", "Pipfile", "poetry.lock",
    "package.json", "package-lock.json", "yarn.lock", "pnpm-lock.yaml",
    "tsconfig.json", "eslint.config.js", ".eslintrc", ".prettierrc",
}

DEFAULT_EXCLUDE_DIRS: Set[str] = {
    ".git", ".hg", ".svn",
    "node_modules", ".next", ".nuxt",
    "dist", "build", "out", "coverage", ".cache",
    ".venv", "venv", "__pycache__",
    "target", "bin", "obj",
}


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Concatène les fichiers texte du projet dans un seul fichier.")
    p.add_argument("-o", "--out", default=None, help="Fichier de sortie (facultatif)")
    p.add_argument("--ext", help="Extensions additionnelles ou personnalisées, séparées par des virgules")
    p.add_argument("--include", action="append", default=[], help="Glob d'inclusion relatif à la racine (répétable)")
    p.add_argument("--exclude", action="append", default=[], help="Glob d'exclusion relatif à la racine (répétable)")
    p.add_argument("--max-size", type=int, default=2_000_000, help="Taille max par fichier en octets")
    p.add_argument("--no-headers", action="store_true", help="Ne pas imprimer d'entêtes par fichier")
    return p.parse_args()


def normalize_exts(exts_csv: Optional[str]) -> Set[str]:
    if not exts_csv:
        return set(DEFAULT_EXTS)
    parts = [e.strip().lower() for e in exts_csv.split(",") if e.strip()]
    normed = set()
    for e in parts:
        if not e.startswith("."):
            e = "." + e
        normed.add(e)
    return normed


def is_probably_text(sample: bytes) -> bool:
    if not sample:
        return True
    if b"\x00" in sample:
        return False
    try:
        sample.decode("utf-8")
        return True
    except UnicodeDecodeError:
        pass
    ctrl_hits = 0
    for b in sample:
        if b < 32 and b not in (9, 10, 13):
            ctrl_hits += 1
    return (ctrl_hits / max(1, len(sample))) < 0.01


def pick_encoding(path: Path) -> Optional[str]:
    try:
        with path.open("rb") as f:
            sample = f.read(32768)
    except Exception:
        return None
    if not is_probably_text(sample):
        return None
    for enc in ("utf-8", "utf-8-sig", "utf-16", "cp1252", "latin-1"):
        try:
            sample.decode(enc)
            return enc
        except UnicodeDecodeError:
            continue
    return "latin-1"


def relpath(base: Path, p: Path) -> str:
    try:
        return str(p.relative_to(base))
    except Exception:
        return str(p)


def should_include_file(base: Path, file_path: Path, allowed_exts: Set[str],
                        include_globs: List[str], exclude_globs: List[str],
                        max_size: int, out_path: Path) -> bool:
    if not file_path.is_file():
        return False
    if file_path == out_path:
        return False
    if file_path.suffix.lower() == ".txt":
        return False
    try:
        if file_path.stat().st_size > max_size:
            return False
    except Exception:
        return False
    rel = relpath(base, file_path)
    for pat in exclude_globs:
        if fnmatch.fnmatch(rel, pat):
            return False
    if include_globs:
        ok = any(fnmatch.fnmatch(rel, pat) for pat in include_globs)
        if not ok:
            return False
    if file_path.suffix.lower() in allowed_exts or file_path.name in NAMES_WITHOUT_EXT:
        return True
    enc = pick_encoding(file_path)
    return enc is not None


def main() -> None:
    args = parse_args()
    base_dir = Path(__file__).resolve().parent
    self_path = Path(__file__).resolve()

    if args.out:
        out_path = (base_dir / args.out).resolve()
    else:
        stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        out_name = f"Code_{base_dir.name}_{stamp}.txt"
        out_path = (base_dir / out_name).resolve()

    allowed_exts = normalize_exts(args.ext)
    include_globs = list(args.include or [])
    exclude_globs = list(args.exclude or [])

    selected: List[Path] = []
    for root, dirs, files in os.walk(base_dir, followlinks=False):
        dirs[:] = [d for d in dirs if d not in DEFAULT_EXCLUDE_DIRS]
        root_path = Path(root)
        for name in files:
            fp = root_path / name
            # exclure le script exécuté lui-même
            try:
                if fp.resolve() == self_path:
                    continue
            except Exception:
                pass
            if should_include_file(base_dir, fp, allowed_exts, include_globs, exclude_globs, args.max_size, out_path):
                selected.append(fp)

    selected.sort(key=lambda p: relpath(base_dir, p).lower())
    out_path.parent.mkdir(parents=True, exist_ok=True)

    with out_path.open("w", encoding="utf-8", newline="\n") as out:
        for p in selected:
            enc = pick_encoding(p) or "utf-8"
            if not args.no_headers:
                out.write(f"\n===== BEGIN {relpath(base_dir, p)} =====\n")
            try:
                with p.open("r", encoding=enc, errors="strict") as f:
                    for line in f:
                        out.write(line)
            except UnicodeDecodeError:
                with p.open("r", encoding="latin-1", errors="replace") as f:
                    for line in f:
                        out.write(line)
            if not args.no_headers:
                out.write(f"\n===== END {relpath(base_dir, p)} =====\n")
            out.write("\n")

    print(f"{len(selected)} fichier(s) concaténé(s) -> {relpath(base_dir, out_path)}")


if __name__ == "__main__":
    main()

===== END modules/concatv3.py =====


===== BEGIN modules/ekoh/achievements-badges/earned-badges-display/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/ekoh/achievements-badges/earned-badges-display/components/CommonWidget/page.tsx =====


===== BEGIN modules/ekoh/dashboard/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/ekoh/dashboard/components/CommonWidget/page.tsx =====


===== BEGIN modules/ekoh/expertise-areas/view-current-expertise/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/ekoh/expertise-areas/view-current-expertise/components/CommonWidget/page.tsx =====


===== BEGIN modules/ekoh/overview-analytics/current-ekoh-score/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/ekoh/overview-analytics/current-ekoh-score/components/CommonWidget/page.tsx =====


===== BEGIN modules/ekoh/voting-influence/current-voting-weight/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/ekoh/voting-influence/current-voting-weight/components/CommonWidget/page.tsx =====


===== BEGIN modules/ethikos/admin/audit/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\modules\ethikos\admin\audit\page.tsx
'use client';

import { PageContainer, ProTable, type ProColumns } from '@ant-design/pro-components';
import { Tag } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchAuditLogs, type LogRow } from '@/services/audit';

export default function AuditLogs() {
  usePageTitle('Admin · Audit Logs');

  const { data, loading } = useRequest(fetchAuditLogs);

  const columns: ProColumns<LogRow>[] = [
    {
      title: 'Time',
      dataIndex: 'ts',
      valueType: 'dateTime',
      width: 180,
      sorter: true,
    },
    {
      title: 'Actor',
      dataIndex: 'actor',
      width: 120,
    },
    {
      title: 'Action',
      dataIndex: 'action',
      width: 200,
    },
    {
      title: 'Target',
      dataIndex: 'target',
      ellipsis: true,
    },
    {
      title: 'Severity',
      dataIndex: 'severity',
      width: 120,
      render: (_, row) => (
        <Tag
          color={
            row.severity === 'critical'
              ? 'red'
              : row.severity === 'warn'
              ? 'orange'
              : 'blue'
          }
        >
          {row.severity}
        </Tag>
      ),
      filters: [
        { text: 'Info', value: 'info' },
        { text: 'Warn', value: 'warn' },
        { text: 'Critical', value: 'critical' },
      ],
      onFilter: (value, record) => record.severity === value,
    },
  ];

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<LogRow>
        rowKey="id"
        columns={columns}
        dataSource={data?.items}
        pagination={{ pageSize: 15 }}
        search={false}
      />
    </PageContainer>
  );
}

===== END modules/ethikos/admin/audit/page.tsx =====


===== BEGIN modules/ethikos/admin/moderation/page.tsx =====
'use client'

import { PageContainer, ProTable } from '@ant-design/pro-components'
import type { ProColumns } from '@ant-design/pro-components'
import { Tag, Popconfirm, Button } from 'antd'
import { useRequest } from 'ahooks'
import usePageTitle from '@/hooks/usePageTitle'
import { fetchModerationQueue, actOnReport } from '@/services/admin'

type Report = {
  id: string
  content: string
  reporter: string
  type: 'Spam' | 'Harassment' | 'Misinformation'
  status: 'Pending' | 'Resolved'
}

type ModerationPayload = { items: Report[] }

export default function Moderation() {
  usePageTitle('Admin · Moderation')

  const { data, loading, mutate } = useRequest<ModerationPayload, []>(
    async () => await fetchModerationQueue()
  )

  const handleModeration = async (id: string, approve: boolean) => {
    await actOnReport(id, approve)
    await mutate()
  }

  const columns: ProColumns<Report>[] = [
    { title: 'Content', dataIndex: 'content', ellipsis: true },
    { title: 'Reporter', dataIndex: 'reporter', width: 120 },
    {
      title: 'Type',
      dataIndex: 'type',
      width: 140,
      render: (_, row) => <Tag color="orange">{row.type}</Tag>,
      filters: [
        { text: 'Spam', value: 'Spam' },
        { text: 'Harassment', value: 'Harassment' },
        { text: 'Misinformation', value: 'Misinformation' },
      ],
      onFilter: (val, row) => row.type === (val as Report['type']),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      width: 120,
      render: (_, row) => (
        <Tag color={row.status === 'Pending' ? 'gold' : 'green'}>{row.status}</Tag>
      ),
      filters: [
        { text: 'Pending', value: 'Pending' },
        { text: 'Resolved', value: 'Resolved' },
      ],
      onFilter: (val, row) => row.status === (val as Report['status']),
    },
    {
      title: 'Actions',
      width: 180,
      render: (_, row) =>
        row.status === 'Pending' ? (
          <>
            <Popconfirm title="Remove content?" onConfirm={() => handleModeration(row.id, true)}>
              <Button size="small" danger>Remove</Button>
            </Popconfirm>
            <Popconfirm title="Dismiss report?" onConfirm={() => handleModeration(row.id, false)}>
              <Button size="small" style={{ marginLeft: 8 }}>Dismiss</Button>
            </Popconfirm>
          </>
        ) : null,
    },
  ]

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<Report>
        rowKey="id"
        columns={columns}
        dataSource={data?.items ?? []}
        pagination={{ pageSize: 10 }}
        search={false}
      />
    </PageContainer>
  )
}

===== END modules/ethikos/admin/moderation/page.tsx =====


===== BEGIN modules/ethikos/admin/roles/page.tsx =====
'use client'

import type { ReactNode } from 'react'
import { PageContainer, ProTable } from '@ant-design/pro-components'
import type { ProColumns } from '@ant-design/pro-components'
import { Switch, Tag } from 'antd'
import { useRequest } from 'ahooks'
import usePageTitle from '@/hooks/usePageTitle'
import { fetchRoles, toggleRole, type RoleRow, type RolePayload } from '@/services/admin'

export default function RoleManagement() {
  usePageTitle('Admin · Role Management')

  // Fix TS2558: ahooks v3 expects 2 generics: <Data, ParamsTuple>
  // No params → params tuple is []
  const { data, loading, refresh } = useRequest<RolePayload, []>(fetchRoles)

  const columns: ProColumns<RoleRow>[] = [
    { title: 'Role', dataIndex: 'name', width: 200 },
    {
      title: 'Users',
      dataIndex: 'userCount',
      width: 100,
      render: (dom: ReactNode) => <Tag>{dom}</Tag>,
    },
    {
      title: 'Enabled',
      dataIndex: 'enabled',
      width: 120,
      render: (_: ReactNode, row: RoleRow) => (
        <Switch
          checked={row.enabled}
          onChange={async (checked: boolean) => {
            await toggleRole(row.id, checked)
            refresh() // typed as () => void by ahooks
          }}
        />
      ),
    },
  ]

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<RoleRow>
        rowKey="id"
        columns={columns}
        dataSource={data?.items ?? []}
        pagination={false}
        search={false}
      />
    </PageContainer>
  )
}

===== END modules/ethikos/admin/roles/page.tsx =====


===== BEGIN modules/ethikos/decide/elite/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\modules\ethikos\decide\elite\page.tsx
// Code d’origine récupéré depuis le dump (File #22). :contentReference[oaicite:0]{index=0}

'use client';

import { PageContainer, ProTable } from '@ant-design/pro-components';
import type { ProColumns } from '@ant-design/pro-components';
import { Progress, Statistic } from 'antd';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchEliteBallots } from '@/services/decide';
import type { Ballot } from '@/types';

type BallotRow = Ballot & { turnout: number };

export default function EliteBallots(): JSX.Element {
  usePageTitle('Decide · Elite Ballots');

  const { data, loading } = useRequest(fetchEliteBallots);

  const columns: ProColumns<BallotRow>[] = [
    { title: 'Title', dataIndex: 'title', width: 260 },
    {
      title: 'Closes In',
      dataIndex: 'closesAt',
      width: 180,
      // ProTable render signature: (dom, entity, index, action, schema)
      render: (_dom, record) => (
        <Statistic.Countdown
          value={dayjs(record.closesAt).valueOf()}
          format="D[d] HH:mm:ss"
        />
      ),
    },
    {
      title: 'Turnout',
      dataIndex: 'turnout',
      width: 160,
      // ProTable render signature: (dom, entity, index, action, schema)
      render: (_dom, record) => <Progress type="circle" percent={record.turnout} />,
    },
    { title: 'Scope', dataIndex: 'scope', width: 100 },
  ];

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<BallotRow>
        rowKey="id"
        columns={columns}
        dataSource={data?.ballots as BallotRow[] | undefined}
        pagination={{ pageSize: 8 }}
        search={false}
      />
    </PageContainer>
  );
}

===== END modules/ethikos/decide/elite/page.tsx =====


===== BEGIN modules/ethikos/decide/methodology/page.tsx =====
'use client'

import { PageContainer } from '@ant-design/pro-components';
import { Typography, Collapse, Steps, Alert } from 'antd';
import usePageTitle from '@/hooks/usePageTitle';

export default function Methodology() {
  usePageTitle('Decide · Methodology');

  return (
    <PageContainer ghost>
      <Typography.Title>How We Count Votes</Typography.Title>

      <Collapse
        items={[
          {
            key: 'weighting',
            label: '1 · Stake-weighted counting',
            children: (
              <Typography.Paragraph>
                Each ballot is tallied with quadratic weighting to dampen plutocratic influence…
              </Typography.Paragraph>
            ),
          },
          {
            key: 'verification',
            label: '2 · Identity verification',
            children: (
              <Typography.Paragraph>
                Voters authenticate via the Desjardins meritocratic ID layer…
              </Typography.Paragraph>
            ),
          },
        ]}
      />

      <Steps
        current={3}
        items={[
          { title: 'Propose' },
          { title: 'Deliberate' },
          { title: 'Vote' },
          { title: 'Audit' },
        ]}
        style={{ marginTop: 40 }}
      />

      <Alert
        type="info"
        message="Open data"
        description="Raw ballots are published (SHA-256 hashed) after a 72-hour cooling-off period."
        showIcon
        style={{ marginTop: 24 }}
      />
    </PageContainer>
  );
}

===== END modules/ethikos/decide/methodology/page.tsx =====


===== BEGIN modules/ethikos/decide/public/page.tsx =====
'use client'

import React, { useEffect, useState } from 'react'
import { PageContainer, ProTable } from '@ant-design/pro-components'
import type { ProColumns } from '@ant-design/pro-components'
import { Select, Space, Input, Popconfirm, Progress, Radio, Slider } from 'antd'
import axios from 'axios'
import usePageTitle from '@/hooks/usePageTitle'

interface Category { id: number; name: string }
interface Format   { id: number; name: string }
interface PublicTopic {
  id: number
  question: string
  description?: string
  debatecategory_id: number
  responseformat_id: number
  turnout?: number
  options?: string[]
  scaleLabels?: string[]
}

export default function PublicVotePage(): JSX.Element {
  usePageTitle('Decide · Public Voting')

  const [categories, setCategories] = useState<Category[]>([])
  const [formats, setFormats]       = useState<Format[]>([])
  const [topicsData, setTopicsData] = useState<{ results: PublicTopic[]; count: number } | null>(null)
  const [activeCat, setActiveCat]   = useState<number | 'all'>('all')
  const [activeFormats, setActiveFormats] = useState<number[]>([])
  const [searchTerm, setSearchTerm] = useState<string>('')
  const [page, setPage]             = useState<number>(1)
  const pageSize = 20

  // 1) Load categories & formats
  useEffect(() => {
    axios
      .get<Category[]>('/api/home/debatecategory/', { params: { is_deleted: false } })
      .then(r => setCategories(r.data))
    axios
      .get<Format[]>('/api/home/responseformat/', { params: { is_deleted: false } })
      .then(r => setFormats(r.data))
  }, [])

  // 2) Load topics with filters & pagination
  useEffect(() => {
    axios
      .get<{ results: PublicTopic[]; count: number }>('/api/home/debatetopic/', {
        params: {
          is_active: true,
          is_deleted: false,
          debatecategory_id: activeCat === 'all' ? undefined : activeCat,
          responseformat_id: activeFormats,
          search: searchTerm,
          page,
          page_size: pageSize,
          ordering: '-created_at',
        },
      })
      .then(r => setTopicsData(r.data))
  }, [activeCat, activeFormats, searchTerm, page])

  // 3) Submit a vote and refresh
  const vote = async (row: PublicTopic, value: any) => {
    await axios.post('/api/home/publicvote/', { topic_id: row.id, value })
    // refresh current page
    axios
      .get<{ results: PublicTopic[]; count: number }>('/api/home/debatetopic/', {
        params: {
          is_active: true,
          is_deleted: false,
          debatecategory_id: activeCat === 'all' ? undefined : activeCat,
          responseformat_id: activeFormats,
          search: searchTerm,
          page,
          page_size: pageSize,
          ordering: '-created_at',
        },
      })
      .then(r => setTopicsData(r.data))
  }

  // 4) Render vote input based on format
  const renderVoteInput = (row: PublicTopic): React.ReactNode => {
    const handleChange = (e: any) => {
      const val = e?.target?.value ?? e
      vote(row, val)
    }

    switch (row.responseformat_id) {
      case 1: // binary (Yes/No)
        return (
          <Radio.Group
            options={(row.options ?? ['Yes', 'No']).map(v => ({ label: v, value: v }))}
            onChange={handleChange}
          />
        )

      case 2: // multiple choice (single-pick UI here; adapt if you support multi-pick)
        return (
          <Radio.Group
            options={(row.options ?? []).map(v => ({ label: v, value: v }))}
            onChange={handleChange}
          />
        )

      case 3: { // scale
        const labels = row.scaleLabels ?? ['1', '2', '3', '4', '5']
        const formatter: (v?: number) => React.ReactNode = (v) => {
          const i = Math.max(0, Math.min(labels.length - 1, Number(v ?? 0)))
          return labels[i]
        }
        return (
          <Space direction="vertical" size={4}>
            <Slider
              min={0}
              max={labels.length - 1}
              step={1}
              tooltip={{ formatter }}
              onAfterChange={handleChange}
            />
          </Space>
        )
      }

      default:
        return null
    }
  }

  // 5) Columns (typed; ProTable render signature respected)
  const columns: ProColumns<PublicTopic>[] = [
    { title: 'Question', dataIndex: 'question', width: 360, ellipsis: true },
    {
      title: 'Vote',
      key: 'vote',
      width: 360,
      search: false,
      render: (_dom, row) => (
        <Popconfirm title="Confirm your vote?" onConfirm={() => {}}>
          {renderVoteInput(row)}
        </Popconfirm>
      ),
    },
    {
      title: 'Turnout',
      dataIndex: 'turnout',
      align: 'center',
      width: 160,
      render: (_dom, row) => <Progress percent={row.turnout ?? 0} size="small" />,
    },
  ]

  return (
    <PageContainer ghost>
      <Space wrap style={{ marginBottom: 16 }}>
        <Select
          placeholder="Catégorie"
          allowClear
          value={activeCat}
          onChange={(val) => { setActiveCat((val ?? 'all') as any); setPage(1) }}
          style={{ width: 200 }}
          options={[
            { label: 'All', value: 'all' as const },
            ...categories.map(c => ({ label: c.name, value: c.id })),
          ]}
        />
        <Select
          mode="multiple"
          placeholder="Formats"
          value={activeFormats}
          onChange={(val: number[]) => { setActiveFormats(val); setPage(1) }}
          style={{ width: 200 }}
          options={formats.map(f => ({ label: f.name, value: f.id }))}
        />
        <Input.Search
          placeholder="Rechercher…"
          onSearch={val => { setSearchTerm(val); setPage(1) }}
          style={{ width: 260 }}
          allowClear
        />
      </Space>

      <ProTable<PublicTopic>
        rowKey="id"
        columns={columns}
        dataSource={topicsData?.results ?? []}
        pagination={{
          total: topicsData?.count ?? 0,
          current: page,
          pageSize,
          onChange: setPage,
          showSizeChanger: false,
        }}
        search={false}
        options={false}
        toolBarRender={false}
      />
    </PageContainer>
  )
}

===== END modules/ethikos/decide/public/page.tsx =====


===== BEGIN modules/ethikos/decide/results/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\modules\ethikos\decide\results\page.tsx
'use client'

import React from 'react'
import { PageContainer, ProTable, type ProColumns } from '@ant-design/pro-components'
import { Tag } from 'antd'
import { useRequest } from 'ahooks'
import usePageTitle from '@/hooks/usePageTitle'
import { fetchDecisionResults } from '@/services/decide'

type ResultRow = {
  id: string
  title: string
  scope: 'Elite' | 'Public'
  passed: boolean
  closesAt: string
  region: string
}

export default function ResultsArchive() {
  usePageTitle('Decide · Results Archive')

  const { data, loading } = useRequest(fetchDecisionResults)

  // Build dynamic region filters from payload
  const regionFilters = React.useMemo(
    () =>
      Array.from(
        new Set(((data?.items as ResultRow[] | undefined) ?? []).map((r) => r.region).filter(Boolean)),
      ).map((r) => ({ text: String(r), value: String(r) })),
    [data?.items],
  )

  const scopeFilters = React.useMemo(
    () => [
      { text: 'Elite', value: 'Elite' },
      { text: 'Public', value: 'Public' },
    ],
    [],
  )

  const columns: ProColumns<ResultRow>[] = [
    { title: 'Title', dataIndex: 'title', width: 260 },
    {
      title: 'Result',
      dataIndex: 'passed',
      width: 120,
      render: (_, row) => (
        <Tag color={row.passed ? 'green' : 'red'}>{row.passed ? 'PASSED' : 'REJECTED'}</Tag>
      ),
      // replace invalid `filters: true` with proper options
      filters: [
        { text: 'Passed', value: true },
        { text: 'Rejected', value: false },
      ],
      // onFilter receives React.Key | boolean; compare strictly to row.passed
      onFilter: (value, row) => row.passed === (value === true || value === 'true'),
    },
    {
      title: 'Scope',
      dataIndex: 'scope',
      width: 120,
      filters: scopeFilters,
      onFilter: (value, row) => row.scope === String(value),
      valueEnum: {
        Elite: { text: 'Elite' },
        Public: { text: 'Public' },
      },
    },
    {
      title: 'Region',
      dataIndex: 'region',
      width: 140,
      filters: regionFilters,
      onFilter: (value, row) => row.region === String(value),
    },
    // use a valid ProComponents valueType
    { title: 'Closed', dataIndex: 'closesAt', valueType: 'dateTime' },
  ]

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<ResultRow>
        rowKey="id"
        columns={columns}
        dataSource={(data?.items as ResultRow[] | undefined) ?? []}
        pagination={{ pageSize: 10 }}
        search={false}
      />
    </PageContainer>
  )
}

===== END modules/ethikos/decide/results/page.tsx =====


===== BEGIN modules/ethikos/deliberate/[topic]/page.tsx =====
'use client';

import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Timeline, Typography } from 'antd';
import { useParams } from 'next/navigation';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchTopicDetail } from '@/services/deliberate';

// Typage dérivé du service pour rester aligné sur la source.
type TopicDetail = Awaited<ReturnType<typeof fetchTopicDetail>>;
type Statement = TopicDetail['statements'][number];

export default function TopicDetailPage() {
  const params = useParams<{ topic: string }>();
  const topicParam = params?.topic;
  const topicId =
    typeof topicParam === 'string'
      ? topicParam
      : Array.isArray(topicParam)
      ? topicParam[0]
      : undefined;

  usePageTitle(`Deliberate · ${topicId ?? ''}`);

  // FIX: useRequest attend 2 génériques <TData, TParams>. Le service n'a pas de paramètres => [].
  const { data, loading } = useRequest<TopicDetail, []>(
    () => fetchTopicDetail(topicId!),
    { ready: !!topicId, refreshDeps: [topicId] },
  );

  return (
    <PageContainer ghost loading={loading}>
      <Typography.Title level={3}>{data?.title ?? 'Topic'}</Typography.Title>

      <ProCard title="Statements Thread" ghost>
        <Timeline
          items={(data?.statements ?? []).map((s) => ({
            key: s.id,
            children: <StatementItem s={s} />,
          }))}
        />
      </ProCard>
    </PageContainer>
  );
}

function StatementItem({ s }: { s: Statement }) {
  return (
    <div>
      <div style={{ display: 'flex', gap: 8, alignItems: 'baseline' }}>
        <Typography.Text strong>{s.author}</Typography.Text>
        <Typography.Text type="secondary">
          {new Date(s.createdAt).toLocaleString()}
        </Typography.Text>
      </div>
      <Typography.Paragraph style={{ marginTop: 4, marginBottom: 0 }}>
        {s.body}
      </Typography.Paragraph>
    </div>
  );
}

===== END modules/ethikos/deliberate/[topic]/page.tsx =====


===== BEGIN modules/ethikos/deliberate/elite/page.tsx =====
'use client';

import React from 'react';
import {
  PageContainer,
  ProCard,
  ProTable,
  StatisticCard,
  ModalForm,
  ProFormText,
  ProFormSelect,
  type ProColumns,
} from '@ant-design/pro-components';
import { Button, Drawer, Empty, Space, Tag, Tooltip, message as antdMessage } from 'antd';
import { PlusOutlined, ReloadOutlined, FireOutlined } from '@ant-design/icons';
import { useRequest, useInterval } from 'ahooks';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';

import usePageTitle from '@/hooks/usePageTitle';
import { fetchEliteTopics, createEliteTopic, fetchTopicPreview } from '@/services/deliberate';
import type { Topic } from '@/types';

dayjs.extend(relativeTime);

/* ------------------------------------------------------------------ */
/*  Types                                                              */
/* ------------------------------------------------------------------ */

interface TopicRow extends Topic {
  createdAt: string;
  lastActivity: string;
  hot: boolean;
  stanceCount: number;
}

type TopicPreview = {
  id: string;
  title: string;
  category: string;
  createdAt: string;
  latest: Array<{ id: string; author: string; body: string }>;
};

/* ------------------------------------------------------------------ */
/*  Composant principal                                                */
/* ------------------------------------------------------------------ */

export default function EliteAgora() {
  usePageTitle('Deliberate · Elite Agora');

  // Service wrapper pour garantir { list: TopicRow[] } au typage de useRequest
  const eliteTopicsService = React.useCallback(async (): Promise<{ list: TopicRow[] }> => {
    const res = await fetchEliteTopics();
    return {
      list: (res?.list ?? []).map((t: any) => ({
        ...t,
        stanceCount: typeof t?.stanceCount === 'number' ? t.stanceCount : 0,
      })) as TopicRow[],
    };
  }, []);

  // useRequest<TData, TParams>. Pas de params -> [].
  const { data, loading, refresh } = useRequest<{ list: TopicRow[] }, []>(eliteTopicsService);
  useInterval(refresh, 60_000);

  /* ---------- drawer preview ---------- */
  const [previewId, setPreviewId] = React.useState<string | null>(null);
  const {
    data: preview,
    loading: previewLoading,
    run: loadPreview,
  } = useRequest<TopicPreview, [string]>(fetchTopicPreview, { manual: true });

  const openPreview = React.useCallback(
    (row: TopicRow) => {
      setPreviewId(row.id);
      loadPreview(row.id);
    },
    [loadPreview],
  );

  /* ---------- KPI header ---------- */
  const headerStats = React.useMemo(
    () => [
      { label: 'Open topics', value: data?.list.length ?? 0 },
      {
        label: 'Avg stances / topic',
        value: data?.list?.length
          ? Math.round(
              data!.list.reduce((sum: number, t: TopicRow) => sum + (t.stanceCount ?? 0), 0) /
                data!.list.length,
            )
          : 0,
      },
      { label: 'Hot topics', value: (data?.list ?? []).filter((t: TopicRow) => t.hot).length },
    ],
    [data],
  );

  /* ---------- filtres de catégorie ---------- */
  const categoryFilters = React.useMemo(
    () =>
      Array.from(
        new Set((data?.list ?? []).map((t: TopicRow) => t.category).filter(Boolean)),
      ).map((c) => ({ text: String(c), value: String(c) })),
    [data?.list],
  );

  /* ---------- colonnes ---------- */
  const columns: ProColumns<TopicRow>[] = React.useMemo(
    () => [
      {
        title: 'Title',
        dataIndex: 'title',
        render: (_, row) => (
          <a onClick={() => openPreview(row)} style={{ cursor: 'pointer' }}>
            {row.title}
          </a>
        ),
      },
      {
        title: 'Category',
        dataIndex: 'category',
        filters: categoryFilters,
        onFilter: (value, record) => String(record.category) === String(value),
        render: (_, row) => <Tag color="geekblue">{row.category}</Tag>,
      },
      {
        title: 'Stances',
        dataIndex: 'stanceCount',
        sorter: true,
        align: 'right',
      },
      {
        title: 'Last activity',
        dataIndex: 'lastActivity',
        // Pas de valueType "fromNow" (non standard). On formate via dayjs.
        render: (_, row) => dayjs(row.lastActivity).fromNow(),
      },
      {
        title: '',
        dataIndex: 'hot',
        width: 60,
        render: (_, row) =>
          row.hot ? (
            <Tooltip title="Trending">
              <FireOutlined style={{ color: '#fa541c' }} />
            </Tooltip>
          ) : null,
      },
    ],
    [categoryFilters, openPreview],
  );

  /* ---------- rendu ---------- */
  return (
    <PageContainer
      ghost
      loading={loading}
      extra={
        <Space>
          <Button icon={<ReloadOutlined />} onClick={refresh} type="text" title="Refresh list" />
          <NewTopicButton onCreated={refresh} />
        </Space>
      }
    >
      {/* KPI */}
      <ProCard gutter={16} wrap style={{ marginBottom: 16 }}>
        {headerStats.map((k) => (
          <StatisticCard
            key={k.label}
            colSpan={{ xs: 24, sm: 8 }}
            statistic={{ title: k.label, value: k.value }}
          />
        ))}
      </ProCard>

      {/* Liste */}
      <ProTable<TopicRow>
        rowKey="id"
        columns={columns}
        dataSource={data?.list}
        search={{ labelWidth: 90, filterType: 'light' }}
        pagination={{ pageSize: 10 }}
      />

      {/* Preview drawer */}
      <Drawer
        width={520}
        open={!!previewId}
        onClose={() => setPreviewId(null)}
        title={preview?.title || 'Preview'}
      >
        {previewLoading ? (
          <Empty description="Loading…" />
        ) : preview ? (
          <>
            <p>
              <strong>Category:</strong> {preview.category}
            </p>
            <p>
              <strong>Opened:</strong> {dayjs(preview.createdAt).format('YYYY-MM-DD HH:mm')}
            </p>
            <h4>Latest statements</h4>
            <ul>
              {preview.latest.map((s) => (
                <li key={s.id}>
                  <em>{s.author}</em> — {s.body}
                </li>
              ))}
            </ul>
            <Button
              type="primary"
              onClick={() => window.location.assign(`/ethikos/deliberate/${preview.id}`)}
            >
              Go to thread →
            </Button>
          </>
        ) : (
          <Empty />
        )}
      </Drawer>
    </PageContainer>
  );
}

/* ------------------------------------------------------------------ */
/*  New Topic modal                                                    */
/* ------------------------------------------------------------------ */

function NewTopicButton({ onCreated }: { onCreated: () => void }) {
  const [visible, setVisible] = React.useState(false);

  // On fige les Params pour typer runAsync correctement
  const { runAsync, loading } = useRequest<unknown, [{ title: string; category: string }]>(
    createEliteTopic,
    {
      manual: true,
      onSuccess: () => {
        antdMessage.success('Topic created 🎉');
        setVisible(false);
        onCreated();
      },
    },
  );

  return (
    <>
      <Button icon={<PlusOutlined />} type="primary" onClick={() => setVisible(true)}>
        New Topic
      </Button>
      <ModalForm<{ title: string; category: string }>
        title="Create new topic"
        open={visible}
        onOpenChange={setVisible}
        onFinish={async (values) => {
          await runAsync(values);
          return true;
        }}
        submitter={{ submitButtonProps: { loading } }}
      >
        <ProFormText name="title" label="Title" rules={[{ required: true, min: 10 }]} />
        <ProFormSelect
          name="category"
          label="Category"
          options={[
            { label: 'AI Policy', value: 'AI Policy' },
            { label: 'Biotech', value: 'Biotech' },
            { label: 'Ethics', value: 'Ethics' },
          ]}
          rules={[{ required: true }]}
        />
      </ModalForm>
    </>
  );
}

===== END modules/ethikos/deliberate/elite/page.tsx =====


===== BEGIN modules/ethikos/deliberate/guidelines/page.tsx =====
'use client'

import { PageContainer } from '@ant-design/pro-components';
import { Typography, Anchor, Divider } from 'antd';
import usePageTitle from '@/hooks/usePageTitle';

export default function Guidelines() {
  usePageTitle('Deliberate · Guidelines');

  return (
    <PageContainer ghost>
      <Anchor
        affix
        items={[
          { key: 'etiquette', href: '#etiquette', title: '1. Etiquette' },
          { key: 'evidence', href: '#evidence', title: '2. Evidence Rules' },
          { key: 'moderation', href: '#moderation', title: '3. Moderation & Appeals' },
        ]}
      />

      <Typography.Title id="etiquette" level={3}>
        1. Etiquette
      </Typography.Title>
      <Typography.Paragraph>
        • Be concise, civil, and on-topic. Personal attacks and profanity are removed.
      </Typography.Paragraph>

      <Divider />

      <Typography.Title id="evidence" level={3}>
        2. Evidence Rules
      </Typography.Title>
      <Typography.Paragraph>
        • Claims must cite peer-reviewed sources or official data. Unsupported assertions can be flagged.
      </Typography.Paragraph>

      <Divider />

      <Typography.Title id="moderation" level={3}>
        3. Moderation & Appeals
      </Typography.Title>
      <Typography.Paragraph>
        • First strike = comment hidden. Second strike = 24 h read-only. Appeals via “Request review” button.
      </Typography.Paragraph>
    </PageContainer>
  );
}

===== END modules/ethikos/deliberate/guidelines/page.tsx =====


===== BEGIN modules/ethikos/impact/feedback/page.tsx =====
'use client'

import { PageContainer, ProCard } from '@ant-design/pro-components';
import { List, Rate, Input, Button, Empty } from 'antd';
import { Comment } from '@ant-design/compatible';import { useRequest } from 'ahooks';
import { useState } from 'react';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchFeedback, submitFeedback } from '@/services/impact';

export default function FeedbackLoops() {
  usePageTitle('Impact · Feedback');

  const { data, loading, mutate } = useRequest(fetchFeedback);
  const [message, setMessage] = useState('');
  const [stars, setStars] = useState<number>(0);
  const [sending, setSending] = useState(false);

  const send = async () => {
    if (!message.trim()) return;
    setSending(true);
    await submitFeedback({ body: message.trim(), rating: stars || undefined });
    setMessage('');
    setStars(0);
    mutate();
    setSending(false);
  };

  return (
    <PageContainer ghost loading={loading}>
      <ProCard title="Add your feedback" ghost>
        <Rate onChange={setStars} value={stars} />
        <Input.TextArea
          rows={3}
          placeholder="Tell us what worked or what didn’t…"
          value={message}
          onChange={e => setMessage(e.target.value)}
          style={{ marginTop: 8 }}
        />
        <Button type="primary" onClick={send} loading={sending} style={{ marginTop: 8 }}>
          Submit
        </Button>
      </ProCard>

      <ProCard title="Community Feedback" ghost style={{ marginTop: 24 }}>
        {data?.items.length ? (
          <List
            dataSource={data.items ?? []}
            renderItem={f => (
              <li>
                <Comment
                  author={f.author}
                  datetime={f.createdAt}
                  content={
                    <>
                      {f.rating !== undefined && <Rate disabled value={f.rating} />}
                      <p style={{ marginTop: 4 }}>{f.body}</p>
                    </>
                  }
                />
              </li>
            )}
          />
        ) : (
          <Empty description="No feedback yet" />
        )}
      </ProCard>
    </PageContainer>
  );
}

===== END modules/ethikos/impact/feedback/page.tsx =====


===== BEGIN modules/ethikos/impact/outcomes/page.tsx =====
'use client'

import { PageContainer, ProCard, StatisticCard } from '@ant-design/pro-components';
import { Tabs } from 'antd';
import { Line, Bar } from '@ant-design/plots';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchImpactOutcomes } from '@/services/impact';

export default function Outcomes() {
  usePageTitle('Impact · Outcomes');

  const { data, loading } = useRequest(fetchImpactOutcomes);

  return (
    <PageContainer ghost loading={loading}>
      <ProCard gutter={16} wrap>
        {data?.kpis.map(k => (
          <StatisticCard
            key={k.label}
            statistic={{ title: k.label, value: k.value, suffix: k.delta && '%' }}
          />
        ))}
      </ProCard>

      <Tabs
        items={data?.charts.map((c, i) => ({
          key: i.toString(),
          label: c.title,
          children: (
            <ProCard ghost>
              {c.type === 'line' && <Line {...c.config} />}
              {c.type === 'bar' && <Bar {...c.config} />}
            </ProCard>
          ),
        }))}
      />
    </PageContainer>
  );
}

===== END modules/ethikos/impact/outcomes/page.tsx =====


===== BEGIN modules/ethikos/impact/tracker/page.tsx =====
'use client';

import React from 'react';
import { PageContainer, ProTable } from '@ant-design/pro-components';
import type { ProColumns } from '@ant-design/pro-components';
import { Select } from 'antd';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchImpactTracker, patchImpactStatus } from '@/services/impact';

dayjs.extend(relativeTime);

type TrackerRow = {
  id: string;
  title: string;
  owner: string;
  status: 'Planned' | 'In-Progress' | 'Completed' | 'Blocked';
  updatedAt: string;
};

type TrackerResponse = {
  items: TrackerRow[];
};

export default function ImpactTracker() {
  usePageTitle('Impact · Tracker');

  // ahooks: useRequest<TData, TParams>
  const { data, loading, mutate } = useRequest<TrackerResponse, []>(fetchImpactTracker);

  const onStatusChange = async (id: string, status: TrackerRow['status']) => {
    await patchImpactStatus(id, status);
    if (data) {
      mutate({
        ...data,
        items: data.items.map((r) => (r.id === id ? { ...r, status } : r)),
      });
    }
  };

  const statusOptions: { value: TrackerRow['status']; label: string }[] = [
    { value: 'Planned', label: 'Planned' },
    { value: 'In-Progress', label: 'In-Progress' },
    { value: 'Completed', label: 'Completed' },
    { value: 'Blocked', label: 'Blocked' },
  ];

  const columns: ProColumns<TrackerRow>[] = [
    { title: 'Title', dataIndex: 'title', width: 260 },
    { title: 'Owner', dataIndex: 'owner', width: 160 },
    {
      title: 'Status',
      dataIndex: 'status',
      width: 180,
      render: (_, row) => (
        <Select<TrackerRow['status']>
          value={row.status}
          options={statusOptions}
          onChange={(val) => onStatusChange(row.id, val)}
          style={{ width: '100%' }}
        />
      ),
    },
    {
      title: 'Updated',
      dataIndex: 'updatedAt',
      sorter: (a, b) => dayjs(a.updatedAt).valueOf() - dayjs(b.updatedAt).valueOf(),
      render: (_, row) => dayjs(row.updatedAt).fromNow(),
      width: 160,
    },
  ];

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<TrackerRow>
        rowKey="id"
        columns={columns}
        dataSource={data?.items}
        pagination={{ pageSize: 12 }}
        search={false}
      />
    </PageContainer>
  );
}

===== END modules/ethikos/impact/tracker/page.tsx =====


===== BEGIN modules/ethikos/learn/changelog/page.tsx =====
'use client'

import { PageContainer } from '@ant-design/pro-components';
import { Timeline, Tag } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchChangelog } from '@/services/learn';

export default function Changelog() {
  usePageTitle('Learn · Changelog');

  const { data, loading } = useRequest(fetchChangelog);

  return (
    <PageContainer ghost loading={loading}>
      <Timeline>
        {data?.entries.map(e => (
          <Timeline.Item key={e.version} label={e.date}>
            <strong>{e.version}</strong>{' '}
            {e.tags.map(t => (
              <Tag key={t} color={t === 'NEW' ? 'green' : t === 'FIX' ? 'blue' : 'default'}>
                {t}
              </Tag>
            ))}
            <ul style={{ marginTop: 4 }}>
              {e.notes.map((n: string, i: number) => (
                <li key={i}>{n}</li>
              ))}
            </ul>
          </Timeline.Item>
        ))}
      </Timeline>
    </PageContainer>
  );
}

===== END modules/ethikos/learn/changelog/page.tsx =====


===== BEGIN modules/ethikos/learn/glossary/page.tsx =====
'use client'

import { PageContainer, ProTable } from '@ant-design/pro-components';
import { Input } from 'antd';
import { useState } from 'react';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchGlossary } from '@/services/learn';

type Term = { id: string; term: string; definition: string };

export default function Glossary() {
  usePageTitle('Learn · Glossary');

  const { data, loading } = useRequest(fetchGlossary);
  const [query, setQuery] = useState('');

  const columns = [
    { title: 'Term', dataIndex: 'term', width: 200 },
    { title: 'Definition', dataIndex: 'definition' },
  ];

  const filtered = data?.items.filter(
    (t: Term) => t.term.toLowerCase().includes(query.toLowerCase()),
  );

  return (
    <PageContainer ghost loading={loading}>
      <Input.Search
        placeholder="Search term…"
        allowClear
        style={{ marginBottom: 16, maxWidth: 320 }}
        onChange={e => setQuery(e.target.value)}
      />

      <ProTable<Term>
        rowKey="id"
        columns={columns}
        dataSource={filtered}
        pagination={{ pageSize: 20 }}
        search={false}
      />
    </PageContainer>
  );
}

===== END modules/ethikos/learn/glossary/page.tsx =====


===== BEGIN modules/ethikos/learn/guides/page.tsx =====
'use client'

import { PageContainer } from '@ant-design/pro-components';
import { Collapse, Anchor, Typography } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchGuides } from '@/services/learn';

export default function Guides() {
  usePageTitle('Learn · Guides');

  const { data, loading } = useRequest(fetchGuides);

  return (
    <PageContainer ghost loading={loading}>
      <Anchor
        affix
        items={data?.sections.map(s => ({
          key: s.id,
          href: `#${s.id}`,
          title: s.title,
        }))}
      />

      <Collapse
        accordion
        items={data?.sections.map(s => ({
          key: s.id,
          label: <Typography.Text id={s.id}>{s.title}</Typography.Text>,
          children: <Typography.Paragraph>{s.content}</Typography.Paragraph>,
        }))}
      />
    </PageContainer>
  );
}

===== END modules/ethikos/learn/guides/page.tsx =====


===== BEGIN modules/ethikos/pulse/health/page.tsx =====
'use client'

import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Pie, Radar } from '@ant-design/plots';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchPulseHealth } from '@/services/pulse';

export default function PulseHealth() {
  usePageTitle('Pulse · Participation Health');

  const { data, loading } = useRequest(fetchPulseHealth);

  return (
    <PageContainer ghost loading={loading}>
      <ProCard gutter={16} wrap>
        <ProCard colSpan={12} title="Diversity Radar">
          <Radar {...data?.radarConfig} />
        </ProCard>

        <ProCard colSpan={12} title="Ethics Score Breakdown">
          <Pie {...data?.pieConfig} />
        </ProCard>
      </ProCard>
    </PageContainer>
  );
}

===== END modules/ethikos/pulse/health/page.tsx =====


===== BEGIN modules/ethikos/pulse/live/page.tsx =====
'use client'

import { PageContainer, ProCard, StatisticCard } from '@ant-design/pro-components';
import { Badge, Space } from 'antd';
import { useInterval, useRequest } from 'ahooks';
import ChartCard from '@/components/charts/ChartCard';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchPulseLiveData } from '@/services/pulse';   // correct import

export default function PulseLive() {
  usePageTitle('Pulse · Live Metrics');

  // custom hook (polls every 20 s)
  const { data, loading, refresh } = usePulseLive(true);

  // manual refresh safety-net
  useInterval(refresh, 20_000);

  return (
    <PageContainer ghost loading={loading}>
      <ProCard gutter={16} wrap>
        {data?.counters.map((c) => {
          // trend is optional, so normalise to 0 for TS safety
          const trend = c.trend ?? 0;

          return (
            <StatisticCard
              key={c.label}
              statistic={{
                title: (
                  <Space>
                    {c.label}
                    <Badge
                      status={
                        trend > 0
                          ? 'success'
                          : trend < 0
                          ? 'error'
                          : 'default'
                      }
                    />
                  </Space>
                ),
                value: c.value,
                precision: 0,
              }}
              chart={
                <ChartCard
                  type="line"
                  data={c.history.map(({ ts, value }) => ({ x: ts, y: value }))}
                  height={50}
                />
              }
            />
          );
        })}
      </ProCard>
    </PageContainer>
  );
}

/* ------------------------------------------------------------------ */
/*  Local data-fetching hook                                           */
/* ------------------------------------------------------------------ */
function usePulseLive(polling = false) {
  return useRequest(fetchPulseLiveData, {
    pollingInterval: polling ? 20_000 : undefined,
  });
}

===== END modules/ethikos/pulse/live/page.tsx =====


===== BEGIN modules/ethikos/pulse/overview/page.tsx =====
'use client'

// pages/ethikos/pulse/overview.tsx
import {
  PageContainer,
  ProCard,
  StatisticCard,
} from '@ant-design/pro-components';
import { Badge, Button, Empty, Skeleton, Space, Tooltip } from 'antd';
import { SyncOutlined, ClockCircleOutlined } from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';

import ChartCard from '@/components/charts/ChartCard';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchPulseOverview } from '@/services/pulse';

/* ------------------------------------------------------------------ */
/*  Data-fetching hook                                                 */
/* ------------------------------------------------------------------ */

function usePulseOverview() {
  const req = useRequest(fetchPulseOverview, { refreshDeps: [] });
  return req;
}

/* ------------------------------------------------------------------ */
/*  Main component                                                     */
/* ------------------------------------------------------------------ */

export default function PulseOverview() {
  usePageTitle('Pulse · Overview');

  const { data, loading, error, refresh } = usePulseOverview();
  const lastUpdated = data ? dayjs(data.refreshedAt).format('HH:mm:ss') : null;

  /* ---------- loading skeleton ---------- */
  if (loading && !data) {
    return (
      <PageContainer ghost>
        <Skeleton active />
      </PageContainer>
    );
  }

  /* ---------- error state ---------- */
  if (error) {
    return (
      <PageContainer ghost>
        <Empty
          description="Failed to load metrics"
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        >
          <Button icon={<SyncOutlined />} onClick={refresh}>
            Retry
          </Button>
        </Empty>
      </PageContainer>
    );
  }

  /* ---------- empty state ---------- */
  if (data && data.kpis.length === 0) {
    return (
      <PageContainer ghost>
        <Empty description="No KPI data yet" />
      </PageContainer>
    );
  }

  /* ---------- happy path ---------- */
  return (
    <PageContainer
      ghost
      extra={
        <Space>
          {lastUpdated && (
            <Badge
              count={
                <Tooltip title={`Last refreshed at ${lastUpdated}`}>
                  <ClockCircleOutlined style={{ color: '#52c41a' }} />
                </Tooltip>
              }
            />
          )}
          <Button
            icon={<SyncOutlined />}
            onClick={refresh}
            size="small"
            type="text"
          />
        </Space>
      }
    >
      <ProCard gutter={[16, 16]} wrap>
        {data!.kpis.map((kpi) => (
          <StatisticCard
            key={kpi.label}
            colSpan={{
              xs: 24,
              sm: 12,
              md: 12,
              lg: 6,
            }}
            statistic={{
              title: kpi.label,
              value: kpi.value,
              suffix: kpi.delta !== undefined ? '%' : undefined,
              description:
                kpi.delta !== undefined ? (
                  <span
                    style={{
                      color: kpi.delta >= 0 ? '#3f8600' : '#cf1322',
                    }}
                  >
                    {kpi.delta >= 0 ? '▲' : '▼'} {Math.abs(kpi.delta)}%
                  </span>
                ) : null,
            }}
            chart={
              <ChartCard
                type="area"
                height={60}
                data={kpi.history.map((h) => ({
                  x: h.date,
                  y: h.value,
                }))}
                tooltip={{
                  formatter: (datum: any) =>
                    `${dayjs(datum.x).format('MMM D')}: ${datum.y}`,
                }}
              />
            }
          />
        ))}
      </ProCard>
    </PageContainer>
  );
}

===== END modules/ethikos/pulse/overview/page.tsx =====


===== BEGIN modules/ethikos/pulse/trends/page.tsx =====
'use client'

import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Tabs } from 'antd';
import { useRequest } from 'ahooks';
import { Line, Area, Heatmap } from '@ant-design/plots';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchPulseTrends } from '@/services/pulse';

export default function PulseTrends() {
  usePageTitle('Pulse · Trends');

  const { data, loading } = useRequest(fetchPulseTrends);

  return (
    <PageContainer ghost loading={loading}>
      <Tabs
        items={data?.charts.map((c, idx) => ({
          key: idx.toString(),
          label: c.title,
          children: (
            <ProCard ghost>
              {c.type === 'line' && <Line {...c.config} />}
              {c.type === 'area' && <Area {...c.config} />}
              {c.type === 'heatmap' && <Heatmap {...c.config} />}
            </ProCard>
          ),
        }))}
      />
    </PageContainer>
  );
}

===== END modules/ethikos/pulse/trends/page.tsx =====


===== BEGIN modules/ethikos/trust/badges/page.tsx =====
'use client';

import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Badge as AntBadge, Card, Empty } from 'antd';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchUserBadges } from '@/services/trust';
import type { Badge as UserBadge } from '@/services/trust';

export default function Badges() {
  usePageTitle('Trust · Badges');

  // ✅ FIX: add second generic argument `[]`
  const { data, loading } = useRequest<UserBadge[], []>(fetchUserBadges);
  const badges = data ?? [];

  return (
    <PageContainer ghost loading={loading}>
      <ProCard gutter={16} wrap>
        {!loading && badges.length === 0 && (
          <Empty description="No badges earned yet" />
        )}

        {badges.map((badge) => (
          <AntBadge.Ribbon
            text={dayjs(badge.earnedAt).format('MMM D, YYYY')}
            color="green"
            key={badge.id}
          >
            <Card
              title={badge.label}
              style={{ width: 260, marginBottom: 16 }}
            >
              <p>{badge.description}</p>
              <p style={{ marginTop: 8, fontSize: 12, opacity: 0.7 }}>
                Earned on {dayjs(badge.earnedAt).format('MMM D, YYYY')}
              </p>
            </Card>
          </AntBadge.Ribbon>
        ))}
      </ProCard>
    </PageContainer>
  );
}

===== END modules/ethikos/trust/badges/page.tsx =====


===== BEGIN modules/ethikos/trust/credentials/page.tsx =====
'use client'

import { PageContainer } from '@ant-design/pro-components';
import { Upload, Button, Result } from 'antd';
import { InboxOutlined } from '@ant-design/icons';
import { useState } from 'react';
import usePageTitle from '@/hooks/usePageTitle';
import { uploadCredential } from '@/services/trust';

export default function Credentials() {
  usePageTitle('Trust · Credentials');

  const [done, setDone] = useState(false);

  const props = {
    name: 'file',
    multiple: false,
    customRequest: async ({ file, onSuccess, onError }: any) => {
      try {
        await uploadCredential(file as File);
        onSuccess('ok');
        setDone(true);
      } catch {
        onError();
      }
    },
  };

  return (
    <PageContainer ghost>
      {done ? (
        <Result
          status="success"
          title="Document uploaded!"
          subTitle="Your credential is pending verification."
          extra={<Button type="primary" onClick={() => setDone(false)}>Upload another</Button>}
        />
      ) : (
        <Upload.Dragger {...props} accept=".pdf,.jpg,.png">
          <p className="ant-upload-drag-icon">
            <InboxOutlined />
          </p>
          <p className="ant-upload-text">Click or drag file to this area to upload</p>
          <p className="ant-upload-hint">Supported: PDF / JPG / PNG &nbsp;·&nbsp; Max 5 MB</p>
        </Upload.Dragger>
      )}
    </PageContainer>
  );
}

===== END modules/ethikos/trust/credentials/page.tsx =====


===== BEGIN modules/ethikos/trust/profile/page.tsx =====
'use client';

import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Avatar, Descriptions, Tag, Timeline, Typography } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchUserProfile, type ReputationProfile } from '@/services/trust';

const { Text } = Typography;

export default function MyProfile() {
  usePageTitle('Trust · My Profile');

  // ahooks generics: <Data, Params>
  const { data, loading } = useRequest<ReputationProfile, []>(fetchUserProfile);

  const level = data?.level ?? 'Visitor';
  const score = data?.score ?? 0;
  const dimensions = data?.dimensions ?? [];
  const recent = data?.recent ?? [];

  const initial = level.charAt(0);

  return (
    <PageContainer ghost loading={loading}>
      <ProCard split="vertical">
        {/* Left column: compact summary */}
        <ProCard colSpan="25%">
          <Avatar size={120}>{initial}</Avatar>

          <Descriptions size="small" column={1} style={{ marginTop: 16 }}>
            <Descriptions.Item label="Level">
              <Tag color="blue">{level}</Tag>
            </Descriptions.Item>

            <Descriptions.Item label="Reputation score">
              <Text>{score}</Text>
            </Descriptions.Item>

            <Descriptions.Item label="Dimensions">
              {dimensions.length ? (
                dimensions.map((d) => (
                  <Tag key={d.key} style={{ marginBottom: 4 }}>
                    {d.label}: {d.score}
                  </Tag>
                ))
              ) : (
                <Text type="secondary">No reputation data yet</Text>
              )}
            </Descriptions.Item>
          </Descriptions>
        </ProCard>

        {/* Right column: recent activity derived from `recent` */}
        <ProCard title="Recent Activity" ghost>
          {recent.length ? (
            <Timeline>
              {recent.map((item, idx) => (
                <Timeline.Item
                  key={idx}
                  color={item.change >= 0 ? 'green' : 'red'}
                >
                  {item.label} · {item.change >= 0 ? '+' : ''}
                  {item.change}
                </Timeline.Item>
              ))}
            </Timeline>
          ) : (
            <Text type="secondary">No recent activity</Text>
          )}
        </ProCard>
      </ProCard>
    </PageContainer>
  );
}

===== END modules/ethikos/trust/profile/page.tsx =====


===== BEGIN modules/global/components/AppShell.tsx =====
﻿"use client";
import React, { PropsWithChildren } from "react";
import { Layout } from "antd";

/** Light-weight wrapper that gives every page a top‑nav + centred body. */
export default function AppShell({ children }: PropsWithChildren) {
  return (
    <Layout style={{ minHeight: "100vh" }}>
      <Layout.Header className="text-white text-lg font-semibold px-8">
        Konnaxion
      </Layout.Header>
      <Layout.Content className="p-8 max-w-5xl w-full mx-auto">
        {children}
      </Layout.Content>
    </Layout>
  );
}

===== END modules/global/components/AppShell.tsx =====


===== BEGIN modules/global/components/GlobalSearchBar.tsx =====
// File: modules/global/components/GlobalSearchBar.tsx
'use client'

import React, { useState } from 'react'
import { Input } from 'antd'
import { useRouter, useSearchParams } from 'next/navigation'

export function GlobalSearchBar() {
  const [q, setQ] = useState(useSearchParams().get('q') ?? '')
  const router = useRouter()

  const onSearch = (value: string) => {
    if (value.trim()) {
      router.push(`/search?q=${encodeURIComponent(value.trim())}`)
    }
  }

  return (
    <Input.Search
      placeholder="Search…"
      value={q}
      onChange={e => setQ(e.target.value)}
      onSearch={onSearch}
      enterButton
      style={{ maxWidth: 400 }}
    />
  )
}

===== END modules/global/components/GlobalSearchBar.tsx =====


===== BEGIN modules/global/components/index.ts =====
﻿// C:\MyCode\Konnaxionv14\frontend\modules\global\components\index.ts
export { default as AppShell } from './AppShell';
export { GlobalSearchBar } from './GlobalSearchBar';

===== END modules/global/components/index.ts =====


===== BEGIN modules/global/hooks/index.ts =====
﻿export { default as useGlobalSearch } from './useGlobalSearch';

===== END modules/global/hooks/index.ts =====


===== BEGIN modules/global/hooks/useGlobalSearch.ts =====
﻿// modules/global/hooks/useGlobalSearch.ts
"use client";

import { useQuery } from "@tanstack/react-query";

export interface GlobalSearchResult {
  id: string;
  title: string;
  snippet: string;
  path: string;
}

interface SearchResponse {
  results: GlobalSearchResult[];
}

/**
 * Client-side global search.
 *
 * Hits the Next.js route: GET /_api/search?q=…
 * - avoids mixing with the backend API baseURL (/api, NEXT_PUBLIC_API_BASE, etc.)
 * - normalizes the `{ results: [...] }` response to `GlobalSearchResult[]`
 */
export default function useGlobalSearch(query: string) {
  const q = query?.trim() ?? "";

  return useQuery<GlobalSearchResult[], Error>({
    queryKey: ["global-search", q],
    enabled: q.length > 0,
    staleTime: 60_000,
    retry: 1,
    queryFn: async () => {
      const params = new URLSearchParams({ q });

      const res = await fetch(`/_api/search?${params.toString()}`, {
        method: "GET",
        credentials: "include",
        headers: {
          Accept: "application/json",
        },
        cache: "no-store",
      });

      if (!res.ok) {
        const body = await res.text().catch(() => "");
        throw new Error(body || `Search failed with status ${res.status}`);
      }

      const json = (await res.json()) as SearchResponse;

      return Array.isArray(json.results) ? json.results : [];
    },
  });
}

===== END modules/global/hooks/useGlobalSearch.ts =====


===== BEGIN modules/global/pages/index.ts =====
export { default as MyWork } from './MyWork';
export { default as Search } from './Search';

===== END modules/global/pages/index.ts =====


===== BEGIN modules/global/pages/MyWork.tsx =====
"use client";
import AppShell from "../components/AppShell";

export default function MyWork() {
  return (
    <AppShell>
      <h1 className="text-xl font-semibold mb-4">My work</h1>
      <p>Coming soon…</p>
    </AppShell>
  );
}

===== END modules/global/pages/MyWork.tsx =====


===== BEGIN modules/global/pages/Search.tsx =====
"use client";
import { useSearchParams } from "next/navigation";
import { Alert, List, Spin } from "antd";
import AppShell from "@/global/components/AppShell";
import useGlobalSearch, { GlobalSearchResult } from "@/global/hooks/useGlobalSearch";

export default function GlobalSearchPage() {
  const q = useSearchParams().get("q") ?? "";
  const { data, isLoading, isError, error } = useGlobalSearch(q);

  return (
    <AppShell>
      {isLoading && <Spin />}
      {isError && <Alert message={error.message} type="error" />}
      {data && (
        <List<GlobalSearchResult>
          itemLayout="vertical"
          dataSource={data}
          renderItem={(item) => (
            <List.Item key={item.id}>
              <List.Item.Meta
                title={<a href={item.path}>{item.title}</a>}
                description={item.snippet}
              />
            </List.Item>
          )}
        />
      )}
    </AppShell>
  );
}

===== END modules/global/pages/Search.tsx =====


===== BEGIN modules/insights/components/__stories__/SmartVoteChart.stories.tsx =====
import SmartVoteChart from '../SmartVoteChart';

export default {
  title: 'Insights/SmartVoteChart',
  component: SmartVoteChart,
};

export const Basic = {
  args: {
    labels: ['Option 1', 'Option 2'],
    votes: [42, 23],
    scores: [1.3, 2.1],
  },
};

===== END modules/insights/components/__stories__/SmartVoteChart.stories.tsx =====


===== BEGIN modules/insights/components/DomainHeatMap.tsx =====
export default function DomainHeatMap() {
  return (
    <div style={{ minHeight: 300, display: "flex", alignItems: "center", justifyContent: "center", color: "#bbb" }}>
      {/* TODO: Implement heatmap with Chart.js or another library */}
      <em>Heatmap chart not available (react-chartjs-2-heatmap does not exist)</em>
    </div>
  );
}

===== END modules/insights/components/DomainHeatMap.tsx =====


===== BEGIN modules/insights/components/ErrorRateSparkline.tsx =====
"use client";
import {
  Chart as ChartJS,
  LineElement,
  CategoryScale,
  LinearScale,
  Tooltip,
} from "chart.js";
import { Line } from "react-chartjs-2";
ChartJS.register(LineElement, CategoryScale, LinearScale, Tooltip);

export default function ErrorRateSparkline({
  labels,
  rates,
}: {
  labels: string[];
  rates: number[];
}) {
  const data = {
    labels,
    datasets: [
      {
        data: rates,
        fill: false,
        tension: 0.3,
        borderWidth: 2,
      },
    ],
  };
  return <Line data={data} options={{ plugins: { legend: { display: false } } }} />;
}


===== END modules/insights/components/ErrorRateSparkline.tsx =====


===== BEGIN modules/insights/components/ExportCSVButton.tsx =====
"use client";
import { Button } from "antd";
import { DownloadOutlined } from "@ant-design/icons";
import { downloadCsv } from "@/shared/downloadCsv";

export default function ExportCSVButton({
  endpoint,
  params,
}: {
  endpoint: string;
  params?: Record<string, unknown>;
}) {
  return (
    <Button
      type="primary"
      icon={<DownloadOutlined />}
      onClick={() => downloadCsv(endpoint, params)}
    >
      Export CSV
    </Button>
  );
}

===== END modules/insights/components/ExportCSVButton.tsx =====


===== BEGIN modules/insights/components/index.ts =====
﻿// C:\MyCode\Konnaxionv14\frontend\modules\insights\components\index.ts
export { default as SmartVoteChart }     from './SmartVoteChart';
export { default as DomainHeatMap }      from './DomainHeatMap';
export { default as ErrorRateSparkline } from './ErrorRateSparkline';
export { default as ExportCSVButton }    from './ExportCSVButton';
export { default as LatencySLOGauge }    from './LatencySLOGauge';
export { default as TimeRangePicker }    from './TimeRangePicker';
export { default as UsageBigNumbers }    from './UsageBigNumbers';

===== END modules/insights/components/index.ts =====


===== BEGIN modules/insights/components/LatencySLOGauge.tsx =====
"use client";
import {
  Chart as ChartJS,
  ArcElement,
  Tooltip,
  Legend,
} from "chart.js";
import { Doughnut } from "react-chartjs-2";
ChartJS.register(ArcElement, Tooltip, Legend);

export default function LatencySLOGauge({
  valueMs,
  sloMs,
}: {
  valueMs: number;
  sloMs: number;
}) {
  const pct = Math.min(100, (valueMs / sloMs) * 100);
  const data = {
    labels: ["Latency", "Budget"],
    datasets: [
      {
        data: [pct, 100 - pct],
        backgroundColor: ["#3b82f6", "#e5e7eb"],
        borderWidth: 0,
      },
    ],
  };
  return (
    <div className="w-48">
      <Doughnut data={data} options={{ cutout: "70%" }} />
      <p className="text-center -mt-14 text-xl font-semibold">{valueMs} ms</p>
    </div>
  );
}


===== END modules/insights/components/LatencySLOGauge.tsx =====


===== BEGIN modules/insights/components/SmartVoteChart.tsx =====
"use client";
import {
  Chart as ChartJS,
  BarElement,
  LineElement,
  CategoryScale,
  LinearScale,
  Tooltip,
  Legend,
  ChartDataset,
} from "chart.js";
import { Chart } from "react-chartjs-2";

ChartJS.register(
  BarElement,
  LineElement,
  CategoryScale,
  LinearScale,
  Tooltip,
  Legend,
);

type Props = {
  labels: string[];
  votes: number[];
  scores: number[];
};

export default function SmartVoteChart({ labels, votes, scores }: Props) {
  const data = {
    labels,
    datasets: [
      {
        type: "bar" as const,
        label: "Votes",
        data: votes,
        yAxisID: "y",
      } as ChartDataset<"bar", number[]>,
      {
        type: "line" as const,
        label: "Avg Score",
        data: scores,
        yAxisID: "y1",
      } as ChartDataset<"line", number[]>,
    ],
  };
  const options = {
    responsive: true,
    interaction: { mode: "index" as const, intersect: false },
    scales: {
      y: { beginAtZero: true },
      y1: { beginAtZero: true, position: "right" as const },
    },
  };
  return <Chart type="bar" data={data} options={options} />;
}

===== END modules/insights/components/SmartVoteChart.tsx =====


===== BEGIN modules/insights/components/TimeRangePicker.tsx =====
"use client";
import { DatePicker } from "antd";
import dayjs from "dayjs";

type Range = [dayjs.Dayjs, dayjs.Dayjs];

export default function TimeRangePicker({
  value,
  onChange,
}: {
  value: Range;
  onChange: (val: Range) => void;
}) {
  return (
    <DatePicker.RangePicker
      className="mb-6"
      value={value}
      onChange={(val) => onChange(val as Range)}
      allowClear={false}
    />
  );
}


===== END modules/insights/components/TimeRangePicker.tsx =====


===== BEGIN modules/insights/components/UsageBigNumbers.tsx =====

type Item = { label: string; value: number };

export default function UsageBigNumbers({ items }: { items: Item[] }) {
  return (
    <div className="grid grid-cols-3 gap-6">
      {items.map((it) => (
        <div key={it.label} className="p-6 bg-white rounded shadow">
          <div className="text-3xl font-bold">{it.value.toLocaleString()}</div>
          <div className="text-gray-500">{it.label}</div>
        </div>
      ))}
    </div>
  );
}

===== END modules/insights/components/UsageBigNumbers.tsx =====


===== BEGIN modules/insights/hooks/__tests__/useReport.test.tsx =====
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useReport } from '../useReport';

// ── mock the shared api instance (relative path = 3 levels up) ────────────────
jest.mock('../../../../shared/api', () => ({
  api: {
    get: jest.fn().mockResolvedValue({
      data: { labels: ['A'], votes: [10], avg_score: [0.7] },
    }),
  },
}));
// ──────────────────────────────────────────────────────────────────────────────

const qc = new QueryClient({ defaultOptions: { queries: { retry: false } } });

test('returns mocked report data', async () => {
  const { result } = renderHook(
    () => useReport('smart-vote', { range: '7d' }),
    { wrapper: ({ children }) => <QueryClientProvider client={qc}>{children}</QueryClientProvider> }
  );

  // initial React-Query status is 'pending'
  expect(result.current.status).toBe('pending');

  // wait until data arrives
  await waitFor(() => expect(result.current.data).toBeDefined());

  expect(result.current.data?.votes).toEqual([10]);
});

===== END modules/insights/hooks/__tests__/useReport.test.tsx =====


===== BEGIN modules/insights/hooks/index.ts =====
﻿// modules/insights/hooks/index.ts
export { useReport } from './useReport';
export { default as useReportStream } from './useReportStream';

===== END modules/insights/hooks/index.ts =====


===== BEGIN modules/insights/hooks/useReport.ts =====
// modules/insights/hooks/useReport.ts
import { useQuery } from "@tanstack/react-query";
import api from "@/api";

type SmartVoteResp = { labels: string[]; votes: number[]; avg_score: number[] };
type UsageResp = { labels: string[]; mau: number[]; projects: number[]; docs: number[] };
type PerfResp = { labels: string[]; p95_latency: number[]; error_rate: number[] };

type EndpointMap = {
  "smart-vote": SmartVoteResp;
  usage: UsageResp;
  perf: PerfResp;
};

export function useReport<E extends keyof EndpointMap>(
  endpoint: E,
  params?: Record<string, unknown>,
) {
  return useQuery<EndpointMap[E]>({
    queryKey: [endpoint, params],
    staleTime: 300_000,
    queryFn: async () =>
      api.get<EndpointMap[E]>(`/reports/${endpoint}`, { params }),
  });
}

===== END modules/insights/hooks/useReport.ts =====


===== BEGIN modules/insights/hooks/useReportStream.ts =====
"use client";

import { useEffect, useRef, useState } from "react";

export type ReportStreamMessage = unknown;

export interface ReportStreamState {
  status: "idle" | "connecting" | "open" | "error" | "closed";
  lastMessage?: ReportStreamMessage;
  error?: string;
}

/**
 * Live report stream for the Insights custom builder.
 *
 * Connects to a WebSocket endpoint (default: ws(s)://<host>/ws/reports/custom).
 * Optionally, you can point to another host via NEXT_PUBLIC_REPORTS_WS_BASE
 * (the hook will append `/ws/reports/custom` to that base URL).
 */
export default function useReportStream(): ReportStreamState {
  const [state, setState] = useState<ReportStreamState>({ status: "idle" });
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    if (wsRef.current) return;
    if (typeof window === "undefined") return;

    if (!("WebSocket" in window)) {
      setState({
        status: "error",
        error: "WebSocket not supported in this browser",
      });
      return;
    }

    let isMounted = true;

    setState({ status: "connecting" });

    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    const host = window.location.host;
    const wsPath = "/ws/reports/custom";

    const baseFromEnv = process.env.NEXT_PUBLIC_REPORTS_WS_BASE;
    const url =
      baseFromEnv && baseFromEnv.length > 0
        ? `${baseFromEnv.replace(/\/$/, "")}${wsPath}`
        : `${protocol}//${host}${wsPath}`;

    const socket = new WebSocket(url);
    wsRef.current = socket;

    socket.onopen = () => {
      if (!isMounted) return;
      setState((prev) => ({ ...prev, status: "open" }));

      // Works with the current minimal backend (ping → pong) and
      // is harmless for a richer reports-api implementation.
      try {
        socket.send("ping");
      } catch {
        // ignore send failures
      }
    };

    socket.onmessage = (event: MessageEvent) => {
      if (!isMounted) return;

      let payload: unknown = event.data;

      if (typeof event.data === "string") {
        try {
          payload = JSON.parse(event.data);
        } catch {
          // keep raw text if it is not JSON
          payload = event.data;
        }
      }

      setState((prev) => ({
        ...prev,
        lastMessage: payload,
      }));
    };

    socket.onerror = () => {
      if (!isMounted) return;

      setState((prev) => ({
        ...prev,
        status: "error",
        error: "WebSocket error",
      }));
    };

    socket.onclose = () => {
      if (!isMounted) return;

      setState((prev) => ({
        ...prev,
        status: "closed",
      }));
      wsRef.current = null;
    };

    return () => {
      isMounted = false;
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
      }
    };
  }, []);

  return state;
}

===== END modules/insights/hooks/useReportStream.ts =====


===== BEGIN modules/insights/pages/CustomBuilderPage.tsx =====
"use client";
import { useEffect, useMemo, useRef, useState } from "react";
import dayjs from "dayjs";

import MainLayout from "@/shared/layout/MainLayout";
import TimeRangePicker from "../components/TimeRangePicker";
import useReportStream from "../hooks/useReportStream";

type Range = [dayjs.Dayjs, dayjs.Dayjs];

type BuilderMetric = "smart-vote" | "usage" | "perf";
type BuilderGroupBy = "day" | "week";

interface BuilderState {
  metric: BuilderMetric;
  groupBy: BuilderGroupBy;
  includeRaw: boolean;
  range: Range;
}

interface StreamMessage {
  ts: string;
  direction: "in" | "out";
  payload: unknown;
}

export default function CustomBuilderPage() {
  // Keep the hook wired so it can evolve to manage the stream internally.
  useReportStream();

  const [builder, setBuilder] = useState<BuilderState>({
    metric: "smart-vote",
    groupBy: "day",
    includeRaw: false,
    range: [dayjs().subtract(7, "day"), dayjs()],
  });

  const [connectionStatus, setConnectionStatus] = useState<
    "idle" | "connecting" | "open" | "closed" | "error"
  >("idle");
  const [messages, setMessages] = useState<StreamMessage[]>([]);
  const [lastError, setLastError] = useState<string | null>(null);

  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    if (typeof window === "undefined") {
      return;
    }

    const protocol = window.location.protocol === "https:" ? "wss" : "ws";
    const host = window.location.host;

    setConnectionStatus("connecting");
    setLastError(null);

    const ws = new WebSocket(`${protocol}://${host}/ws/reports/custom`);
    wsRef.current = ws;

    ws.onopen = () => {
      setConnectionStatus("open");
    };

    ws.onerror = () => {
      setConnectionStatus("error");
      setLastError("Unable to open /ws/reports/custom WebSocket.");
    };

    ws.onclose = () => {
      setConnectionStatus((prev) => (prev === "error" ? prev : "closed"));
    };

    ws.onmessage = (event) => {
      let payload: unknown = event.data;
      if (typeof event.data === "string") {
        try {
          payload = JSON.parse(event.data);
        } catch {
          payload = event.data;
        }
      }

      setMessages((prev) => [
        {
          ts: new Date().toISOString(),
          direction: "in",
          payload,
        },
        ...prev,
      ]);
    };

    return () => {
      wsRef.current = null;
      ws.close();
    };
  }, []);

  const payload = useMemo(
    () => ({
      metric: builder.metric,
      group_by: builder.groupBy,
      include_raw_samples: builder.includeRaw,
      range: {
        from: builder.range[0].toISOString(),
        to: builder.range[1].toISOString(),
      },
    }),
    [builder],
  );

  const handleSend = () => {
    const ws = wsRef.current;
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      setLastError(
        "Live stream is not connected yet. Wait for status “Connected” and try again.",
      );
      return;
    }

    const outgoing = {
      kind: "custom-report-query",
      ...payload,
    };

    ws.send(JSON.stringify(outgoing));

    setMessages((prev) => [
      {
        ts: new Date().toISOString(),
        direction: "out",
        payload: outgoing,
      },
      ...prev,
    ]);
    setLastError(null);
  };

  const statusLabel =
    connectionStatus === "idle"
      ? "Idle"
      : connectionStatus === "connecting"
      ? "Connecting…"
      : connectionStatus === "open"
      ? "Connected"
      : connectionStatus === "closed"
      ? "Closed"
      : "Error";

  const statusDotClass =
    connectionStatus === "open"
      ? "bg-green-500"
      : connectionStatus === "error"
      ? "bg-red-500"
      : connectionStatus === "connecting"
      ? "bg-yellow-400"
      : "bg-gray-300";

  return (
    <MainLayout>
      <div className="mb-6 flex items-center justify-between">
        <h1 className="text-xl font-semibold">Custom report builder</h1>
        <div className="flex items-center gap-2 text-sm text-gray-500">
          <span
            className={`inline-block h-2 w-2 rounded-full ${statusDotClass}`}
          />
          <span>{statusLabel}</span>
        </div>
      </div>

      <p className="mb-6 text-sm text-gray-600">
        Define an Insights query and send it over the live WebSocket stream.
        This page is a beta playground; the backend may still return only test
        data.
      </p>

      {lastError && (
        <div className="mb-4 rounded border border-red-200 bg-red-50 px-4 py-2 text-sm text-red-700">
          {lastError}
        </div>
      )}

      <div className="grid gap-8 lg:grid-cols-3">
        <div className="space-y-4 lg:col-span-2">
          <section>
            <h2 className="mb-3 text-sm font-semibold uppercase tracking-wide text-gray-600">
              Query definition
            </h2>

            <div className="mb-4">
              <label className="mb-1 block text-xs font-medium text-gray-600">
                Time range
              </label>
              <TimeRangePicker
                value={builder.range}
                onChange={(range) =>
                  setBuilder((prev) => ({
                    ...prev,
                    range,
                  }))
                }
              />
            </div>

            <div className="mb-4 grid gap-4 md:grid-cols-3">
              <div>
                <label className="mb-1 block text-xs font-medium text-gray-600">
                  Metric
                </label>
                <select
                  className="w-full rounded border border-gray-300 px-2 py-1 text-sm"
                  value={builder.metric}
                  onChange={(e) =>
                    setBuilder((prev) => ({
                      ...prev,
                      metric: e.target.value as BuilderMetric,
                    }))
                  }
                >
                  <option value="smart-vote">Smart Vote</option>
                  <option value="usage">Usage</option>
                  <option value="perf">API performance</option>
                </select>
              </div>

              <div>
                <label className="mb-1 block text-xs font-medium text-gray-600">
                  Grouping
                </label>
                <select
                  className="w-full rounded border border-gray-300 px-2 py-1 text-sm"
                  value={builder.groupBy}
                  onChange={(e) =>
                    setBuilder((prev) => ({
                      ...prev,
                      groupBy: e.target.value as BuilderGroupBy,
                    }))
                  }
                >
                  <option value="day">By day</option>
                  <option value="week">By week</option>
                </select>
              </div>

              <div className="flex items-center gap-2 pt-5">
                <input
                  id="include-raw"
                  type="checkbox"
                  className="h-4 w-4"
                  checked={builder.includeRaw}
                  onChange={(e) =>
                    setBuilder((prev) => ({
                      ...prev,
                      includeRaw: e.target.checked,
                    }))
                  }
                />
                <label
                  htmlFor="include-raw"
                  className="text-xs font-medium text-gray-600"
                >
                  Include raw samples
                </label>
              </div>
            </div>

            <button
              type="button"
              onClick={handleSend}
              className="rounded bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700 disabled:cursor-not-allowed disabled:bg-blue-300"
              disabled={connectionStatus !== "open"}
            >
              Send to live stream
            </button>
          </section>
        </div>

        <div className="space-y-4">
          <section>
            <h2 className="mb-2 text-sm font-semibold uppercase tracking-wide text-gray-600">
              Payload preview
            </h2>
            <pre className="max-h-64 overflow-auto rounded bg-gray-50 p-3 text-xs">
              {JSON.stringify(payload, null, 2)}
            </pre>
          </section>

          <section>
            <h2 className="mb-2 text-sm font-semibold uppercase tracking-wide text-gray-600">
              Live stream (debug)
            </h2>
            {messages.length === 0 ? (
              <p className="text-xs text-gray-500">
                No messages yet. When the backend starts emitting responses over
                /ws/reports/custom, they will appear here.
              </p>
            ) : (
              <ul className="max-h-64 space-y-2 overflow-auto rounded border border-gray-200 bg-white p-2 text-xs">
                {messages.map((msg, idx) => (
                  <li key={`${msg.ts}-${idx}`}>
                    <div className="mb-1 flex items-center justify-between">
                      <span className="font-mono text-[11px] text-gray-500">
                        {msg.ts}
                      </span>
                      <span className="rounded bg-gray-100 px-1 py-0.5 text-[10px] uppercase text-gray-600">
                        {msg.direction === "out" ? "Sent" : "Received"}
                      </span>
                    </div>
                    <pre className="overflow-auto rounded bg-gray-50 p-2">
                      {JSON.stringify(msg.payload, null, 2)}
                    </pre>
                  </li>
                ))}
              </ul>
            )}
          </section>
        </div>
      </div>
    </MainLayout>
  );
}

===== END modules/insights/pages/CustomBuilderPage.tsx =====


===== BEGIN modules/insights/pages/index.ts =====
export { default as CustomBuilderPage } from './CustomBuilderPage';
export { default as InsightsHomePage } from './InsightsHomePage';
export { default as PerfDashboard } from './PerfDashboard';
export { default as SmartVoteDashboard } from './SmartVoteDashboard';
export { default as UsageDashboard } from './UsageDashboard';

===== END modules/insights/pages/index.ts =====


===== BEGIN modules/insights/pages/InsightsHomePage.tsx =====

import MainLayout from "@/shared/layout/MainLayout";
import Link from "next/link";

export default function InsightsHomePage() {
  const links = [
    ["smart-vote", "Smart-Vote dashboard"],
    ["usage", "Usage dashboard"],
    ["perf", "Performance dashboard"],
    ["custom", "Custom report builder"],
  ];
  return (
    <MainLayout>
      <h1 className="mb-6 text-xl font-semibold">Insights</h1>
      <ul className="space-y-4 text-blue-600 underline">
        {links.map(([slug, label]) => (
          <li key={slug}>
            <Link href={`/reports/${slug}`}>{label}</Link>
          </li>
        ))}
      </ul>
    </MainLayout>
  );
}

===== END modules/insights/pages/InsightsHomePage.tsx =====


===== BEGIN modules/insights/pages/PerfDashboard.tsx =====
"use client"; 
import MainLayout from "@/shared/layout/MainLayout";
import { useReport } from "../hooks/useReport";
import LatencySLOGauge from "../components/LatencySLOGauge";
import ErrorRateSparkline from "../components/ErrorRateSparkline";

export default function PerfDashboard() {
  const { data, isLoading } = useReport("perf", { range: "24h" });

  if (isLoading || !data) {
    return (
      <MainLayout>
        <p>Loading…</p>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <h2 className="mb-4 font-semibold">Latency (p95 vs SLO)</h2>
      <LatencySLOGauge valueMs={data.p95_latency.at(-1) ?? 0} sloMs={300} />

      <h2 className="mt-10 mb-4 font-semibold">Error Rate</h2>
      <ErrorRateSparkline labels={data.labels} rates={data.error_rate} />
    </MainLayout>
  );
}

===== END modules/insights/pages/PerfDashboard.tsx =====


===== BEGIN modules/insights/pages/SmartVoteDashboard.tsx =====
"use client"; 
import { useState } from "react";
import dayjs from "dayjs";

import MainLayout from "@/shared/layout/MainLayout";
import { useReport } from "../hooks/useReport";
import SmartVoteChart from "../components/SmartVoteChart";
import TimeRangePicker from "../components/TimeRangePicker";
import ExportCSVButton from "../components/ExportCSVButton";

export default function SmartVoteDashboard() {
  const [range, setRange] = useState<[dayjs.Dayjs, dayjs.Dayjs]>([
    dayjs().subtract(30, "day"),
    dayjs(),
  ]);

  const params = { from: range[0].toISOString(), to: range[1].toISOString() };
  const { data, isLoading } = useReport("smart-vote", params);

  return (
    <MainLayout>
      <div className="flex items-center justify-between mb-6">
        <TimeRangePicker value={range} onChange={setRange} />
        <ExportCSVButton endpoint="smart-vote" params={params} />
      </div>

      {isLoading || !data ? (
        <p>Loading…</p>
      ) : (
        <SmartVoteChart
          labels={data.labels}
          votes={data.votes}
          scores={data.avg_score}
        />
      )}
    </MainLayout>
  );
}

===== END modules/insights/pages/SmartVoteDashboard.tsx =====


===== BEGIN modules/insights/pages/UsageDashboard.tsx =====
"use client"; 
import MainLayout from "@/shared/layout/MainLayout";
import { useReport } from "../hooks/useReport";
import UsageBigNumbers from "../components/UsageBigNumbers";

export default function UsageDashboard() {
  const { data, isLoading } = useReport("usage");

  if (isLoading || !data) {
    return (
      <MainLayout>
        <p>Loading…</p>
      </MainLayout>
    );
  }

  const items = [
    { label: "Monthly Active Users", value: data.mau.at(-1) ?? 0 },
    { label: "Projects", value: data.projects.at(-1) ?? 0 },
    { label: "Docs Indexed", value: data.docs.at(-1) ?? 0 },
  ];

  return (
    <MainLayout>
      <UsageBigNumbers items={items} />
    </MainLayout>
  );
}

===== END modules/insights/pages/UsageDashboard.tsx =====


===== BEGIN modules/insights/types/liveReportState.ts =====
// modules/insights/types/liveReportState.ts

/**
 * Connection status of the live report stream.
 *
 * This is intentionally generic so the backend can refine the contract
 * without forcing a breaking change on the frontend.
 */
export type LiveReportConnectionStatus =
  | 'idle'
  | 'connecting'
  | 'connected'
  | 'reconnecting'
  | 'disconnected'
  | 'error';

export interface LiveReportError {
  /** Stable machine-readable error code (e.g. "AUTH_FAILED", "TIMEOUT"). */
  code: string;
  /** Human-readable explanation, suitable for logs or UI. */
  message: string;
  /** Optional backend-supplied details (stack, context, etc.). */
  details?: unknown;
}

/**
 * A single time-bucketed data point emitted by the stream.
 * Used to drive preview charts in the custom report builder.
 */
export interface LiveReportSample {
  /** ISO timestamp for the sample (UTC). */
  ts: string;
  /** Optional human-readable label, bucket name, etc. */
  label?: string;
  /**
   * Arbitrary numeric metrics for this sample, keyed by metric name.
   * Example keys: "count", "avg_score", "p95_latency_ms".
   */
  metrics: Record<string, number | null>;
  /**
   * Optional raw payload from the backend for debugging or drill-down.
   * Keep this opaque from the UI perspective.
   */
  raw?: unknown;
}

/**
 * Lightweight summary of the latest window of data the builder is looking at.
 */
export interface LiveReportSummary {
  /** Unique identifier for the query / report definition, if provided. */
  queryId?: string;
  /** Total number of samples seen in the current window. */
  sampleCount?: number;
  /** Duration of the last query in milliseconds, if known. */
  durationMs?: number;
  /**
   * Arbitrary aggregate metrics, keyed by metric name.
   * Example keys: "total_votes", "avg_score", "error_rate_pct".
   */
  aggregates?: Record<string, number | null>;
  /** Additional backend-supplied metadata (e.g. source table, filters). */
  meta?: Record<string, unknown>;
}

/**
 * High-level shape of events emitted on the stream.
 * This union is narrow but extensible via the 'custom' variant.
 */
export type LiveReportEvent =
  | { kind: 'connected'; at: string }
  | { kind: 'disconnected'; at: string; reason?: string }
  | { kind: 'reconnecting'; at: string; attempt: number }
  | { kind: 'error'; at: string; error: LiveReportError }
  | { kind: 'sample'; at: string; sample: LiveReportSample }
  | { kind: 'summary'; at: string; summary: LiveReportSummary }
  | { kind: 'keepalive'; at: string; payload?: unknown }
  | { kind: 'custom'; at: string; type: string; payload: unknown };

/**
 * Connection-related state for the live stream.
 */
export interface LiveReportConnectionState {
  status: LiveReportConnectionStatus;
  /** When we last successfully connected, in ISO format. */
  lastConnectedAt?: string;
  /** When we last received any event on the stream, in ISO format. */
  lastEventAt?: string;
  /** Last error, if the stream is in a degraded state. */
  lastError?: LiveReportError | null;
  /** How many reconnection attempts have been made in this session. */
  reconnectAttempts: number;
}

/**
 * Root state object returned by useReportStream().
 *
 * CustomBuilderPage currently renders this via JSON.stringify, so it is
 * safe to add new optional fields here without breaking the UI.
 */
export interface LiveReportState {
  /** Connection details for the underlying socket / stream. */
  connection: LiveReportConnectionState;

  /**
   * Optional logical group name the user is currently subscribed to
   * (e.g. "reports_user_<id>" or a specific report slug).
   */
  group?: string | null;

  /**
   * If the builder is scoped to a particular report definition,
   * this can be used to track that identifier.
   */
  activeReportId?: string | null;

  /** Rolling window of the most recent samples for preview charts. */
  samples: LiveReportSample[];

  /** Most recent aggregates / summary, if the backend emits them. */
  summary?: LiveReportSummary;

  /**
   * Raw event log, useful for debugging and future UI affordances
   * (timeline, activity summary, etc.).
   */
  events: LiveReportEvent[];
}

/**
 * Convenience constant for useReportStream() initial state.
 */
export const initialLiveReportState: LiveReportState = {
  connection: {
    status: 'idle',
    reconnectAttempts: 0,
    lastError: null,
  },
  group: null,
  activeReportId: null,
  samples: [],
  summary: undefined,
  events: [],
};

===== END modules/insights/types/liveReportState.ts =====


===== BEGIN modules/keenkonnect/ai-team-matching/find-teams/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/ai-team-matching/find-teams/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/ai-team-matching/match-preferences/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/ai-team-matching/match-preferences/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/ai-team-matching/my-matches/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/ai-team-matching/my-matches/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/dashboard/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/dashboard/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/knowledge/browse-repository/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/knowledge/browse-repository/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/knowledge/document-management/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/knowledge/document-management/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/knowledge/search-filter-documents/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/knowledge/search-filter-documents/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/knowledge/upload-new-document/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/knowledge/upload-new-document/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/projects/browse-projects/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/projects/browse-projects/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/projects/create-new-project/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/projects/create-new-project/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/projects/my-projects/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/projects/my-projects/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/projects/project-workspace/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/projects/project-workspace/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/sustainability-impact/submit-impact-reports/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/sustainability-impact/submit-impact-reports/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/sustainability-impact/sustainability-dashboard/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/sustainability-impact/sustainability-dashboard/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/sustainability-impact/track-project-impact/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/sustainability-impact/track-project-impact/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/user-reputation/account-preferences/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/user-reputation/account-preferences/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/user-reputation/manage-expertise-areas/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/user-reputation/manage-expertise-areas/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/user-reputation/view-reputation-ekoh/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/user-reputation/view-reputation-ekoh/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/workspaces/browse-available-workspaces/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/workspaces/browse-available-workspaces/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/workspaces/launch-new-workspace/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/workspaces/launch-new-workspace/components/CommonWidget/page.tsx =====


===== BEGIN modules/keenkonnect/workspaces/my-workspaces/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/keenkonnect/workspaces/my-workspaces/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/certifications/certification-programs/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/certifications/certification-programs/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/certifications/exam-dashboard-results/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/certifications/exam-dashboard-results/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/certifications/exam-preparation/components/CommonWidget/page.tsx =====
'use client'

import React from 'react'
import styles from './CommonWidget.module.css'

interface CommonWidgetProps {
  title: string
  description: string
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  )
}

export default CommonWidget

===== END modules/konnected/certifications/exam-preparation/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/certifications/exam-registration/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/certifications/exam-registration/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/community-discussions/active-threads/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/community-discussions/active-threads/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/community-discussions/moderation/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/community-discussions/moderation/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/community-discussions/start-new-discussion/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/community-discussions/start-new-discussion/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/dashboard/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/dashboard/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/learning-library/browse-resources/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/learning-library/browse-resources/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/learning-library/offline-content/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/learning-library/offline-content/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/learning-library/recommended-resources/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/learning-library/recommended-resources/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/learning-library/search-filters/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/learning-library/search-filters/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/learning-paths/create-learning-path/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/learning-paths/create-learning-path/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/learning-paths/manage-existing-paths/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/learning-paths/manage-existing-paths/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/learning-paths/my-learning-path/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/learning-paths/my-learning-path/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/teams-collaboration/activity-planner/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/teams-collaboration/activity-planner/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/teams-collaboration/my-teams/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/teams-collaboration/my-teams/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/teams-collaboration/project-workspaces/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/teams-collaboration/project-workspaces/components/CommonWidget/page.tsx =====


===== BEGIN modules/konnected/teams-collaboration/team-builder/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/konnected/teams-collaboration/team-builder/components/CommonWidget/page.tsx =====


===== BEGIN modules/konsensus/components/index.ts =====
﻿// C:\MyCode\Konnaxionv14\frontend\modules\konsensus\components\index.ts
export { default as VoteButtons } from './VoteButtons';

===== END modules/konsensus/components/index.ts =====


===== BEGIN modules/konsensus/components/PollBarChart.tsx =====
"use client";
import {
  Chart as ChartJS,
  BarElement,
  CategoryScale,
  LinearScale,
  Tooltip,
  Legend,
} from "chart.js";
import { Bar } from "react-chartjs-2";

ChartJS.register(BarElement, CategoryScale, LinearScale, Tooltip, Legend);

export default function PollBarChart({
  labels,
  votes,
}: {
  labels: string[];
  votes: number[];
}) {
  const data = { labels, datasets: [{ label: "Votes", data: votes }] };
  return <Bar data={data} options={{ responsive: true }} />;
}

===== END modules/konsensus/components/PollBarChart.tsx =====


===== BEGIN modules/konsensus/components/VoteButtons.tsx =====
﻿"use client";
import React from "react";
import { Button } from "antd";

// Explicit props: parent passes pollId and option list
export interface VoteButtonsProps {
  pollId: string;
  options: string[];
  onVote: (option: string) => void;
}

export default function VoteButtons({ pollId, options, onVote }: VoteButtonsProps) {
  return (
    <div className="flex gap-2">
      {options.map((option) => (
        <Button key={option} onClick={() => onVote(option)}>
          {option.charAt(0).toUpperCase() + option.slice(1)}
        </Button>
      ))}
    </div>
  );
}

===== END modules/konsensus/components/VoteButtons.tsx =====


===== BEGIN modules/konsensus/hooks/index.ts =====
﻿export * from './usePoll';

===== END modules/konsensus/hooks/index.ts =====


===== BEGIN modules/konsensus/hooks/useLivePoll.ts =====
// modules/konsensus/hooks/useLivePoll.ts
"use client";

import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import type { PollId } from "./usePoll";

/**
 * Lightweight "live" layer for Konsensus polls.
 *
 * Instead of a dedicated WebSocket endpoint (/api/poll/:id),
 * this hook periodically invalidates the React Query cache
 * so `usePoll` refetches fresh data from the Smart‑Vote API
 * (kollective/votes/).
 */
export default function useLivePoll(
  id: PollId,
  intervalMs = 5000,
): void {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!id) return;

    const timer = window.setInterval(() => {
      queryClient.invalidateQueries({ queryKey: ["poll", id] });
    }, intervalMs);

    return () => {
      window.clearInterval(timer);
    };
  }, [id, intervalMs, queryClient]);
}

===== END modules/konsensus/hooks/useLivePoll.ts =====


===== BEGIN modules/konsensus/hooks/usePoll.ts =====
﻿// modules/konsensus/hooks/usePoll.ts
import { useQuery } from "@tanstack/react-query";
import { api } from "@/shared/api";

/**
 * Shape of a single vote row returned by the Smart‑Vote API.
 * Note: weighted_value may come back as a string (DecimalField).
 */
export interface VoteRecord {
  id: number;
  user: string;
  target_type: string;
  target_id: number;
  raw_value: number | string;
  weighted_value: number | string;
  voted_at: string;
}

/**
 * Mapping between a logical poll id used in the UI and
 * the backend Smart‑Vote target (type + id).
 *
 * You can add more polls here later (e.g. "consultation-2025-01"…).
 */
const POLL_CONFIG = {
  current: {
    targetType: "konsensus.poll",
    targetId: 1,
    question: "Do you support rolling out the Konsensus pilot to all users?",
  },
} as const;

export type PollId = keyof typeof POLL_CONFIG;

export interface PollData {
  id: PollId;
  question: string;
  yes: number;
  no: number;
  total: number;
  /** 0–100, rounded integer */
  supportPercent: number;
}

export const DEFAULT_POLL_ID: PollId = "current";
/** Exported so pages/components can reuse the same mapping. */
export const pollConfig = POLL_CONFIG;

/**
 * Aggregate raw vote rows into a simple yes/no poll.
 * Convention: raw_value > 0 => "yes", raw_value <= 0 => "no".
 */
function aggregateVotes(votes: VoteRecord[]): {
  yes: number;
  no: number;
  total: number;
  supportPercent: number;
} {
  let yes = 0;
  let no = 0;

  for (const v of votes) {
    const val = Number(v.raw_value ?? 0);
    if (val > 0) yes += 1;
    else no += 1;
  }

  const total = yes + no;
  const supportPercent = total > 0 ? Math.round((yes / total) * 100) : 0;

  return { yes, no, total, supportPercent };
}

/**
 * Fetches a poll snapshot from the Smart‑Vote backend.
 *
 * - Hits kollective/votes/ (real DRF endpoint, via baseURL /api).
 * - Filters by target_type + target_id for the selected poll.
 * - Aggregates into a simple yes/no PollData structure.
 */
export function usePoll(id: PollId = DEFAULT_POLL_ID) {
  const cfg = POLL_CONFIG[id];

  return useQuery<PollData>({
    queryKey: ["poll", id],
    staleTime: 30_000,
    retry: 1,
    queryFn: async () => {
      const { data: payload } = await api.get<any>("kollective/votes/", {
        params: {
          target_type: cfg.targetType,
          target_id: cfg.targetId,
        },
      });

      // Handle both "bare list" and "paginated { results: [...] }" shapes
      let rows: VoteRecord[] = [];
      if (Array.isArray(payload)) {
        rows = payload as VoteRecord[];
      } else if (payload && Array.isArray((payload as any).results)) {
        rows = (payload as any).results as VoteRecord[];
      }

      // Extra client‑side filter in case backend ignores query params for now
      const filtered = rows.filter(
        (v) =>
          v.target_type === cfg.targetType &&
          String(v.target_id) === String(cfg.targetId),
      );

      const { yes, no, total, supportPercent } = aggregateVotes(filtered);

      return {
        id,
        question: cfg.question,
        yes,
        no,
        total,
        supportPercent,
      };
    },
  });
}

===== END modules/konsensus/hooks/usePoll.ts =====


===== BEGIN modules/konsensus/pages/index.ts =====
export { default as PollPage } from './PollPage';

===== END modules/konsensus/pages/index.ts =====


===== BEGIN modules/konsensus/pages/PollPage.tsx =====
// modules/konsensus/pages/PollPage.tsx
"use client";

import React from "react";
import { Card, Spin, Alert, message } from "antd";
import { useQueryClient } from "@tanstack/react-query";
import { api } from "@/shared/api";
import { usePoll, DEFAULT_POLL_ID, pollConfig } from "../hooks/usePoll";
import useLivePoll from "../hooks/useLivePoll";
import VoteButtons from "../components/VoteButtons";
import PollBarChart from "../components/PollBarChart";

/**
 * Konsensus Center – Smart‑Vote yes/no poll.
 *
 * Reads aggregated results from the Smart‑Vote API
 * (kollective/votes/) via usePoll, and posts new votes
 * back to the same endpoint.
 */
export default function PollPage() {
  const pollId = DEFAULT_POLL_ID;
  const cfg = pollConfig[pollId];
  const queryClient = useQueryClient();

  const {
    data: poll,
    isLoading,
    isError,
    error,
  } = usePoll(pollId);

  // Periodically refresh the poll snapshot
  useLivePoll(pollId, 5000);

  const handleVote = async (option: string) => {
    if (!cfg) return;

    const normalized = option.toLowerCase();
    const rawValue = normalized === "yes" ? 1 : -1;

    try {
      await api.post("kollective/votes/", {
        target_type: cfg.targetType,
        target_id: cfg.targetId,
        raw_value: rawValue,
        // For now, weighted_value mirrors raw_value.
        // A more advanced Ekoh/EcKo engine can later adjust it server‑side.
        weighted_value: rawValue,
      });

      // Refresh local snapshot
      queryClient.invalidateQueries({ queryKey: ["poll", pollId] });
      message.success("Your vote has been recorded.");
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Vote submission failed", e);
      message.error("Unable to record your vote. Please try again.");
    }
  };

  if (isLoading) return <Spin />;
  if (isError)
    return (
      <Alert
        message={
          (error as Error)?.message || "Failed to load the current poll."
        }
        type="error"
      />
    );
  if (!poll) return null;

  return (
    <div className="container mx-auto py-8">
      <Card title="Current Konsensus Poll">
        <h1 className="mb-4 text-xl font-semibold">{poll.question}</h1>

        <div className="mb-4 flex flex-wrap items-baseline gap-4">
          <span>Yes: {poll.yes}</span>
          <span>No: {poll.no}</span>
          <span>Total: {poll.total}</span>
          <span>Support: {poll.supportPercent}%</span>
        </div>

        <div className="mb-6 max-w-md">
          <PollBarChart
            labels={["Yes", "No"]}
            votes={[poll.yes, poll.no]}
          />
        </div>

        <VoteButtons
          pollId={pollId}
          options={["yes", "no"]}
          onVote={handleVote}
        />
      </Card>
    </div>
  );
}

===== END modules/konsensus/pages/PollPage.tsx =====


===== BEGIN modules/konsultations/components/ConsultationForm.tsx =====
﻿import React, { useState } from 'react';
import { Form, Slider, Input, Button, message as antdMessage } from 'antd';
// (Assume an axios-based helper or useRequest hook is available for API calls)
import { useRequest } from 'ahooks';

interface ConsultationFormProps {
  consultationId: string | number;
  // Optionally, currentValue could be passed in to show existing stance
  initialValue?: number;
}

const stanceMarks = {
  [-3]: '-3',
  [-2]: '-2',
  [-1]: '-1',
  0: '0',
  1: '1',
  2: '2',
  3: '3',
};

const stanceLabels: Record<number, string> = {
  [-3]: 'Strongly Against',
  [-2]: 'Against',
  [-1]: 'Slightly Against',
  0: 'Neutral',
  1: 'Slightly For',
  2: 'For',
  3: 'Strongly For',
};

const ConsultationForm: React.FC<ConsultationFormProps> = ({ consultationId, initialValue }) => {
  const [form] = Form.useForm();
  const [submitting, setSubmitting] = useState(false);

  // Use ahooks useRequest for the submission API call (POST stance)
  const { run: submitStance } = useRequest(
    async (value: number, comment?: string) => {
      // Example API endpoint: POST /api/konsultations/consultations/{id}/vote/
      // Payload: { value: ..., comment: ... }
      // (The exact endpoint may vary; adjust based on backend routes)
      return await axios.post(`/api/konsultations/consultations/${consultationId}/vote/`, {
        value,
        comment,
      });
    },
    {
      manual: true,
      onSuccess: () => {
        antdMessage.success('Your stance has been recorded.');
        // Optionally refresh consultation data (results, etc.)
        form.resetFields(['comment']);
      },
      onError: () => {
        antdMessage.error('Failed to submit stance. Please try again.');
      },
      onFinally: () => setSubmitting(false),
    }
  );

  const onFinish = ({ value, comment }: { value: number; comment?: string }) => {
    setSubmitting(true);
    submitStance(value, comment);
  };

  return (
    <Form 
      form={form} 
      layout="vertical" 
      initialValues={{ value: initialValue, comment: '' }} 
      onFinish={onFinish}
    >
      <Form.Item 
        label="Your stance" 
        name="value" 
        rules={[{ required: true, message: 'Please select a stance.' }]}
      >
        <Slider 
          min={-3} max={3} step={1} marks={stanceMarks} 
          tooltip={{ formatter: (val) => stanceLabels[val as number] }} 
        />
      </Form.Item>
      <Form.Item label="Comment (optional)" name="comment">
        <Input.TextArea rows={3} placeholder="Add an explanation or suggestion (optional)" />
      </Form.Item>
      <Form.Item>
        <Button type="primary" htmlType="submit" loading={submitting}>
          Submit Stance
        </Button>
      </Form.Item>
    </Form>
  );
};

export default ConsultationForm;

===== END modules/konsultations/components/ConsultationForm.tsx =====


===== BEGIN modules/konsultations/components/ConsultationList.tsx =====
﻿'use client';

import React, { useEffect, useState } from 'react';
import Link from 'next/link';
import { List, Tag, Spin, Alert } from 'antd';

interface Consultation {
  id: number | string;
  title: string;
  open_date?: string;
  close_date?: string;
  status: string;
}

export default function ConsultationList(): JSX.Element {
  const [consultations, setConsultations] = useState<Consultation[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let isMounted = true;
    const fetchConsultations = async () => {
      try {
        setLoading(true);
        setError(null);
        const res = await fetch('/api/konsultations/consultations', { method: 'GET' });
        if (!res.ok) {
          throw new Error(`Failed to load consultations (status ${res.status})`);
        }
        const data = await res.json();
        // Support both plain array and paginated response shapes
        const items: unknown[] = Array.isArray(data) ? data : (data.items ?? data.results ?? []);
        const list = items as Consultation[];
        if (isMounted) {
          setConsultations(list);
        }
      } catch (err) {
        console.error('Error loading consultations:', err);
        if (isMounted) {
          setError('Unable to load consultations from the server.');
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };
    fetchConsultations();
    return () => {
      isMounted = false;
    };
  }, []);

  // Split consultations by status
  const openConsultations = consultations.filter((c) =>
    c.status.toLowerCase() === 'open'
  );
  const closedConsultations = consultations.filter((c) =>
    c.status.toLowerCase() !== 'open'
  );

  // Formatting helper for dates
  const formatDate = (isoDate?: string): string => {
    if (!isoDate) return '';
    const date = new Date(isoDate);
    if (Number.isNaN(date.getTime())) return isoDate; // return original if parsing fails
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  if (loading) {
    return (
      <div style={{ textAlign: 'center', padding: 24 }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <>
      {error && (
        <Alert 
          message={error} 
          type="error" 
          showIcon 
          style={{ marginBottom: 16 }} 
        />
      )}
      {openConsultations.length > 0 && (
        <List
          header={<h3 style={{ marginBottom: 8 }}>Open Consultations</h3>}
          itemLayout="vertical"
          dataSource={openConsultations}
          renderItem={(item) => {
            const statusLabel =
              item.status.charAt(0).toUpperCase() + item.status.slice(1);
            const closeDate = formatDate(item.close_date);
            return (
              <List.Item
                actions={[
                  <Link 
                    key="participate" 
                    href={{ pathname: '/konsultations/suggestion', query: { consultationId: String(item.id) } }}
                  >
                    Participate
                  </Link>,
                ]}
              >
                <List.Item.Meta
                  title={
                    <span>
                      {item.title}{' '}
                      <Tag color="green">{statusLabel}</Tag>
                    </span>
                  }
                  description={
                    closeDate ? `Closes on ${closeDate}` : undefined
                  }
                />
              </List.Item>
            );
          }}
        />
      )}
      {closedConsultations.length > 0 && (
        <List
          header={<h3 style={{ marginTop: 24, marginBottom: 8 }}>Closed Consultations</h3>}
          itemLayout="vertical"
          dataSource={closedConsultations}
          renderItem={(item) => {
            const statusLabel =
              item.status.charAt(0).toUpperCase() + item.status.slice(1);
            const closeDate = formatDate(item.close_date);
            return (
              <List.Item
                actions={[
                  <Link 
                    key="results" 
                    href={{ pathname: '/konsultations/results', query: { consultationId: String(item.id) } }}
                  >
                    View Results
                  </Link>,
                ]}
              >
                <List.Item.Meta
                  title={
                    <span>
                      {item.title}{' '}
                      <Tag color="blue">{statusLabel}</Tag>
                    </span>
                  }
                  description={
                    closeDate ? `Closed on ${closeDate}` : undefined
                  }
                />
              </List.Item>
            );
          }}
        />
      )}
    </>
  );
}

===== END modules/konsultations/components/ConsultationList.tsx =====


===== BEGIN modules/konsultations/components/ConsultationVotePanel.tsx =====
﻿// frontend/modules/konsultations/components/ConsultationVotePanel.tsx

import React, { useEffect, useMemo, useState } from 'react';
import {
  Alert,
  Card,
  Divider,
  Empty,
  Progress,
  Slider,
  Space,
  Statistic,
  Tag,
  Typography,
  message,
} from 'antd';
import { useRequest } from 'ahooks';
import { get, post } from '@/services/_request';

const { Paragraph, Text, Title } = Typography;

/* ------------------------------------------------------------------ */
/*  Types                                                             */
/* ------------------------------------------------------------------ */

export interface ConsultationVotePanelProps {
  /** Ethikos topic id backing this consultation (numeric or string) */
  topicId?: string | number;
  /** Optional title override; defaults to "Your stance" */
  title?: React.ReactNode;
  /** When true, hides the collective summary section */
  hideSummary?: boolean;
  /** Optional CSS class for the outer Card */
  className?: string;
}

interface EthikosStancePoint {
  id: number;
  topic: number;
  value: number; // -3 … +3
  timestamp: string;
  user?: string;
}

interface UserMeApi {
  username: string;
  name?: string | null;
  email?: string;
  url?: string;
}

interface StanceStats {
  total: number;
  average: number;
  positive: number;
  neutral: number;
  negative: number;
  counts: Record<number, number>;
}

/* ------------------------------------------------------------------ */
/*  Helpers                                                           */
/* ------------------------------------------------------------------ */

function computeStanceStats(stances: EthikosStancePoint[]): StanceStats {
  const counts: Record<number, number> = {
    [-3]: 0,
    [-2]: 0,
    [-1]: 0,
    0: 0,
    1: 0,
    2: 0,
    3: 0,
  };

  let total = 0;
  let sum = 0;
  let positive = 0;
  let neutral = 0;
  let negative = 0;

  for (const s of stances) {
    const v = Math.max(-3, Math.min(3, s.value));
    counts[v] = (counts[v] ?? 0) + 1;
    total += 1;
    sum += v;

    if (v > 0) positive += 1;
    else if (v < 0) negative += 1;
    else neutral += 1;
  }

  const average = total > 0 ? sum / total : 0;

  return {
    total,
    average,
    positive,
    neutral,
    negative,
    counts,
  };
}

function stanceLabel(value: number): string {
  switch (value) {
    case -3:
      return 'Strongly against';
    case -2:
      return 'Moderately against';
    case -1:
      return 'Somewhat against';
    case 0:
      return 'Neutral / undecided';
    case 1:
      return 'Somewhat for';
    case 2:
      return 'Moderately for';
    case 3:
      return 'Strongly for';
    default:
      return 'Neutral / undecided';
  }
}

async function fetchTopicStances(topicId: string): Promise<EthikosStancePoint[]> {
  const numericId = Number(topicId);
  if (!Number.isFinite(numericId)) return [];
  return get<EthikosStancePoint[]>('ethikos/stances/', {
    params: { topic: numericId },
  });
}

async function submitTopicStance(topicId: string, value: number): Promise<void> {
  const numericId = Number(topicId);
  if (!Number.isFinite(numericId)) {
    throw new Error(`Invalid topic id: ${topicId}`);
  }
  await post('ethikos/stances/', {
    topic: numericId,
    value,
  });
}

/* ------------------------------------------------------------------ */
/*  Component                                                         */
/* ------------------------------------------------------------------ */

const sliderMarks: Record<number, React.ReactNode> = {
  [-3]: '−3',
  [-2]: '',
  [-1]: '−1',
  0: '0',
  1: '+1',
  2: '',
  3: '+3',
};

export default function ConsultationVotePanel(
  props: ConsultationVotePanelProps,
): JSX.Element {
  const { topicId, title, hideSummary, className } = props;

  const topicKey = useMemo(
    () => (topicId != null ? String(topicId) : undefined),
    [topicId],
  );

  const {
    data: stances,
    loading: loadingStances,
    refresh: refreshStances,
  } = useRequest<EthikosStancePoint[], []>(
    () => fetchTopicStances(topicKey!),
    {
      ready: !!topicKey,
      refreshDeps: [topicKey],
    },
  );

  const { data: me } = useRequest<UserMeApi, []>(() =>
    get<UserMeApi>('users/me/'),
  );

  const [stanceValue, setStanceValue] = useState<number>(0);
  const [stanceHydrated, setStanceHydrated] = useState(false);
  const [savingStance, setSavingStance] = useState(false);

  // Initialize slider from existing stance once user & stances are loaded
  useEffect(() => {
    if (stanceHydrated) return;
    if (!me || !stances) return;

    const mine = stances.find((s) => s.user === me.username);
    if (mine) {
      setStanceValue(Math.max(-3, Math.min(3, mine.value)));
    }
    setStanceHydrated(true);
  }, [me, stances, stanceHydrated]);

  const stanceStats = useMemo(
    () => computeStanceStats(stances ?? []),
    [stances],
  );

  const handleSaveStance = async () => {
    if (!topicKey) return;
    setSavingStance(true);
    try {
      await submitTopicStance(topicKey, stanceValue);
      message.success('Stance saved');
      await refreshStances();
    } catch (err) {
      message.error('Could not save your stance. Please try again.');
    } finally {
      setSavingStance(false);
    }
  };

  if (!topicKey) {
    return (
      <Card className={className}>
        <Empty description="No consultation selected" />
      </Card>
    );
  }

  return (
    <Card
      className={className}
      title={title ?? 'Your stance'}
      bordered
      bodyStyle={{ paddingBottom: hideSummary ? 16 : 24 }}
    >
      <Paragraph type="secondary">
        Use the scale below to register how strongly you are for or against this
        consultation. You can change your stance while the consultation is open.
      </Paragraph>

      <div style={{ marginTop: 16 }}>
        <Slider
          min={-3}
          max={3}
          step={1}
          dots
          marks={sliderMarks}
          value={stanceValue}
          tooltip={{
            formatter: (v) =>
              typeof v === 'number' ? stanceLabel(v) : undefined,
          }}
          onChange={(v) => setStanceValue(v as number)}
        />

        <Space
          style={{
            marginTop: 8,
            justifyContent: 'space-between',
            width: '100%',
          }}
        >
          <Text type="secondary">Strongly against</Text>
          <Text type="secondary">Neutral</Text>
          <Text type="secondary">Strongly for</Text>
        </Space>

        <Paragraph style={{ marginTop: 8 }}>
          Current selection: <Text strong>{stanceLabel(stanceValue)}</Text>
        </Paragraph>

        <Space style={{ marginTop: 8 }}>
          <Statistic
            title="Raw stance"
            value={stanceValue}
            precision={0}
            style={{ marginRight: 16 }}
          />
          <Tag color="geekblue">−3 … +3 scale</Tag>
        </Space>

        <Space style={{ marginTop: 12 }}>
          <button
            type="button"
            className="ant-btn ant-btn-primary"
            onClick={handleSaveStance}
            disabled={savingStance}
          >
            {savingStance ? 'Saving…' : 'Save stance'}
          </button>
          <button
            type="button"
            className="ant-btn"
            onClick={() => setStanceValue(0)}
            disabled={savingStance}
          >
            Reset to neutral
          </button>
        </Space>

        <Alert
          style={{ marginTop: 16 }}
          type="info"
          showIcon
          message="One stance per topic"
          description="You can adjust your position at any time; only your latest stance is used in the consensus."
        />
      </div>

      {!hideSummary && (
        <>
          <Divider />
          <Title level={5} style={{ marginTop: 0 }}>
            Collective stance
          </Title>
          <Paragraph type="secondary">
            Snapshot of all recorded stances for this consultation.
          </Paragraph>

          <Space
            size="large"
            style={{ marginTop: 12, flexWrap: 'wrap' }}
          >
            <Statistic
              title="Participants"
              value={stanceStats.total}
              loading={loadingStances}
            />
            <Statistic
              title="Average stance"
              value={stanceStats.average}
              precision={2}
              loading={loadingStances}
            />
            <Statistic
              title="For / Against balance"
              value={
                stanceStats.total > 0
                  ? Math.round(
                      (1 -
                        Math.abs(
                          stanceStats.positive - stanceStats.negative,
                        ) /
                          stanceStats.total) *
                        100,
                    )
                  : 100
              }
              suffix="%"
              loading={loadingStances}
            />
          </Space>

          {stanceStats.total > 0 ? (
            <div style={{ marginTop: 16 }}>
              <Space
                direction="vertical"
                size="small"
                style={{ width: '100%' }}
              >
                <div>
                  <Text>For</Text>
                  <Progress
                    percent={Math.round(
                      (stanceStats.positive / stanceStats.total) * 100,
                    )}
                    showInfo
                  />
                </div>
                <div>
                  <Text>Neutral</Text>
                  <Progress
                    percent={Math.round(
                      (stanceStats.neutral / stanceStats.total) * 100,
                    )}
                    showInfo
                  />
                </div>
                <div>
                  <Text>Against</Text>
                  <Progress
                    percent={Math.round(
                      (stanceStats.negative / stanceStats.total) * 100,
                    )}
                    showInfo
                  />
                </div>

                <Paragraph style={{ marginTop: 4 }}>
                  <Tag color="geekblue">−3 … +3 scale</Tag>{' '}
                  <Text type="secondary">
                    0 = neutral; negative values = against; positive values =
                    for.
                  </Text>
                </Paragraph>
              </Space>
            </div>
          ) : (
            <Empty
              description="No stances recorded yet"
              image={Empty.PRESENTED_IMAGE_SIMPLE}
              style={{ marginTop: 16 }}
            />
          )}
        </>
      )}
    </Card>
  );
}

===== END modules/konsultations/components/ConsultationVotePanel.tsx =====


===== BEGIN modules/konsultations/components/ImpactTimeline.tsx =====
﻿'use client';

import { Timeline, Typography, Empty, Tag, Space } from 'antd';
import { ClockCircleOutlined } from '@ant-design/icons';
import dayjs from 'dayjs';

const { Text } = Typography;

export type ImpactEventKind =
  | 'opened'
  | 'phase'
  | 'engagement'
  | 'result'
  | 'follow-up'
  | 'other';

export interface ImpactEvent {
  /** Stable identifier for React keys */
  id: string;
  /** ISO datetime or human-readable date */
  when: string;
  /** Main label for the event (e.g. "Consultation opened") */
  title: string;
  /** Optional extra context shown under the title */
  detail?: string;
  /** Optional semantic type that drives colors / badges */
  kind?: ImpactEventKind;
}

export interface ImpactTimelineProps {
  /** Chronological list of impact events for a single consultation */
  events?: ImpactEvent[] | null;
  /** Optional CSS class for outer wrapper */
  className?: string;
}

const KIND_LABEL: Record<ImpactEventKind, string> = {
  opened: 'Opened',
  phase: 'Phase',
  engagement: 'Engagement',
  result: 'Result',
  'follow-up': 'Follow-up',
  other: 'Activity',
};

const KIND_COLOR: Record<ImpactEventKind, 'blue' | 'green' | 'red' | 'gray'> = {
  opened: 'blue',
  phase: 'blue',
  engagement: 'gray',
  result: 'green',
  'follow-up': 'gray',
  other: 'gray',
};

/**
 * Small, reusable timeline component to visualise the impact
 * lifecycle of a single consultation.
 *
 * Data loading (e.g. via `useImpact(consultationId)`) is handled
 * by the parent; this component is purely presentational.
 */
export default function ImpactTimeline({
  events,
  className,
}: ImpactTimelineProps) {
  const sorted = [...(events ?? [])].sort((a, b) => {
    const ta = Date.parse(a.when);
    const tb = Date.parse(b.when);
    if (Number.isNaN(ta) || Number.isNaN(tb)) {
      return a.when.localeCompare(b.when);
    }
    // Oldest first
    return ta - tb;
  });

  if (!sorted.length) {
    return (
      <div className={className}>
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description="No impact events recorded for this consultation yet."
        />
      </div>
    );
  }

  const items = sorted.map((evt) => {
    const kind: ImpactEventKind = evt.kind ?? 'other';
    const label = dayjs(evt.when).isValid()
      ? dayjs(evt.when).format('YYYY-MM-DD')
      : evt.when;

    return {
      key: evt.id,
      color: KIND_COLOR[kind],
      dot: <ClockCircleOutlined />,
      label,
      children: (
        <Space direction="vertical" size={0}>
          <Space size="small" wrap>
            <Text strong>{evt.title}</Text>
            {evt.kind && (
              <Tag color={KIND_COLOR[kind]}>{KIND_LABEL[kind]}</Tag>
            )}
          </Space>
          {evt.detail && <Text type="secondary">{evt.detail}</Text>}
        </Space>
      ),
    };
  });

  return (
    <div className={className}>
      <Timeline mode="left" items={items} />
    </div>
  );
}

===== END modules/konsultations/components/ImpactTimeline.tsx =====


===== BEGIN modules/konsultations/components/index.ts =====
﻿export { default as ConsultationForm }   from './ConsultationForm';
export { default as ConsultationList }   from './ConsultationList';
export { default as ConsultationVotePanel } from './ConsultationVotePanel';
export { default as ImpactTimeline }     from './ImpactTimeline';
export { default as ResultsChart }       from './ResultsChart';
export { default as ResultsDashboard }   from './ResultsDashboard';
export { default as SuggestionBoard }    from './SuggestionBoard';
export { default as SuggestionsBoard }   from './SuggestionsBoard';

===== END modules/konsultations/components/index.ts =====


===== BEGIN modules/konsultations/components/ResultsChart.tsx =====
﻿'use client';

import React, { useMemo } from 'react';
import type { ReactNode } from 'react';
import { Empty } from 'antd';
import { Bar } from '@ant-design/plots';

export type ConsultationResultMode = 'raw' | 'weighted';

export interface ConsultationResultDatum {
  /**
   * Option label displayed on the X axis, e.g. "Strongly agree".
   */
  option: string;
  /**
   * Raw number of votes for this option.
   */
  votes: number;
  /**
   * Optional weighted score (e.g. reputation‑weighted, 0–100).
   * If not provided and mode="weighted", we fall back to `votes`.
   */
  weightedScore?: number | null;
  /**
   * Optional cohort label (e.g. "Public", "Experts").
   * When provided, the chart renders grouped bars per option.
   */
  cohort?: string;
}

export interface ResultsChartProps {
  /**
   * Aggregated results to display. Can be single-series (no cohort)
   * or multi-series (cohort provided).
   */
  data: ConsultationResultDatum[];
  /**
   * Metric to chart: raw vote counts or weighted scores.
   */
  mode?: ConsultationResultMode;
  /**
   * Chart height in pixels.
   */
  height?: number;
  /**
   * Show legend (only relevant when cohorts are used).
   */
  showLegend?: boolean;
  /**
   * Optional custom empty-state message.
   */
  emptyMessage?: ReactNode;
}

/**
 * Generic bar chart for consultation results.
 * - X axis: options
 * - Y axis: votes or weighted score
 * - Optional grouping by cohort
 */
export default function ResultsChart({
  data,
  mode = 'raw',
  height = 260,
  showLegend = true,
  emptyMessage = 'No consultation results available yet.',
}: ResultsChartProps) {
  const hasData = Array.isArray(data) && data.length > 0;

  const multiCohort = useMemo(
    () => hasData && data.some((d) => d.cohort),
    [data, hasData],
  );

  const chartData = useMemo(() => {
    if (!hasData) return [];

    const getValue = (d: ConsultationResultDatum): number => {
      if (mode === 'weighted') {
        if (typeof d.weightedScore === 'number') return d.weightedScore;
        // Fallback to raw votes if weighted score is missing
        return d.votes ?? 0;
      }
      return d.votes ?? 0;
    };

    if (multiCohort) {
      return data.map((d) => ({
        option: d.option,
        cohort: d.cohort ?? 'All',
        value: getValue(d),
      }));
    }

    return data.map((d) => ({
      option: d.option,
      value: getValue(d),
    }));
  }, [data, hasData, mode, multiCohort]);

  if (!hasData) {
    return <Empty description={emptyMessage} />;
  }

  const config: any = multiCohort
    ? {
        data: chartData,
        isGroup: true,
        xField: 'option',
        yField: 'value',
        seriesField: 'cohort',
        autoFit: true,
        height,
        legend: showLegend ? undefined : false,
        columnStyle: {
          radius: [4, 4, 0, 0],
        },
        tooltip: {
          shared: true,
        },
      }
    : {
        data: chartData,
        xField: 'option',
        yField: 'value',
        autoFit: true,
        height,
        legend: false,
        columnStyle: {
          radius: [4, 4, 0, 0],
        },
        tooltip: {
          shared: true,
        },
      };

  return <Bar {...config} />;
}

===== END modules/konsultations/components/ResultsChart.tsx =====


===== BEGIN modules/konsultations/components/ResultsDashboard.tsx =====
﻿'use client';

import {
  Alert,
  Card,
  Col,
  Empty,
  List,
  Progress,
  Row,
  Space,
  Statistic,
  Tag,
  Timeline,
  Typography,
} from 'antd';
import {
  useConsultation,
  useConsultationResults,
  useImpact,
  useSuggestions,
} from '../hooks';

const { Text } = Typography;

type ConsultationStatus = 'open' | 'closed' | 'archived' | string;

interface ConsultationSummary {
  id: string;
  title: string;
  status?: ConsultationStatus;
  openDate?: string;
  closeDate?: string;
  region?: string;
}

interface OptionResult {
  key?: string;
  label: string;
  rawCount: number;
  weightedCount?: number | null;
}

interface ConsultationResults {
  totalVotes: number;
  turnoutPercent?: number;
  rawAverage?: number;
  weightedAverage?: number;
  supportPercent?: number;
  medianStance?: number;
  options?: OptionResult[];
}

interface ImpactItem {
  id: string;
  action: string;
  status?: string;
  date?: string;
}

interface SuggestionItem {
  id: string;
  author?: string;
  content: string;
  createdAt?: string;
  status?: string;
  supportCount?: number;
}

export interface ResultsDashboardProps {
  consultationId?: string | number;
}

function statusTagColor(status?: string): string {
  if (!status) return 'default';
  const normalized = status.toLowerCase();
  if (normalized === 'open') return 'green';
  if (normalized === 'closed') return 'geekblue';
  if (normalized === 'archived') return 'default';
  return 'default';
}

function impactStatusColor(status?: string): string {
  if (!status) return 'default';
  const normalized = status.toLowerCase();
  if (normalized === 'planned') return 'blue';
  if (normalized === 'in-progress' || normalized === 'in_progress') return 'gold';
  if (normalized === 'completed') return 'green';
  if (normalized === 'blocked') return 'red';
  return 'default';
}

function formatDate(value?: string): string | null {
  if (!value) return null;
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return null;
  return date.toLocaleDateString();
}

function formatDateRange(openDate?: string, closeDate?: string): string | null {
  const open = formatDate(openDate);
  const close = formatDate(closeDate);
  if (open && close) return `${open} → ${close}`;
  if (open) return `Opens ${open}`;
  if (close) return `Closes ${close}`;
  return null;
}

export default function ResultsDashboard({
  consultationId,
}: ResultsDashboardProps) {
  // Hooks are currently stubs; casting via `any` keeps this component tolerant
  // until the Konsultations hooks are fully implemented.
  const consultationState = (useConsultation as any)(consultationId) || {};
  const resultsState = (useConsultationResults as any)(consultationId) || {};
  const impactState = (useImpact as any)(consultationId) || {};
  const suggestionsState = (useSuggestions as any)(consultationId) || {};

  const consultation = consultationState.data as ConsultationSummary | undefined;
  const consultationLoading = Boolean(consultationState.loading);
  const consultationError = consultationState.error as Error | undefined;

  const results = resultsState.data as ConsultationResults | undefined;
  const resultsLoading = Boolean(resultsState.loading);
  const resultsError = resultsState.error as Error | undefined;

  const impactItems: ImpactItem[] =
    (impactState.items as ImpactItem[] | undefined) ??
    (impactState.data?.items as ImpactItem[] | undefined) ??
    [];
  const impactLoading = Boolean(impactState.loading);
  const impactError = impactState.error as Error | undefined;

  const suggestions: SuggestionItem[] =
    (suggestionsState.items as SuggestionItem[] | undefined) ??
    (suggestionsState.data?.items as SuggestionItem[] | undefined) ??
    [];
  const suggestionsLoading = Boolean(suggestionsState.loading);
  const suggestionsError = suggestionsState.error as Error | undefined;

  const loading =
    consultationLoading || resultsLoading || impactLoading || suggestionsLoading;

  if (!consultationId) {
    return (
      <Card>
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description="Select a consultation to view live results and impact."
        />
      </Card>
    );
  }

  const headerError = consultationError || resultsError;

  const totalVotes = results?.totalVotes ?? 0;
  const turnoutPct = results?.turnoutPercent;
  const supportPct = results?.supportPercent;
  const rawAvg = results?.rawAverage;
  const weightedAvg = results?.weightedAverage;
  const medianStance =
    typeof results?.medianStance === 'number'
      ? results.medianStance
      : typeof weightedAvg === 'number'
      ? weightedAvg
      : rawAvg;

  const options = results?.options ?? [];
  const dateRange = formatDateRange(consultation?.openDate, consultation?.closeDate);

  return (
    <Space direction="vertical" size="middle" style={{ width: '100%' }}>
      {headerError && (
        <Alert
          type="error"
          showIcon
          message="Unable to load consultation results."
          description={headerError.message}
        />
      )}

      <Card
        loading={loading}
        title={consultation?.title ?? 'Consultation results'}
        extra={
          <Space size={8} wrap>
            {consultation?.status && (
              <Tag color={statusTagColor(consultation.status)}>
                {consultation.status.toUpperCase()}
              </Tag>
            )}
            {consultation?.region && <Tag>{consultation.region}</Tag>}
          </Space>
        }
      >
        <Space direction="vertical" size="small" style={{ width: '100%' }}>
          {dateRange && (
            <Text type="secondary">Consultation window: {dateRange}</Text>
          )}
          <Text type="secondary">
            Results combine raw votes with optional Ekoh‑weighted aggregates. As
            new votes and impact actions are recorded, this snapshot updates
            automatically.
          </Text>

          <Row gutter={16} style={{ marginTop: 16 }}>
            <Col xs={12} md={6}>
              <Statistic title="Total votes" value={totalVotes} />
            </Col>
            <Col xs={12} md={6}>
              <Statistic
                title="Weighted support"
                value={supportPct != null ? Math.round(supportPct) : undefined}
                suffix={supportPct != null ? '%' : undefined}
              />
            </Col>
            <Col xs={12} md={6}>
              <Statistic
                title="Turnout"
                value={turnoutPct != null ? Math.round(turnoutPct) : undefined}
                suffix={turnoutPct != null ? '%' : undefined}
              />
            </Col>
            <Col xs={12} md={6}>
              <Statistic
                title="Avg. stance"
                value={
                  typeof medianStance === 'number'
                    ? medianStance.toFixed(2)
                    : undefined
                }
              />
            </Col>
          </Row>
        </Space>
      </Card>

      <Row gutter={16}>
        <Col xs={24} lg={14}>
          <Card loading={resultsLoading} title="Vote distribution">
            {!results || options.length === 0 ? (
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description="No votes recorded yet for this consultation."
              />
            ) : (
              <List
                dataSource={options}
                renderItem={(opt) => (
                  <List.Item key={opt.key ?? opt.label}>
                    <List.Item.Meta
                      title={opt.label}
                      description={
                        <Space size={8} wrap>
                          <Text type="secondary">
                            Raw: {opt.rawCount}
                          </Text>
                          {typeof opt.weightedCount === 'number' && (
                            <Text type="secondary">
                              Weighted: {opt.weightedCount.toFixed(1)}
                            </Text>
                          )}
                        </Space>
                      }
                    />
                    <div style={{ minWidth: 160 }}>
                      <Progress
                        percent={
                          totalVotes
                            ? Math.round((opt.rawCount / totalVotes) * 100)
                            : 0
                        }
                        size="small"
                      />
                    </div>
                  </List.Item>
                )}
              />
            )}
          </Card>
        </Col>

        <Col xs={24} lg={10}>
          <Card
            loading={impactLoading}
            title="Impact & follow‑up actions"
          >
            {impactError && (
              <Alert
                type="error"
                showIcon
                message="Could not load impact actions."
                description={impactError.message}
                style={{ marginBottom: 8 }}
              />
            )}

            {!impactError && impactItems.length === 0 ? (
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description="No follow‑up actions have been logged yet."
              />
            ) : (
              <Timeline
                items={impactItems.map((item) => ({
                  key: item.id,
                  color: impactStatusColor(item.status),
                  children: (
                    <Space direction="vertical" size={0}>
                      <Text strong>{item.action}</Text>
                      <Space size={4} wrap>
                        {item.status && (
                          <Tag color={impactStatusColor(item.status)}>
                            {item.status}
                          </Tag>
                        )}
                        {item.date && (
                          <Text type="secondary">
                            {new Date(item.date).toLocaleDateString()}
                          </Text>
                        )}
                      </Space>
                    </Space>
                  ),
                }))}
              />
            )}
          </Card>

          <Card
            loading={suggestionsLoading}
            title="Top citizen suggestions"
            style={{ marginTop: 16 }}
          >
            {suggestionsError && (
              <Alert
                type="error"
                showIcon
                message="Could not load suggestions."
                description={suggestionsError.message}
                style={{ marginBottom: 8 }}
              />
            )}

            {!suggestionsError && suggestions.length === 0 ? (
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description="No suggestions submitted for this consultation yet."
              />
            ) : (
              <List
                size="small"
                dataSource={suggestions.slice(0, 5)}
                renderItem={(s) => (
                  <List.Item key={s.id}>
                    <List.Item.Meta
                      title={s.content}
                      description={
                        <Space size={4} wrap>
                          {s.author && (
                            <Text type="secondary">By {s.author}</Text>
                          )}
                          {s.status && (
                            <Tag
                              color={
                                s.status === 'accepted'
                                  ? 'green'
                                  : s.status === 'rejected'
                                  ? 'red'
                                  : 'default'
                              }
                            >
                              {s.status}
                            </Tag>
                          )}
                          {s.createdAt && (
                            <Text type="secondary">
                              {new Date(s.createdAt).toLocaleDateString()}
                            </Text>
                          )}
                          {typeof s.supportCount === 'number' && (
                            <Text type="secondary">
                              · Support: {s.supportCount}
                            </Text>
                          )}
                        </Space>
                      }
                    />
                  </List.Item>
                )}
              />
            )}
          </Card>
        </Col>
      </Row>
    </Space>
  );
}

===== END modules/konsultations/components/ResultsDashboard.tsx =====


===== BEGIN modules/konsultations/components/SuggestionBoard.tsx =====
﻿// frontend/modules/konsultations/components/SuggestionBoard.tsx
'use client';

import React, { useMemo, useState } from 'react';
import {
  Alert,
  Button,
  Card,
  Empty,
  Input,
  List,
  Radio,
  Space,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  LikeOutlined,
  DislikeOutlined,
  FilterOutlined,
  PlusOutlined,
  SortAscendingOutlined,
  SortDescendingOutlined,
} from '@ant-design/icons';

const { Text, Paragraph } = Typography;

export type SuggestionStatus =
  | 'new'
  | 'under_review'
  | 'accepted'
  | 'rejected'
  | 'implemented';

export interface Suggestion {
  id: string;
  body: string;
  createdAt: string;
  authorName?: string | null;
  upvotes: number;
  downvotes?: number;
  score?: number; // optional aggregated score (e.g. weighted support)
  status?: SuggestionStatus;
  tags?: string[];
}

export interface SuggestionBoardProps {
  /** Suggestions to display for the current consultation */
  suggestions: Suggestion[];

  /** Optional loading / error flags from the data‑fetching layer */
  isLoading?: boolean;
  errorMessage?: string | null;

  /** Enable/disable interactions */
  allowVoting?: boolean;
  allowNewSuggestions?: boolean;

  /** Optional limit for new suggestion length (characters) */
  maxLength?: number;

  /** Called when the user submits a new suggestion */
  onCreateSuggestion?: (body: string) => Promise<void> | void;

  /** Called when the user upvotes a suggestion */
  onUpvote?: (id: string) => Promise<void> | void;

  /** Called when the user downvotes a suggestion */
  onDownvote?: (id: string) => Promise<void> | void;
}

type SortMode = 'top' | 'recent';

const DEFAULT_MAX_LENGTH = 800;

function statusTag(status?: SuggestionStatus) {
  if (!status) return null;

  switch (status) {
    case 'new':
      return <Tag color="default">New</Tag>;
    case 'under_review':
      return <Tag color="processing">Under review</Tag>;
    case 'accepted':
      return <Tag color="green">Accepted</Tag>;
    case 'implemented':
      return <Tag color="blue">Implemented</Tag>;
    case 'rejected':
      return <Tag color="red">Rejected</Tag>;
    default:
      return null;
  }
}

function truncate(text: string, max = 200): string {
  if (text.length <= max) return text;
  return `${text.slice(0, max - 1).trimEnd()}…`;
}

const SuggestionBoard: React.FC<SuggestionBoardProps> = ({
  suggestions,
  isLoading,
  errorMessage,
  allowVoting = true,
  allowNewSuggestions = true,
  maxLength = DEFAULT_MAX_LENGTH,
  onCreateSuggestion,
  onUpvote,
  onDownvote,
}) => {
  const [sortMode, setSortMode] = useState<SortMode>('top');
  const [statusFilter, setStatusFilter] = useState<'all' | SuggestionStatus>('all');
  const [search, setSearch] = useState('');
  const [draft, setDraft] = useState('');
  const [submitting, setSubmitting] = useState(false);
  const [localError, setLocalError] = useState<string | null>(null);

  const normalizedSearch = search.trim().toLowerCase();

  const visibleSuggestions = useMemo(() => {
    let items = suggestions.slice();

    if (statusFilter !== 'all') {
      items = items.filter((s) => s.status === statusFilter);
    }

    if (normalizedSearch) {
      items = items.filter((s) => {
        const haystack = `${s.body} ${s.authorName ?? ''}`.toLowerCase();
        return haystack.includes(normalizedSearch);
      });
    }

    items.sort((a, b) => {
      if (sortMode === 'recent') {
        const ta = new Date(a.createdAt).getTime() || 0;
        const tb = new Date(b.createdAt).getTime() || 0;
        return tb - ta;
      }

      const scoreA =
        typeof a.score === 'number'
          ? a.score
          : a.upvotes - (typeof a.downvotes === 'number' ? a.downvotes : 0);
      const scoreB =
        typeof b.score === 'number'
          ? b.score
          : b.upvotes - (typeof b.downvotes === 'number' ? b.downvotes : 0);

      if (scoreB !== scoreA) return scoreB - scoreA;

      // tie‑break by recency
      const ta = new Date(a.createdAt).getTime() || 0;
      const tb = new Date(b.createdAt).getTime() || 0;
      return tb - ta;
    });

    return items;
  }, [suggestions, sortMode, statusFilter, normalizedSearch]);

  const handleSubmit = async () => {
    const body = draft.trim();
    if (!body) {
      setLocalError('Please write a suggestion before submitting.');
      return;
    }
    if (body.length > maxLength) {
      setLocalError(`Suggestions are limited to ${maxLength} characters.`);
      return;
    }
    if (!onCreateSuggestion) {
      setLocalError('Suggestion submission is not available.');
      return;
    }

    try {
      setLocalError(null);
      setSubmitting(true);
      await onCreateSuggestion(body);
      setDraft('');
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Failed to submit suggestion', err);
      setLocalError('Unable to submit your suggestion. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  const handleUpvote = async (id: string) => {
    if (!allowVoting || !onUpvote) return;
    try {
      await onUpvote(id);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Failed to upvote suggestion', err);
    }
  };

  const handleDownvote = async (id: string) => {
    if (!allowVoting || !onDownvote) return;
    try {
      await onDownvote(id);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Failed to downvote suggestion', err);
    }
  };

  const hasAnySuggestions = suggestions.length > 0;

  return (
    <Card
      title="Suggestions"
      extra={
        <Space size="middle" wrap>
          <Space>
            <FilterOutlined />
            <Radio.Group
              size="small"
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
            >
              <Radio.Button value="all">All</Radio.Button>
              <Radio.Button value="new">New</Radio.Button>
              <Radio.Button value="under_review">Under review</Radio.Button>
              <Radio.Button value="accepted">Accepted</Radio.Button>
              <Radio.Button value="implemented">Implemented</Radio.Button>
              <Radio.Button value="rejected">Rejected</Radio.Button>
            </Radio.Group>
          </Space>

          <Space>
            {sortMode === 'top' ? (
              <Tooltip title="Sorted by highest support first">
                <Button
                  size="small"
                  type="text"
                  icon={<SortDescendingOutlined />}
                  onClick={() => setSortMode('recent')}
                >
                  Top
                </Button>
              </Tooltip>
            ) : (
              <Tooltip title="Sorted by most recent first">
                <Button
                  size="small"
                  type="text"
                  icon={<SortAscendingOutlined />}
                  onClick={() => setSortMode('top')}
                >
                  Recent
                </Button>
              </Tooltip>
            )}
          </Space>

          <Input.Search
            allowClear
            size="small"
            placeholder="Search suggestions…"
            style={{ width: 220 }}
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
        </Space>
      }
    >
      <Space direction="vertical" size="large" style={{ width: '100%' }}>
        {(errorMessage || localError) && (
          <Alert
            type="error"
            showIcon
            message={errorMessage || localError}
          />
        )}

        {allowNewSuggestions && (
          <div>
            <Paragraph type="secondary" style={{ marginBottom: 8 }}>
              Propose a concrete change, amendment, or idea for this consultation. Be specific and
              explain trade‑offs where possible.
            </Paragraph>
            <Input.TextArea
              rows={4}
              value={draft}
              onChange={(e) => setDraft(e.target.value)}
              placeholder="Write your suggestion…"
              maxLength={maxLength}
              showCount
            />
            <Space style={{ marginTop: 8, width: '100%', justifyContent: 'space-between' }}>
              <Text type="secondary">
                {draft.trim().length === 0
                  ? 'Suggestions may be moderated according to Ethikos guidelines.'
                  : `${draft.length}/${maxLength} characters`}
              </Text>
              <Button
                type="primary"
                icon={<PlusOutlined />}
                onClick={handleSubmit}
                loading={submitting}
                disabled={submitting || draft.trim().length === 0}
              >
                Submit suggestion
              </Button>
            </Space>
          </div>
        )}

        {!hasAnySuggestions && !isLoading && (
          <Empty
            image={Empty.PRESENTED_IMAGE_SIMPLE}
            description="No suggestions yet. Be the first to propose one."
          />
        )}

        {hasAnySuggestions && (
          <List<Suggestion>
            itemLayout="vertical"
            dataSource={visibleSuggestions}
            renderItem={(item) => {
              const netScore =
                typeof item.score === 'number'
                  ? item.score
                  : item.upvotes - (typeof item.downvotes === 'number' ? item.downvotes : 0);

              return (
                <List.Item
                  key={item.id}
                  extra={
                    allowVoting && (
                      <Space direction="vertical" align="center">
                        <Tooltip title="I support this">
                          <Button
                            size="small"
                            icon={<LikeOutlined />}
                            onClick={() => handleUpvote(item.id)}
                          >
                            {item.upvotes}
                          </Button>
                        </Tooltip>
                        <Tooltip title="I do not support this">
                          <Button
                            size="small"
                            icon={<DislikeOutlined />}
                            onClick={() => handleDownvote(item.id)}
                          >
                            {item.downvotes ?? 0}
                          </Button>
                        </Tooltip>
                        <Text type="secondary" style={{ fontSize: 11 }}>
                          Net: {netScore}
                        </Text>
                      </Space>
                    )
                  }
                >
                  <List.Item.Meta
                    title={
                      <Space wrap>
                        <Text strong>Suggestion</Text>
                        {statusTag(item.status)}
                        {Array.isArray(item.tags) &&
                          item.tags.map((t) => (
                            <Tag key={t} color="default">
                              {t}
                            </Tag>
                          ))}
                      </Space>
                    }
                    description={
                      <Space direction="vertical" size={2}>
                        <Text type="secondary">
                          {item.authorName || 'Anonymous'} ·{' '}
                          {new Date(item.createdAt).toLocaleString()}
                        </Text>
                      </Space>
                    }
                  />
                  <Paragraph style={{ marginTop: 8, marginBottom: 0 }}>
                    {truncate(item.body, 600)}
                  </Paragraph>
                </List.Item>
              );
            }}
          />
        )}
      </Space>
    </Card>
  );
};

export default SuggestionBoard;

===== END modules/konsultations/components/SuggestionBoard.tsx =====


===== BEGIN modules/konsultations/components/SuggestionsBoard.tsx =====
﻿// modules/konsultations/components/SuggestionsBoard.tsx
'use client';

import React, { useMemo, useState } from 'react';
import dayjs from 'dayjs';
import {
  Card,
  List,
  Tag,
  Button,
  Space,
  Typography,
  Empty,
  Segmented,
  Select,
  Tooltip,
} from 'antd';
import {
  LikeOutlined,
  DislikeOutlined,
  CommentOutlined,
  ClockCircleOutlined,
} from '@ant-design/icons';

const { Text, Paragraph } = Typography;

/* ------------------------------------------------------------------ */
/*  Domain types                                                       */
/* ------------------------------------------------------------------ */

export type SuggestionStatus = 'new' | 'under-review' | 'accepted' | 'rejected';

export type SuggestionsSortKey = 'most-supported' | 'newest' | 'oldest';

export interface Suggestion {
  id: string;
  /** Short label for the suggestion (can be same as first sentence of body) */
  title: string;
  /** Main suggestion body / explanation */
  body: string;
  author: string;
  createdAt: string; // ISO string
  /** Number of supporting signals (votes, endorsements, etc.) */
  upvotes: number;
  /** Optional number of opposing signals */
  downvotes?: number;
  /** Optional number of comments / replies */
  commentsCount?: number;
  status: SuggestionStatus;
  /** Optional thematic tags (e.g. "Budget", "Governance") */
  tags?: string[];
}

export interface SuggestionsBoardProps {
  suggestions: Suggestion[];
  loading?: boolean;
  /** Custom empty state message */
  emptyMessage?: string;
  /** Initial status filter; defaults to "all" */
  defaultStatusFilter?: SuggestionStatus | 'all';
  /** Initial sort; defaults to "most-supported" */
  defaultSort?: SuggestionsSortKey;
  /** Optional callback when user clicks support / oppose */
  onVote?: (id: string, direction: 'up' | 'down') => void;
  /** Optional callback to open a full suggestion view */
  onOpenSuggestion?: (suggestion: Suggestion) => void;
}

type StatusFilter = SuggestionStatus | 'all';

const STATUS_LABELS: Record<SuggestionStatus, string> = {
  new: 'New',
  'under-review': 'Under review',
  accepted: 'Accepted',
  rejected: 'Rejected',
};

const STATUS_COLORS: Record<SuggestionStatus, string> = {
  new: 'default',
  'under-review': 'processing',
  accepted: 'success',
  rejected: 'error',
};

const DEFAULT_STATUS_FILTER_OPTIONS: { label: string; value: StatusFilter }[] = [
  { value: 'all', label: 'All' },
  { value: 'new', label: 'New' },
  { value: 'under-review', label: 'Under review' },
  { value: 'accepted', label: 'Accepted' },
  { value: 'rejected', label: 'Rejected' },
];

const SORT_OPTIONS: { value: SuggestionsSortKey; label: string }[] = [
  { value: 'most-supported', label: 'Most supported' },
  { value: 'newest', label: 'Newest first' },
  { value: 'oldest', label: 'Oldest first' },
];

/* ------------------------------------------------------------------ */
/*  Component                                                          */
/* ------------------------------------------------------------------ */

export default function SuggestionsBoard({
  suggestions,
  loading = false,
  emptyMessage = 'No suggestions have been submitted yet.',
  defaultStatusFilter = 'all',
  defaultSort = 'most-supported',
  onVote,
  onOpenSuggestion,
}: SuggestionsBoardProps): JSX.Element {
  const [statusFilter, setStatusFilter] = useState<StatusFilter>(defaultStatusFilter);
  const [sortKey, setSortKey] = useState<SuggestionsSortKey>(defaultSort);

  const items = Array.isArray(suggestions) ? suggestions : [];

  const filteredAndSorted = useMemo(() => {
    let list = items;

    if (statusFilter !== 'all') {
      list = list.filter((s) => s.status === statusFilter);
    }

    const sorted = [...list];

    sorted.sort((a, b) => {
      if (sortKey === 'newest') {
        return dayjs(b.createdAt).valueOf() - dayjs(a.createdAt).valueOf();
      }
      if (sortKey === 'oldest') {
        return dayjs(a.createdAt).valueOf() - dayjs(b.createdAt).valueOf();
      }

      // most-supported: sort by support score (upvotes - downvotes), fallback to newest
      const scoreA = a.upvotes - (a.downvotes ?? 0);
      const scoreB = b.upvotes - (b.downvotes ?? 0);
      if (scoreB !== scoreA) {
        return scoreB - scoreA;
      }
      return dayjs(b.createdAt).valueOf() - dayjs(a.createdAt).valueOf();
    });

    return sorted;
  }, [items, statusFilter, sortKey]);

  const hasData = items.length > 0;

  return (
    <Card
      title="Suggestions"
      loading={loading && !hasData}
      extra={
        <Space size="middle" wrap>
          <Segmented
            size="small"
            value={statusFilter}
            onChange={(val) => setStatusFilter(val as StatusFilter)}
            options={DEFAULT_STATUS_FILTER_OPTIONS}
          />
          <Select<SuggestionsSortKey>
            size="small"
            style={{ minWidth: 160 }}
            value={sortKey}
            onChange={(val) => setSortKey(val)}
            options={SORT_OPTIONS}
          />
        </Space>
      }
    >
      {!hasData && !loading ? (
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description={emptyMessage}
        />
      ) : (
        <List
          itemLayout="vertical"
          dataSource={filteredAndSorted}
          renderItem={(item) => {
            const created = dayjs(item.createdAt);
            const hasDownvotes = typeof item.downvotes === 'number';
            const hasComments = typeof item.commentsCount === 'number';

            return (
              <List.Item key={item.id}>
                <Space
                  direction="vertical"
                  size={6}
                  style={{ width: '100%' }}
                >
                  <Space wrap>
                    <Text strong>{item.title}</Text>
                    <Tag color={STATUS_COLORS[item.status]}>
                      {STATUS_LABELS[item.status]}
                    </Tag>
                    {item.tags?.map((tag) => (
                      <Tag key={tag}>{tag}</Tag>
                    ))}
                  </Space>

                  <Paragraph
                    type="secondary"
                    style={{ marginBottom: 4 }}
                    ellipsis={{ rows: 3 }}
                  >
                    {item.body}
                  </Paragraph>

                  <Space
                    size={16}
                    wrap
                    style={{ fontSize: 12 }}
                  >
                    <Text type="secondary">
                      <ClockCircleOutlined /> {created.format('YYYY-MM-DD HH:mm')}
                    </Text>
                    <Text type="secondary">By {item.author}</Text>
                  </Space>

                  <Space size={12} wrap>
                    <Tooltip title="Support this suggestion">
                      <Button
                        size="small"
                        icon={<LikeOutlined />}
                        onClick={() => onVote?.(item.id, 'up')}
                      >
                        {item.upvotes}
                      </Button>
                    </Tooltip>

                    {hasDownvotes && (
                      <Tooltip title="Express reservations">
                        <Button
                          size="small"
                          icon={<DislikeOutlined />}
                          onClick={() => onVote?.(item.id, 'down')}
                        >
                          {item.downvotes}
                        </Button>
                      </Tooltip>
                    )}

                    {hasComments && (
                      <Tooltip title="Comments">
                        <span>
                          <CommentOutlined /> {item.commentsCount}
                        </span>
                      </Tooltip>
                    )}

                    {onOpenSuggestion && (
                      <Button
                        size="small"
                        type="link"
                        onClick={() => onOpenSuggestion(item)}
                      >
                        Open details
                      </Button>
                    )}
                  </Space>
                </Space>
              </List.Item>
            );
          }}
        />
      )}
    </Card>
  );
}

===== END modules/konsultations/components/SuggestionsBoard.tsx =====


===== BEGIN modules/konsultations/hooks/index.ts =====
﻿export { default as useConsultation }        from './useConsultation';
export { default as useConsultationResults } from './useConsultationResults';
export { default as useConsultations }       from './useConsultations';
export { default as useConsultationVote }    from './useConsultationVote';
export { default as useImpact }              from './useImpact';
export { default as useSuggestions }         from './useSuggestions';

===== END modules/konsultations/hooks/index.ts =====


===== BEGIN modules/konsultations/hooks/useConsultation.ts =====
﻿// modules/konsultations/hooks/useConsultations.ts

import { useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import dayjs from 'dayjs';
import {
  fetchPublicBallots,
  type PublicBallot,
  type PublicBallotResponse,
} from '@/services/decide';

export type QuickFilter = 'all' | 'closing-soon' | 'high-turnout';

export interface UseConsultationsParams {
  /** Free‑text search on consultation title */
  search?: string;
  /** Quick filter for the list (default: 'all') */
  quickFilter?: QuickFilter;
}

export interface ConsultationStat {
  label: string;
  value: number;
  suffix?: string;
}

export interface UseConsultationsResult {
  /** Raw list of open public consultations (ballots) */
  ballots: PublicBallot[];
  /** Ballots filtered according to `search` + `quickFilter` */
  filteredBallots: PublicBallot[];
  /** KPI header stats (active count, avg turnout, closing‑soon count) */
  stats: ConsultationStat[];
  /** React‑Query flags */
  isLoading: boolean;
  isError: boolean;
  error: Error | null;
  /** Manual refresh helper */
  refresh: () => void;
}

/**
 * High‑level hook for Ethikos public consultations.
 *
 * Wraps `fetchPublicBallots()` and exposes:
 * - raw `ballots`
 * - derived `stats` for KPI cards
 * - `filteredBallots` based on search + quick filter
 */
export default function useConsultations(
  params: UseConsultationsParams = {},
): UseConsultationsResult {
  const { search = '', quickFilter = 'all' } = params;

  const query = useQuery<PublicBallotResponse, Error>({
    queryKey: ['consultations', 'public-ballots'],
    staleTime: 60_000,
    retry: 1,
    queryFn: fetchPublicBallots,
  });

  const ballots = query.data?.ballots ?? [];

  const stats = useMemo<ConsultationStat[]>(() => {
    const total = ballots.length;
    const avgTurnout =
      total > 0
        ? Math.round(
            ballots.reduce((sum, b) => sum + (b.turnout ?? 0), 0) / total,
          )
        : 0;

    const closingSoon = ballots.filter((ballot) => {
      const closes = dayjs(ballot.closesAt);
      if (!closes.isValid()) return false;
      // Mirror the 48h "closing soon" logic from the public Decide page
      return closes.diff(dayjs(), 'hour') <= 48;
    }).length;

    return [
      { label: 'Active consultations', value: total },
      { label: 'Avg participation', value: avgTurnout, suffix: '%' },
      { label: 'Closing ≤ 48h', value: closingSoon },
    ];
  }, [ballots]);

  const filteredBallots = useMemo<PublicBallot[]>(() => {
    const normalizedSearch = search.trim().toLowerCase();
    const now = dayjs();

    return ballots.filter((ballot) => {
      if (
        normalizedSearch &&
        !ballot.title.toLowerCase().includes(normalizedSearch)
      ) {
        return false;
      }

      if (quickFilter === 'closing-soon') {
        const closes = dayjs(ballot.closesAt);
        if (!closes.isValid()) return false;
        return closes.diff(now, 'hour') <= 48;
      }

      if (quickFilter === 'high-turnout') {
        return (ballot.turnout ?? 0) >= 50;
      }

      return true;
    });
  }, [ballots, quickFilter, search]);

  return {
    ballots,
    filteredBallots,
    stats,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error ?? null,
    refresh: () => {
      void query.refetch();
    },
  };
}

===== END modules/konsultations/hooks/useConsultation.ts =====


===== BEGIN modules/konsultations/hooks/useConsultationResults.ts =====
﻿// modules/konsultations/hooks/useConsultationResults.ts

import { useQuery } from '@tanstack/react-query';
import { get } from '@/services/_request';

/**
 * Raw stance row coming from the Ethikos backend.
 * Backend: GET /api/ethikos/stances/?topic=<id>
 */
interface EthikosStancePoint {
  id: number;
  topic: number;
  value: number; // −3 … +3
  timestamp: string;
  user?: string;
}

/**
 * Aggregated statistics on the −3…+3 stance scale.
 */
export interface StanceStats {
  /** Total number of stances recorded for this consultation */
  total: number;
  /** Arithmetic mean of all stance values (−3…+3) */
  average: number;
  /** Count of stances with value > 0 */
  positive: number;
  /** Count of stances with value === 0 */
  neutral: number;
  /** Count of stances with value < 0 */
  negative: number;
  /**
   * Histogram of counts for each discrete value −3…+3.
   * Keys are the stance value (e.g. counts[-3], counts[0], counts[3]).
   */
  counts: Record<number, number>;
}

/**
 * Convenience structure for charting and UIs.
 */
export interface StanceBucket {
  /** Raw stance value (−3…+3) */
  value: number;
  /** Human‑readable label for the value */
  label: string;
  /** Number of participants that selected this value */
  count: number;
  /** Share in [0, 1] of all stances */
  share: number;
}

/**
 * Final shape returned by the hook.
 */
export interface ConsultationResults {
  /** Logical consultation id (backed by Ethikos topic id) */
  consultationId: number;
  /** Aggregated stance statistics */
  stats: StanceStats;
  /** Histogram buckets ready for charts / dashboards */
  buckets: StanceBucket[];
}

/* ------------------------------------------------------------------ */
/*  Helpers                                                            */
/* ------------------------------------------------------------------ */

function computeStanceStats(stances: EthikosStancePoint[]): StanceStats {
  const counts: Record<number, number> = {
    [-3]: 0,
    [-2]: 0,
    [-1]: 0,
    0: 0,
    1: 0,
    2: 0,
    3: 0,
  };

  let total = 0;
  let sum = 0;
  let positive = 0;
  let neutral = 0;
  let negative = 0;

  for (const s of stances) {
    // Clamp to the expected scale just in case
    const v = Math.max(-3, Math.min(3, s.value));

    counts[v] = (counts[v] ?? 0) + 1;
    total += 1;
    sum += v;

    if (v > 0) positive += 1;
    else if (v < 0) negative += 1;
    else neutral += 1;
  }

  const average = total > 0 ? sum / total : 0;

  return {
    total,
    average,
    positive,
    neutral,
    negative,
    counts,
  };
}

function stanceLabel(value: number): string {
  switch (value) {
    case -3:
      return 'Strongly against';
    case -2:
      return 'Moderately against';
    case -1:
      return 'Somewhat against';
    case 0:
      return 'Neutral / undecided';
    case 1:
      return 'Somewhat for';
    case 2:
      return 'Moderately for';
    case 3:
      return 'Strongly for';
    default:
      return 'Neutral / undecided';
  }
}

/* ------------------------------------------------------------------ */
/*  Hook                                                               */
/* ------------------------------------------------------------------ */

/**
 * Aggregated results for a single consultation.
 *
 * Internally this maps a “consultation” to an Ethikos topic and
 * aggregates all stance rows returned by:
 *   GET /api/ethikos/stances/?topic=<consultationId>
 */
export default function useConsultationResults(
  consultationId?: number | string,
) {
  const numericId = Number(consultationId);
  const enabled = Number.isFinite(numericId);

  return useQuery<ConsultationResults>({
    queryKey: ['consultation-results', numericId],
    enabled,
    staleTime: 60_000,
    retry: 1,
    queryFn: async () => {
      if (!Number.isFinite(numericId)) {
        throw new Error('Invalid consultation id');
      }

      const stances = await get<EthikosStancePoint[]>('ethikos/stances/', {
        params: { topic: numericId },
      });

      const stats = computeStanceStats(stances ?? []);

      const buckets: StanceBucket[] = [-3, -2, -1, 0, 1, 2, 3].map((value) => {
        const count = stats.counts[value] ?? 0;
        const share = stats.total > 0 ? count / stats.total : 0;
        return {
          value,
          label: stanceLabel(value),
          count,
          share,
        };
      });

      return {
        consultationId: numericId,
        stats,
        buckets,
      };
    },
  });
}

===== END modules/konsultations/hooks/useConsultationResults.ts =====


===== BEGIN modules/konsultations/hooks/useConsultations.ts =====
﻿export default function stub() { /* TODO */ }

===== END modules/konsultations/hooks/useConsultations.ts =====


===== BEGIN modules/konsultations/hooks/useConsultationVote.ts =====
﻿// modules/konsultations/hooks/useConsultationVote.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { submitPublicVote } from "@/services/decide";

export interface ConsultationVotePayload {
  id: string;
  option: string;
}

export interface UseConsultationVoteOptions {
  onSuccess?: (
    data: { ok: true },
    variables: ConsultationVotePayload,
  ) => void | Promise<void>;
  onError?: (
    error: Error,
    variables: ConsultationVotePayload,
  ) => void | Promise<void>;
}

/**
 * Hook to submit a vote on a public consultation (Ethikos topic).
 *
 * Wraps services/decide.submitPublicVote() and exposes a mutation API.
 */
export default function useConsultationVote(opts?: UseConsultationVoteOptions) {
  const queryClient = useQueryClient();

  const mutation = useMutation<{ ok: true }, Error, ConsultationVotePayload>({
    mutationKey: ["consultation-vote"],
    mutationFn: async ({ id, option }) => submitPublicVote(id, option),
    onSuccess: async (data, variables) => {
      // Keep related views in sync
      queryClient.invalidateQueries({ queryKey: ["consultations"] });
      queryClient.invalidateQueries({
        queryKey: ["consultation", variables.id],
      });
      queryClient.invalidateQueries({
        queryKey: ["consultation-results", variables.id],
      });

      if (opts?.onSuccess) {
        await opts.onSuccess(data, variables);
      }
    },
    onError: async (error, variables) => {
      if (opts?.onError) {
        await opts.onError(error, variables);
      }
    },
  });

  return {
    ...mutation,
    /** Fire-and-forget vote submission */
    castVote: mutation.mutate,
    /** Async variant returning the mutation promise */
    castVoteAsync: mutation.mutateAsync,
  };
}

===== END modules/konsultations/hooks/useConsultationVote.ts =====


===== BEGIN modules/konsultations/hooks/useImpact.ts =====
﻿// modules/konsultations/hooks/useImpact.ts
import { useQuery } from '@tanstack/react-query';
import api from '@/api';
import type { ImpactStatus } from '@/services/impact';

/**
 * Logical scope of a consultation (reuses Ethikos semantics).
 */
export type ConsultationScope = 'Elite' | 'Public';

type TopicStatus = 'open' | 'closed' | 'archived';

interface EthikosCategoryApi {
  id: number;
  name: string;
  description?: string;
}

interface EthikosTopicApi {
  id: number;
  title: string;
  description: string;
  status: TopicStatus;
  total_votes?: number | null;
  last_activity: string;
  created_at: string;
  category: EthikosCategoryApi;
  expertise_category?: number | null;
  created_by?: string;
}

interface EthikosStanceApi {
  id: number;
  topic: number;
  value: number; // −3…+3
  timestamp: string;
}

interface EthikosArgumentApi {
  id: number;
  topic: number;
  user: string;
  content: string;
  created_at: string;
}

/**
 * One milestone on the consultation impact timeline.
 */
export interface ConsultationImpactEvent {
  id: string;
  date: string; // ISO timestamp
  label: string;
  description?: string;
}

/**
 * Aggregated summary for a single consultation.
 */
export interface ConsultationImpactSummary {
  id: string;
  title: string;
  category?: string;
  scope: ConsultationScope;
  status: ImpactStatus;
  createdAt: string;
  closesAt: string;
  /** Turnout proxy in [0, 100] (same heuristic as Decide service). */
  turnout: number;
  /** Number of recorded stances (votes). */
  stances: number;
  /** Number of arguments in the thread. */
  arguments: number;
  /**
   * Approximate agreement in [0, 100].
   * 0 = fully against, 50 = neutral, 100 = fully in favour.
   * Undefined when no stances yet.
   */
  support?: number;
}

/**
 * Full impact payload returned by the hook.
 */
export interface ConsultationImpactResult {
  summary: ConsultationImpactSummary;
  timeline: ConsultationImpactEvent[];
}

/* -------------------------------------------------------------------------- */
/* Helpers                                                                    */
/* -------------------------------------------------------------------------- */

function topicStatusToImpactStatus(status: TopicStatus): ImpactStatus {
  switch (status) {
    case 'closed':
      return 'Completed';
    case 'archived':
      return 'Blocked';
    case 'open':
    default:
      return 'In-Progress';
  }
}

/**
 * Simple heuristic reused from services/decide.ts:
 * - open → 7 days after creation
 * - closed/archived → last_activity
 */
function computeClosesAt(topic: EthikosTopicApi): string {
  const created = new Date(topic.created_at);
  if (topic.status === 'open' && !Number.isNaN(created.getTime())) {
    const closes = new Date(created);
    closes.setDate(closes.getDate() + 7);
    return closes.toISOString();
  }

  const last = new Date(topic.last_activity);
  return Number.isNaN(last.getTime()) ? topic.last_activity : last.toISOString();
}

/**
 * Clamp total_votes into a 0–100 turnout proxy.
 */
function normalizeTurnout(totalVotes?: number | null): number {
  const n = typeof totalVotes === 'number' ? totalVotes : 0;
  return Math.max(0, Math.min(100, n));
}

/**
 * Map Ethikos expertise_category presence to scope.
 */
function topicScope(topic: EthikosTopicApi): ConsultationScope {
  return topic.expertise_category ? 'Elite' : 'Public';
}

function toNumberId(id: string | number): number {
  const n = typeof id === 'string' ? Number(id) : id;
  if (!Number.isFinite(n)) {
    throw new Error(`Invalid consultation/topic id: ${id}`);
  }
  return n;
}

/**
 * Build a small, human‑friendly event timeline from topic + activity.
 */
function buildTimeline(
  topic: EthikosTopicApi,
  stances: EthikosStanceApi[],
  args: EthikosArgumentApi[],
  support?: number,
): ConsultationImpactEvent[] {
  const events: ConsultationImpactEvent[] = [];

  // Creation
  events.push({
    id: `topic-created-${topic.id}`,
    date: topic.created_at,
    label: 'Consultation created',
    description: `Debate opened in category “${topic.category?.name ?? 'Uncategorised'}”.`,
  });

  // Status / closing
  const impactStatus = topicStatusToImpactStatus(topic.status);
  const closesAt = computeClosesAt(topic);

  events.push({
    id: `topic-status-${topic.id}`,
    date: closesAt,
    label:
      impactStatus === 'Completed'
        ? 'Decision closed'
        : impactStatus === 'Blocked'
        ? 'Consultation archived'
        : 'Consultation is open',
    description:
      impactStatus === 'In-Progress'
        ? 'Participants can still submit stances and arguments.'
        : `Status: ${impactStatus}.`,
  });

  // Stance activity
  if (stances.length > 0) {
    const sorted = [...stances].sort((a, b) =>
      a.timestamp.localeCompare(b.timestamp),
    );
    const first = sorted[0];
    const last = sorted[sorted.length - 1];

    events.push({
      id: `stance-first-${topic.id}`,
      date: first.timestamp,
      label: 'First stance submitted',
      description: 'The first participant expressed a position on this question.',
    });

    events.push({
      id: `stance-latest-${topic.id}`,
      date: last.timestamp,
      label: 'Latest stance activity',
      description: [
        `${stances.length} total stances recorded.`,
        support != null ? `Approx. ${support}% agreement so far.` : undefined,
      ]
        .filter(Boolean)
        .join(' '),
    });
  }

  // Argument activity
  if (args.length > 0) {
    const sorted = [...args].sort((a, b) =>
      a.created_at.localeCompare(b.created_at),
    );
    const first = sorted[0];
    const last = sorted[sorted.length - 1];

    events.push({
      id: `argument-first-${topic.id}`,
      date: first.created_at,
      label: 'First argument posted',
      description: `${first.user} started the written debate.`,
    });

    events.push({
      id: `argument-latest-${topic.id}`,
      date: last.created_at,
      label: 'Latest argument activity',
      description: `${args.length} arguments exchanged so far.`,
    });
  }

  // Sort chronologically
  events.sort(
    (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime(),
  );

  return events;
}

/**
 * Fetch and aggregate everything needed for the impact view of one consultation.
 */
async function loadConsultationImpact(
  consultationId: string | number,
): Promise<ConsultationImpactResult> {
  const topicId = toNumberId(consultationId);

  const [topic, stancesRaw, argsRaw] = await Promise.all([
    api.get<EthikosTopicApi>(`ethikos/topics/${topicId}/`),
    api.get<EthikosStanceApi[]>('ethikos/stances/', {
      params: { topic: topicId },
    }),
    api.get<EthikosArgumentApi[]>('ethikos/arguments/', {
      params: { topic: topicId },
    }),
  ]);

  const stances = stancesRaw.filter((s) => s.topic === topicId);
  const args = argsRaw.filter((a) => a.topic === topicId);

  const stanceCount = stances.length;

  let support: number | undefined;
  if (stanceCount > 0) {
    const sum = stances.reduce((acc, s) => acc + s.value, 0);
    const avg = sum / stanceCount; // −3…+3
    const normalized = Math.max(-1, Math.min(1, avg / 3)); // → −1…+1
    support = Math.round((normalized + 1) * 50); // → 0…100
  }

  const summary: ConsultationImpactSummary = {
    id: String(topic.id),
    title: topic.title,
    category: topic.category?.name,
    scope: topicScope(topic),
    status: topicStatusToImpactStatus(topic.status),
    createdAt: topic.created_at,
    closesAt: computeClosesAt(topic),
    turnout: normalizeTurnout(topic.total_votes),
    stances: stanceCount,
    arguments: args.length,
    support,
  };

  const timeline = buildTimeline(topic, stances, args, support);

  return { summary, timeline };
}

/* -------------------------------------------------------------------------- */
/* Public hook                                                                */
/* -------------------------------------------------------------------------- */

export interface UseImpactOptions {
  /**
   * Force-enable/disable the query.
   * Defaults to enabled when consultationId is truthy.
   */
  enabled?: boolean;
}

/**
 * High-level hook for consultation impact:
 * - loads Ethikos topic, stances and arguments for a single consultation
 * - returns a summary + a coarse timeline of key events
 *
 * Typical usage:
 *   const { data, isLoading, error } = useImpact(consultationId);
 */
export default function useImpact(
  consultationId: string | number | null | undefined,
  options?: UseImpactOptions,
) {
  const enabled =
    (options?.enabled ?? true) && consultationId !== null && consultationId !== undefined;

  return useQuery<ConsultationImpactResult>({
    queryKey: ['konsultations-impact', consultationId],
    enabled,
    staleTime: 60_000,
    queryFn: () => {
      if (consultationId === null || consultationId === undefined) {
        throw new Error('Missing consultation id for impact view');
      }
      return loadConsultationImpact(consultationId);
    },
  });
}

===== END modules/konsultations/hooks/useImpact.ts =====


===== BEGIN modules/konsultations/hooks/useSuggestions.ts =====
﻿// modules/konsultations/hooks/useSuggestions.ts
'use client';

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import apiRequest from '@/services/_request';

/**
 * Raw Ethikos argument shape as returned by /api/ethikos/arguments/.
 * Parent fields are optional and may or may not be present depending
 * on how the serializer is configured.
 */
interface EthikosArgumentApi {
  id: number;
  topic: number;
  user: string;
  content: string;
  created_at: string;
  parent?: number | null;
  parent_id?: number | null;
}

/**
 * Normalized suggestion used by the Konsultations UI.
 */
export interface Suggestion {
  id: string;
  consultationId: string;
  author: string;
  body: string;
  createdAt: string;
  parentId: string | null;
}

/**
 * Payload for creating a new suggestion.
 * `parentId` can be used for threaded replies.
 */
export interface CreateSuggestionInput {
  body: string;
  parentId?: string | number | null;
}

export interface UseSuggestionsResult {
  suggestions: Suggestion[];
  isLoading: boolean;
  isError: boolean;
  error: Error | null;
  /**
   * Refetch the suggestion list from the backend.
   * Returns the freshly loaded items (or undefined on error).
   */
  refetch: () => Promise<Suggestion[] | undefined>;
  /**
   * Create a new suggestion for the current consultation.
   */
  submit: (input: CreateSuggestionInput) => Promise<void>;
  isSubmitting: boolean;
}

const QUERY_KEY = 'konsultations-suggestions';

async function fetchSuggestionsForConsultation(
  topicId: number,
): Promise<Suggestion[]> {
  const rows = await apiRequest.get<EthikosArgumentApi[]>(
    'ethikos/arguments/',
    { params: { topic: topicId } },
  );

  return rows.map((arg) => {
    const parentRaw =
      arg.parent != null
        ? arg.parent
        : arg.parent_id != null
        ? arg.parent_id
        : null;

    return {
      id: String(arg.id),
      consultationId: String(arg.topic),
      author: arg.user,
      body: arg.content,
      createdAt: arg.created_at,
      parentId: parentRaw == null ? null : String(parentRaw),
    };
  });
}

async function createSuggestionForConsultation(
  topicId: number,
  input: CreateSuggestionInput,
): Promise<void> {
  const payload: {
    topic: number;
    content: string;
    parent?: number;
  } = {
    topic: topicId,
    content: input.body,
  };

  if (input.parentId != null) {
    const parentNumeric = Number(input.parentId);
    if (Number.isFinite(parentNumeric)) {
      payload.parent = parentNumeric;
    }
  }

  await apiRequest.post('ethikos/arguments/', payload);
}

/**
 * Konsultations suggestions hook.
 *
 * - Reads suggestions from the Ethikos arguments endpoint for a given topic id.
 * - Exposes a mutation to submit new suggestions (and optional replies).
 */
export default function useSuggestions(
  consultationId: string | number | null | undefined,
): UseSuggestionsResult {
  const queryClient = useQueryClient();

  const topicId = (() => {
    if (consultationId == null) return NaN;
    const n = Number(consultationId);
    return Number.isFinite(n) ? n : NaN;
  })();

  const canUseTopic = Number.isFinite(topicId);

  const query = useQuery<Suggestion[], Error>({
    queryKey: [QUERY_KEY, topicId],
    enabled: canUseTopic,
    staleTime: 30_000,
    retry: 1,
    queryFn: () => {
      if (!canUseTopic) {
        return Promise.resolve<Suggestion[]>([]);
      }
      return fetchSuggestionsForConsultation(topicId as number);
    },
  });

  const mutation = useMutation<void, Error, CreateSuggestionInput>({
    mutationFn: (input) => {
      if (!canUseTopic) {
        return Promise.reject(
          new Error('Cannot submit suggestion without a consultation id.'),
        );
      }
      return createSuggestionForConsultation(topicId as number, input);
    },
    onSuccess: async () => {
      if (!canUseTopic) return;
      await queryClient.invalidateQueries({
        queryKey: [QUERY_KEY, topicId],
      });
    },
  });

  return {
    suggestions: query.data ?? [],
    isLoading: query.isLoading,
    isError: query.isError,
    error: (query.error as Error) ?? null,
    refetch: async () => {
      const res = await query.refetch();
      return res.data;
    },
    submit: mutation.mutateAsync,
    isSubmitting: mutation.isPending,
  };
}

===== END modules/konsultations/hooks/useSuggestions.ts =====


===== BEGIN modules/konsultations/pages/ConsultationDetailPage.tsx =====
﻿import React from 'react';
import { Space, Typography, Alert, Tag, Empty, Result } from 'antd';
import { PageContainer, ProCard } from '@ant-design/pro-components';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';

import EthikosPageShell from '@/app/ethikos/EthikosPageShell';
import { ConsultationForm, ResultsChart, SuggestionBoard, ImpactTimeline } from '@/modules/konsultations/components';
import { useConsultation, useConsultationResults, useSuggestions, useImpact } from '@/modules/konsultations/hooks';

const { Title, Paragraph, Text } = Typography;

interface ConsultationDetailProps {
  consultationId: string;  // likely passed via route params
}

const ConsultationDetailPage: React.FC<ConsultationDetailProps> = ({ consultationId }) => {
  // Fetch consultation metadata (title, description, status, dates, etc.)
  const { data: consultation, loading, error } = useConsultation(consultationId);
  // Fetch aggregated results for this consultation (e.g., stance distribution)
  const { data: results } = useConsultationResults(consultationId);
  // Fetch citizen suggestions for this consultation
  const { data: suggestions } = useSuggestions(consultationId);
  // Fetch impact timeline entries for this consultation
  const { data: impactItems } = useImpact(consultationId);

  if (error) {
    // Show an error state if consultation failed to load (e.g., not found or server error)
    return (
      <Result 
        status="error" 
        title="Failed to load consultation" 
        subTitle={error.message || 'This consultation may not exist or an error occurred.'} 
      />
    );
  }

  // Determine consultation status tag and date info
  let statusTag: React.ReactNode = null;
  let dateInfo: React.ReactNode = null;
  if (consultation) {
    const isOpen = consultation.status === 'open';
    statusTag = (
      <Tag color={isOpen ? 'blue' : 'red'} style={{ marginRight: 8 }}>
        {isOpen ? 'Open' : 'Closed'}
      </Tag>
    );
    if (isOpen && consultation.closeDate) {
      dateInfo = <Text type="secondary">Closes on {dayjs(consultation.closeDate).format('YYYY-MM-DD')}</Text>;
    } else if (!isOpen && consultation.closeDate) {
      dateInfo = <Text type="secondary">Closed on {dayjs(consultation.closeDate).format('YYYY-MM-DD')}</Text>;
    }
  }

  return (
    <EthikosPageShell 
      title={consultation ? consultation.title : 'Consultation'} 
      sectionLabel="Consultation"
      metaTitle={consultation ? `ethiKos · Consultation · ${consultation.title}` : undefined}
    >
      <PageContainer ghost loading={loading}>
        {consultation ? (
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            {/* Consultation metadata */}
            <div>
              {statusTag}
              {dateInfo}
              {consultation.description && (
                <Paragraph style={{ marginTop: 4 }}>{consultation.description}</Paragraph>
              )}
            </div>

            {/* Stance submission form */}
            <ProCard title="Your Stance" bordered>
              <ConsultationForm consultationId={consultation.id} />
            </ProCard>

            {/* Results and Suggestions side by side (responsive) */}
            <ProCard ghost gutter={16} wrap>
              <ProCard colSpan={{ xs: 24, md: 12 }} title="Results">
                {results ? (
                  <ResultsChart data={results} />
                ) : (
                  <Empty description="No results yet" />
                )}
              </ProCard>
              <ProCard colSpan={{ xs: 24, md: 12 }} title="Suggestions">
                {suggestions ? (
                  <SuggestionBoard items={suggestions} />
                ) : (
                  <Empty description="No suggestions yet" />
                )}
              </ProCard>
            </ProCard>

            {/* Impact timeline */}
            <ProCard title="Impact Timeline" bordered>
              {impactItems ? (
                <ImpactTimeline items={impactItems} />
              ) : (
                <Empty description="No impact actions recorded yet." />
              )}
            </ProCard>
          </Space>
        ) : (
          // If consultation is not loaded yet (and not error), show nothing (loading spinner is handled by PageContainer)
          <></>
        )}
      </PageContainer>
    </EthikosPageShell>
  );
};

export default ConsultationDetailPage;

===== END modules/konsultations/pages/ConsultationDetailPage.tsx =====


===== BEGIN modules/konsultations/pages/ConsultationHub.tsx =====
﻿'use client';

import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Alert, Typography } from 'antd';
import usePageTitle from '@/hooks/usePageTitle';
import {
  ConsultationForm,
  ConsultationList,
  ConsultationVotePanel,
  ImpactTimeline,
  ResultsDashboard,
  SuggestionBoard,
} from '../components';

const { Title, Paragraph, Text } = Typography;

export default function ConsultationHub(): JSX.Element {
  usePageTitle('Konsultations · Consultation Hub');

  return (
    <PageContainer ghost>
      {/* Intro / context */}
      <ProCard ghost style={{ marginBottom: 16 }}>
        <Title level={2} style={{ marginBottom: 8 }}>
          Consultation Hub
        </Title>
        <Paragraph type="secondary">
          Central hub for participatory consultations: discover open topics, take part in votes,
          review results, and follow how decisions translate into real-world impact.
        </Paragraph>
        <Alert
          type="info"
          showIcon
          style={{ marginTop: 16 }}
          message="How this hub is structured"
          description={
            <Text>
              The blocks below are wired to dedicated Konsultations components (list, vote,
              results, impact, suggestions). Each widget can evolve independently while keeping a
              single entry point for consultations.
            </Text>
          }
        />
      </ProCard>

      {/* Main layout */}
      <ProCard gutter={16} wrap>
        {/* Open consultations + create new */}
        <ProCard
          title="Open consultations"
          colSpan={{ xs: 24, md: 16 }}
          bordered
        >
          {/* List of active / upcoming consultations */}
          <ConsultationList />
        </ProCard>

        <ProCard
          title="Start a new consultation"
          colSpan={{ xs: 24, md: 8 }}
          bordered
        >
          {/* Wizard / form to launch a new consultation */}
          <ConsultationForm />
        </ProCard>

        {/* Participation panel */}
        <ProCard
          title="Participate in a consultation"
          colSpan={{ xs: 24 }}
          bordered
        >
          {/* Voting / stance capture for the currently focused consultation */}
          <ConsultationVotePanel />
        </ProCard>

        {/* Results + impact */}
        <ProCard
          title="Results & analytics"
          colSpan={{ xs: 24, md: 12 }}
          bordered
        >
          {/* High-level KPIs, charts, breakdowns */}
          <ResultsDashboard />
        </ProCard>

        <ProCard
          title="Impact over time"
          colSpan={{ xs: 24, md: 12 }}
          bordered
        >
          {/* Timeline of how decisions are implemented and updated */}
          <ImpactTimeline />
        </ProCard>

        {/* Suggestions / qualitative input */}
        <ProCard
          title="Suggestions from participants"
          colSpan={{ xs: 24 }}
          bordered
        >
          {/* Board for proposed improvements, comments, ideas */}
          <SuggestionBoard />
        </ProCard>
      </ProCard>
    </PageContainer>
  );
}

===== END modules/konsultations/pages/ConsultationHub.tsx =====


===== BEGIN modules/konsultations/pages/ConsultationsHomePage.tsx =====
﻿'use client';

import Link from 'next/link';
import {
  PageContainer,
  ProCard,
  ProTable,
  StatisticCard,
  type ProColumns,
} from '@ant-design/pro-components';
import {
  Alert,
  Button,
  Empty,
  Progress,
  Space,
  Tag,
  Typography,
} from 'antd';
import {
  BarChartOutlined,
  GlobalOutlined,
  HistoryOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';

import usePageTitle from '@/hooks/usePageTitle';
import {
  fetchPublicBallots,
  type PublicBallot,
  type PublicBallotResponse,
} from '@/services/decide';
import {
  fetchImpactOutcomes,
  type OutcomeKPI,
} from '@/services/impact';

const { Paragraph, Text } = Typography;

type BallotRow = PublicBallot;
type ImpactData = Awaited<ReturnType<typeof fetchImpactOutcomes>>;

export default function ConsultationsHomePage(): JSX.Element {
  usePageTitle('Konsultations · Home');

  const { data: ballotsData, loading: loadingBallots } =
    useRequest<PublicBallotResponse, []>(fetchPublicBallots);

  const { data: impactData, loading: loadingImpact } =
    useRequest<ImpactData, []>(fetchImpactOutcomes);

  const ballots = ballotsData?.ballots ?? [];
  const impactKpis = impactData?.kpis ?? [];
  const loading = loadingBallots || loadingImpact;

  const totalConsultations = ballots.length;
  const avgTurnout =
    totalConsultations > 0
      ? Math.round(
          ballots.reduce((sum, b) => sum + (b.turnout ?? 0), 0) /
            totalConsultations,
        )
      : 0;

  const closingSoonCount = ballots.filter((ballot) => {
    const closes = dayjs(ballot.closesAt);
    return closes.isValid() && closes.diff(dayjs(), 'hour') <= 48;
  }).length;

  const headerStats = [
    { label: 'Active consultations', value: totalConsultations },
    { label: 'Avg participation', value: avgTurnout, suffix: '%' },
    { label: 'Closing ≤ 48h', value: closingSoonCount },
  ];

  const kpiByKey = new Map<string, OutcomeKPI>();
  for (const k of impactKpis) {
    kpiByKey.set(k.key, k);
  }

  const impactSummaryKpis: OutcomeKPI[] = [
    kpiByKey.get('resolved'),
    kpiByKey.get('participation'),
    kpiByKey.get('agreement'),
    kpiByKey.get('open'),
  ].filter(Boolean) as OutcomeKPI[];

  const columns: ProColumns<BallotRow>[] = [
    {
      title: 'Consultation',
      dataIndex: 'title',
      width: 320,
      ellipsis: true,
    },
    {
      title: 'Closes',
      dataIndex: 'closesAt',
      width: 220,
      render: (_, row) => {
        const closes = dayjs(row.closesAt);
        const closingSoon =
          closes.isValid() && closes.diff(dayjs(), 'hour') <= 48;

        return (
          <Space direction="vertical" size={2}>
            <span>
              {closes.isValid()
                ? closes.format('YYYY-MM-DD HH:mm')
                : '—'}
            </span>
            {closingSoon && <Tag color="volcano">Closing soon</Tag>}
          </Space>
        );
      },
    },
    {
      title: 'Turnout',
      dataIndex: 'turnout',
      width: 180,
      render: (_, row) => {
        const turnout = Math.round(row.turnout ?? 0);
        return (
          <Space>
            <Progress type="circle" percent={turnout} width={44} />
            <span>{turnout}%</span>
          </Space>
        );
      },
    },
    {
      title: 'Scope',
      dataIndex: 'scope',
      width: 120,
      render: (_, row) => <Tag color="purple">{row.scope}</Tag>,
    },
    {
      title: 'Actions',
      dataIndex: 'actions',
      width: 240,
      render: () => (
        <Space>
          <Link href="/ethikos/decide/public" prefetch={false}>
            <Button size="small" type="primary">
              Open voting
            </Button>
          </Link>
          <Link href="/ethikos/decide/results" prefetch={false}>
            <Button size="small" icon={<BarChartOutlined />}>
              Results
            </Button>
          </Link>
        </Space>
      ),
    },
  ];

  return (
    <PageContainer
      ghost
      loading={loading}
      header={{
        title: 'Konsultations',
        subTitle:
          'Time‑boxed public consultations on Ethikos topics, with transparent weighted outcomes.',
      }}
    >
      <Space
        direction="vertical"
        size="large"
        style={{ width: '100%' }}
      >
        <Alert
          type="info"
          showIcon
          message="How Konsultations fit into Ethikos"
          description={
            <Paragraph style={{ marginBottom: 0 }}>
              Consultations sit on top of Korum debates. While a
              consultation is open, verified participants can express a
              nuanced stance on a −3…+3 scale. Once closed, outcomes feed
              into the Ethikos impact tracker and opinion analytics.
            </Paragraph>
          }
        />

        <ProCard gutter={16} wrap>
          {headerStats.map((stat) => (
            <StatisticCard
              key={stat.label}
              colSpan={{ xs: 24, sm: 8, md: 6 }}
              statistic={{
                title: stat.label,
                value: stat.value,
                suffix: stat.suffix,
              }}
            />
          ))}

          {impactSummaryKpis.map((kpi) => (
            <StatisticCard
              key={kpi.key}
              colSpan={{ xs: 24, sm: 8, md: 6 }}
              statistic={{
                title: kpi.label,
                value: kpi.value,
                suffix:
                  typeof kpi.delta === 'number' ? '%' : undefined,
              }}
            />
          ))}
        </ProCard>

        <ProCard
          title="Open consultations snapshot"
          extra={
            <Space>
              <Text type="secondary">
                Snapshot of public Ethikos consultations currently open
                for voting.
              </Text>
              <Link href="/ethikos/decide/public" prefetch={false}>
                <Button
                  type="default"
                  size="small"
                  icon={<GlobalOutlined />}
                >
                  Go to full list
                </Button>
              </Link>
            </Space>
          }
        >
          {ballots.length === 0 ? (
            <Empty
              image={Empty.PRESENTED_IMAGE_SIMPLE}
              description="No open public consultations right now."
            />
          ) : (
            <ProTable<BallotRow>
              rowKey="id"
              size="small"
              columns={columns}
              dataSource={ballots}
              pagination={{ pageSize: 5 }}
              search={false}
              options={false}
              toolBarRender={false}
            />
          )}
        </ProCard>

        <ProCard
          title="Outcomes and implementation"
          extra={
            <Space>
              <Link href="/ethikos/impact/outcomes" prefetch={false}>
                <Button
                  size="small"
                  icon={<BarChartOutlined />}
                >
                  Outcomes analytics
                </Button>
              </Link>
              <Link href="/ethikos/impact/tracker" prefetch={false}>
                <Button
                  size="small"
                  icon={<HistoryOutlined />}
                >
                  Impact tracker
                </Button>
              </Link>
            </Space>
          }
        >
          <Paragraph type="secondary" style={{ marginBottom: 0 }}>
            Use Ethikos impact dashboards to follow how consultation
            results translate into decisions and implementation work over
            time.
          </Paragraph>
        </ProCard>
      </Space>
    </PageContainer>
  );
}

===== END modules/konsultations/pages/ConsultationsHomePage.tsx =====


===== BEGIN modules/konsultations/pages/index.ts =====
export { default as ConsultationDetailPage } from './ConsultationDetailPage';
export { default as ConsultationHub } from './ConsultationHub';
export { default as ConsultationsHomePage } from './ConsultationsHomePage';
export { default as ResultsPage } from './ResultsPage';
export { default as SuggestionPage } from './SuggestionPage';

===== END modules/konsultations/pages/index.ts =====


===== BEGIN modules/konsultations/pages/ResultsPage.tsx =====
﻿'use client';

import React, { useEffect, useState, useMemo } from 'react';
import { useRouter } from 'next/router';
import { Spin, Alert } from 'antd';
import EkohPageShell from '@/app/ekoh/EkohPageShell';
import {
  ResponsiveContainer,
  BarChart,
  CartesianGrid,
  XAxis,
  YAxis,
  Tooltip,
  Bar,
  Cell,
} from 'recharts';

interface ResultsData {
  yes: number;
  no: number;
  total: number;
  supportPercent: number;
}

export default function ConsultationResultsPage(): JSX.Element {
  const router = useRouter();
  const { consultationId } = router.query;
  const [consultationTitle, setConsultationTitle] = useState<string>('');
  const [results, setResults] = useState<ResultsData>({ yes: 0, no: 0, total: 0, supportPercent: 0 });
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!consultationId) {
      return;
    }
    const fetchResults = async () => {
      try {
        setLoading(true);
        setError(null);
        // Fetch consultation details and results in parallel
        const [res1, res2] = await Promise.all([
          fetch(`/api/konsultations/consultations/${consultationId}`),
          fetch(`/api/konsultations/consultations/${consultationId}/results`),
        ]);
        if (!res1.ok || !res2.ok) {
          throw new Error(`Failed to load results (status ${res1.status} / ${res2.status})`);
        }
        const consultation = await res1.json();
        const resultData = await res2.json();
        // Determine title and voting outcomes
        setConsultationTitle(consultation.title ?? 'Consultation');
        // Assuming resultData contains yes/no counts (raw or aggregated)
        const yesCount: number = resultData.yes ?? resultData.approve ?? resultData.up ?? 0;
        const noCount: number = resultData.no ?? resultData.reject ?? resultData.down ?? 0;
        const totalVotes = yesCount + noCount;
        const supportPct = totalVotes > 0 ? Math.round((yesCount / totalVotes) * 100) : 0;
        setResults({
          yes: yesCount,
          no: noCount,
          total: totalVotes,
          supportPercent: supportPct,
        });
      } catch (err) {
        console.error('Error loading consultation results:', err);
        setError('Unable to load consultation results.');
      } finally {
        setLoading(false);
      }
    };
    fetchResults();
  }, [consultationId]);

  // Prepare data for chart
  const chartData = useMemo(
    () => [
      { name: 'Yes', value: results.yes },
      { name: 'No', value: results.no },
    ],
    [results.yes, results.no]
  );
  const COLORS = ['#52c41a', '#ff4d4f']; // green for Yes, red for No

  return (
    <EkohPageShell
      title="Consultation Results"
      subtitle={consultationTitle ? consultationTitle : undefined}
    >
      {loading ? (
        <div style={{ textAlign: 'center', padding: 24 }}>
          <Spin size="large" />
        </div>
      ) : error ? (
        <Alert message={error} type="error" showIcon />
      ) : (
        <>
          {/* Summary statistics */}
          <div className="mb-4 flex flex-wrap items-baseline gap-4">
            <span>Yes: {results.yes}</span>
            <span>No: {results.no}</span>
            <span>Total: {results.total}</span>
            <span>Support: {results.supportPercent}%</span>
          </div>
          {/* Bar chart visualization */}
          <div className="mb-6 max-w-md">
            <ResponsiveContainer width="100%" height={320}>
              <BarChart data={chartData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Bar dataKey="value">
                  {chartData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Bar>
              </BarChart>
            </ResponsiveContainer>
          </div>
        </>
      )}
    </EkohPageShell>
  );
}

===== END modules/konsultations/pages/ResultsPage.tsx =====


===== BEGIN modules/konsultations/pages/SuggestionPage.tsx =====
﻿// frontend/modules/konsultations/pages/SuggestionPage.tsx
"use client";

import React from "react";
import { Alert, Button, Space, Tag, Typography } from "antd";
import {
  BulbOutlined,
  FilterOutlined,
  InfoCircleOutlined,
} from "@ant-design/icons";
import { SuggestionBoard } from "../components";

const { Title, Paragraph, Text } = Typography;

export default function SuggestionPage() {
  return (
    <div className="container mx-auto py-8">
      <header className="mb-6 space-y-2">
        <Space align="baseline" size="middle">
          <BulbOutlined />
          <Title level={3} className="!mb-0">
            Consultation suggestions
          </Title>
        </Space>

        <Paragraph type="secondary" className="!mb-0">
          Collect, cluster, and prioritise suggestions before moving them into a
          formal consultation or Smart‑Vote ballot.
        </Paragraph>

        <Space wrap>
          <Tag color="blue">Suggestion flow</Tag>
          <Tag color="purple">Pre‑decision stage</Tag>
        </Space>
      </header>

      <section className="mb-4">
        <Alert
          type="info"
          showIcon
          icon={<InfoCircleOutlined />}
          message="How this board works"
          description={
            <Text type="secondary">
              Each card represents a suggestion from participants. Use the
              board below to triage new ideas, merge duplicates, and surface
              candidates for the next voting round.
            </Text>
          }
        />
      </section>

      <section className="mb-4 flex flex-wrap items-center justify-between gap-3">
        <Space wrap>
          <Button icon={<FilterOutlined />}>Filter &amp; sort</Button>
          <Text type="secondary">
            Focus on new, high‑support, or controversial suggestions.
          </Text>
        </Space>
      </section>

      {/* Core suggestion workflow – data + interactions live inside SuggestionBoard */}
      <SuggestionBoard />
    </div>
  );
}

===== END modules/konsultations/pages/SuggestionPage.tsx =====


===== BEGIN modules/kontact/components/index.ts =====
﻿export { default as OpportunityList } from './OpportunityList';
export { default as ProfileCard }    from './ProfileCard';

===== END modules/kontact/components/index.ts =====


===== BEGIN modules/kontact/components/OpportunityList.tsx =====
﻿// frontend/modules/kontact/components/OpportunityList.tsx
'use client';

import React from 'react';
import { Card, Empty, List, Space, Tag, Typography } from 'antd';
import {
  EnvironmentOutlined,
  TeamOutlined,
  ClockCircleOutlined,
} from '@ant-design/icons';
import dayjs from 'dayjs';

const { Text, Title } = Typography;

export interface Opportunity {
  id: string;
  title: string;
  summary?: string;
  organisation?: string;
  location?: string;
  tags?: string[];
  commitmentLevel?: string;
  participantsNeeded?: number;
  /** ISO date string or human‑readable date */
  closingDate?: string;
}

export interface OpportunityListProps {
  /**
   * Opportunities to display.
   * In the full platform this will usually come from `useOpportunities`.
   */
  opportunities: Opportunity[] | undefined;
  /**
   * Whether data is currently loading.
   * When true and there are no items yet, the Card shows a loading skeleton.
   */
  loading?: boolean;
  /**
   * Optional click handler when an opportunity is selected.
   */
  onSelect?(opportunity: Opportunity): void;
}

/**
 * Kontact – list view for collaboration / engagement opportunities.
 *
 * Pure presentational component; data is provided by a container using
 * the Kontact hooks (e.g. `useOpportunities`).
 */
export default function OpportunityList({
  opportunities,
  loading = false,
  onSelect,
}: OpportunityListProps): JSX.Element {
  const items = opportunities ?? [];

  return (
    <Card
      title="Opportunities"
      loading={loading && !items.length}
      bodyStyle={{ padding: items.length ? 0 : undefined }}
    >
      {!items.length && !loading ? (
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description="No opportunities are available at the moment."
        />
      ) : (
        <List
          itemLayout="vertical"
          dataSource={items}
          renderItem={(item) => (
            <List.Item
              key={item.id}
              style={{ cursor: onSelect ? 'pointer' : 'default' }}
              onClick={() => onSelect?.(item)}
            >
              <List.Item.Meta
                title={
                  <Space direction="vertical" size={2} style={{ width: '100%' }}>
                    <Space wrap align="baseline">
                      <Title level={5} style={{ margin: 0 }}>
                        {item.title}
                      </Title>
                      {item.organisation && (
                        <Text type="secondary">{item.organisation}</Text>
                      )}
                    </Space>
                    <Space size="small" wrap>
                      {item.location && (
                        <Tag icon={<EnvironmentOutlined />}>{item.location}</Tag>
                      )}

                      {item.commitmentLevel && (
                        <Tag>{item.commitmentLevel}</Tag>
                      )}

                      {item.closingDate && (
                        <Tag icon={<ClockCircleOutlined />}>
                          {formatClosingDate(item.closingDate)}
                        </Tag>
                      )}

                      {typeof item.participantsNeeded === 'number' && (
                        <Tag icon={<TeamOutlined />}>
                          {item.participantsNeeded} needed
                        </Tag>
                      )}

                      {item.tags?.map((tag) => (
                        <Tag key={tag}>{tag}</Tag>
                      ))}
                    </Space>
                  </Space>
                }
                description={
                  item.summary ? (
                    <Text type="secondary">{item.summary}</Text>
                  ) : null
                }
              />
            </List.Item>
          )}
        />
      )}
    </Card>
  );
}

function formatClosingDate(value: string): string {
  const parsed = dayjs(value);
  if (parsed.isValid()) {
    return `Closes ${parsed.format('YYYY-MM-DD')}`;
  }
  return `Closes ${value}`;
}

===== END modules/kontact/components/OpportunityList.tsx =====


===== BEGIN modules/kontact/components/ProfileCard.tsx =====
﻿'use client';

import React from 'react';
import { Avatar, Button, Card, Space, Tag, Tooltip, Typography } from 'antd';
import {
  EnvironmentOutlined,
  MessageOutlined,
  TeamOutlined,
  UserOutlined,
} from '@ant-design/icons';

const { Text } = Typography;

/**
 * Minimal, module-local representation of a profile surfaced by the Kontact
 * connect center (KeenKonnect / KonnectED).
 *
 * This is intentionally UI-focused: it only exposes the fields needed
 * to render a rich card. The data can come from any backend endpoint.
 */
export interface KontactProfileSummary {
  id: string;
  /** Display name shown as the main title */
  name: string;
  /** Short headline/tagline, e.g. "AI ethics researcher · Product lead" */
  headline?: string;
  /** Optional avatar URL */
  avatarUrl?: string | null;
  /** Organization or team, e.g. "Konnaxion Labs" */
  organization?: string | null;
  /** Free-form location, e.g. "Paris, France" */
  location?: string | null;
  /** Short bio / focus areas. Keep this reasonably small (1–3 lines). */
  bio?: string | null;
  /** Key expertise tags (max a handful – UI truncates if many). */
  expertiseTags?: string[];
  /** Additional interests (optional, not always shown). */
  interests?: string[];
  /** Optional Ekoh trust score (0–100 or similar scale). */
  ekohScore?: number;
  /**
   * Optional SmartVote weight (e.g. 1.0, 1.5, 2.0) derived from Ekoh.
   * Only shown when different from 1.0.
   */
  smartVoteWeight?: number;
  /** Human-readable last activity, e.g. "2 days ago" or "Just now". */
  lastActiveAgo?: string;
  /** Whether this profile is explicitly open for new collaborations. */
  isOpenToCollab?: boolean;
}

export interface ProfileCardProps {
  profile: KontactProfileSummary;
  /**
   * Called when user clicks "View profile".
   * The parent is responsible for routing (e.g. using next/navigation).
   */
  onViewProfile?: (profile: KontactProfileSummary) => void;
  /** Optional CTA to start a connection / request. */
  onConnect?: (profile: KontactProfileSummary) => void;
  /** Optional CTA to start a direct message or chat. */
  onMessage?: (profile: KontactProfileSummary) => void;
  /** Compact variant used in dense lists. */
  compact?: boolean;
  /** Allow parent to hide the footer actions completely. */
  showActions?: boolean;
}

/**
 * Presentational profile card for the Kontact module.
 *
 * Used by:
 * - ConnectCenter (profile discovery / matching)
 * - PublicProfile (summary view of a single profile)
 *
 * This component is deliberately dumb: it does not fetch data and does not
 * know about routing. It simply renders the provided `profile` and forwards
 * callbacks for primary actions.
 */
const ProfileCard: React.FC<ProfileCardProps> = ({
  profile,
  onViewProfile,
  onConnect,
  onMessage,
  compact = false,
  showActions = true,
}) => {
  const {
    name,
    headline,
    avatarUrl,
    organization,
    location,
    bio,
    expertiseTags = [],
    ekohScore,
    smartVoteWeight,
    lastActiveAgo,
    isOpenToCollab,
  } = profile;

  const avatarInitial =
    (typeof name === 'string' && name.trim().charAt(0).toUpperCase()) || '?';

  const hasTags = expertiseTags.length > 0;
  const showBio = !compact && !!bio;
  const maxTags = compact ? 3 : 6;
  const visibleTags = expertiseTags.slice(0, maxTags);
  const hiddenCount = expertiseTags.length - visibleTags.length;

  const showFooter =
    showActions &&
    (onViewProfile != null || onConnect != null || onMessage != null || !!lastActiveAgo);

  return (
    <Card
      hoverable
      bodyStyle={{ padding: compact ? 16 : 20 }}
      style={{ width: '100%' }}
    >
      <Space direction="vertical" size={compact ? 8 : 12} style={{ width: '100%' }}>
        {/* Header: avatar + name + meta */}
        <div style={{ display: 'flex', gap: 16 }}>
          <Avatar
            size={compact ? 40 : 56}
            src={avatarUrl ?? undefined}
            alt={name}
            icon={!avatarUrl && <UserOutlined />}
          >
            {!avatarUrl && avatarInitial}
          </Avatar>

          <div style={{ flex: 1, minWidth: 0 }}>
            <Space direction="vertical" size={4} style={{ width: '100%' }}>
              <Space size={8} wrap>
                <Text
                  strong
                  style={{
                    fontSize: compact ? 14 : 16,
                    lineHeight: 1.25,
                  }}
                >
                  {name}
                </Text>

                {typeof isOpenToCollab === 'boolean' && (
                  <Tag color={isOpenToCollab ? 'green' : 'default'}>
                    {isOpenToCollab ? 'Open to collaboration' : 'Not actively looking'}
                  </Tag>
                )}

                {typeof ekohScore === 'number' && !Number.isNaN(ekohScore) && (
                  <Tooltip title="Ekoh trust score used inside KeenKonnect decisions">
                    <Tag color="gold">Ekoh {Math.round(ekohScore)}</Tag>
                  </Tooltip>
                )}

                {typeof smartVoteWeight === 'number' &&
                  !Number.isNaN(smartVoteWeight) &&
                  smartVoteWeight !== 1 && (
                    <Tooltip title="SmartVote influence weight from Ekoh reputation">
                      <Tag color="purple">Weight ×{smartVoteWeight.toFixed(1)}</Tag>
                    </Tooltip>
                  )}
              </Space>

              {headline && (
                <Text
                  type="secondary"
                  style={{
                    display: 'block',
                    fontSize: 13,
                    whiteSpace: 'nowrap',
                    textOverflow: 'ellipsis',
                    overflow: 'hidden',
                  }}
                >
                  {headline}
                </Text>
              )}

              {(organization || location) && (
                <Space size={8} wrap style={{ marginTop: 2 }}>
                  {organization && (
                    <Tag icon={<TeamOutlined />} color="default">
                      {organization}
                    </Tag>
                  )}
                  {location && (
                    <Tag icon={<EnvironmentOutlined />} color="default">
                      {location}
                    </Tag>
                  )}
                </Space>
              )}
            </Space>
          </div>
        </div>

        {/* Bio */}
        {showBio && (
          <Text
            type="secondary"
            style={{
              fontSize: 13,
              display: 'block',
              marginTop: 2,
              maxHeight: compact ? 40 : 60,
              overflow: 'hidden',
            }}
          >
            {bio}
          </Text>
        )}

        {/* Expertise tags */}
        {hasTags && (
          <Space size={[4, 4]} wrap style={{ marginTop: compact ? 4 : 6 }}>
            {visibleTags.map((tag) => (
              <Tag key={tag} color="blue">
                {tag}
              </Tag>
            ))}
            {hiddenCount > 0 && (
              <Tag>+{hiddenCount} more</Tag>
            )}
          </Space>
        )}

        {/* Footer: activity + actions */}
        {showFooter && (
          <div
            style={{
              marginTop: compact ? 4 : 8,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              gap: 8,
              flexWrap: 'wrap',
            }}
          >
            {lastActiveAgo && (
              <Text type="secondary" style={{ fontSize: 12 }}>
                Active {lastActiveAgo}
              </Text>
            )}

            <Space size={8} wrap>
              {onViewProfile && (
                <Button
                  size="small"
                  type="link"
                  icon={<UserOutlined />}
                  onClick={() => onViewProfile(profile)}
                >
                  View profile
                </Button>
              )}

              {onConnect && (
                <Button
                  size="small"
                  type="primary"
                  icon={<TeamOutlined />}
                  onClick={() => onConnect(profile)}
                >
                  Connect
                </Button>
              )}

              {onMessage && (
                <Button
                  size="small"
                  icon={<MessageOutlined />}
                  onClick={() => onMessage(profile)}
                >
                  Message
                </Button>
              )}
            </Space>
          </div>
        )}
      </Space>
    </Card>
  );
};

export default ProfileCard;

===== END modules/kontact/components/ProfileCard.tsx =====


===== BEGIN modules/kontact/hooks/index.ts =====
﻿export { default as useOpportunities } from './useOpportunities';
export { default as useProfiles }      from './useProfiles';

===== END modules/kontact/hooks/index.ts =====


===== BEGIN modules/kontact/hooks/useOpportunities.ts =====
﻿// modules/kontact/hooks/useOpportunities.ts

import { useQuery } from '@tanstack/react-query';

export interface Opportunity {
  id: string;
  title: string;
  summary: string;
  organisation?: string;
  location?: string;
  commitment?: string;
  skills?: string[];
  tags?: string[];
  isRemote?: boolean;
  matchScore?: number;
  createdAt?: string;
  deadline?: string;
  url?: string;
  /** True when coming from the built‑in sample fallback rather than the API. */
  isSample?: boolean;
}

export interface OpportunityFilters {
  /** Free‑text search across title, summary, organisation, tags and skills. */
  search?: string;
  /** Filter by main location label (e.g. "Paris", "Remote", "EU"). */
  location?: string;
  /** If true, only return remote‑friendly opportunities. */
  remoteOnly?: boolean;
  /** All of these skills must be present in the opportunity’s skills/tags. */
  skills?: string[];
}

/* ------------------------------------------------------------------ */
/*  Helpers to normalize API responses                                */
/* ------------------------------------------------------------------ */

function normalizeList<T = unknown>(
  raw: unknown,
): { items: T[]; count?: number } {
  if (Array.isArray(raw)) {
    return { items: raw as T[] };
  }

  if (raw && typeof raw === 'object') {
    const obj = raw as { results?: unknown; items?: unknown; count?: number };
    const items =
      (Array.isArray(obj.results) && (obj.results as T[])) ||
      (Array.isArray(obj.items) && (obj.items as T[])) ||
      [];
    return {
      items,
      count: typeof obj.count === 'number' ? obj.count : undefined,
    };
  }

  return { items: [] };
}

function normalizeOpportunities(raw: unknown): Opportunity[] {
  const { items } = normalizeList<any>(raw);

  return items.map((row, index) => {
    const id = row.id ?? row.pk ?? index;

    const tagsSource = row.tags ?? row.keywords ?? row.labels ?? [];
    const skillsSource = row.skills ?? row.skill_tags ?? [];

    const tags = Array.isArray(tagsSource)
      ? tagsSource.map((t: unknown) => String(t))
      : undefined;

    const skills = Array.isArray(skillsSource)
      ? skillsSource.map((s: unknown) => String(s))
      : undefined;

    const isRemote = Boolean(
      row.is_remote ?? row.remote ?? row.remote_friendly ?? false,
    );

    const url =
      row.url ??
      row.link ??
      (typeof row.slug === 'string'
        ? `/kontact/opportunities/${encodeURIComponent(row.slug)}`
        : undefined);

    const organisation =
      row.organisation ??
      row.organization ??
      row.org ??
      row.org_name ??
      row.company ??
      undefined;

    const location =
      row.location ??
      row.city ??
      row.country ??
      (isRemote ? 'Remote' : undefined);

    const commitment =
      row.commitment ??
      row.time_commitment ??
      row.time_required ??
      row.availability ??
      undefined;

    const summary =
      row.summary ??
      row.teaser ??
      row.description ??
      row.short_description ??
      '';

    const matchScore =
      typeof row.match_score === 'number'
        ? row.match_score
        : typeof row.score === 'number'
        ? row.score
        : undefined;

    const createdAt =
      row.created_at ??
      row.createdAt ??
      row.published_at ??
      row.listed_at ??
      undefined;

    const deadline =
      row.deadline ??
      row.closes_at ??
      row.apply_by ??
      row.application_deadline ??
      undefined;

    return {
      id: String(id),
      title: row.title ?? row.name ?? 'Untitled opportunity',
      summary,
      organisation,
      location,
      commitment,
      skills,
      tags,
      isRemote,
      matchScore,
      createdAt,
      deadline,
      url,
      isSample: Boolean(row.isSample),
    };
  });
}

const sampleOpportunities: Opportunity[] = [
  {
    id: 'sample-1',
    title: 'Join a sustainability task‑force',
    summary:
      'Support a cross‑functional team designing and tracking sustainability KPIs for a pilot project.',
    organisation: 'KeenKonnect Community',
    location: 'Remote · EU‑friendly time zones',
    commitment: '2–4 hours per week',
    skills: ['Data analysis', 'Sustainability', 'Project coordination'],
    tags: ['climate', 'impact', 'volunteering'],
    isRemote: true,
    matchScore: 0.9,
    createdAt: new Date().toISOString(),
    url: '/keenkonnect/sustainability-impact/sustainability-dashboard',
    isSample: true,
  },
  {
    id: 'sample-2',
    title: 'UX partner for a civic‑tech app',
    summary:
      'Co‑design user journeys and low‑fidelity prototypes for a local participation and voting portal.',
    organisation: 'Civic Lab',
    location: 'Hybrid · Paris / Remote',
    commitment: '1–2 evenings per week',
    skills: ['UX research', 'Prototyping', 'Civic tech'],
    tags: ['civic‑tech', 'participation', 'design'],
    isRemote: true,
    matchScore: 0.82,
    createdAt: new Date().toISOString(),
    url: '/ethikos/deliberate/guidelines',
    isSample: true,
  },
  {
    id: 'sample-3',
    title: 'Community moderator for consultations',
    summary:
      'Help facilitate respectful and inclusive dialogue in Ethikos consultations and feedback spaces.',
    organisation: 'Ethikos',
    location: 'Remote',
    commitment: '3–5 hours per month',
    skills: ['Moderation', 'Conflict resolution', 'Community management'],
    tags: ['ethics', 'governance', 'community'],
    isRemote: true,
    matchScore: 0.76,
    createdAt: new Date().toISOString(),
    url: '/ethikos/admin/moderation',
    isSample: true,
  },
  {
    id: 'sample-4',
    title: 'Mentoring circle on AI & ethics',
    summary:
      'Small peer‑learning group for students and early‑career professionals exploring AI governance.',
    organisation: 'Ekoh / KonnectED',
    location: 'Online',
    commitment: 'Monthly 90‑minute sessions',
    skills: ['AI ethics', 'Facilitation', 'Research'],
    tags: ['AI', 'ethics', 'mentoring'],
    isRemote: true,
    matchScore: 0.88,
    createdAt: new Date().toISOString(),
    url: '/konnected/learning-library/browse-resources',
    isSample: true,
  },
];

/* ------------------------------------------------------------------ */
/*  Local filtering for the sample / generic lists                     */
/* ------------------------------------------------------------------ */

function applyLocalFilters(
  items: Opportunity[],
  filters?: OpportunityFilters,
): Opportunity[] {
  if (!filters) return items;

  const { search, location, remoteOnly, skills } = filters;
  let result = items;

  if (search && search.trim()) {
    const needle = search.trim().toLowerCase();
    result = result.filter((item) => {
      const inTitle = item.title.toLowerCase().includes(needle);
      const inSummary = item.summary.toLowerCase().includes(needle);
      const inOrg = item.organisation
        ? item.organisation.toLowerCase().includes(needle)
        : false;
      const inTags = item.tags
        ? item.tags.some((tag) => tag.toLowerCase().includes(needle))
        : false;
      const inSkills = item.skills
        ? item.skills.some((skill) => skill.toLowerCase().includes(needle))
        : false;

      return inTitle || inSummary || inOrg || inTags || inSkills;
    });
  }

  if (location && location.trim()) {
    const locNeedle = location.trim().toLowerCase();
    result = result.filter((item) =>
      item.location ? item.location.toLowerCase().includes(locNeedle) : false,
    );
  }

  if (remoteOnly) {
    result = result.filter((item) => Boolean(item.isRemote));
  }

  if (skills && skills.length) {
    const wanted = skills.map((s) => s.toLowerCase());
    result = result.filter((item) => {
      const itemSkills =
        item.skills?.map((s) => s.toLowerCase()) ??
        item.tags?.map((t) => t.toLowerCase()) ??
        [];
      return wanted.every((skill) => itemSkills.includes(skill));
    });
  }

  return result;
}

/* ------------------------------------------------------------------ */
/*  Wire to API with graceful fallbacks                               */
/* ------------------------------------------------------------------ */

async function fetchOpportunities(
  filters?: OpportunityFilters,
): Promise<Opportunity[]> {
  const params = new URLSearchParams();

  if (filters?.search?.trim()) {
    params.set('q', filters.search.trim());
  }
  if (filters?.location?.trim()) {
    params.set('location', filters.location.trim());
  }
  if (filters?.remoteOnly) {
    params.set('remote', 'true');
  }
  if (filters?.skills?.length) {
    params.set('skills', filters.skills.join(','));
  }

  const queryString = params.toString();
  const suffix = queryString ? `?${queryString}` : '';

  // Try a small set of likely endpoints. Only 404/501 are treated as "not wired".
  const endpoints = [
    '/api/kontact/opportunities/',
    '/api/opportunities/',
    '/api/keenkonnect/opportunities/',
  ];

  let hardError: Error | null = null;

  for (const base of endpoints) {
    try {
      const res = await fetch(`${base}${suffix}`, {
        method: 'GET',
        credentials: 'include',
        headers: {
          Accept: 'application/json',
        },
        cache: 'no-store',
      });

      if (!res.ok) {
        if (res.status === 404 || res.status === 501) {
          // Endpoint not available; try the next variant.
          continue;
        }

        const body = await res.text().catch(() => '');
        hardError = new Error(
          body || `Failed to load opportunities (${res.status})`,
        );
        // For "hard" API errors, stop trying alternates and let React Query surface the error.
        break;
      }

      const json = (await res.json()) as unknown;
      const items = normalizeOpportunities(json);
      return applyLocalFilters(items, filters);
    } catch {
      // Network / CORS / other fetch‑level issue → treat as "no live endpoint yet"
      // and try the next variant. We intentionally do not set hardError here.
      continue;
    }
  }

  if (hardError) {
    throw hardError;
  }

  // No live endpoint: fall back to in‑memory sample opportunities so the UI is usable.
  // eslint-disable-next-line no-console
  console.warn(
    'Kontact opportunities API not available; using sample opportunities instead.',
  );

  return applyLocalFilters(sampleOpportunities, filters);
}

/* ------------------------------------------------------------------ */
/*  Public hook                                                        */
/* ------------------------------------------------------------------ */

export default function useOpportunities(filters?: OpportunityFilters) {
  return useQuery<Opportunity[], Error>({
    queryKey: ['kontact', 'opportunities', filters ?? {}],
    staleTime: 5 * 60 * 1000, // 5 minutes
    queryFn: () => fetchOpportunities(filters),
  });
}

===== END modules/kontact/hooks/useOpportunities.ts =====


===== BEGIN modules/kontact/hooks/useProfiles.ts =====
﻿// modules/kontact/hooks/useProfiles.ts

import { useQuery } from '@tanstack/react-query';
import { fetchUserProfile, type ReputationProfile } from '@/services/trust';

export type ReputationLevel = ReputationProfile['level'];

export interface KontactProfile {
  id: string;
  username: string;
  displayName: string;
  avatarUrl?: string | null;
  headline?: string;
  shortBio?: string;
  primaryDomain?: string;
  domains: string[];
  expertiseTags: string[];
  location?: string;
  availability?: string;
  reputationLevel: ReputationLevel;
  reputationScore: number;
  isYou?: boolean;
}

export interface ProfilesFilter {
  /**
   * Free‑text search applied to name, username, headline,
   * domains and expertise tags.
   */
  search?: string;

  /**
   * Filter by primary domain or any domain label.
   * Example: "Climate & Resilience", "AI Ethics".
   */
  domain?: string;

  /**
   * Minimum Ekoh reputation score (0–100).
   * Example: 40 → only Contributors and Stewards above that score.
   */
  minScore?: number;

  /**
   * Only keep Steward‑level profiles.
   */
  onlyStewards?: boolean;

  /**
   * When false, hides the current user from the result set.
   * Default: true (include).
   */
  includeSelf?: boolean;

  /**
   * Optional hard filter to retrieve a single profile by username.
   * Useful for the public profile page.
   */
  username?: string;
}

/**
 * Build a synthetic roster of collaboration profiles for the Connect Center.
 *
 * There is no dedicated "Kontact profiles" endpoint yet; instead we:
 * - derive the current user's identity + reputation from the Ekoh profile
 * - add a small set of curated example peers
 * - apply client‑side filters (search, domain, score, level)
 */
async function loadProfiles(filter: ProfilesFilter = {}): Promise<KontactProfile[]> {
  const me = await fetchUserProfile();

  const allProfiles = buildSampleProfiles(me);

  return applyFilter(allProfiles, filter);
}

function buildSampleProfiles(me: ReputationProfile): KontactProfile[] {
  const username = me.username ?? 'you';
  const displayName = me.displayName ?? username;

  const you: KontactProfile = {
    id: `user-${username}`,
    username,
    displayName,
    avatarUrl: me.avatarUrl ?? null,
    headline: `Ekoh ${me.level} · score ${Math.round(me.score)}/100`,
    shortBio:
      'Your orchestrator profile as seen across Ekoh & KeenKonnect. Used for matching, trust and collaboration signals.',
    primaryDomain: 'Cross‑ecosystem orchestration',
    domains: ['Ethikos debates', 'KeenKonnect workspaces'],
    expertiseTags: [
      'Deliberation quality',
      'Participation',
      'Influence (weighted votes)',
    ],
    location: undefined,
    availability: 'Open to selective collaborations',
    reputationLevel: me.level,
    reputationScore: me.score,
    isYou: true,
  };

  // Curated example peers – purely front‑end for now.
  // These give the Connect Center UI realistic data until a backend is wired.
  const peers: KontactProfile[] = [
    {
      id: 'user-aminata',
      username: 'aminata',
      displayName: 'Aminata N.',
      avatarUrl: null,
      headline: 'Climate policy researcher · Just transition facilitator',
      shortBio:
        'Works with cities and communities on climate resilience and inclusive transition roadmaps.',
      primaryDomain: 'Climate & resilience',
      domains: ['Climate & resilience', 'Urban policy'],
      expertiseTags: [
        'Participatory climate roadmapping',
        'Just transition',
        'Community engagement',
      ],
      location: 'Dakar · Remote‑friendly',
      availability: '3–5 h / week · Open to new projects',
      reputationLevel: 'Steward',
      reputationScore: 86,
    },
    {
      id: 'user-lucas',
      username: 'lucas',
      displayName: 'Lucas R.',
      avatarUrl: null,
      headline: 'AI ethics & product · Guardrails for applied ML',
      shortBio:
        'Helps product teams ship responsible ML features and align experiments with governance frameworks.',
      primaryDomain: 'AI ethics',
      domains: ['AI ethics', 'Product strategy'],
      expertiseTags: [
        'AI guardrails',
        'Fairness by design',
        'Experimentation & A/B testing',
      ],
      location: 'Montréal · Hybrid',
      availability: 'Evenings & week‑ends',
      reputationLevel: 'Contributor',
      reputationScore: 72,
    },
    {
      id: 'user-sofia',
      username: 'sofia',
      displayName: 'Sofia P.',
      avatarUrl: null,
      headline: 'Impact measurement · Learning ecosystems',
      shortBio:
        'Designs lightweight impact frameworks and runs sense‑making sessions with multi‑stakeholder teams.',
      primaryDomain: 'Impact & evaluation',
      domains: ['Impact & evaluation', 'Learning design'],
      expertiseTags: [
        'Outcome mapping',
        'Qualitative evaluation',
        'Learning loops',
      ],
      location: 'Lisbon · Remote',
      availability: '5–8 h / month · Advisory',
      reputationLevel: 'Contributor',
      reputationScore: 64,
    },
    {
      id: 'user-raj',
      username: 'raj',
      displayName: 'Raj K.',
      avatarUrl: null,
      headline: 'Systems design · Collaborative governance',
      shortBio:
        'Supports networks of cities and labs to co‑design governance experiments and decision protocols.',
      primaryDomain: 'Systems & governance',
      domains: ['Systems & governance', 'Civic tech'],
      expertiseTags: [
        'Multi‑stakeholder facilitation',
        'Governance pilots',
        'Decision protocols',
      ],
      location: 'Bengaluru · Remote‑first',
      availability: 'Open to new collaborations',
      reputationLevel: 'Steward',
      reputationScore: 91,
    },
    {
      id: 'user-ines',
      username: 'ines',
      displayName: 'Inès L.',
      avatarUrl: null,
      headline: 'Community builder · Practice‑based cohorts',
      shortBio:
        'Designs peer learning cohorts for practitioners working on climate, AI and social innovation.',
      primaryDomain: 'Communities & learning',
      domains: ['Communities & learning', 'Facilitation'],
      expertiseTags: [
        'Cohort design',
        'Online facilitation',
        'Community health',
      ],
      location: 'Paris · Hybrid',
      availability: 'Side‑project friendly',
      reputationLevel: 'Contributor',
      reputationScore: 58,
    },
  ];

  return [you, ...peers];
}

function applyFilter(
  profiles: KontactProfile[],
  filter: ProfilesFilter,
): KontactProfile[] {
  const {
    search,
    domain,
    minScore,
    onlyStewards,
    includeSelf = true,
    username,
  } = filter;

  let result = [...profiles];

  // Hard filter by username (e.g. public profile view)
  if (username && username.trim()) {
    const target = username.trim().toLowerCase();
    result = result.filter(
      (p) => p.username.toLowerCase() === target || p.id.toLowerCase() === target,
    );
  }

  if (!includeSelf) {
    result = result.filter((p) => !p.isYou);
  }

  if (onlyStewards) {
    result = result.filter((p) => p.reputationLevel === 'Steward');
  }

  if (typeof minScore === 'number') {
    result = result.filter((p) => p.reputationScore >= minScore);
  }

  if (domain && domain.trim() && domain !== 'all') {
    const d = domain.trim().toLowerCase();
    result = result.filter(
      (p) =>
        p.primaryDomain?.toLowerCase() === d ||
        p.domains.some((dom) => dom.toLowerCase() === d),
    );
  }

  const q = search?.trim().toLowerCase();
  if (q) {
    result = result.filter((p) => {
      const haystack = [
        p.displayName,
        p.username,
        p.headline ?? '',
        p.shortBio ?? '',
        p.primaryDomain ?? '',
        ...p.domains,
        ...p.expertiseTags,
      ]
        .join(' ')
        .toLowerCase();

      return haystack.includes(q);
    });
  }

  return result;
}

export default function useProfiles(filter: ProfilesFilter = {}) {
  return useQuery<KontactProfile[], Error>({
    queryKey: ['kontact-profiles', filter],
    queryFn: () => loadProfiles(filter),
    staleTime: 5 * 60_000, // 5 minutes
  });
}

===== END modules/kontact/hooks/useProfiles.ts =====


===== BEGIN modules/kontact/pages/ConnectCenter.tsx =====
﻿// frontend/modules/kontact/pages/ConnectCenter.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { PageContainer } from '@ant-design/pro-components';
import {
  Alert,
  Badge,
  Col,
  Empty,
  Input,
  Row,
  Space,
  Spin,
  Tabs,
  Tag,
  Typography,
} from 'antd';
import {
  AppstoreOutlined,
  SearchOutlined,
  TeamOutlined,
  UserOutlined,
} from '@ant-design/icons';

import usePageTitle from '@/hooks/usePageTitle';
import { useOpportunities, useProfiles } from '@/kontact/hooks';
import { OpportunityList, ProfileCard } from '@/kontact/components';

const { Text, Title } = Typography;
const { Search } = Input;

type TabKey = 'people' | 'opportunities' | 'all';

export default function ConnectCenter(): JSX.Element {
  usePageTitle('Kontact · Connect center');

  const [searchTerm, setSearchTerm] = useState('');
  const [activeTab, setActiveTab] = useState<TabKey>('people');

  // Hooks are currently stubs; this code is defensive so the page still renders
  // with empty data until real implementations are added.
  const profilesQuery: any = useProfiles();
  const opportunitiesQuery: any = useOpportunities();

  const rawProfiles = profilesQuery?.data ?? profilesQuery?.items ?? [];
  const rawOpportunities = opportunitiesQuery?.data ?? opportunitiesQuery?.items ?? [];

  const profiles: any[] = Array.isArray(rawProfiles) ? rawProfiles : [];
  const opportunities: any[] = Array.isArray(rawOpportunities) ? rawOpportunities : [];

  const profilesLoading = Boolean(
    (profilesQuery && profilesQuery.isLoading) ||
      (profilesQuery && profilesQuery.loading),
  );
  const opportunitiesLoading = Boolean(
    (opportunitiesQuery && opportunitiesQuery.isLoading) ||
      (opportunitiesQuery && opportunitiesQuery.loading),
  );
  const loading = profilesLoading || opportunitiesLoading;

  const profilesError: Error | undefined = profilesQuery?.error;
  const opportunitiesError: Error | undefined = opportunitiesQuery?.error;
  const error = profilesError ?? opportunitiesError;

  const lowerSearch = searchTerm.trim().toLowerCase();

  const filteredProfiles = useMemo(
    () =>
      !lowerSearch
        ? profiles
        : profiles.filter((p: any) => {
            const skills = Array.isArray(p.skills) ? p.skills.join(' ') : '';
            const tags = Array.isArray(p.tags) ? p.tags.join(' ') : '';
            const haystack = `${p.name ?? ''} ${p.headline ?? ''} ${skills} ${tags}`.toLowerCase();
            return haystack.includes(lowerSearch);
          }),
    [profiles, lowerSearch],
  );

  const filteredOpportunities = useMemo(
    () =>
      !lowerSearch
        ? opportunities
        : opportunities.filter((o: any) => {
            const tags = Array.isArray(o.tags) ? o.tags.join(' ') : '';
            const haystack = `${o.title ?? ''} ${o.organization ?? ''} ${tags}`.toLowerCase();
            return haystack.includes(lowerSearch);
          }),
    [opportunities, lowerSearch],
  );

  const totalMatches = filteredProfiles.length + filteredOpportunities.length;

  const renderPeopleTab = () => {
    if (loading && profiles.length === 0) {
      return (
        <div style={{ textAlign: 'center', padding: 24 }}>
          <Spin />
        </div>
      );
    }

    if (!loading && filteredProfiles.length === 0) {
      return <Empty description="No matching people yet" />;
    }

    return (
      <Row gutter={[16, 16]}>
        {filteredProfiles.map((profile: any) => (
          <Col
            key={profile.id ?? profile.username ?? profile.email ?? Math.random().toString(36)}
            xs={24}
            sm={12}
            xl={8}
          >
            {/* ProfileCard will be implemented to accept a `profile` prop */}
            <ProfileCard profile={profile} />
          </Col>
        ))}
      </Row>
    );
  };

  const renderOpportunitiesTab = () => {
    if (loading && opportunities.length === 0) {
      return (
        <div style={{ textAlign: 'center', padding: 24 }}>
          <Spin />
        </div>
      );
    }

    if (!loading && filteredOpportunities.length === 0) {
      return <Empty description="No matching opportunities yet" />;
    }

    // OpportunityList will be implemented to accept these props
    return (
      <OpportunityList
        opportunities={filteredOpportunities}
        loading={opportunitiesLoading}
      />
    );
  };

  const renderAllTabChildren = () => (
    <Row gutter={[24, 24]}>
      <Col xs={24} lg={12}>
        <Space direction="vertical" size="small" style={{ width: '100%' }}>
          <Text type="secondary">People</Text>
          {renderPeopleTab()}
        </Space>
      </Col>
      <Col xs={24} lg={12}>
        <Space direction="vertical" size="small" style={{ width: '100%' }}>
          <Text type="secondary">Opportunities</Text>
          {renderOpportunitiesTab()}
        </Space>
      </Col>
    </Row>
  );

  const tabItems = [
    {
      key: 'people',
      label: (
        <span>
          <UserOutlined /> People
          {filteredProfiles.length > 0 && (
            <Badge
              style={{ marginLeft: 8 }}
              count={filteredProfiles.length}
              overflowCount={99}
            />
          )}
        </span>
      ),
      children: renderPeopleTab(),
    },
    {
      key: 'opportunities',
      label: (
        <span>
          <AppstoreOutlined /> Opportunities
          {filteredOpportunities.length > 0 && (
            <Badge
              style={{ marginLeft: 8 }}
              count={filteredOpportunities.length}
              overflowCount={99}
            />
          )}
        </span>
      ),
      children: renderOpportunitiesTab(),
    },
    {
      key: 'all',
      label: (
        <span>
          <TeamOutlined /> Combined
        </span>
      ),
      children: renderAllTabChildren(),
    },
  ];

  return (
    <PageContainer ghost>
      <Space direction="vertical" size="large" style={{ width: '100%' }}>
        {/* Header + search */}
        <Space direction="vertical" size="small" style={{ width: '100%' }}>
          <Title level={3} style={{ marginBottom: 0 }}>
            Connect center
          </Title>
          <Text type="secondary">
            Discover people to collaborate with and opportunities that match your skills,
            interests, and impact goals.
          </Text>

          <Space
            align="center"
            style={{
              marginTop: 12,
              width: '100%',
              justifyContent: 'space-between',
              gap: 16,
              flexWrap: 'wrap',
            }}
          >
            <Search
              placeholder="Search people or opportunities…"
              allowClear
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              onSearch={(value) => setSearchTerm(value)}
              style={{ maxWidth: 420, flex: 1 }}
              prefix={<SearchOutlined />}
            />

            <Space size="small" wrap>
              <Tag color="blue">
                People&nbsp;
                {filteredProfiles.length}
              </Tag>
              <Tag color="green">
                Opportunities&nbsp;
                {filteredOpportunities.length}
              </Tag>
              <Tag>{totalMatches} total matches</Tag>
            </Space>
          </Space>
        </Space>

        {/* Error state */}
        {error && (
          <Alert
            type="error"
            showIcon
            message="Unable to load connect data"
            description={error.message ?? 'Please try again in a moment.'}
          />
        )}

        {/* Tabs */}
        <Tabs
          activeKey={activeTab}
          onChange={(key) => setActiveTab(key as TabKey)}
          items={tabItems}
        />
      </Space>
    </PageContainer>
  );
}

===== END modules/kontact/pages/ConnectCenter.tsx =====


===== BEGIN modules/kontact/pages/index.ts =====
export { default as ConnectCenter } from './ConnectCenter';
export { default as PublicProfile } from './PublicProfile';

===== END modules/kontact/pages/index.ts =====


===== BEGIN modules/kontact/pages/PublicProfile.tsx =====
﻿// frontend/modules/kontact/pages/PublicProfile.tsx

import MainLayout from '@/shared/layout/MainLayout';
import UserProfile from '@/components/user-components/UserProfile';

/**
 * Kontact · Public Profile page
 *
 * Reuses the existing UserProfile component, which:
 * - reads ?id=<USER_ID> from the URL
 * - fetches /users/:id and /users/:id/comments via the shared API client
 * - renders profile summary + recent comments
 */
export default function PublicProfilePage() {
  return (
    <MainLayout>
      <UserProfile />
    </MainLayout>
  );
}

===== END modules/kontact/pages/PublicProfile.tsx =====


===== BEGIN modules/kreative/collaborative-spaces/find-spaces/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/collaborative-spaces/find-spaces/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/collaborative-spaces/my-spaces/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/collaborative-spaces/my-spaces/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/collaborative-spaces/start-new-space/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/collaborative-spaces/start-new-space/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/community-showcases/featured-projects/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/community-showcases/featured-projects/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/community-showcases/submit-to-showcase/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/community-showcases/submit-to-showcase/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/community-showcases/top-creators/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/community-showcases/top-creators/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/creative-hub/explore-ideas/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/creative-hub/explore-ideas/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/creative-hub/inspiration-gallery/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/creative-hub/inspiration-gallery/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/creative-hub/submit-creative-work/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/creative-hub/submit-creative-work/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/dashboard/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/dashboard/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/idea-incubator/collaborate-on-ideas/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/idea-incubator/collaborate-on-ideas/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/idea-incubator/create-new-idea/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/idea-incubator/create-new-idea/components/CommonWidget/page.tsx =====


===== BEGIN modules/kreative/idea-incubator/my-ideas/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END modules/kreative/idea-incubator/my-ideas/components/CommonWidget/page.tsx =====

