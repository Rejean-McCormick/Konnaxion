===== TOC (100 fichiers) =====
1. C:\MyCode\Konnaxionv14\frontend\app\_api\admin\moderation\route.ts
2. C:\MyCode\Konnaxionv14\frontend\app\_api\admin\stats\route.ts
3. C:\MyCode\Konnaxionv14\frontend\app\_api\health\route.ts
4. C:\MyCode\Konnaxionv14\frontend\app\_api\search\route.ts
5. C:\MyCode\Konnaxionv14\frontend\app\DOCHowtonest\keenkonnect.txt
6. C:\MyCode\Konnaxionv14\frontend\app\ekoh\achievements-badges\earned-badges-display\page.tsx
7. C:\MyCode\Konnaxionv14\frontend\app\ekoh\dashboard\page.tsx
8. C:\MyCode\Konnaxionv14\frontend\app\ekoh\EkohPageShell.tsx
9. C:\MyCode\Konnaxionv14\frontend\app\ekoh\expertise-areas\view-current-expertise\page.tsx
10. C:\MyCode\Konnaxionv14\frontend\app\ekoh\layout.tsx
11. C:\MyCode\Konnaxionv14\frontend\app\ekoh\overview-analytics\current-ekoh-score\page.tsx
12. C:\MyCode\Konnaxionv14\frontend\app\ekoh\voting-influence\current-voting-weight\page.tsx
13. C:\MyCode\Konnaxionv14\frontend\app\ethikos\admin\audit\page.tsx
14. C:\MyCode\Konnaxionv14\frontend\app\ethikos\admin\moderation\page.tsx
15. C:\MyCode\Konnaxionv14\frontend\app\ethikos\admin\roles\page.tsx
16. C:\MyCode\Konnaxionv14\frontend\app\ethikos\decide\elite\page.tsx
17. C:\MyCode\Konnaxionv14\frontend\app\ethikos\decide\methodology\page.tsx
18. C:\MyCode\Konnaxionv14\frontend\app\ethikos\decide\public\page.tsx
19. C:\MyCode\Konnaxionv14\frontend\app\ethikos\decide\results\page.tsx
20. C:\MyCode\Konnaxionv14\frontend\app\ethikos\deliberate\[topic]\page.tsx
21. C:\MyCode\Konnaxionv14\frontend\app\ethikos\deliberate\elite\page.tsx
22. C:\MyCode\Konnaxionv14\frontend\app\ethikos\deliberate\guidelines\page.tsx
23. C:\MyCode\Konnaxionv14\frontend\app\ethikos\EthikosPageShell.tsx
24. C:\MyCode\Konnaxionv14\frontend\app\ethikos\impact\feedback\page.tsx
25. C:\MyCode\Konnaxionv14\frontend\app\ethikos\impact\outcomes\page.tsx
26. C:\MyCode\Konnaxionv14\frontend\app\ethikos\impact\tracker\page.tsx
27. C:\MyCode\Konnaxionv14\frontend\app\ethikos\layout.tsx
28. C:\MyCode\Konnaxionv14\frontend\app\ethikos\learn\changelog\page.tsx
29. C:\MyCode\Konnaxionv14\frontend\app\ethikos\learn\glossary\page.tsx
30. C:\MyCode\Konnaxionv14\frontend\app\ethikos\learn\guides\page.tsx
31. C:\MyCode\Konnaxionv14\frontend\app\ethikos\pulse\health\page.tsx
32. C:\MyCode\Konnaxionv14\frontend\app\ethikos\pulse\live\page.tsx
33. C:\MyCode\Konnaxionv14\frontend\app\ethikos\pulse\overview\page.tsx
34. C:\MyCode\Konnaxionv14\frontend\app\ethikos\pulse\trends\page.tsx
35. C:\MyCode\Konnaxionv14\frontend\app\ethikos\trust\badges\page.tsx
36. C:\MyCode\Konnaxionv14\frontend\app\ethikos\trust\credentials\page.tsx
37. C:\MyCode\Konnaxionv14\frontend\app\ethikos\trust\profile\page.tsx
38. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\ai-team-matching\find-teams\page.tsx
39. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\ai-team-matching\match-preferences\page.tsx
40. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\ai-team-matching\my-matches\page.tsx
41. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\dashboard\page.tsx
42. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\KeenPageShell.tsx
43. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\knowledge\browse-repository\page.tsx
44. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\knowledge\document-management\page.tsx
45. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\knowledge\search-filter-documents\page.tsx
46. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\knowledge\upload-new-document\page.tsx
47. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\layout.tsx
48. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\projects\browse-projects\page.tsx
49. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\projects\create-new-project\page.tsx
50. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\projects\my-projects\page.tsx
51. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\projects\project-workspace\page.tsx
52. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\sustainability-impact\submit-impact-reports\page.tsx
53. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\sustainability-impact\sustainability-dashboard\page.tsx
54. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\sustainability-impact\track-project-impact\page.tsx
55. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\user-reputation\account-preferences\page.tsx
56. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\user-reputation\manage-expertise-areas\page.tsx
57. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\user-reputation\view-reputation-ekoh\page.tsx
58. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\workspaces\browse-available-workspaces\page.tsx
59. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\workspaces\launch-new-workspace\page.tsx
60. C:\MyCode\Konnaxionv14\frontend\app\keenkonnect\workspaces\my-workspaces\page.tsx
61. C:\MyCode\Konnaxionv14\frontend\app\konnected\certifications\certification-programs\page.tsx
62. C:\MyCode\Konnaxionv14\frontend\app\konnected\certifications\exam-dashboard-results\page.tsx
63. C:\MyCode\Konnaxionv14\frontend\app\konnected\certifications\exam-preparation\page.tsx
64. C:\MyCode\Konnaxionv14\frontend\app\konnected\certifications\exam-registration\page.tsx
65. C:\MyCode\Konnaxionv14\frontend\app\konnected\community-discussions\active-threads\page.tsx
66. C:\MyCode\Konnaxionv14\frontend\app\konnected\community-discussions\moderation\page.tsx
67. C:\MyCode\Konnaxionv14\frontend\app\konnected\community-discussions\start-new-discussion\page.tsx
68. C:\MyCode\Konnaxionv14\frontend\app\konnected\dashboard\page.tsx
69. C:\MyCode\Konnaxionv14\frontend\app\konnected\KonnectedPageShell.tsx
70. C:\MyCode\Konnaxionv14\frontend\app\konnected\layout.tsx
71. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-library\browse-resources\page.tsx
72. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-library\offline-content\page.tsx
73. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-library\recommended-resources\page.tsx
74. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-library\search-filters\page.tsx
75. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-paths\create-learning-path\page.tsx
76. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-paths\manage-existing-paths\page.tsx
77. C:\MyCode\Konnaxionv14\frontend\app\konnected\learning-paths\my-learning-path\page.tsx
78. C:\MyCode\Konnaxionv14\frontend\app\konnected\teams-collaboration\activity-planner\page.tsx
79. C:\MyCode\Konnaxionv14\frontend\app\konnected\teams-collaboration\my-teams\page.tsx
80. C:\MyCode\Konnaxionv14\frontend\app\konnected\teams-collaboration\project-workspaces\page.tsx
81. C:\MyCode\Konnaxionv14\frontend\app\konnected\teams-collaboration\team-builder\page.tsx
82. C:\MyCode\Konnaxionv14\frontend\app\konsensus\page.tsx
83. C:\MyCode\Konnaxionv14\frontend\app\kreative\collaborative-spaces\find-spaces\page.tsx
84. C:\MyCode\Konnaxionv14\frontend\app\kreative\collaborative-spaces\my-spaces\page.tsx
85. C:\MyCode\Konnaxionv14\frontend\app\kreative\collaborative-spaces\start-new-space\page.tsx
86. C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\featured-projects\page.tsx
87. C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\submit-to-showcase\page.tsx
88. C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\top-creators\page.tsx
89. C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\explore-ideas\page.tsx
90. C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\inspiration-gallery\page.tsx
91. C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\submit-creative-work\page.tsx
92. C:\MyCode\Konnaxionv14\frontend\app\kreative\dashboard\page.tsx
93. C:\MyCode\Konnaxionv14\frontend\app\kreative\idea-incubator\collaborate-on-ideas\page.tsx
94. C:\MyCode\Konnaxionv14\frontend\app\kreative\idea-incubator\create-new-idea\page.tsx
95. C:\MyCode\Konnaxionv14\frontend\app\kreative\idea-incubator\my-ideas\page.tsx
96. C:\MyCode\Konnaxionv14\frontend\app\kreative\kreativePageShell.tsx
97. C:\MyCode\Konnaxionv14\frontend\app\kreative\layout.tsx
98. C:\MyCode\Konnaxionv14\frontend\app\layout.tsx
99. C:\MyCode\Konnaxionv14\frontend\app\page.tsx
100. C:\MyCode\Konnaxionv14\frontend\app\providers\AuthProvider.tsx
===== END TOC =====


===== BEGIN app/_api/admin/moderation/route.ts =====
import { NextResponse } from 'next/server'

interface ModerationItem {
  id: string
  type: string
  content: string
  reason: string
  userId: string
  createdAt: string
}

export async function GET() {
  // TODO: fetch your real moderation queue here
  const queue: ModerationItem[] = [
    {
      id: '1',
      type: 'comment',
      content: 'Offensive comment text here',
      reason: 'profanity',
      userId: 'user_123',
      createdAt: new Date().toISOString(),
    },
  ]

  return NextResponse.json<ModerationItem[]>(queue, {
    status: 200,
    headers: { 'Cache-Control': 'no-store' },
  })
}

===== END app/_api/admin/moderation/route.ts =====


===== BEGIN app/_api/admin/stats/route.ts =====
import { NextResponse } from 'next/server'

interface AdminStats {
  totalUsers: number
  activeUsers: number
  newUsers: number
}

export async function GET() {
  // TODO: hook up your real DB call here
  const stats: AdminStats = {
    totalUsers: 1234,
    activeUsers: 567,
    newUsers: 89,
  }

  return NextResponse.json<AdminStats>(stats, {
    status: 200,
    headers: { 'Cache-Control': 'no-store' },
  })
}

===== END app/_api/admin/stats/route.ts =====


===== BEGIN app/_api/health/route.ts =====
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.json(
    { status: 'ok', timestamp: new Date().toISOString() },
    {
      status: 200,
      headers: { 'Cache-Control': 'no-store' },
    }
  )
}

===== END app/_api/health/route.ts =====


===== BEGIN app/_api/search/route.ts =====
import { NextRequest, NextResponse } from 'next/server'

interface SearchResult {
  id: string
  title: string
  snippet: string
  path: string
}

export async function GET(request: NextRequest) {
  const url = new URL(request.url)
  const q = url.searchParams.get('q')?.trim() || ''
  if (!q) {
    return NextResponse.json({ error: 'Missing query parameter `q`' }, { status: 400 })
  }

  // TODO: replace with real search logic
  const results: SearchResult[] = [
    {
      id: 'item-1',
      title: `Result for "${q}" #1`,
      snippet: 'A brief snippet of matching content‚Ä¶',
      path: `/some/path/1`,
    },
  ]

  return NextResponse.json<{ results: SearchResult[] }>({ results }, {
    status: 200,
    headers: { 'Cache-Control': 'no-store' },
  })
}

===== END app/_api/search/route.ts =====


===== BEGIN app/DOCHowtonest/keenkonnect.txt =====
Voici un mod√®le central que tu peux r√©utiliser comme **r√©f√©rence de layout KeenKonnect** et donner tel quel √† une autre IA quand tu lui demandes de refactor des pages.

Je vais d‚Äôabord te donner **le composant central**, puis **la structure de page de r√©f√©rence**, puis **les r√®gles pour corriger les autres pages**.

---

## 1. Composant central : `<KeenPage>` (√† cr√©er une fois)

> Objectif : toutes les pages KeenKonnect passent par ce wrapper, pour aligner :
>
> * largeur
> * padding
> * taille du titre
> * zone de description
> * toolbar √† droite
> * pas de breadcrumb local (on laisse le layout global le g√©rer)

**Fichier sugg√©r√©** : `components/keenkonnect/KeenPage.tsx`

```tsx
'use client';

import React from 'react';
import Head from 'next/head';
import usePageTitle from '@/hooks/usePageTitle';

type KeenPageProps = {
  /** Gros titre de la page, affich√© en <h1> */
  title: string;

  /** Sous-titre / description sous le titre */
  description?: string;

  /** Titre <title> du navigateur. Si non fourni, on g√©n√®re "KeenKonnect ¬∑ {title}" */
  metaTitle?: string;

  /** Contenu principal de la page */
  children: React.ReactNode;

  /**
   * √âl√©ment(s) √† droite du titre (boutons d‚Äôaction, filtres, etc.)
   * ex: <Button type="primary">New</Button>
   */
  toolbar?: React.ReactNode;

  /** Largeur max de la zone centrale */
  maxWidth?: number | string;
};

export default function KeenPage({
  title,
  description,
  metaTitle,
  children,
  toolbar,
  maxWidth = 1200,
}: KeenPageProps) {
  const finalMetaTitle = metaTitle ?? `KeenKonnect ¬∑ ${title}`;

  // Synchronise le titre de l‚Äôonglet (hook existant dans ton codebase)
  usePageTitle(finalMetaTitle);

  return (
    <>
      <Head>
        <title>{finalMetaTitle}</title>
      </Head>

      <div className="container mx-auto p-5" style={{ maxWidth }}>
        {/* Header de page standardis√© */}
        <div className="mb-4 flex flex-wrap items-center justify-between gap-3">
          <div>
            <h1 className="text-2xl font-bold">{title}</h1>
            {description && (
              <p className="mt-1 text-gray-500">{description}</p>
            )}
          </div>

          {toolbar && <div className="flex items-center gap-2">{toolbar}</div>}
        </div>

        {/* Contenu sp√©cifique √† la page */}
        {children}
      </div>
    </>
  );
}
```

**R√®gles associ√©es :**

* ‚úÖ **Toujours** utiliser `<KeenPage>` pour les pages KeenKonnect (sauf cas ultra-sp√©ciaux).
* ‚úÖ Titre **toujours** en `text-2xl font-bold`, pas de `Typography.Title level={1}` ou `level={2}` diff√©rents selon les pages.
* ‚úÖ Padding global **toujours** `className="container mx-auto p-5"`.
* ‚úÖ Toolbar (boutons √† droite du titre) passe par la prop `toolbar`.
* üö´ **Pas** de breadcrumb local dans les pages (le layout du haut s‚Äôen charge).
* üö´ **Pas** de `margin-top` √©norme ou de `padding` custom sur le container : tout doit se faire √† l‚Äôint√©rieur du contenu via des `Card`, `Row`, etc.

---

## 2. Page de r√©f√©rence (mod√®le √† recopier)

Ta page `search-filter-documents` est globalement le bon ¬´ look ¬ª.
Voici la version **r√©f√©renc√©e** qui l‚Äôutilise via `<KeenPage>` :

```tsx
'use client';

import React from 'react';
import { Card, Alert } from 'antd';
import type { PaginationProps } from 'antd';
import {
  ProTable,
  QueryFilter,
  ProFormText,
  ProFormSelect,
  ProFormDateRangePicker,
} from '@ant-design/pro-components';
import KeenPage from '@/components/keenkonnect/KeenPage';

// ... types + donn√©es (DocumentResource, sampleDocuments, etc.)

export default function SearchFilterDocumentsPage(): JSX.Element {
  // ... state, filtres, useMemo, columns, paginationProps, etc.

  return (
    <KeenPage
      title="Search & Filter Documents"
      description="Advanced search and filtering for knowledge documents in KeenKonnect."
    >
      {/* Bloc filtres */}
      <Card className="mb-4">
        <QueryFilter
          onFinish={handleFilterFinish}
          onReset={handleFilterReset}
          labelWidth="auto"
          defaultCollapsed={false}
          span={8}
          initialValues={{ sort: DEFAULT_SORT }}
        >
          {/* ... champs de filtre */}
        </QueryFilter>
      </Card>

      {/* R√©sum√© + table */}
      <Alert /* ...props */ className="mb-4" />

      <Card>
        <ProTable
          /* ...props */
        />
        {/* Pagination externe */}
      </Card>
    </KeenPage>
  );
}
```

üëâ **C‚Äôest cette structure qu‚Äôil faut viser partout** :
`<KeenPage>` en haut, puis `Card`, `ProTable`, `StepsForm`, `Tabs`, etc. √† l‚Äôint√©rieur.

---

## 3. Que corriger, et o√π ? (central vs par page)

### 3.1. Ce qui se corrige **de mani√®re centrale**

En cr√©ant / imposant `<KeenPage>` tu centralises :

1. **Taille & style du titre**

   * `h1.text-2xl.font-bold` partout.
   * Plus de `Typography.Title` avec des niveaux diff√©rents.

2. **Padding & largeur**

   * Tout le monde utilise `container mx-auto p-5` avec le m√™me `maxWidth`.
   * Plus de pages full-bleed sans padding.

3. **Structure de base**

   * Header de page = m√™me layout : titre + description + toolbar √† droite.
   * Plus de pages o√π un bouton important flotte dans un coin sans alignement.

4. **Fil d‚ÄôAriane (breadcrumb)**

   * **Jamais** en local dans la page.
   * Si un jour on veut ajouter un breadcrumb global, on le fait dans le layout `app/keenkonnect/layout.tsx` uniquement.

R√©sultat : 80% des diff√©rences visuelles disparaissent juste en passant par `<KeenPage>`.

---

### 3.2. Ce qui doit √™tre fait **par page** (m√©canique mais simple)

Pour chaque page existante (exemples : `my-projects`, `create-new-project`, `document-management`, `track-project-impact`, etc.) :

#### 1. Remplacer le wrapper racine

**Avant (exemples actuels) :**

```tsx
<div style={{ maxWidth: 960, margin: '0 auto', padding: 24 }}>
  {/* ... */}
</div>
```

ou

```tsx
<div className="container mx-auto p-5">
  <h1 className="text-3xl font-semibold">Big Title</h1>
  {/* ... */}
</div>
```

ou

```tsx
<PageContainer
  header={{
    title: 'My Page',
    breadcrumb: { /* ... */ },
  }}
>
  {/* ... */}
</PageContainer>
```

**Apr√®s (mod√®le unique) :**

```tsx
import KeenPage from '@/components/keenkonnect/KeenPage';

export default function SomePage() {
  return (
    <KeenPage
      title="My Page"
      description="One-line description of what this page does."
      toolbar={(
        /* optionnel : boutons d‚Äôaction √† droite du titre */
      )}
    >
      {/* Ancien contenu, sans h1, sans Head, sans breadcrumb */}
    </KeenPage>
  );
}
```

> üîÅ **Important** :
>
> * Supprimer le `h1` local, `Typography.Title` principal, et les gros marges hautes ‚Äî c‚Äôest g√©r√© par KeenPage.
> * Si la page utilisait `PageContainer`, garder le contenu mais le mettre dans des `Card` ou `ProCard` √† l‚Äôint√©rieur de `<KeenPage>`.

#### 2. Supprimer les breadcumbs locaux

Tout ce qui ressemble √† :

```tsx
<Breadcrumb /* ... */ />
```

ou

```tsx
<PageContainer
  header={{
    breadcrumb: { /* ... */ },
  }}
/>
```

‚û°Ô∏è **√Ä supprimer**.
Breadcrumb = only via layout global (la ‚Äúupper bar‚Äù).

#### 3. Unifier les titres secondaires

√Ä l‚Äôint√©rieur des pages, pour les sous-sections, tu peux :

* soit utiliser `Card` avec `title="..."`,
* soit `h2` / `h3` tailwind (`text-lg font-semibold`, etc.) mais de fa√ßon coh√©rente :

Par ex :

```tsx
<h2 className="text-lg font-semibold mb-2">Team Settings</h2>
```

ou

```tsx
<Card title="Team Settings" className="mb-4">
  {/* ... */}
</Card>
```

---

## 4. Quels types de pages & comment les aligner

Tu peux inclure ce bloc dans ta doc pour guider l‚ÄôIA selon le type de page.

### 4.1. Pages ‚Äúform wizard‚Äù (StepsForm)

Ex : `create-new-project`, `submit-impact-reports`, `match-preferences`, etc.

**Pattern recommand√© :**

```tsx
<KeenPage
  title="Create New Project"
  description="Use this guided wizard to describe your project and configure the team."
>
  <Card>
    <StepsForm
      onFinish={...}
      formProps={{ layout: 'vertical' }}
      submitter={{
        // pas de nextText/prevText custom si le type ne le supporte pas
      }}
    >
      {/* StepForm ... */}
    </StepsForm>
  </Card>
</KeenPage>
```

**Checklist :**

* Pas de marge/padding custom autour du `Card`.
* StepForm toujours dans un `Card` (ou deux si besoin).
* Titre principal g√©r√© par `<KeenPage>`.

---

### 4.2. Pages ‚Äútableau & filtres‚Äù (list, ProTable)

Ex :
`knowledge/search-filter-documents` (r√©f√©rence), `projects/my-projects`, `workspaces/my-workspaces`, `knowledge/document-management`.

**Pattern recommand√© :**

```tsx
<KeenPage
  title="My Projects"
  description="Browse and manage your KeenKonnect projects."
  toolbar={(
    <Button type="primary">New project</Button>
  )}
>
  <Card className="mb-4">
    {/* Filtres / QueryFilter / search bar */}
  </Card>

  <Card>
    <ProTable /* ... */ />
  </Card>
</KeenPage>
```

---

### 4.3. Pages ‚Äúdashboard / analytics‚Äù

Ex :
`sustainability-impact/sustainability-dashboard`, `track-project-impact`.

M√™me base, mais tu joues avec `Row`/`Col` + `Card`/`ProCard` :

```tsx
<KeenPage
  title="Sustainability Impact Dashboard"
  description="High-level dashboard aggregating sustainability impact across projects."
>
  <Row gutter={[16, 16]}>
    <Col xs={24} md={12}>
      <Card title="CO‚ÇÇ saved">
        {/* Graph / KPI */}
      </Card>
    </Col>
    {/* ... */}
  </Row>
</KeenPage>
```

---

## 5. R√©ponse directe √† tes questions

> **‚Äúwhat fix is needed for each page? is this a central fix, or a fix per page?‚Äù**

* **Central** :

  * Cr√©er `<KeenPage>` et l‚Äôadopter comme **obligatoire** pour toutes les pages KeenKonnect.
  * Imposer les r√®gles :

    * `container mx-auto p-5`
    * `h1.text-2xl.font-bold`
    * description en `text-gray-500`
    * toolbar √† droite via prop
    * **aucun breadcrumb local**.

* **Par page (mais m√©canique)** :

  * Remplacer le wrapper racine par `<KeenPage>`.
  * Supprimer les `h1` / `Title` custom.
  * Supprimer les breadcrumbs locaux.
  * Remettre les contenus dans des `Card` / `Row` / `Col` avec marges coh√©rentes (`mb-4`, etc.).
  * Pour les pages qui utilisaient `PageContainer`, migrer le header dans les props de `<KeenPage>`.

> **‚Äúwhich page are ok (like search-filter-documents)‚Äù**

√Ä partir de ce qu‚Äôon a vu ensemble :

* ‚úÖ `knowledge/search-filter-documents`
  ‚Üí d√©j√† tr√®s proche du mod√®le. Il suffit juste √©ventuellement de le faire passer par `<KeenPage>` mais visuellement tu es d√©j√† dans le bon style.

* ‚ö†Ô∏è Les autres pages qu‚Äôon a modifi√©es (projects, workspaces, sustainability, etc.)
  ‚Üí doivent √™tre **align√©es** sur ce mod√®le en les enveloppant dans `<KeenPage>` et en supprimant :

  * leurs wrappers custom (`div` avec padding/margin),
  * leurs gros `Title` Ant Design,
  * leurs breadcrumbs locaux,
  * leurs variations de padding.

---

### TL;DR √† copier dans ton repo / Notion

* Cr√©er `components/keenkonnect/KeenPage.tsx` (code ci-dessus).
* Toute nouvelle page KeenKonnect = **obligatoirement** bas√©e sur `<KeenPage>`.
* Toute page existante = refactor pour utiliser `<KeenPage>` et supprimer les layouts locaux.

Si tu veux, ensuite, tu peux me coller le code d‚Äôune page ‚Äúmoche‚Äù et on la r√©√©crit ensemble 100% align√©e sur ce template.

===== END app/DOCHowtonest/keenkonnect.txt =====


===== BEGIN app/ekoh/achievements-badges/earned-badges-display/page.tsx =====
'use client';

import React, { useState, useMemo } from 'react';
import Head from 'next/head';
import { Card, List, Modal, Select, Row, Col, Typography, Empty, Divider } from 'antd';

const { Title, Text } = Typography;
const { Option } = Select;

interface Badge {
  id: string;
  name: string;
  icon: string;
  category: string;
  dateEarned: string;
  description: string;
}

const sampleBadges: Badge[] = [
  { id: '1', name: 'Top Contributor', icon: '/badges/top-contributor.png', category: 'Expertise', dateEarned: '2023-08-20', description: 'Awarded for exceptional contributions in discussions.' },
  { id: '2', name: 'Community Champion', icon: '/badges/community-champion.png', category: 'Community', dateEarned: '2023-07-15', description: 'Recognizes outstanding community engagement and support.' },
  { id: '3', name: 'Innovator', icon: '/badges/innovator.png', category: 'Innovation', dateEarned: '2023-06-10', description: 'Awarded for innovative ideas and solutions.' },
  { id: '4', name: 'Expert Reviewer', icon: '/badges/expert-reviewer.png', category: 'Expertise', dateEarned: '2023-05-22', description: 'Given to users providing insightful reviews.' },
  { id: '5', name: 'Active Participant', icon: '/badges/active-participant.png', category: 'Community', dateEarned: '2023-09-01', description: 'Recognizes consistent participation over time.' },
];

export default function EarnedBadgesDisplay() {
  const [filterCategory, setFilterCategory] = useState<string>('All');
  const [sortOrder, setSortOrder] = useState<string>('Newest');
  const [selectedBadge, setSelectedBadge] = useState<Badge | null>(null);
  const [modalVisible, setModalVisible] = useState<boolean>(false);

  const totalBadges = sampleBadges.length;
  const userLevel = totalBadges >= 5 ? 'Gold' : totalBadges >= 3 ? 'Silver' : 'Bronze';

  const displayedBadges = useMemo(() => {
    let badges = [...sampleBadges];
    if (filterCategory !== 'All') {
      badges = badges.filter((badge) => badge.category === filterCategory);
    }
    badges.sort((a, b) => {
      const dateA = new Date(a.dateEarned).getTime();
      const dateB = new Date(b.dateEarned).getTime();
      return sortOrder === 'Newest' ? dateB - dateA : dateA - dateB;
    });
    return badges;
  }, [filterCategory, sortOrder]);

  const showBadgeDetails = (badge: Badge) => {
    setSelectedBadge(badge);
    setModalVisible(true);
  };

  return (
    <>
      <Head>
        <title>Achievements & Badges</title>
        <meta
          name="description"
          content="View all your earned badges and achievements with filtering and detailed views."
        />
      </Head>

      <div className="container mx-auto p-5">
        <Title level={2}>Achievements & Badges</Title>
        <Divider />

        <Row gutter={16} className="mb-6">
          <Col xs={24} sm={12}>
            <Text strong>Total Badges:</Text> <Text>{totalBadges}</Text>
          </Col>
          <Col xs={24} sm={12}>
            <Text strong>Level:</Text> <Text>{userLevel}</Text>
          </Col>
        </Row>

        <Row gutter={[16, 16]} className="mb-6">
          <Col xs={24} sm={12}>
            <Text>Filter by Category:</Text>
            <Select defaultValue="All" style={{ width: '100%' }} onChange={(v) => setFilterCategory(v)}>
              <Option value="All">All</Option>
              <Option value="Expertise">Expertise</Option>
              <Option value="Community">Community</Option>
              <Option value="Innovation">Innovation</Option>
            </Select>
          </Col>
          <Col xs={24} sm={12}>
            <Text>Sort by Date Earned:</Text>
            <Select defaultValue="Newest" style={{ width: '100%' }} onChange={(v) => setSortOrder(v)}>
              <Option value="Newest">Newest</Option>
              <Option value="Oldest">Oldest</Option>
            </Select>
          </Col>
        </Row>

        {displayedBadges.length > 0 ? (
          <List
            grid={{ gutter: 16, xs: 1, sm: 2, md: 3, lg: 4, xl: 4 }}
            dataSource={displayedBadges ?? []}
            renderItem={(badge: Badge) => (
              <List.Item>
                <Card
                  hoverable
                  onClick={() => showBadgeDetails(badge)}
                  cover={
                    <img
                      alt={badge.name}
                      src={badge.icon}
                      style={{ padding: '10px', objectFit: 'contain', height: 120 }}
                    />
                  }
                >
                  <Card.Meta title={badge.name} description={badge.category} />
                </Card>
              </List.Item>
            )}
          />
        ) : (
          <Empty description="No badges earned yet." />
        )}

        <Modal
          title={selectedBadge?.name}
          open={modalVisible}
          onOk={() => setModalVisible(false)}
          onCancel={() => setModalVisible(false)}
          footer={null}
        >
          {selectedBadge && (
            <div>
              <img
                alt={selectedBadge.name}
                src={selectedBadge.icon}
                style={{ width: '100%', maxHeight: 150, objectFit: 'contain', marginBottom: 16 }}
              />
              <p>
                <strong>Description:</strong> {selectedBadge.description}
              </p>
              <p>
                <strong>Date Earned:</strong> {selectedBadge.dateEarned}
              </p>
            </div>
          )}
        </Modal>
      </div>
    </>
  );
}

===== END app/ekoh/achievements-badges/earned-badges-display/page.tsx =====


===== BEGIN app/ekoh/dashboard/page.tsx =====
'use client'

// pages/ekoh/dashboard/index.tsx
import React, { useState, useEffect } from 'react';
import Head from 'next/head';
import type { NextPage } from 'next';
import { Card, Statistic, Row, Col, Tabs } from 'antd';
import MainLayout from '@/components/layout-components/MainLayout';
import LineChart from '@/components/dashboard-components/LineChart';

const { TabPane } = Tabs;

const EkohDashboard = () => {
  // √âtats simulant des donn√©es utilisateur
  const [ekohScore, setEkohScore] = useState<number>(80);
  const [smartVoteWeight, setSmartVoteWeight] = useState<number>(70);
  const [badgesEarned, setBadgesEarned] = useState<number>(12);

  // Donn√©es pour le graphique de tendance (Ekoh score over time)
  const [trendData, setTrendData] = useState<Array<{ time: string; score: number }>>([
    { time: '08:00', score: 70 },
    { time: '10:00', score: 72 },
    { time: '12:00', score: 75 },
    { time: '14:00', score: 78 },
    { time: '16:00', score: 80 },
    { time: '18:00', score: 82 },
    { time: '20:00', score: 80 },
  ]);

  // Notable achievements et recent contributions (donn√©es simul√©es)
  const notableAchievements = [
    'Reached Expert Level 5',
    'Highest vote weight: 78%',
    'Awarded "Community Champion" badge',
  ];
  const recentContributions = [
    'Voted on Economic Reform Proposal',
    'Commented on Climate Policy Debate',
    'Shared article on Smart Voting Impact',
  ];

  // Simulation d'actualisation du graphique (optionnelle)
  useEffect(() => {
    const interval = setInterval(() => {
      // Simuler une mise √† jour du score en ajoutant un nouveau point et en conservant les 7 derniers points
      const newTime = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const newScore = 70 + Math.floor(Math.random() * 20);
      setTrendData(prev => [...prev.slice(-6), { time: newTime, score: newScore }]);
    }, 5000);
    return () => clearInterval(interval);
  }, []);

  return (
    <>
      <Head>
        <title>Ekoh Dashboard</title>
        <meta name="description" content="Overview of your reputation and influence in the Ekoh system." />
      </Head>
      <div className="container mx-auto p-5">
        {/* En-t√™te de la page */}
        <h1 className="text-2xl font-bold mb-4">Ekoh Dashboard</h1>

        {/* Overview cards */}
        <Row gutter={16} className="mb-6">
          <Col xs={24} sm={8}>
            <Card>
              <Statistic title="Ekoh Score" value={ekohScore} suffix="pts" />
            </Card>
          </Col>
          <Col xs={24} sm={8}>
            <Card>
              <Statistic title="Smart Vote Weight" value={smartVoteWeight} suffix="%" />
            </Card>
          </Col>
          <Col xs={24} sm={8}>
            <Card>
              <Statistic title="Badges Earned" value={badgesEarned} />
            </Card>
          </Col>
        </Row>

        {/* Reputation trend chart */}
        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-2">Reputation Trend Over Time</h2>
          {/* On transforme les donn√©es pour que le composant LineChart attende {time, value} */}
          <LineChart data={trendData.map(item => ({ time: item.time, value: item.score }))} />
        </Card>

        {/* Onglets pour les vues approfondies */}
        <Card className="mb-6">
          <Tabs defaultActiveKey="overview">
            <TabPane tab="Overview" key="overview">
              <p>This section provides an overall summary of your reputation, voting influence, expertise, and badges.</p>
            </TabPane>
            <TabPane tab="Voting Influence" key="votingInfluence">
              <p>Detailed view on your Smart Vote weight and how it affects overall decisions.</p>
            </TabPane>
            <TabPane tab="Expertise" key="expertise">
              <p>Breakdown of your expertise areas and performance therein.</p>
            </TabPane>
            <TabPane tab="Badges" key="badges">
              <p>Review your earned badges and achievements in detail.</p>
            </TabPane>
          </Tabs>
        </Card>

        {/* Achievements & Recent Contributions */}
        <Row gutter={16}>
          <Col xs={24} md={12}>
            <Card title="Notable Achievements" className="mb-6">
              <ul>
                {notableAchievements.map((achievement, index) => (
                  <li key={index}>{achievement}</li>
                ))}
              </ul>
            </Card>
          </Col>
          <Col xs={24} md={12}>
            <Card title="Recent Contributions" className="mb-6">
              <ul>
                {recentContributions.map((contribution, index) => (
                  <li key={index}>{contribution}</li>
                ))}
              </ul>
            </Card>
          </Col>
        </Row>
      </div>
    </>
  );
}

export default EkohDashboard;

===== END app/ekoh/dashboard/page.tsx =====


===== BEGIN app/ekoh/EkohPageShell.tsx =====
// app/ekoh/EkohPageShell.tsx
'use client';

import React, { ReactNode } from 'react';
import { Typography, Space } from 'antd';

const { Title, Paragraph } = Typography;

export type EkohPageShellProps = {
  /** Main page title (big, H1-equivalent) */
  title: string;
  /** Optional subtitle / helper text under the title */
  subtitle?: ReactNode;
  /** Main CTA on the right (e.g. primary button) */
  primaryAction?: ReactNode;
  /** Secondary actions on the right (e.g. ghost buttons, filters) */
  secondaryActions?: ReactNode;
  /** Main page content */
  children: ReactNode;
};

/**
 * Central layout wrapper for Ekoh pages.
 *
 * Usage rules:
 * - No extra big <h1> / Title outside of this shell in your pages.
 * - No breadcrumb here (rely on the global layout / shell).
 * - All Ekoh pages should use this for consistent padding & header.
 */
function EkohPageShell({
  title,
  subtitle,
  primaryAction,
  secondaryActions,
  children,
}: EkohPageShellProps): JSX.Element {
  const hasActions = Boolean(primaryAction || secondaryActions);

  return (
    <div className="container mx-auto p-5">
      {/* Header: title + subtitle + actions */}
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div className="min-w-0">
          <Title level={2} className="!mb-1">
            {title}
          </Title>
          {subtitle && (
            <Paragraph type="secondary" className="!mb-0">
              {subtitle}
            </Paragraph>
          )}
        </div>

        {hasActions && (
          <Space wrap>
            {secondaryActions}
            {primaryAction}
          </Space>
        )}
      </div>

      {/* Main content */}
      {children}
    </div>
  );
}

export default EkohPageShell;

===== END app/ekoh/EkohPageShell.tsx =====


===== BEGIN app/ekoh/expertise-areas/view-current-expertise/page.tsx =====
'use client'

// pages/ekoh/expertise-areas/view-current-expertise/index.tsx
import React from 'react';
import Head from 'next/head';
import type { NextPage } from 'next';
import { Card, List, Progress, Tag, Typography } from 'antd';
import MainLayout from '@/components/layout-components/MainLayout';

const { Title } = Typography;

// Exemple de donn√©es simul√©es pour l'expertise de l'utilisateur
interface Expertise {
  id: string;
  domain: string;
  proficiency: number; // en pourcentage
  contributions: number;
  lastUpdated: string; // format ISO ou date format√©e
}

const expertiseData: Expertise[] = [
  {
    id: '1',
    domain: 'Economy',
    proficiency: 80,
    contributions: 45,
    lastUpdated: '2023-08-28',
  },
  {
    id: '2',
    domain: 'Politics',
    proficiency: 65,
    contributions: 30,
    lastUpdated: '2023-08-25',
  },
  {
    id: '3',
    domain: 'Technology',
    proficiency: 75,
    contributions: 38,
    lastUpdated: '2023-08-27',
  },
];

const ViewCurrentExpertise = () => {
  return (
    <>
      <Head>
        <title>Expertise Areas</title>
        <meta
          name="description"
          content="View your recognized expertise areas along with proficiency levels and contribution details."
        />
      </Head>
      <div className="container mx-auto p-5">
        {/* En-t√™te de la page */}
        <Title level={2}>Expertise Areas</Title>

        {/* Liste des domaines d'expertise */}
        <Card className="mb-6">
          <List
            itemLayout="vertical"
            dataSource={expertiseData ?? []}
            renderItem={(item) => (
              <List.Item key={item.id}>
                <List.Item.Meta
                  title={
                    <span>
                      {item.domain}{' '}
                      <Tag color="blue">Proficiency: {item.proficiency}%</Tag>
                    </span>
                  }
                  description={
                    <span>
                      Contributions: {item.contributions} | Last Updated: {item.lastUpdated}
                    </span>
                  }
                />
                <Progress percent={item.proficiency} status="active" />
              </List.Item>
            )}
          />
        </Card>
      </div>
    </>
  );
}

export default ViewCurrentExpertise;

===== END app/ekoh/expertise-areas/view-current-expertise/page.tsx =====


===== BEGIN app/ekoh/layout.tsx =====
import React, { Suspense } from 'react'
import MainLayout from '@/components/layout-components/MainLayout'

export default function SegmentLayout({ children }: { children: React.ReactNode }) {
  return (
    <Suspense fallback={null}>
      <MainLayout>{children}</MainLayout>
    </Suspense>
  )
}
===== END app/ekoh/layout.tsx =====


===== BEGIN app/ekoh/overview-analytics/current-ekoh-score/page.tsx =====
'use client'

import React, { useState, useEffect } from 'react'
import Head from 'next/head'
import type { NextPage } from 'next'
import { Card, Alert, Timeline, Table } from 'antd'
import MainLayout from '@/components/layout-components/MainLayout'
import {
  PieChart as RePieChart,
  Pie,
  Cell,
  Legend,
  Tooltip as ReTooltip,
  ResponsiveContainer,
  LineChart as ReLineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
} from 'recharts'

const COLORS = ['#0088FE', '#00C49F', '#FFBB28']

type Point = { date: string; score: number }

const CurrentEkohScore = () => {
  const [pieData] = useState([
    { name: 'Expertise', value: 40 },
    { name: 'Community Feedback', value: 35 },
    { name: 'Ethics', value: 25 },
  ])

  const [trendData, setTrendData] = useState<Point[]>([
    { date: '2023-08-01', score: 60 },
    { date: '2023-08-02', score: 62 },
    { date: '2023-08-03', score: 65 },
    { date: '2023-08-04', score: 67 },
    { date: '2023-08-05', score: 70 },
    { date: '2023-08-06', score: 72 },
    { date: '2023-08-07', score: 75 },
  ])

  const timelineData = [
    { key: '1', time: '2023-08-02', event: 'Achieved Expert Level 3' },
    { key: '2', time: '2023-08-04', event: 'Received high community feedback' },
    { key: '3', time: '2023-08-06', event: 'Ethics audit improved rating' },
  ]

  const tableColumns = [
    { title: 'Date', dataIndex: 'date', key: 'date' },
    { title: 'Contribution Detail', dataIndex: 'detail', key: 'detail' },
  ]

  const tableData = [
    { key: '1', date: '2023-08-02', detail: 'Expert review added +4 points' },
    { key: '2', date: '2023-08-04', detail: 'Community vote increased score by +3 points' },
    { key: '3', date: '2023-08-06', detail: 'Ethics audit contributed +2 points' },
  ]

  useEffect(() => {
    const tick = () => {
      const datePart = new Date().toLocaleDateString('en-CA') // "YYYY-MM-DD"
      const newScore = 60 + Math.floor(Math.random() * 20)

      setTrendData(prev => {
        const last = prev.slice(-7)
        const existingIndex = last.findIndex(p => p.date === datePart)

        if (existingIndex >= 0) {
          // √âvite Point | undefined: pas d‚Äôindexation, on map
          return last.map((p, i) => (i === existingIndex ? { date: p.date, score: newScore } : p))
        }

        return [...prev.slice(-6), { date: datePart, score: newScore }]
      })
    }

    tick()
    const id = setInterval(tick, 5000)
    return () => clearInterval(id)
  }, [])

  return (
    <>
      <Head>
        <title>Current Ekoh Score ‚Äì Overview & Analytics</title>
        <meta name="description" content="Detailed breakdown of your Ekoh score with charts, timeline, and evaluation details." />
      </Head>
      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-4">Current Ekoh Score ‚Äì Overview & Analytics</h1>

        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-4">Score Breakdown</h2>
          <div style={{ width: '100%', height: 300 }}>
            <ResponsiveContainer>
              <RePieChart>
                <ReTooltip />
                <Legend verticalAlign="bottom" height={36} />
                <Pie data={pieData} cx="50%" cy="50%" innerRadius={60} outerRadius={100} dataKey="value" paddingAngle={5}>
                  {pieData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
              </RePieChart>
            </ResponsiveContainer>
          </div>
        </Card>

        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-4">Historical Trend</h2>
          <div style={{ width: '100%', height: 250 }}>
            <ResponsiveContainer>
              <ReLineChart data={trendData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <ReTooltip />
                <Line type="monotone" dataKey="score" stroke="#82ca9d" />
              </ReLineChart>
            </ResponsiveContainer>
          </div>
        </Card>

        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-4">Key Events Influencing Your Score</h2>
          <Timeline>
            {timelineData.map(item => (
              <Timeline.Item key={item.key}>
                <strong>{item.time}</strong> - {item.event}
              </Timeline.Item>
            ))}
          </Timeline>
        </Card>

        <Card className="mb-6">
          <h2 className="text-xl font-semibold mb-4">How Your Score is Calculated</h2>
          <Alert
            message="Score Calculation Explained"
            description="Your Ekoh score is derived from a weighted combination of your expertise level, community feedback, and ethical evaluations. This transparent approach ensures that every contribution is fairly recognized."
            type="info"
            showIcon
          />
        </Card>

        <Card>
          <h2 className="text-xl font-semibold mb-4">Recent Evaluations Impacting Your Score</h2>
          <Table columns={tableColumns} dataSource={tableData} pagination={false} />
        </Card>
      </div>
    </>
  )
}



export default CurrentEkohScore

===== END app/ekoh/overview-analytics/current-ekoh-score/page.tsx =====


===== BEGIN app/ekoh/voting-influence/current-voting-weight/page.tsx =====
'use client';

import React from 'react';
import { Card, Statistic, Row, Col, Typography, List } from 'antd';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from 'recharts';

const { Title, Paragraph } = Typography;

// Simulated data for the comparison chart
const weightComparisonData: { category: string; weight: number }[] = [
  { category: 'Your Weight', weight: 70 },
  { category: 'Average Weight', weight: 50 },
  { category: 'Top Experts', weight: 90 },
];

// Simulated data for high-weight domains
const weightByDomain: { domain: string; weight: string }[] = [
  { domain: 'Economy', weight: '80%' },
  { domain: 'Politics', weight: '65%' },
  { domain: 'Technology', weight: '75%' },
];

export default function CurrentVotingWeightPage() {
  // Example: user's smart voting weight (percent)
  const smartVoteWeight = 70;

  return (
    <div className="container mx-auto p-5">
      {/* Page header */}
      <Title level={2}>Current Voting Weight</Title>

      {/* Prominent current weight */}
      <Card className="mb-6">
        <Row justify="center">
          <Col>
            <Statistic title="Smart Vote Weight" value={smartVoteWeight} suffix="%" />
          </Col>
        </Row>
      </Card>

      {/* Explanation */}
      <Card className="mb-6">
        <Paragraph>
          Your Smart Vote weight represents your relative influence in collective
          decisions based on your Ekoh reputation. A higher percentage means your
          vote carries more weight compared to the average user.
        </Paragraph>
      </Card>

      {/* Comparison chart */}
      <Card className="mb-6">
        <Title level={4}>Comparison with Others</Title>
        <div style={{ width: '100%', height: 300 }}>
          <ResponsiveContainer>
            <BarChart data={weightComparisonData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="category" />
              <YAxis domain={[0, 100]} />
              <Tooltip />
              <Bar dataKey="weight" fill="#82ca9d" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </Card>

      {/* High-weight domains */}
      <Card className="mb-6">
        <Title level={4}>Highest Weight by Domain</Title>
        <List
          dataSource={weightByDomain}
          renderItem={(item) => (
            <List.Item>
              <strong>{item.domain}:</strong>&nbsp;{item.weight}
            </List.Item>
          )}
        />
      </Card>
    </div>
  );
}

===== END app/ekoh/voting-influence/current-voting-weight/page.tsx =====


===== BEGIN app/ethikos/admin/audit/page.tsx =====
'use client';

import React from 'react';
import { PageContainer, ProTable, type ProColumns } from '@ant-design/pro-components';
import { Tag } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchAuditLogs } from '@/services/admin';

type LogRow = {
  id: string;
  actor: string;
  action: string;
  target: string;
  severity: 'info' | 'warn' | 'critical';
  ts: string; // ISO
};

type AuditPayload = { items: LogRow[] };

export default function AuditLogs(): JSX.Element {
  usePageTitle('Admin ¬∑ Audit Logs');

  const service = async (): Promise<AuditPayload> => {
    const res = await fetchAuditLogs();
    return res as AuditPayload;
  };

  // Note: ahooks' useRequest generics are <Data, Params>
  const { data, loading } = useRequest<AuditPayload, []>(service);

  const columns: ProColumns<LogRow>[] = [
    {
      title: 'Time',
      dataIndex: 'ts',
      valueType: 'dateTime' as const, // keep literal, avoid widening to string
      width: 180,
      sorter: true,
    },
    { title: 'Actor', dataIndex: 'actor', width: 120 },
    { title: 'Action', dataIndex: 'action', width: 200 },
    { title: 'Target', dataIndex: 'target', ellipsis: true },
    {
      title: 'Severity',
      dataIndex: 'severity',
      width: 120,
      filters: [
        { text: 'Info', value: 'info' },
        { text: 'Warn', value: 'warn' },
        { text: 'Critical', value: 'critical' },
      ],
      onFilter: (value, record) =>
        record.severity === (String(value) as LogRow['severity']),
      render: (_: React.ReactNode, record: LogRow) => (
        <Tag
          color={
            record.severity === 'critical'
              ? 'red'
              : record.severity === 'warn'
              ? 'orange'
              : 'blue'
          }
        >
          {record.severity}
        </Tag>
      ),
    },
  ];

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<LogRow>
        rowKey="id"
        columns={columns}
        dataSource={data?.items ?? []}
        pagination={{ pageSize: 15 }}
        search={false}
      />
    </PageContainer>
  );
}

===== END app/ethikos/admin/audit/page.tsx =====


===== BEGIN app/ethikos/admin/moderation/page.tsx =====
'use client'

import { PageContainer, ProTable } from '@ant-design/pro-components'
import type { ProColumns } from '@ant-design/pro-components'
import { Tag, Popconfirm, Button } from 'antd'
import { useRequest } from 'ahooks'
import usePageTitle from '@/hooks/usePageTitle'
import { fetchModerationQueue, actOnReport } from '@/services/admin'

type Report = {
  id: string
  content: string
  reporter: string
  type: 'Spam' | 'Harassment' | 'Misinformation'
  status: 'Pending' | 'Resolved'
}

type ModerationPayload = { items: Report[] }

export default function Moderation() {
  usePageTitle('Admin ¬∑ Moderation')

  const { data, loading, refresh } = useRequest<ModerationPayload, []>(
    () => fetchModerationQueue() as Promise<ModerationPayload>
  )

  const handleModeration = async (id: string, approve: boolean) => {
    await actOnReport(id, approve)
    refresh()
  }

  const columns: ProColumns<Report>[] = [
    { title: 'Content', dataIndex: 'content', ellipsis: true },
    { title: 'Reporter', dataIndex: 'reporter', width: 120 },
    {
      title: 'Type',
      dataIndex: 'type',
      width: 140,
      render: (_, row) => <Tag color="orange">{row.type}</Tag>,
      filters: [
        { text: 'Spam', value: 'Spam' },
        { text: 'Harassment', value: 'Harassment' },
        { text: 'Misinformation', value: 'Misinformation' },
      ],
      onFilter: (val, row) => row.type === (val as Report['type']),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      width: 120,
      render: (_, row) => (
        <Tag color={row.status === 'Pending' ? 'gold' : 'green'}>{row.status}</Tag>
      ),
      filters: [
        { text: 'Pending', value: 'Pending' },
        { text: 'Resolved', value: 'Resolved' },
      ],
      onFilter: (val, row) => row.status === (val as Report['status']),
    },
    {
      title: 'Actions',
      width: 180,
      render: (_, row) =>
        row.status === 'Pending' ? (
          <>
            <Popconfirm title="Remove content?" onConfirm={() => handleModeration(row.id, true)}>
              <Button size="small" danger>Remove</Button>
            </Popconfirm>
            <Popconfirm title="Dismiss report?" onConfirm={() => handleModeration(row.id, false)}>
              <Button size="small" style={{ marginLeft: 8 }}>Dismiss</Button>
            </Popconfirm>
          </>
        ) : null,
    },
  ]

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<Report>
        rowKey="id"
        columns={columns}
        dataSource={data?.items ?? []}
        pagination={{ pageSize: 10 }}
        search={false}
      />
    </PageContainer>
  )
}

===== END app/ethikos/admin/moderation/page.tsx =====


===== BEGIN app/ethikos/admin/roles/page.tsx =====
'use client'

import type { ReactNode } from 'react'
import { PageContainer, ProTable } from '@ant-design/pro-components'
import type { ProColumns } from '@ant-design/pro-components'
import { Switch, Tag } from 'antd'
import { useRequest } from 'ahooks'
import usePageTitle from '@/hooks/usePageTitle'
import { fetchRoles, toggleRole } from '@/services/admin'

type RoleRow = { id: string; name: string; userCount: number; enabled: boolean }
type RolePayload = { items: RoleRow[] }

export default function RoleManagement() {
  usePageTitle('Admin ¬∑ Role Management') // sets <title> on the client :contentReference[oaicite:3]{index=3}

  // useRequest: data shape is { items: RoleRow[] }; no params ‚Üí params tuple is []
  const { data, loading, refresh } = useRequest<RolePayload, []>(fetchRoles) // :contentReference[oaicite:4]{index=4}

  const columns: ProColumns<RoleRow>[] = [
    { title: 'Role', dataIndex: 'name', width: 200 },
    {
      title: 'Users',
      dataIndex: 'userCount',
      width: 100,
      render: (dom: ReactNode) => <Tag>{dom}</Tag>, // avoid implicit any
    },
    {
      title: 'Enabled',
      dataIndex: 'enabled',
      width: 120,
      render: (_: ReactNode, row: RoleRow) => (
        <Switch
          checked={row.enabled}
          onChange={async (checked) => {
            await toggleRole(row.id, checked) // PATCH /admin/roles/:id { enabled } :contentReference[oaicite:5]{index=5}
            refresh()
          }}
        />
      ),
    },
  ]

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<RoleRow>
        rowKey="id"
        columns={columns}
        dataSource={data?.items ?? []}
        pagination={false}
        search={false}
      />
    </PageContainer>
  )
}

===== END app/ethikos/admin/roles/page.tsx =====


===== BEGIN app/ethikos/decide/elite/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\ethikos\decide\elite\page.tsx
'use client'

import { PageContainer, ProTable } from '@ant-design/pro-components'
import type { ProColumns } from '@ant-design/pro-components'
import type { ReactNode } from 'react'
import { Progress, Statistic } from 'antd'
import { useRequest } from 'ahooks'
import dayjs from 'dayjs'
import usePageTitle from '@/hooks/usePageTitle'
import { fetchEliteBallots } from '@/services/decide'
import type { Ballot } from '@/types'

type Row = Ballot & { turnout: number }

export default function EliteBallots() {
  usePageTitle('Decide ¬∑ Elite Ballots')

  // ahooks v3 expects two generics: <TData, TParams>. No params ‚Üí [].
  const { data, loading } = useRequest<{ ballots: Row[] }, []>(fetchEliteBallots)

  const columns: ProColumns<Row>[] = [
    { title: 'Title', dataIndex: 'title', width: 260 },
    {
      title: 'Closes In',
      dataIndex: 'closesAt',
      width: 180,
      render: (_dom: ReactNode, row: Row) => (
        <Statistic.Countdown value={dayjs(row.closesAt).valueOf()} format="D[d] HH:mm:ss" />
      ),
    },
    {
      title: 'Turnout',
      dataIndex: 'turnout',
      width: 160,
      render: (_dom: ReactNode, row: Row) => <Progress type="circle" percent={row.turnout} />,
    },
    { title: 'Scope', dataIndex: 'scope', width: 100 },
  ]

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<Row>
        rowKey="id"
        columns={columns}
        dataSource={data?.ballots ?? []}
        pagination={{ pageSize: 8 }}
        search={false}
      />
    </PageContainer>
  )
}

===== END app/ethikos/decide/elite/page.tsx =====


===== BEGIN app/ethikos/decide/methodology/page.tsx =====
'use client'

import { PageContainer } from '@ant-design/pro-components';
import { Typography, Collapse, Steps, Alert } from 'antd';
import usePageTitle from '@/hooks/usePageTitle';

export default function Methodology() {
  usePageTitle('Decide ¬∑ Methodology');

  return (
    <PageContainer ghost>
      <Typography.Title>How We Count Votes</Typography.Title>

      <Collapse
        items={[
          {
            key: 'weighting',
            label: '1 ¬∑ Stake-weighted counting',
            children: (
              <Typography.Paragraph>
                Each ballot is tallied with quadratic weighting to dampen plutocratic influence‚Ä¶
              </Typography.Paragraph>
            ),
          },
          {
            key: 'verification',
            label: '2 ¬∑ Identity verification',
            children: (
              <Typography.Paragraph>
                Voters authenticate via the Desjardins meritocratic ID layer‚Ä¶
              </Typography.Paragraph>
            ),
          },
        ]}
      />

      <Steps
        current={3}
        items={[
          { title: 'Propose' },
          { title: 'Deliberate' },
          { title: 'Vote' },
          { title: 'Audit' },
        ]}
        style={{ marginTop: 40 }}
      />

      <Alert
        type="info"
        message="Open data"
        description="Raw ballots are published (SHA-256 hashed) after a 72-hour cooling-off period."
        showIcon
        style={{ marginTop: 24 }}
      />
    </PageContainer>
  );
}

===== END app/ethikos/decide/methodology/page.tsx =====


===== BEGIN app/ethikos/decide/public/page.tsx =====
// app/ethikos/decide/public/page.tsx
'use client';

import React, { useCallback, useEffect, useMemo, useState } from 'react';
import axios from 'axios';
import { PageContainer, ProTable } from '@ant-design/pro-components';
import type { ProColumns } from '@ant-design/pro-components';
import { Select, Space, Input, Progress, Radio, Slider, message } from 'antd';
import type { RadioChangeEvent } from 'antd';
import usePageTitle from '@/hooks/usePageTitle';

type Format = 'SINGLE' | 'MULTIPLE' | 'SCALE';

export interface PublicTopic {
  id: string | number;
  question: string;
  category: string;
  responseformat_id: number; // 1 = binary, 2 = multiple, 3 = scale
  options?: string[];        // SINGLE/MULTIPLE
  labels?: string[];         // SCALE
  turnout?: number;          // 0..100
}

interface PagedResult<T> {
  results: T[];
  count: number;
}

export default function PublicVotePage(): JSX.Element {
  usePageTitle('D√©cider ‚Äî Public');

  // --- UI state ---
  const [page, setPage] = useState<number>(1);
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [activeCat, setActiveCat] = useState<string | undefined>(undefined);

  // --- data ---
  const [categories, setCategories] = useState<string[]>([]);
  const [topicsData, setTopicsData] = useState<PagedResult<PublicTopic> | null>(null);
  const [loading, setLoading] = useState<boolean>(false);

  // Load category filter values
  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const catsRes = await axios.get<string[]>('/api/home/categories/');
        if (!mounted) return;
        setCategories(Array.isArray(catsRes.data) ? catsRes.data : []);
      } catch (e) {
        console.warn('Failed to load categories', e);
      }
    })();
    return () => {
      mounted = false;
    };
  }, []);

  // Fetch topics list
  const fetchTopics = useCallback(async () => {
    setLoading(true);
    try {
      const res = await axios.get<PagedResult<PublicTopic>>('/api/home/debatetopic/', {
        params: {
          page,
          q: searchTerm || undefined,
          cat: activeCat || undefined,
        },
      });
      setTopicsData(res.data);
    } catch (e) {
      message.error("√âchec du chargement des sujets.");
    } finally {
      setLoading(false);
    }
  }, [activeCat, page, searchTerm]);

  useEffect(() => {
    fetchTopics();
  }, [fetchTopics]);

  // Submit a vote (adapt the endpoint as needed)
  const submitVote = useCallback(
    async (topic: PublicTopic, value: string | string[] | number) => {
      try {
        await axios.post(`/api/home/debatetopic/${topic.id}/vote`, { value });
        message.success('Vote enregistr√©');
        fetchTopics(); // refresh after voting
      } catch {
        message.error("Impossible d'enregistrer le vote");
      }
    },
    [fetchTopics]
  );

  /**
   * Per-topic vote UI:
   * - SCALE: Slider with labeled marks (no unsafe array indexing)
   * - MULTIPLE: Select[multiple]
   * - SINGLE / default: Radio group
   */
  const renderVoteInput = useCallback(
    (topic: PublicTopic) => {
      // 3: scale
      if (topic.responseformat_id === 3) {
        const labels = topic.labels ?? topic.options ?? [];
        const marks = labels.reduce<Record<number, React.ReactNode>>((acc, label, i) => {
          acc[i] = label;
          return acc;
        }, {});
        const max = Math.max(0, labels.length - 1);
        const onAfterChange = (value: number | [number, number]) => {
          const v = Array.isArray(value) ? value[0] : value;
          submitVote(topic, v);
        };
        return (
          <Slider
            marks={marks}
            min={0}
            max={max}
            defaultValue={Math.round(max / 2)}
            onAfterChange={onAfterChange}
          />
        );
      }

      // 2: multiple
      if (topic.responseformat_id === 2) {
        const opts = topic.options ?? topic.labels ?? [];
        const onChange = (value: string[]) => submitVote(topic, value);
        return (
          <Select
            mode="multiple"
            placeholder="S√©lectionnez‚Ä¶"
            style={{ minWidth: 220 }}
            onChange={onChange}
            options={opts.map((o) => ({ label: o, value: o }))}
          />
        );
      }

      // 1: binary / single (default)
      const opts = topic.options ?? ['Oui', 'Non'];
      const onRadio: (e: RadioChangeEvent) => void = (e) => submitVote(topic, e.target.value as string);
      return (
        <Radio.Group onChange={onRadio}>
          {opts.map((o) => (
            <Radio key={o} value={o}>
              {o}
            </Radio>
          ))}
        </Radio.Group>
      );
    },
    [submitVote]
  );

  // Table columns (typed; ProTable v3 render signature respected)
  const columns: ProColumns<PublicTopic>[] = useMemo(
    () => [
      {
        title: 'Question',
        dataIndex: 'question',
        ellipsis: true,
        width: 360,
      },
      {
        title: 'Vote',
        key: 'vote',
        search: false,
        width: 360,
        render: (_dom, row) => renderVoteInput(row),
      },
      {
        title: 'Participation',
        dataIndex: 'turnout',
        align: 'center',
        width: 160,
        render: (_dom, row) => <Progress percent={row.turnout ?? 0} size="small" />,
      },
    ],
    [renderVoteInput]
  );

  return (
    <PageContainer
      ghost
      header={{ title: 'D√©cider (public)' }}
      content={
        <Space wrap style={{ marginBottom: 16 }}>
          <Select
            allowClear
            placeholder="Cat√©gorie"
            style={{ minWidth: 200 }}
            value={activeCat}
            onChange={(v) => setActiveCat(v || undefined)}
            options={categories.map((c) => ({ label: c, value: c }))}
          />
          <Input.Search
            allowClear
            placeholder="Recherche‚Ä¶"
            onSearch={(v) => {
              setPage(1);
              setSearchTerm(v);
            }}
            style={{ width: 260 }}
          />
        </Space>
      }
    >
      <ProTable<PublicTopic>
        rowKey="id"
        search={false}
        options={false}
        loading={loading}
        columns={columns}
        dataSource={topicsData?.results ?? []}
        pagination={{
          current: page,
          total: topicsData?.count ?? 0,
          showSizeChanger: false,
          onChange: (p) => setPage(p),
        }}
        toolBarRender={false}
      />
    </PageContainer>
  );
}

===== END app/ethikos/decide/public/page.tsx =====


===== BEGIN app/ethikos/decide/results/page.tsx =====
'use client';

import { PageContainer, ProTable, type ProColumns } from '@ant-design/pro-components';
import { Tag } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchDecisionResults } from '@/services/decide';

type ResultRow = {
  id: string;
  title: string;
  scope: 'Elite' | 'Public';
  passed: boolean;
  closesAt: string;
  region: string;
};

export default function ResultsArchive() {
  usePageTitle('Decide ¬∑ Results Archive');

  const { data, loading } = useRequest(fetchDecisionResults);

  // Note the second generic argument (`any`) so valueType isn't restricted to "text"
  const columns: ProColumns<ResultRow, any>[] = [
    { title: 'Title', dataIndex: 'title', width: 260 },
    {
      title: 'Result',
      dataIndex: 'passed',
      width: 120,
      // Avoid implicit-any by annotating both params
      render: (_: any, row: ResultRow) => (
        <Tag color={row.passed ? 'green' : 'red'}>{row.passed ? 'PASSED' : 'REJECTED'}</Tag>
      ),
      // Use boolean filter values to match the Table's onFilter type
      filters: [
        { text: 'Passed', value: true },
        { text: 'Rejected', value: false },
      ],
      // Keep the wider param type that AntD expects to avoid typing conflicts
      onFilter: (value: React.Key | boolean, row: ResultRow) => {
        const v = typeof value === 'boolean' ? value : String(value) === 'true';
        return row.passed === v;
      },
    },
    { title: 'Scope', dataIndex: 'scope', width: 120 },
    { title: 'Region', dataIndex: 'region', width: 140 },
    { title: 'Closed', dataIndex: 'closesAt', valueType: 'dateTime' },
  ];

  return (
    <PageContainer ghost loading={loading}>
      {/* Match ProTable's generics with the columns declaration */}
      <ProTable<ResultRow, any>
        rowKey="id"
        columns={columns}
        dataSource={data?.items ?? []}
        pagination={{ pageSize: 10 }}
        search={false}
      />
    </PageContainer>
  );
}

===== END app/ethikos/decide/results/page.tsx =====


===== BEGIN app/ethikos/deliberate/[topic]/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\ethikos\deliberate\[topic]\page.tsx
'use client';

import React from 'react';
import { PageContainer } from '@ant-design/pro-components';
import { Card, Empty, List, Typography } from 'antd';
import { Comment } from '@ant-design/compatible';
import { useParams } from 'next/navigation';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';

import usePageTitle from '@/hooks/usePageTitle';
import { fetchTopicPreview, type TopicPreviewResponse } from '@/services/deliberate';

dayjs.extend(relativeTime);

type Preview = TopicPreviewResponse;
type Statement = Preview['latest'][number];

export default function TopicThreadPage() {
  const params = useParams<{ topic: string }>();
  const topicParam = params?.topic;
  const topicId =
    typeof topicParam === 'string'
      ? topicParam
      : Array.isArray(topicParam)
      ? topicParam[0]
      : undefined;

  usePageTitle('Deliberate ¬∑ Thread');

  const { data, loading } = useRequest<Preview, []>(
    () => fetchTopicPreview(topicId!),
    {
      ready: !!topicId,
      refreshDeps: [topicId],
    },
  );

  const preview = data;

  return (
    <PageContainer ghost loading={loading}>
      {preview ? (
        <>
          <Typography.Title level={3} style={{ marginTop: 0 }}>
            {preview.title}
          </Typography.Title>
          <Typography.Paragraph type="secondary" style={{ marginBottom: 16 }}>
            {preview.category ? `${preview.category} ¬∑ ` : ''}
            {preview.createdAt ? dayjs(preview.createdAt).fromNow() : null}
          </Typography.Paragraph>

          <Card title="Latest statements" bordered={false} bodyStyle={{ padding: 0 }}>
            <List<Statement>
              itemLayout="horizontal"
              dataSource={preview.latest ?? []}
              locale={{ emptyText: <Empty description="No statements" /> }}
              renderItem={(s) => (
                <li key={s.id}>
                  <Comment
                    author={s.author}
                    content={<div style={{ whiteSpace: 'pre-wrap' }}>{s.body}</div>}
                  />
                </li>
              )}
              pagination={{ pageSize: 15, hideOnSinglePage: true }}
            />
          </Card>
        </>
      ) : (
        <Empty />
      )}
    </PageContainer>
  );
}

===== END app/ethikos/deliberate/[topic]/page.tsx =====


===== BEGIN app/ethikos/deliberate/elite/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\ethikos\deliberate\elite\page.tsx
'use client';

import React from 'react';
import {
  PageContainer,
  ProCard,
  ProTable,
  StatisticCard,
  ModalForm,
  ProFormText,
  ProFormSelect,
  type ProColumns,
} from '@ant-design/pro-components';
import { Button, Drawer, Empty, Space, Tag, Tooltip, message as antdMessage } from 'antd';
import { PlusOutlined, ReloadOutlined, FireOutlined } from '@ant-design/icons';
import { useRequest, useInterval } from 'ahooks';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';

import usePageTitle from '@/hooks/usePageTitle';
import { fetchEliteTopics, createEliteTopic, fetchTopicPreview } from '@/services/deliberate';
import type { Topic } from '@/types';

dayjs.extend(relativeTime);

/* ------------------------------------------------------------------ */
/*  Types                                                              */
/* ------------------------------------------------------------------ */

interface TopicRow extends Topic {
  createdAt: string;
  lastActivity: string;
  hot: boolean;         // calcul√© c√¥t√© serveur
  stanceCount: number;  // utilis√© par KPI et la colonne
}

type TopicPreview = {
  id: string;
  title: string;
  category: string;
  createdAt: string;
  latest: Array<{ id: string; author: string; body: string }>;
};

/* ------------------------------------------------------------------ */
/*  Service wrapper (type-safe)                                        */
/* ------------------------------------------------------------------ */

// Le service natif ne garantit pas `stanceCount`. On normalise ici pour
// faire correspondre exactement <{ list: TopicRow[] }, []>.
const useEliteService = () =>
  React.useCallback(async (): Promise<{ list: TopicRow[] }> => {
    const res = await fetchEliteTopics();
    const list = (res?.list ?? []).map((t: any) => ({
      ...t,
      stanceCount: typeof t.stanceCount === 'number' ? t.stanceCount : 0,
    })) as TopicRow[];
    return { list };
  }, []);

/* ------------------------------------------------------------------ */
/*  Composant principal                                                */
/* ------------------------------------------------------------------ */

export default function EliteAgora() {
  usePageTitle('Deliberate ¬∑ Elite Agora');

  /* ---------- data ---------- */
  const eliteService = useEliteService();
  // useRequest attend 2 g√©n√©riques <TData, TParams>. Le service n‚Äôa pas de params -> [].
  const { data, loading, refresh } = useRequest<{ list: TopicRow[] }, []>(eliteService);
  useInterval(refresh, 60_000); // polling 1 min

  /* ---------- drawer state ---------- */
  const [previewId, setPreviewId] = React.useState<string | null>(null);
  const {
    data: preview,
    loading: previewLoading,
    run: loadPreview,
  } = useRequest<TopicPreview, [string]>(fetchTopicPreview, { manual: true });

  /* ---------- open drawer ---------- */
  const openPreview = React.useCallback(
    (row: TopicRow) => {
      setPreviewId(row.id);
      loadPreview(row.id);
    },
    [loadPreview],
  );

  /* ---------- KPI header ---------- */
  const headerStats = React.useMemo(
    () => [
      { label: 'Open topics', value: data?.list.length ?? 0 },
      {
        label: 'Avg stances / topic',
        value: data?.list?.length
          ? Math.round(
              data!.list.reduce((sum: number, t: TopicRow) => sum + (t.stanceCount ?? 0), 0) /
                data!.list.length,
            )
          : 0,
      },
      { label: 'Hot topics', value: (data?.list ?? []).filter((t: TopicRow) => t.hot).length },
    ],
    [data],
  );

  /* ---------- filtres cat√©gorie ---------- */
  const categoryFilters = React.useMemo(
    () =>
      Array.from(
        new Set((data?.list ?? []).map((t: TopicRow) => t.category).filter(Boolean)),
      ).map((c) => ({ text: String(c), value: String(c) })),
    [data?.list],
  );

  /* ---------- colonnes ---------- */
  const columns: ProColumns<TopicRow>[] = React.useMemo(
    () => [
      {
        title: 'Title',
        dataIndex: 'title',
        render: (_: any, row: TopicRow) => (
          <a onClick={() => openPreview(row)} style={{ cursor: 'pointer' }}>
            {row.title}
          </a>
        ),
      },
      {
        title: 'Category',
        dataIndex: 'category',
        filters: categoryFilters,
        onFilter: (value: React.Key | boolean, record: TopicRow) =>
          String(record.category) === String(value),
        render: (_: any, row: TopicRow) => <Tag color="geekblue">{row.category}</Tag>,
      },
      {
        title: 'Stances',
        dataIndex: 'stanceCount',
        sorter: true,
        align: 'right',
      },
      {
        title: 'Last activity',
        dataIndex: 'lastActivity',
        // Pas de valueType non standard. On rend ‚ÄúfromNow‚Äù explicitement.
        render: (_: any, row: TopicRow) => dayjs(row.lastActivity).fromNow(),
      },
      {
        title: '',
        dataIndex: 'hot',
        width: 60,
        render: (_: any, row: TopicRow) =>
          row.hot ? (
            <Tooltip title="Trending">
              <FireOutlined style={{ color: '#fa541c' }} />
            </Tooltip>
          ) : null,
      },
    ],
    [categoryFilters, openPreview],
  );

  /* ---------- rendu ---------- */
  return (
    <PageContainer
      ghost
      loading={loading}
      extra={
        <Space>
          <Button icon={<ReloadOutlined />} onClick={refresh} type="text" title="Refresh list" />
          <NewTopicButton onCreated={refresh} />
        </Space>
      }
    >
      {/* KPI summary */}
      <ProCard gutter={16} wrap style={{ marginBottom: 16 }}>
        {headerStats.map((k) => (
          <StatisticCard
            key={k.label}
            colSpan={{ xs: 24, sm: 8 }}
            statistic={{ title: k.label, value: k.value }}
          />
        ))}
      </ProCard>

      {/* liste */}
      <ProTable<TopicRow>
        rowKey="id"
        columns={columns}
        dataSource={data?.list}
        search={{ labelWidth: 90, filterType: 'light' }}
        pagination={{ pageSize: 10 }}
      />

      {/* preview drawer */}
      <Drawer
        width={520}
        open={!!previewId}
        onClose={() => setPreviewId(null)}
        title={preview?.title || 'Preview'}
      >
        {previewLoading ? (
          <Empty description="Loading‚Ä¶" />
        ) : preview ? (
          <>
            <p>
              <strong>Category:</strong> {preview.category}
            </p>
            <p>
              <strong>Opened:</strong> {dayjs(preview.createdAt).format('YYYY-MM-DD HH:mm')}
            </p>
            <h4>Latest statements</h4>
            <ul>
              {preview.latest.map((s) => (
                <li key={s.id}>
                  <em>{s.author}</em> ‚Äî {s.body}
                </li>
              ))}
            </ul>
            <Button
              type="primary"
              onClick={() => window.location.assign(`/ethikos/deliberate/${preview.id}`)}
            >
              Go to thread ‚Üí
            </Button>
          </>
        ) : (
          <Empty />
        )}
      </Drawer>
    </PageContainer>
  );
}

/* ------------------------------------------------------------------ */
/*  New Topic modal                                                    */
/* ------------------------------------------------------------------ */

function NewTopicButton({ onCreated }: { onCreated: () => void }) {
  const [visible, setVisible] = React.useState(false);

  const { runAsync, loading } = useRequest(createEliteTopic, {
    manual: true,
    onSuccess: () => {
      antdMessage.success('Topic created üéâ');
      setVisible(false);
      onCreated();
    },
  });

  return (
    <>
      <Button icon={<PlusOutlined />} type="primary" onClick={() => setVisible(true)}>
        New Topic
      </Button>
      <ModalForm
        title="Create new topic"
        open={visible}
        onOpenChange={setVisible}
        onFinish={async (values: { title: string; category: string }) => {
          await runAsync(values);
          return true;
        }}
        submitter={{ submitButtonProps: { loading } }}
      >
        <ProFormText name="title" label="Title" rules={[{ required: true, min: 10 }]} />
        <ProFormSelect
          name="category"
          label="Category"
          options={[
            { label: 'AI Policy', value: 'AI Policy' },
            { label: 'Biotech', value: 'Biotech' },
            { label: 'Ethics', value: 'Ethics' },
          ]}
          rules={[{ required: true }]}
        />
      </ModalForm>
    </>
  );
}

===== END app/ethikos/deliberate/elite/page.tsx =====


===== BEGIN app/ethikos/deliberate/guidelines/page.tsx =====
'use client'

import { PageContainer } from '@ant-design/pro-components';
import { Typography, Anchor, Divider } from 'antd';
import usePageTitle from '@/hooks/usePageTitle';

export default function Guidelines() {
  usePageTitle('Deliberate ¬∑ Guidelines');

  return (
    <PageContainer ghost>
      <Anchor
        affix
        items={[
          { key: 'etiquette', href: '#etiquette', title: '1. Etiquette' },
          { key: 'evidence', href: '#evidence', title: '2. Evidence Rules' },
          { key: 'moderation', href: '#moderation', title: '3. Moderation & Appeals' },
        ]}
      />

      <Typography.Title id="etiquette" level={3}>
        1. Etiquette
      </Typography.Title>
      <Typography.Paragraph>
        ‚Ä¢ Be concise, civil, and on-topic. Personal attacks and profanity are removed.
      </Typography.Paragraph>

      <Divider />

      <Typography.Title id="evidence" level={3}>
        2. Evidence Rules
      </Typography.Title>
      <Typography.Paragraph>
        ‚Ä¢ Claims must cite peer-reviewed sources or official data. Unsupported assertions can be flagged.
      </Typography.Paragraph>

      <Divider />

      <Typography.Title id="moderation" level={3}>
        3. Moderation & Appeals
      </Typography.Title>
      <Typography.Paragraph>
        ‚Ä¢ First strike = comment hidden. Second strike = 24 h read-only. Appeals via ‚ÄúRequest review‚Äù button.
      </Typography.Paragraph>
    </PageContainer>
  );
}

===== END app/ethikos/deliberate/guidelines/page.tsx =====


===== BEGIN app/ethikos/EthikosPageShell.tsx =====
// app/ethikos/EthikosPageShell.tsx
'use client';

import React, { ReactNode } from 'react';
import { Typography, Space } from 'antd';

const { Title, Paragraph } = Typography;

export type EthikosPageShellProps = {
  /** Main page title (big, H1-equivalent) */
  title: string;
  /** Optional subtitle / helper text under the title */
  subtitle?: ReactNode;
  /** Main CTA on the right (e.g. primary button) */
  primaryAction?: ReactNode;
  /** Secondary actions on the right (e.g. ghost buttons, filters) */
  secondaryActions?: ReactNode;
  /** Main page content */
  children: ReactNode;
};

/**
 * Central layout wrapper for Ethikos pages.
 *
 * Usage rules:
 * - No extra big <h1> / Title outside of this shell in your pages.
 * - No breadcrumb here (rely on the global layout / shell).
 * - All Ethikos pages should use this for consistent padding & header.
 */
export default function EthikosPageShell({
  title,
  subtitle,
  primaryAction,
  secondaryActions,
  children,
}: EthikosPageShellProps): JSX.Element {
  const hasActions = Boolean(primaryAction || secondaryActions);

  return (
    <div className="container mx-auto p-5">
      {/* Header: title + subtitle + actions */}
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div className="min-w-0">
          <Title level={2} className="!mb-1">
            {title}
          </Title>
          {subtitle && (
            <Paragraph type="secondary" className="!mb-0">
              {subtitle}
            </Paragraph>
          )}
        </div>

        {hasActions && (
          <Space wrap>
            {secondaryActions}
            {primaryAction}
          </Space>
        )}
      </div>

      {/* Main content */}
      {children}
    </div>
  );
}

===== END app/ethikos/EthikosPageShell.tsx =====


===== BEGIN app/ethikos/impact/feedback/page.tsx =====
'use client'

import { useState } from 'react'
import { useRequest } from 'ahooks'

import { PageContainer, ProCard } from '@ant-design/pro-components'
import { Comment } from '@ant-design/compatible'
import { Button, Empty, Input, List, Rate } from 'antd'

import usePageTitle from '@/hooks/usePageTitle'
import { fetchFeedback, submitFeedback } from '@/services/impact'

export default function FeedbackLoops() {
  usePageTitle('Impact ¬∑ Feedback')

  const { data, loading, mutate } = useRequest(fetchFeedback)
  const [message, setMessage] = useState('')
  const [stars, setStars] = useState<number>(0)
  const [sending, setSending] = useState(false)

  const send = async () => {
    if (!message.trim()) return
    setSending(true)
    await submitFeedback({ body: message.trim(), rating: stars || undefined })
    setMessage('')
    setStars(0)
    await mutate()
    setSending(false)
  }

  return (
    <PageContainer ghost loading={loading}>
      <ProCard title="Add your feedback" ghost>
        <Rate onChange={setStars} value={stars} />
        <Input.TextArea
          rows={3}
          placeholder="Tell us what worked or what didn‚Äôt‚Ä¶"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          style={{ marginTop: 8 }}
        />
        <Button
          type="primary"
          onClick={send}
          loading={sending}
          style={{ marginTop: 8 }}
        >
          Submit
        </Button>
      </ProCard>

      <ProCard title="Community Feedback" ghost style={{ marginTop: 24 }}>
        {data?.items?.length ? (
          <List
            dataSource={data?.items ?? []}
            renderItem={(f) => (
              <li key={f.id}>
                <Comment
                  author={f.author}
                  datetime={f.createdAt}
                  content={
                    <>
                      {f.rating !== undefined && <Rate disabled value={f.rating} />}
                      <p style={{ marginTop: 4 }}>{f.body}</p>
                    </>
                  }
                />
              </li>
            )}
          />
        ) : (
          <Empty description="No feedback yet" />
        )}
      </ProCard>
    </PageContainer>
  )
}

===== END app/ethikos/impact/feedback/page.tsx =====


===== BEGIN app/ethikos/impact/outcomes/page.tsx =====
'use client';

import { PageContainer, ProCard, StatisticCard } from '@ant-design/pro-components';
import { Tabs } from 'antd';
import { Line, Bar } from '@ant-design/plots';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchImpactOutcomes } from '@/services/impact';

export default function Outcomes() {
  usePageTitle('Impact ¬∑ Outcomes');

  const { data, loading } = useRequest(fetchImpactOutcomes);

  return (
    <PageContainer ghost loading={loading}>
      <ProCard gutter={16} wrap>
        {data?.kpis.map(k => (
          <StatisticCard
            key={k.label}
            statistic={{ title: k.label, value: k.value, suffix: k.delta && '%' }}
          />
        ))}
      </ProCard>

      <Tabs
        items={data?.charts.map((c, i) => ({
          key: i.toString(),
          label: c.title,
          children: (
            <ProCard ghost>
              {c.type === 'line' && <Line {...c.config} />}
              {c.type === 'bar' && <Bar {...c.config} />}
            </ProCard>
          ),
        }))}
      />
    </PageContainer>
  );
}

===== END app/ethikos/impact/outcomes/page.tsx =====


===== BEGIN app/ethikos/impact/tracker/page.tsx =====
'use client';

import { PageContainer, ProTable, type ProColumns } from '@ant-design/pro-components';
import { Select } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchImpactTracker, patchImpactStatus } from '@/services/impact';

type TrackerRow = {
  id: string;
  title: string;
  owner: string;
  status: 'Planned' | 'In-Progress' | 'Completed' | 'Blocked';
  updatedAt: string;
};

export default function ImpactTracker() {
  usePageTitle('Impact ¬∑ Tracker');

  const { data, loading, mutate } = useRequest(fetchImpactTracker);

  const onStatusChange = async (id: string, status: TrackerRow['status']) => {
    await patchImpactStatus(id, status);
    mutate((d) => ({
      items: d!.items.map((r) => (r.id === id ? { ...r, status } : r)),
    }));
  };

  const columns: ProColumns<TrackerRow>[] = [
    { title: 'Title', dataIndex: 'title', width: 260 },
    { title: 'Owner', dataIndex: 'owner', width: 160 },
    {
      title: 'Status',
      dataIndex: 'status',
      width: 180,
      render: (_, row) => (
        <Select
          value={row.status}
          options={[
            { value: 'Planned', label: 'Planned' },
            { value: 'In-Progress', label: 'In-Progress' },
            { value: 'Completed', label: 'Completed' },
            { value: 'Blocked', label: 'Blocked' },
          ]}
          onChange={(val) => onStatusChange(row.id, val as TrackerRow['status'])}
          style={{ width: '100%' }}
        />
      ),
    },
    { title: 'Updated', dataIndex: 'updatedAt', valueType: 'dateTime', sorter: true },
  ];

  return (
    <PageContainer ghost loading={loading}>
      <ProTable<TrackerRow>
        rowKey="id"
        columns={columns}
        dataSource={data?.items ?? []}
        pagination={{ pageSize: 12 }}
        search={false}
      />
    </PageContainer>
  );
}

===== END app/ethikos/impact/tracker/page.tsx =====


===== BEGIN app/ethikos/layout.tsx =====
import React, { Suspense } from 'react'
import MainLayout from '@/components/layout-components/MainLayout'

export default function SegmentLayout({ children }: { children: React.ReactNode }) {
  return (
    <Suspense fallback={null}>
      <MainLayout>{children}</MainLayout>
    </Suspense>
  )
}
===== END app/ethikos/layout.tsx =====


===== BEGIN app/ethikos/learn/changelog/page.tsx =====
'use client'

import { PageContainer } from '@ant-design/pro-components';
import { Timeline, Tag } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchChangelog } from '@/services/learn';

export default function Changelog() {
  usePageTitle('Learn ¬∑ Changelog');

  const { data, loading } = useRequest(fetchChangelog);

  return (
    <PageContainer ghost loading={loading}>
      <Timeline>
        {data?.entries.map(e => (
          <Timeline.Item key={e.version} label={e.date}>
            <strong>{e.version}</strong>{' '}
            {e.tags.map(t => (
              <Tag key={t} color={t === 'NEW' ? 'green' : t === 'FIX' ? 'blue' : 'default'}>
                {t}
              </Tag>
            ))}
            <ul style={{ marginTop: 4 }}>
              {e.notes.map((n: string, i: number) => (
                <li key={i}>{n}</li>
              ))}
            </ul>
          </Timeline.Item>
        ))}
      </Timeline>
    </PageContainer>
  );
}

===== END app/ethikos/learn/changelog/page.tsx =====


===== BEGIN app/ethikos/learn/glossary/page.tsx =====
'use client'
import { PageContainer, ProTable } from '@ant-design/pro-components'
import { Input } from 'antd'
import { useState } from 'react'
import { useRequest } from 'ahooks'
import usePageTitle from '@/hooks/usePageTitle'
import { fetchGlossary } from '@/services/learn'

type Term = { id: string; term: string; definition: string }

export default function Glossary() {
  usePageTitle('Learn ¬∑ Glossary')

  const { data, loading } = useRequest(fetchGlossary)
  const [query, setQuery] = useState('')

  const columns = [
    { title: 'Term', dataIndex: 'term', width: 200 },
    { title: 'Definition', dataIndex: 'definition' },
  ]

  const filtered = data?.items.filter((t: Term) =>
    t.term.toLowerCase().includes(query.toLowerCase())
  )

  return (
    <PageContainer ghost loading={loading}>
      <Input.Search
        placeholder="Search term‚Ä¶"
        allowClear
        style={{ marginBottom: 16, maxWidth: 320 }}
        onChange={(e) => setQuery(e.target.value)}
      />

      <ProTable<Term>
        rowKey="id"
        columns={columns}
        dataSource={filtered}
        pagination={{ pageSize: 20 }}
        search={false}
      />
    </PageContainer>
  )
}

===== END app/ethikos/learn/glossary/page.tsx =====


===== BEGIN app/ethikos/learn/guides/page.tsx =====
'use client'

import { PageContainer } from '@ant-design/pro-components';
import { Collapse, Anchor, Typography } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchGuides } from '@/services/learn';

export default function Guides() {
  usePageTitle('Learn ¬∑ Guides');

  const { data, loading } = useRequest(fetchGuides);

  return (
    <PageContainer ghost loading={loading}>
      <Anchor
        affix
        items={data?.sections.map(s => ({
          key: s.id,
          href: `#${s.id}`,
          title: s.title,
        }))}
      />

      <Collapse
        accordion
        items={data?.sections.map(s => ({
          key: s.id,
          label: <Typography.Text id={s.id}>{s.title}</Typography.Text>,
          children: <Typography.Paragraph>{s.content}</Typography.Paragraph>,
        }))}
      />
    </PageContainer>
  );
}

===== END app/ethikos/learn/guides/page.tsx =====


===== BEGIN app/ethikos/pulse/health/page.tsx =====
'use client';
import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Pie, Radar } from '@ant-design/plots';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchPulseHealth } from '@/services/pulse';

export default function PulseHealth() {
  usePageTitle('Pulse ¬∑ Participation Health');

  const { data, loading } = useRequest(fetchPulseHealth);

  return (
    <PageContainer ghost loading={loading}>
      <ProCard gutter={16} wrap>
        <ProCard colSpan={12} title="Diversity Radar">
          <Radar {...data?.radarConfig} />
        </ProCard>

        <ProCard colSpan={12} title="Ethics Score Breakdown">
          <Pie {...data?.pieConfig} />
        </ProCard>
      </ProCard>
    </PageContainer>
  );
}

===== END app/ethikos/pulse/health/page.tsx =====


===== BEGIN app/ethikos/pulse/live/page.tsx =====
'use client'

import { PageContainer, ProCard, StatisticCard } from '@ant-design/pro-components';
import { Badge, Space } from 'antd';
import { useInterval, useRequest } from 'ahooks';
import ChartCard from '@/components/charts/ChartCard';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchPulseLiveData } from '@/services/pulse';   // ‚Üê import correct

export default function PulseLive() {
  usePageTitle('Pulse ¬∑ Live Metrics');

  // custom hook (polls every 20 s)
  const { data, loading, refresh } = usePulseLive(true);

  // manual refresh safety-net
  useInterval(refresh, 20_000);

  return (
    <PageContainer ghost loading={loading}>
      <ProCard gutter={16} wrap>
        {data?.counters.map((c) => (
          <StatisticCard
            key={c.label}
            statistic={{
              title: (
                <Space>
                  {c.label}
                  <Badge status={c.trend > 0 ? 'success' : c.trend < 0 ? 'error' : 'default'} />
                </Space>
              ),
              value: c.value,
              precision: 0,
            }}
            chart={
              <ChartCard
                type="line"
                data={c.history.map(({ ts, value }) => ({ x: ts, y: value }))}
                height={50}
              />
            }
          />
        ))}
      </ProCard>
    </PageContainer>
  );
}

/* ------------------------------------------------------------------ */
/*  Local data-fetching hook                                           */
/* ------------------------------------------------------------------ */
function usePulseLive(polling = false) {
  return useRequest(fetchPulseLiveData, {
    pollingInterval: polling ? 20_000 : undefined,
  });
}

===== END app/ethikos/pulse/live/page.tsx =====


===== BEGIN app/ethikos/pulse/overview/page.tsx =====
'use client'

// pages/ethikos/pulse/overview.tsx
import {
  PageContainer,
  ProCard,
  StatisticCard,
} from '@ant-design/pro-components';
import { Badge, Button, Empty, Skeleton, Space, Tooltip } from 'antd';
import { SyncOutlined, ClockCircleOutlined } from '@ant-design/icons';
import { useRequest } from 'ahooks';
import dayjs from 'dayjs';

import ChartCard from '@/components/charts/ChartCard';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchPulseOverview } from '@/services/pulse';

/* ------------------------------------------------------------------ */
/*  Data-fetching hook                                                 */
/* ------------------------------------------------------------------ */

function usePulseOverview() {
  const req = useRequest(fetchPulseOverview, { refreshDeps: [] });
  return req;
}

/* ------------------------------------------------------------------ */
/*  Main component                                                     */
/* ------------------------------------------------------------------ */

export default function PulseOverview() {
  usePageTitle('Pulse ¬∑ Overview');

  const { data, loading, error, refresh } = usePulseOverview();
  const lastUpdated = data ? dayjs(data.refreshedAt).format('HH:mm:ss') : null;

  /* ---------- loading skeleton ---------- */
  if (loading && !data) {
    return (
      <PageContainer ghost>
        <Skeleton active />
      </PageContainer>
    );
  }

  /* ---------- error state ---------- */
  if (error) {
    return (
      <PageContainer ghost>
        <Empty
          description="Failed to load metrics"
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        >
          <Button icon={<SyncOutlined />} onClick={refresh}>
            Retry
          </Button>
        </Empty>
      </PageContainer>
    );
  }

  /* ---------- empty state ---------- */
  if (data && data.kpis.length === 0) {
    return (
      <PageContainer ghost>
        <Empty description="No KPI data yet" />
      </PageContainer>
    );
  }

  /* ---------- happy path ---------- */
  return (
    <PageContainer
      ghost
      extra={
        <Space>
          {lastUpdated && (
            <Badge
              count={
                <Tooltip title={`Last refreshed at ${lastUpdated}`}>
                  <ClockCircleOutlined style={{ color: '#52c41a' }} />
                </Tooltip>
              }
            />
          )}
          <Button
            icon={<SyncOutlined />}
            onClick={refresh}
            size="small"
            type="text"
          />
        </Space>
      }
    >
      <ProCard gutter={[16, 16]} wrap>
        {data!.kpis.map((kpi) => (
          <StatisticCard
            key={kpi.label}
            colSpan={{
              xs: 24,
              sm: 12,
              md: 12,
              lg: 6,
            }}
            statistic={{
              title: kpi.label,
              value: kpi.value,
              suffix: kpi.delta !== undefined ? '%' : undefined,
              description:
                kpi.delta !== undefined ? (
                  <span
                    style={{
                      color: kpi.delta >= 0 ? '#3f8600' : '#cf1322',
                    }}
                  >
                    {kpi.delta >= 0 ? '‚ñ≤' : '‚ñº'} {Math.abs(kpi.delta)}%
                  </span>
                ) : null,
            }}
            chart={
              <ChartCard
                type="area"
                height={60}
                data={kpi.history.map((h) => ({
                  x: h.date,
                  y: h.value,
                }))}
                tooltip={{
                  formatter: (datum: any) =>
                    `${dayjs(datum.x).format('MMM D')}: ${datum.y}`,
                }}
              />
            }
          />
        ))}
      </ProCard>
    </PageContainer>
  );
}

===== END app/ethikos/pulse/overview/page.tsx =====


===== BEGIN app/ethikos/pulse/trends/page.tsx =====
'use client';
import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Tabs } from 'antd';
import { useRequest } from 'ahooks';
import { Line, Area, Heatmap } from '@ant-design/plots';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchPulseTrends } from '@/services/pulse';

export default function PulseTrends() {
  usePageTitle('Pulse ¬∑ Trends');

  const { data, loading } = useRequest(fetchPulseTrends);

  return (
    <PageContainer ghost loading={loading}>
      <Tabs
        items={data?.charts.map((c, idx) => ({
          key: idx.toString(),
          label: c.title,
          children: (
            <ProCard ghost>
              {c.type === 'line' && <Line {...c.config} />}
              {c.type === 'area' && <Area {...c.config} />}
              {c.type === 'heatmap' && <Heatmap {...c.config} />}
            </ProCard>
          ),
        }))}
      />
    </PageContainer>
  );
}

===== END app/ethikos/pulse/trends/page.tsx =====


===== BEGIN app/ethikos/trust/badges/page.tsx =====
'use client'

import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Badge, Card, Progress, Tooltip } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchUserBadges } from '@/services/trust';

export default function Badges() {
  usePageTitle('Trust ¬∑ Badges');

  const { data, loading } = useRequest(fetchUserBadges);

  return (
    <PageContainer ghost loading={loading}>
      <ProCard gutter={16} wrap>
        {data?.earned?.map((b) => (
          <Badge.Ribbon text="Earned" color="green" key={b.id}>
            <Card title={b.name} style={{ width: 220, marginBottom: 16 }}>
              <p>{b.desc}</p>
            </Card>
          </Badge.Ribbon>
        ))}

        {data?.progress?.map((p) => (
          <Tooltip title={`${p.current}/${p.required}`} key={p.id}>
            <Card title={p.name} bordered={false} style={{ width: 220, marginBottom: 16 }}>
              <Progress percent={Math.round((p.current / p.required) * 100)} />
            </Card>
          </Tooltip>
        ))}
      </ProCard>
    </PageContainer>
  );
}

===== END app/ethikos/trust/badges/page.tsx =====


===== BEGIN app/ethikos/trust/credentials/page.tsx =====
'use client';

import { PageContainer } from '@ant-design/pro-components';
import { Upload, Button, Result } from 'antd';
import { InboxOutlined } from '@ant-design/icons';
import { useState } from 'react';
import usePageTitle from '@/hooks/usePageTitle';
import { uploadCredential } from '@/services/trust';

export default function Credentials() {
  usePageTitle('Trust ¬∑ Credentials');

  const [done, setDone] = useState(false);

  const props = {
    name: 'file',
    multiple: false,
    customRequest: async ({ file, onSuccess, onError }: any) => {
      try {
        await uploadCredential(file as File);
        onSuccess('ok');
        setDone(true);
      } catch {
        onError();
      }
    },
  };

  return (
    <PageContainer ghost>
      {done ? (
        <Result
          status="success"
          title="Document uploaded!"
          subTitle="Your credential is pending verification."
          extra={
            <Button type="primary" onClick={() => setDone(false)}>
              Upload another
            </Button>
          }
        />
      ) : (
        <Upload.Dragger {...props} accept=".pdf,.jpg,.png">
          <p className="ant-upload-drag-icon">
            <InboxOutlined />
          </p>
          <p className="ant-upload-text">Click or drag file to this area to upload</p>
          <p className="ant-upload-hint">Supported: PDF / JPG / PNG ¬∑ Max 5 MB</p>
        </Upload.Dragger>
      )}
    </PageContainer>
  );
}

===== END app/ethikos/trust/credentials/page.tsx =====


===== BEGIN app/ethikos/trust/profile/page.tsx =====
'use client'

import { PageContainer, ProCard } from '@ant-design/pro-components';
import { Avatar, Descriptions, Tag, Timeline } from 'antd';
import { useRequest } from 'ahooks';
import usePageTitle from '@/hooks/usePageTitle';
import { fetchUserProfile } from '@/services/trust';

export default function MyProfile() {
  usePageTitle('Trust ¬∑ My Profile');

  const { data, loading } = useRequest(fetchUserProfile);

  return (
    <PageContainer ghost loading={loading}>
      <ProCard split="vertical">
        <ProCard colSpan="25%">
          <Avatar size={120} src={data?.avatar ?? undefined} />
          <Descriptions size="small" column={1} style={{ marginTop: 16 }}>
            <Descriptions.Item label="Name">{data?.name}</Descriptions.Item>
            <Descriptions.Item label="Joined">{data?.joined}</Descriptions.Item>
            <Descriptions.Item label="Reputation">
              <Tag color="blue">{data?.score}</Tag>
            </Descriptions.Item>
          </Descriptions>
        </ProCard>
        <ProCard title="Recent Activity" ghost>
          <Timeline>
            {data?.activity?.map((a) => (
              <Timeline.Item key={a.id}>
                {a.when} ¬∑ {a.text}
              </Timeline.Item>
            ))}
          </Timeline>
        </ProCard>
      </ProCard>
    </PageContainer>
  );
}

===== END app/ethikos/trust/profile/page.tsx =====


===== BEGIN app/keenkonnect/ai-team-matching/find-teams/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import {
  Badge,
  Button,
  Card,
  Divider,
  Drawer,
  Empty,
  Input,
  List,
  Row,
  Col,
  Select,
  Space,
  Switch,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  FilterOutlined,
  InfoCircleOutlined,
  SearchOutlined,
  TeamOutlined,
  UserAddOutlined,
  HeartOutlined,
  ReloadOutlined,
} from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Title, Text, Paragraph } = Typography;
const { Option } = Select;

type TeamSizeFilter = 'all' | 'small' | 'medium' | 'large';

interface TeamMatch {
  id: string;
  name: string;
  description: string;
  domain: string;
  members: string[];
  teamSize: number;
  matchReason: string;
  isOpen: boolean;
}

const sampleTeamMatches: TeamMatch[] = [
  {
    id: '1',
    name: 'AI Innovators',
    description: 'A team focused on cutting-edge AI projects and research.',
    domain: 'AI & Robotics',
    members: ['Alice', 'Bob', 'Charlie'],
    teamSize: 3,
    matchReason: 'Your background in robotics aligns with the team‚Äôs focus.',
    isOpen: true,
  },
  {
    id: '2',
    name: 'Sustainable Cities Lab',
    description:
      'Collaborating on innovative solutions for sustainable urban development.',
    domain: 'Sustainable Cities',
    members: ['Dana', 'Eve'],
    teamSize: 2,
    matchReason:
      'Your interest in urban planning and green infrastructure is highly relevant.',
    isOpen: true,
  },
  {
    id: '3',
    name: 'HealthTech Pioneers',
    description:
      'Exploring new technologies in health and wellness management.',
    domain: 'Health & Wellness',
    members: ['Frank', 'Grace', 'Heidi', 'Ivan'],
    teamSize: 4,
    matchReason:
      'Your experience at the intersection of healthcare and digital platforms is a strong match.',
    isOpen: false,
  },
];

const getTeamSizeTag = (size: number) => {
  if (size <= 3) return { label: 'Small team', color: 'green' as const };
  if (size <= 6) return { label: 'Medium team', color: 'blue' as const };
  return { label: 'Large team', color: 'purple' as const };
};

const domainOptions = Array.from(new Set(sampleTeamMatches.map((t) => t.domain)));

const FindTeamsPage: React.FC = () => {
  const router = useRouter();

  const [searchText, setSearchText] = useState('');
  const [domainFilter, setDomainFilter] = useState<string>('all');
  const [teamSizeFilter, setTeamSizeFilter] = useState<TeamSizeFilter>('all');
  const [openOnly, setOpenOnly] = useState<boolean>(false);

  const [selectedTeam, setSelectedTeam] = useState<TeamMatch | null>(null);
  const [drawerVisible, setDrawerVisible] = useState(false);

  const handleOpenDrawer = (team: TeamMatch) => {
    setSelectedTeam(team);
    setDrawerVisible(true);
  };

  const handleCloseDrawer = () => {
    setDrawerVisible(false);
    setSelectedTeam(null);
  };

  const resetFilters = () => {
    setSearchText('');
    setDomainFilter('all');
    setTeamSizeFilter('all');
    setOpenOnly(false);
  };

  const filteredTeams = useMemo(
    () =>
      sampleTeamMatches.filter((team) => {
        const matchesSearch =
          !searchText ||
          team.name.toLowerCase().includes(searchText.toLowerCase()) ||
          team.description.toLowerCase().includes(searchText.toLowerCase()) ||
          team.domain.toLowerCase().includes(searchText.toLowerCase());

        const matchesDomain =
          domainFilter === 'all' || team.domain === domainFilter;

        const matchesOpen = !openOnly || team.isOpen;

        let matchesSize = true;
        if (teamSizeFilter === 'small') {
          matchesSize = team.teamSize <= 3;
        } else if (teamSizeFilter === 'medium') {
          matchesSize = team.teamSize > 3 && team.teamSize <= 6;
        } else if (teamSizeFilter === 'large') {
          matchesSize = team.teamSize > 6;
        }

        return matchesSearch && matchesDomain && matchesOpen && matchesSize;
      }),
    [searchText, domainFilter, teamSizeFilter, openOnly],
  );

  const hasActiveFilters =
    !!searchText ||
    domainFilter !== 'all' ||
    teamSizeFilter !== 'all' ||
    openOnly;

  const handleGoToPreferences = () => {
    router.push('/keenkonnect/ai-team-matching/match-preferences');
  };

  const handleViewMatches = () => {
    router.push('/keenkonnect/ai-team-matching/my-matches');
  };

  const handleViewWorkspace = (team: TeamMatch) => {
    router.push(
      `/keenkonnect/projects/project-workspace?teamId=${encodeURIComponent(
        team.id,
      )}`,
    );
  };

  return (
    <PageContainer title="Find AI‚Äërecommended teams">
      <Space direction="vertical" size="large" style={{ width: '100%' }}>
        {/* Intro / CTA */}
        <Card>
          <Row gutter={[16, 16]} align="middle">
            <Col xs={24} md={16}>
              <Space direction="vertical" size={8}>
                <Title level={3} style={{ marginBottom: 0 }}>
                  Discover teams that match your profile
                </Title>
                <Text type="secondary">
                  KeenKonnect uses your skills, experience, and preferences to
                  suggest teams where you‚Äôre likely to thrive. Refine the filters
                  or adjust your preferences to tune the recommendations.
                </Text>
              </Space>
            </Col>
            <Col xs={24} md={8}>
              <Space
                direction="vertical"
                size={8}
                style={{ width: '100%', justifyContent: 'flex-end' }}
              >
                <Space wrap style={{ width: '100%', justifyContent: 'flex-end' }}>
                  <Button
                    onClick={handleGoToPreferences}
                    icon={<FilterOutlined />}
                  >
                    Adjust match preferences
                  </Button>
                  <Button
                    type="primary"
                    onClick={handleViewMatches}
                    icon={<TeamOutlined />}
                  >
                    View my matches
                  </Button>
                </Space>
                <Text type="secondary">
                  <InfoCircleOutlined /> Results are simulated mock data for UI
                  only.
                </Text>
              </Space>
            </Col>
          </Row>
        </Card>

        {/* Filters */}
        <Card>
          <Space direction="vertical" size="middle" style={{ width: '100%' }}>
            <Row gutter={[16, 16]}>
              <Col xs={24} md={10}>
                <Input
                  allowClear
                  prefix={<SearchOutlined />}
                  placeholder="Search teams, domains, keywords‚Ä¶"
                  value={searchText}
                  onChange={(e) => setSearchText(e.target.value)}
                />
              </Col>
              <Col xs={24} sm={12} md={5}>
                <Select
                  style={{ width: '100%' }}
                  value={domainFilter}
                  onChange={(value) => setDomainFilter(value)}
                  placeholder="Domain"
                >
                  <Option value="all">All domains</Option>
                  {domainOptions.map((domain) => (
                    <Option key={domain} value={domain}>
                      {domain}
                    </Option>
                  ))}
                </Select>
              </Col>
              <Col xs={24} sm={12} md={5}>
                <Select
                  style={{ width: '100%' }}
                  value={teamSizeFilter}
                  onChange={(value: TeamSizeFilter) => setTeamSizeFilter(value)}
                >
                  <Option value="all">All team sizes</Option>
                  <Option value="small">Small (‚â§3)</Option>
                  <Option value="medium">Medium (4‚Äì6)</Option>
                  <Option value="large">Large (7+)</Option>
                </Select>
              </Col>
              <Col xs={24} sm={12} md={4}>
                <Space>
                  <Switch
                    checked={openOnly}
                    onChange={setOpenOnly}
                    size="small"
                  />
                  <Text>Open to new members only</Text>
                </Space>
              </Col>
            </Row>

            {hasActiveFilters && (
              <Row>
                <Col span={24}>
                  <Space wrap>
                    {searchText && (
                      <Tag closable onClose={() => setSearchText('')}>
                        Search: {searchText}
                      </Tag>
                    )}
                    {domainFilter !== 'all' && (
                      <Tag closable onClose={() => setDomainFilter('all')}>
                        Domain: {domainFilter}
                      </Tag>
                    )}
                    {teamSizeFilter !== 'all' && (
                      <Tag closable onClose={() => setTeamSizeFilter('all')}>
                        Team size: {teamSizeFilter}
                      </Tag>
                    )}
                    {openOnly && (
                      <Tag closable onClose={() => setOpenOnly(false)}>
                        Open teams only
                      </Tag>
                    )}
                    <Button
                      type="link"
                      size="small"
                      icon={<ReloadOutlined />}
                      onClick={resetFilters}
                    >
                      Clear all filters
                    </Button>
                  </Space>
                </Col>
              </Row>
            )}
          </Space>
        </Card>

        {/* Teams list */}
        <Card
          title={
            <Space>
              <TeamOutlined />
              <span>Recommended teams</span>
              <Badge
                count={filteredTeams.length}
                style={{ backgroundColor: '#1890ff' }}
              />
            </Space>
          }
        >
          {filteredTeams.length === 0 ? (
            <Empty
              description={
                <span>
                  No teams match your current filters. Try broadening your search
                  or{' '}
                  <Button
                    type="link"
                    size="small"
                    onClick={handleGoToPreferences}
                  >
                    updating your preferences
                  </Button>
                  .
                </span>
              }
            />
          ) : (
            <List
              grid={{
                gutter: 16,
                xs: 1,
                sm: 1,
                md: 2,
                lg: 2,
                xl: 3,
                xxl: 3,
              }}
              dataSource={filteredTeams}
              renderItem={(team) => {
                const sizeTag = getTeamSizeTag(team.teamSize);

                return (
                  <List.Item>
                    <Card
                      hoverable
                      onClick={() => handleOpenDrawer(team)}
                      actions={[
                        <Tooltip
                          key="join"
                          title="Express interest in joining this team"
                        >
                          <Button
                            type="link"
                            icon={<UserAddOutlined />}
                            onClick={(e) => {
                              e.stopPropagation();
                              handleOpenDrawer(team);
                            }}
                          >
                            Request to join
                          </Button>
                        </Tooltip>,
                        <Tooltip key="save" title="Save this team for later">
                          <Button
                            type="link"
                            icon={<HeartOutlined />}
                            onClick={(e) => e.stopPropagation()}
                          >
                            Save
                          </Button>
                        </Tooltip>,
                      ]}
                    >
                      <Space
                        direction="vertical"
                        size={8}
                        style={{ width: '100%' }}
                      >
                        <Space align="center" style={{ width: '100%' }}>
                          <Title
                            level={5}
                            style={{ marginBottom: 0, flex: 1 }}
                          >
                            {team.name}
                          </Title>
                          <Badge
                            status={team.isOpen ? 'success' : 'default'}
                            text={team.isOpen ? 'Open' : 'Currently full'}
                          />
                        </Space>

                        <Text type="secondary">{team.description}</Text>

                        <Space wrap size={[4, 4]}>
                          <Tag color="geekblue">{team.domain}</Tag>
                          <Tag color={sizeTag.color}>
                            {sizeTag.label} ({team.teamSize})
                          </Tag>
                          <Tag>{team.members.join(', ')}</Tag>
                        </Space>

                        <Divider style={{ margin: '8px 0' }} />

                        <Space direction="vertical" size={4}>
                          <Text strong>Why this is a good match</Text>
                          <Paragraph
                            type="secondary"
                            ellipsis={{ rows: 2 }}
                            style={{ marginBottom: 0 }}
                          >
                            {team.matchReason}
                          </Paragraph>
                        </Space>

                        <Button
                          type="default"
                          block
                          onClick={(e) => {
                            e.stopPropagation();
                            handleOpenDrawer(team);
                          }}
                        >
                          View details
                        </Button>
                      </Space>
                    </Card>
                  </List.Item>
                );
              }}
            />
          )}
        </Card>
      </Space>

      {/* Details drawer */}
      <Drawer
        title={
          selectedTeam ? (
            <Space direction="vertical" size={0}>
              <Space align="center">
                <TeamOutlined />
                <span>{selectedTeam.name}</span>
                {selectedTeam.isOpen && (
                  <Tag color="green">Open to new members</Tag>
                )}
              </Space>
              <Text type="secondary">{selectedTeam.domain}</Text>
            </Space>
          ) : (
            'Team details'
          )
        }
        width={520}
        open={drawerVisible}
        onClose={handleCloseDrawer}
        destroyOnClose
      >
        {selectedTeam && (
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <section>
              <Title level={5}>Overview</Title>
              <Paragraph>{selectedTeam.description}</Paragraph>
              <Text type="secondary">
                <InfoCircleOutlined /> This team recommendation is based on your
                profile and AI matching preferences.
              </Text>
            </section>

            <section>
              <Title level={5}>Why you‚Äôre a match</Title>
              <Paragraph>{selectedTeam.matchReason}</Paragraph>
            </section>

            <section>
              <Title level={5}>Team composition</Title>
              <Space direction="vertical" style={{ width: '100%' }}>
                <Space size="small" wrap>
                  <Tag icon={<TeamOutlined />}>
                    {selectedTeam.teamSize} member
                    {selectedTeam.teamSize > 1 ? 's' : ''}
                  </Tag>
                  {selectedTeam.isOpen ? (
                    <Tag color="green">Actively recruiting</Tag>
                  ) : (
                    <Tag color="default">Currently full</Tag>
                  )}
                </Space>
                <List
                  size="small"
                  bordered
                  dataSource={selectedTeam.members}
                  renderItem={(member, index) => (
                    <List.Item>
                      <Text>
                        {index + 1}. {member}
                      </Text>
                    </List.Item>
                  )}
                />
              </Space>
            </section>

            <section>
              <Title level={5}>Next steps</Title>
              <Space direction="vertical" style={{ width: '100%' }}>
                <Button
                  type="primary"
                  icon={<UserAddOutlined />}
                  block
                  onClick={() => {
                    // Placeholder for future integration
                    // eslint-disable-next-line no-console
                    console.log('Request to join', selectedTeam.id);
                  }}
                >
                  Request to join this team
                </Button>
                <Button block onClick={() => handleViewWorkspace(selectedTeam)}>
                  View team workspace (mock)
                </Button>
                <Button
                  type="dashed"
                  icon={<HeartOutlined />}
                  block
                  onClick={() => {
                    // eslint-disable-next-line no-console
                    console.log('Saved team', selectedTeam.id);
                  }}
                >
                  Save this team
                </Button>
              </Space>
            </section>
          </Space>
        )}
      </Drawer>
    </PageContainer>
  );
};

export default FindTeamsPage;

===== END app/keenkonnect/ai-team-matching/find-teams/page.tsx =====


===== BEGIN app/keenkonnect/ai-team-matching/match-preferences/page.tsx =====
'use client';

import React from 'react';
import { Card, Space, Typography } from 'antd';
import {
  StepsForm,
  ProFormSlider,
  ProFormSelect,
  ProFormSwitch,
  ProFormTextArea,
} from '@ant-design/pro-components';

const { Title, Paragraph } = Typography;

const MatchPreferencesPage: React.FC = () => {
  return (
    <div style={{ maxWidth: 960, margin: '0 auto', padding: 24 }}>
      <Space direction="vertical" size="large" style={{ width: '100%' }}>
        <div>
          <Title level={2} style={{ marginBottom: 8 }}>
            Pr√©f√©rences de matching
          </Title>
          <Paragraph type="secondary" style={{ marginBottom: 0 }}>
            Configure tes pr√©f√©rences pour que KeenKonnect puisse te proposer des √©quipes et
            co√©quipier¬∑√®res qui te correspondent vraiment.
          </Paragraph>
        </div>

        <Card>
          <StepsForm
            containerStyle={{ maxWidth: 840, margin: '0 auto' }}
            onFinish={async (values: Record<string, unknown>) => {
              // TODO: brancher sur ton backend / API de matching
              // eslint-disable-next-line no-console
              console.log('Match preferences:', values);
              return true;
            }}
            stepsFormRender={(dom, submitter) => (
              <div>
                {dom}
                <div style={{ marginTop: 24 }}>{submitter}</div>
              </div>
            )}
          >
            {/* √âtape 1 ‚Äî Profil & objectifs */}
            <StepsForm.StepForm
              name="profile"
              title="Profil & objectifs"
              stepProps={{
                description: 'Ce que tu cherches dans l‚Äô√©quipe',
              }}
            >
              <ProFormSelect
                name="matchGoal"
                label="Objectif principal"
                placeholder="Choisis ton objectif principal"
                rules={[{ required: true, message: 'Merci de pr√©ciser ton objectif principal.' }]}
                options={[
                  { label: 'Trouver un¬∑e cofondateur¬∑rice', value: 'cofounder' },
                  { label: 'Trouver une √©quipe pour un projet', value: 'join_team' },
                  { label: 'Trouver des freelances / experts', value: 'freelance' },
                  { label: 'Brainstorm / networking uniquement', value: 'networking' },
                ]}
              />

              <ProFormSlider
                name="seniorityPreference"
                label="Niveau d‚Äôexp√©rience souhait√© dans l‚Äô√©quipe"
                min={1}
                max={10}
                marks={{
                  1: 'Tr√®s junior',
                  5: 'Mixte',
                  10: 'Tr√®s senior',
                }}
                tooltip={{
                  formatter: (value?: number) =>
                    value !== undefined ? `${value}/10` : undefined,
                }}
              />

              <ProFormSelect
                name="timeCommitment"
                label="Disponibilit√© souhait√©e des membres"
                placeholder="S√©lectionne une option"
                allowClear
                options={[
                  { label: 'Side project (3‚Äì5 h / semaine)', value: 'side' },
                  { label: 'Engagement mod√©r√© (5‚Äì10 h / semaine)', value: 'medium' },
                  { label: 'Engagement √©lev√© (10h+ / semaine)', value: 'high' },
                ]}
              />

              <ProFormSwitch
                name="remoteOnly"
                label="Je veux uniquement des collaborations 100% √† distance"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Non',
                }}
              />
            </StepsForm.StepForm>

            {/* √âtape 2 ‚Äî Style d‚Äô√©quipe */}
            <StepsForm.StepForm
              name="team"
              title="Style d‚Äô√©quipe"
              stepProps={{
                description: 'Comment tu aimes travailler',
              }}
            >
              <ProFormSlider
                name="teamSize"
                label="Taille d‚Äô√©quipe id√©ale"
                min={2}
                max={12}
                marks={{
                  2: 'Tr√®s lean',
                  5: '√âquipe moyenne',
                  10: 'Grosse √©quipe',
                }}
              />

              <ProFormSelect
                name="communicationStyle"
                label="Style de communication pr√©f√©r√©"
                placeholder="S√©lectionne ce qui te ressemble le plus"
                options={[
                  {
                    label: 'Tr√®s structur√© (notes, comptes-rendus, suivi serr√©)',
                    value: 'structured',
                  },
                  { label: 'Flexible mais r√©actif', value: 'flexible' },
                  { label: 'Informel, au feeling', value: 'casual' },
                ]}
              />

              <ProFormSlider
                name="asyncPreference"
                label="Pr√©f√©rence pour le travail asynchrone"
                min={0}
                max={10}
                marks={{
                  0: 'Tout en temps r√©el',
                  5: 'Mixte',
                  10: 'Quasi 100% asynchrone',
                }}
              />

              <ProFormSwitch
                name="needsFacilitator"
                label="Je pr√©f√®re qu‚Äôil y ait un¬∑e facilitateur¬∑rice / PM dans l‚Äô√©quipe"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Pas n√©cessaire',
                }}
              />

              <ProFormSwitch
                name="preferDiverseBackgrounds"
                label="Je souhaite une √©quipe avec des profils tr√®s vari√©s"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Peu importe',
                }}
              />
            </StepsForm.StepForm>

            {/* √âtape 3 ‚Äî Contraintes & priorit√©s */}
            <StepsForm.StepForm
              name="constraints"
              title="Contraintes & priorit√©s"
              stepProps={{
                description: 'Ce qui est non n√©gociable pour toi',
              }}
            >
              <ProFormSlider
                name="timeZoneOverlap"
                label="Chevauchement horaire minimum souhait√©"
                min={0}
                max={8}
                marks={{
                  0: 'Peu importe',
                  2: '2h',
                  4: '4h',
                  6: '6h',
                  8: '8h+',
                }}
                tooltip={{
                  formatter: (value?: number) =>
                    value !== undefined ? `${value}h de chevauchement` : undefined,
                }}
              />

              <ProFormSelect
                name="meetingFrequency"
                label="Fr√©quence de r√©unions souhait√©e"
                placeholder="S√©lectionne une option"
                allowClear
                options={[
                  { label: '1 fois par semaine', value: 'weekly' },
                  { label: '2‚Äì3 fois par semaine', value: 'twice_week' },
                  { label: 'Quotidien stand-up court', value: 'daily' },
                  { label: 'Au besoin uniquement', value: 'on_demand' },
                ]}
              />

              <ProFormSwitch
                name="openToWeekend"
                label="Ok pour travailler ponctuellement le week‚Äëend"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Non',
                }}
              />

              <ProFormSwitch
                name="openToNightSessions"
                label="Ok pour des sessions tard le soir si n√©cessaire"
                fieldProps={{
                  checkedChildren: 'Oui',
                  unCheckedChildren: 'Non',
                }}
              />

              <ProFormTextArea
                name="notes"
                label="D√©tails compl√©mentaires pour l‚Äôalgorithme de matching"
                placeholder="Ex.: je pr√©f√®re les √©quipes qui prototypent rapidement, j‚Äô√©vite les projets blockchain, etc."
                fieldProps={{
                  autoSize: { minRows: 3, maxRows: 6 },
                  showCount: true,
                  maxLength: 600,
                }}
              />
            </StepsForm.StepForm>
          </StepsForm>
        </Card>
      </Space>
    </div>
  );
};

export default MatchPreferencesPage;

===== END app/keenkonnect/ai-team-matching/match-preferences/page.tsx =====


===== BEGIN app/keenkonnect/ai-team-matching/my-matches/page.tsx =====
'use client';

import React from 'react';
import Head from 'next/head';
import { ProTable, ProCard, type ProColumns } from '@ant-design/pro-components';
import { Badge, Button, Drawer, Progress, Space, Tag, Typography } from 'antd';

const { Text, Title, Paragraph } = Typography;

type MatchType = 'team' | 'partner';

interface MatchRow {
  id: string;
  type: MatchType;
  name: string;
  matchScore: number;
  commonInterests: string;
  roleOrNeed: string;
  location?: string;
  availability?: string;
  membersCount?: number;
  new?: boolean;
}

/**
 * Donn√©es mock ‚Äì Teams
 * (√† remplacer par l‚ÄôAPI AI Team Matching plus tard)
 */
const teamMatches: MatchRow[] = [
  {
    id: 'team1',
    type: 'team',
    name: 'Alpha Team',
    matchScore: 92,
    commonInterests: 'UI/UX, Backend, DevOps',
    roleOrNeed: 'Recherche un¬∑e full‚Äëstack pour stabiliser le MVP.',
    location: 'Remote / Europe-friendly',
    availability: '3‚Äì5 h / semaine',
    membersCount: 4,
    new: true,
  },
  {
    id: 'team2',
    type: 'team',
    name: 'Beta Squad',
    matchScore: 85,
    commonInterests: 'Mobile, Frontend, Design System',
    roleOrNeed: 'Besoin d‚Äôun¬∑e designer produit + front React Native.',
    location: 'Montr√©al / Hybrid',
    availability: 'Soirs & week-ends',
    membersCount: 3,
  },
  {
    id: 'team3',
    type: 'team',
    name: 'Gamma Builders',
    matchScore: 78,
    commonInterests: 'Data, ML Ops, Product Analytics',
    roleOrNeed: 'Profil orient√© data storytelling & dashboards.',
    location: 'Remote',
    availability: 'Flexible',
    membersCount: 5,
  },
];

/**
 * Donn√©es mock ‚Äì Partenaires individuels
 */
const partnerMatches: MatchRow[] = [
  {
    id: 'partner1',
    type: 'partner',
    name: 'Jane Doe',
    matchScore: 88,
    commonInterests: 'Product Management, Design Thinking, Strategy',
    roleOrNeed: 'Veut co‚Äëlead un produit AI early‚Äëstage.',
    location: 'Montr√©al / Hybrid',
    availability: 'Soirs de semaine',
    new: true,
  },
  {
    id: 'partner2',
    type: 'partner',
    name: 'John Smith',
    matchScore: 80,
    commonInterests: 'Data Science, Machine Learning, Experimentation',
    roleOrNeed: 'Cherche une √©quipe pour un projet ML appliqu√©.',
    location: 'Remote / North America',
    availability: '2‚Äì3 soirs / semaine',
  },
  {
    id: 'partner3',
    type: 'partner',
    name: 'Amina K.',
    matchScore: 73,
    commonInterests: 'Community building, Facilitation, UX research',
    roleOrNeed: 'Souhaite rejoindre un projet orient√© impact social.',
    location: 'Paris',
    availability: 'Week-ends',
  },
];

export default function MyMatchesPage(): JSX.Element {
  const [selectedMatch, setSelectedMatch] = React.useState<MatchRow | null>(null);
  const [drawerOpen, setDrawerOpen] = React.useState(false);

  const allMatches: MatchRow[] = [...teamMatches, ...partnerMatches];

  const total = allMatches.length;
  const newCount = allMatches.filter((m) => m.new).length;
  const avgScore = total
    ? Math.round(allMatches.reduce((acc, m) => acc + m.matchScore, 0) / total)
    : 0;
  const strongMatches = allMatches.filter((m) => m.matchScore >= 80).length;

  const columns: ProColumns<MatchRow>[] = [
    {
      title: 'Type',
      dataIndex: 'type',
      width: 140,
      filters: [
        { text: 'Teams', value: 'team' },
        { text: 'Partners', value: 'partner' },
      ],
      onFilter: (value, row) => row.type === String(value),
      render: (_, row) => (
        <Tag color={row.type === 'team' ? 'blue' : 'purple'}>
          {row.type === 'team' ? 'Team match' : 'Partner match'}
        </Tag>
      ),
    },
    {
      title: 'Nom',
      dataIndex: 'name',
      width: 240,
      render: (_, row) => (
        <Space>
          {row.new && <Badge dot />}
          <Text strong>{row.name}</Text>
        </Space>
      ),
    },
    {
      title: 'Match',
      dataIndex: 'matchScore',
      width: 220,
      sorter: (a, b) => a.matchScore - b.matchScore,
      render: (_, row) => (
        <Space direction="vertical" size={4} style={{ width: '100%' }}>
          <Progress
            percent={row.matchScore}
            size="small"
            status={
              row.matchScore >= 85
                ? 'success'
                : row.matchScore >= 70
                ? 'active'
                : 'normal'
            }
          />
          <Text type="secondary">{row.matchScore}% de compatibilit√© globale</Text>
        </Space>
      ),
    },
    {
      title: 'Points communs',
      dataIndex: 'commonInterests',
      ellipsis: true,
    },
    {
      title: 'R√¥le / Besoin',
      dataIndex: 'roleOrNeed',
      ellipsis: true,
      width: 260,
    },
    {
      title: 'Localisation',
      dataIndex: 'location',
      width: 180,
      render: (_, row) =>
        row.location ? (
          <Text>{row.location}</Text>
        ) : (
          <Text type="secondary">‚Äî</Text>
        ),
    },
    {
      title: 'Actions',
      valueType: 'option',
      width: 200,
      render: (_, row) => [
        <Button
          key="view"
          type="link"
          onClick={() => {
            setSelectedMatch(row);
            setDrawerOpen(true);
          }}
        >
          Voir le d√©tail
        </Button>,
        <Button key="connect" type="link">
          Proposer une connexion
        </Button>,
      ],
    },
  ];

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Mes correspondances</title>
      </Head>

      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-4">Mes correspondances</h1>
        <p className="text-gray-500 mb-6">
          R√©sum√© de tes matches g√©n√©r√©s par l‚ÄôAI Team Matching&nbsp;: √©quipes, partenaires
          potentiels et niveau de compatibilit√©.
        </p>

        <Space direction="vertical" size="large" style={{ width: '100%' }}>
          {/* Bandeau de KPIs / r√©sum√© */}
          <ProCard ghost gutter={[16, 16]} wrap>
            <ProCard colSpan={{ xs: 24, sm: 12, md: 6 }} bordered>
              <Text type="secondary">Total de matches</Text>
              <Title level={3} style={{ marginTop: 8, marginBottom: 0 }}>
                {total}
              </Title>
            </ProCard>

            <ProCard colSpan={{ xs: 24, sm: 12, md: 6 }} bordered>
              <Text type="secondary">Nouveaux matches</Text>
              <Space align="baseline">
                <Title level={3} style={{ marginTop: 8, marginBottom: 0 }}>
                  {newCount}
                </Title>
                {newCount > 0 && (
                  <Badge
                    count="Nouveau"
                    style={{ backgroundColor: '#52c41a', marginLeft: 8 }}
                  />
                )}
              </Space>
            </ProCard>

            <ProCard colSpan={{ xs: 24, sm: 12, md: 6 }} bordered>
              <Text type="secondary">Compatibilit√© moyenne</Text>
              <Title level={3} style={{ marginTop: 8, marginBottom: 0 }}>
                {avgScore}%
              </Title>
              <Progress
                percent={avgScore}
                size="small"
                style={{ marginTop: 8 }}
                status={
                  avgScore >= 85 ? 'success' : avgScore >= 70 ? 'active' : 'normal'
                }
              />
            </ProCard>

            <ProCard colSpan={{ xs: 24, sm: 12, md: 6 }} bordered>
              <Text type="secondary">Matches forts (‚â• 80%)</Text>
              <Title level={3} style={{ marginTop: 8, marginBottom: 0 }}>
                {strongMatches}
              </Title>
            </ProCard>
          </ProCard>

          {/* Tableau principal */}
          <ProTable<MatchRow>
            rowKey="id"
            columns={columns}
            dataSource={allMatches}
            search={false}
            pagination={{ pageSize: 6 }}
            options={false}
            onRow={(record) => ({
              onClick: () => {
                setSelectedMatch(record);
                setDrawerOpen(true);
              },
            })}
          />
        </Space>

        {/* Drawer de d√©tail d‚Äôun match */}
        <Drawer
          title={selectedMatch ? selectedMatch.name : 'D√©tail du match'}
          open={drawerOpen}
          width={520}
          onClose={() => {
            setDrawerOpen(false);
            setSelectedMatch(null);
          }}
        >
          {selectedMatch && (
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              <Space>
                <Tag color={selectedMatch.type === 'team' ? 'blue' : 'purple'}>
                  {selectedMatch.type === 'team' ? 'Team match' : 'Partner match'}
                </Tag>
                {selectedMatch.new && (
                  <Badge count="Nouveau" style={{ backgroundColor: '#52c41a' }} />
                )}
              </Space>

              <Space align="center">
                <Progress
                  type="dashboard"
                  percent={selectedMatch.matchScore}
                  status={
                    selectedMatch.matchScore >= 85
                      ? 'success'
                      : selectedMatch.matchScore >= 70
                      ? 'active'
                      : 'normal'
                  }
                  style={{ marginRight: 16 }}
                />
                <div>
                  <Text strong>
                    {selectedMatch.matchScore}% de compatibilit√© globale
                  </Text>
                  <Paragraph type="secondary" style={{ marginBottom: 0 }}>
                    Calcul√© √† partir des int√©r√™ts, comp√©tences, disponibilit√© et
                    style de collaboration.
                  </Paragraph>
                </div>
              </Space>

              <div>
                <Title level={5}>Ce que vous avez en commun</Title>
                <Paragraph>{selectedMatch.commonInterests}</Paragraph>
              </div>

              <div>
                <Title level={5}>R√¥le &amp; attentes</Title>
                <Paragraph>{selectedMatch.roleOrNeed}</Paragraph>
              </div>

              {selectedMatch.location && (
                <Paragraph>
                  <Text strong>Localisation :</Text> {selectedMatch.location}
                </Paragraph>
              )}

              {selectedMatch.availability && (
                <Paragraph>
                  <Text strong>Disponibilit√© :</Text>{' '}
                  {selectedMatch.availability}
                </Paragraph>
              )}

              {selectedMatch.membersCount != null && (
                <Paragraph>
                  <Text strong>Taille de l‚Äô√©quipe :</Text>{' '}
                  {selectedMatch.membersCount} membres
                </Paragraph>
              )}

              <Space>
                <Button type="primary">Proposer une connexion</Button>
                <Button>Voir le profil complet</Button>
              </Space>
            </Space>
          )}
        </Drawer>
      </div>
    </>
  );
}

===== END app/keenkonnect/ai-team-matching/my-matches/page.tsx =====


===== BEGIN app/keenkonnect/dashboard/page.tsx =====
'use client';

import React from 'react';
import Link from 'next/link';
import { PageContainer, ProCard, StatisticCard } from '@ant-design/pro-components';
import {
  Badge,
  Button,
  List,
  Space,
  Tag,
  Timeline,
  Typography,
  Avatar,
  Divider,
  Progress,
} from 'antd';
import {
  AppstoreOutlined,
  RocketOutlined,
  TeamOutlined,
  FileTextOutlined,
  DashboardOutlined,
  CrownOutlined,
  PlusOutlined,
  BellOutlined,
  ClockCircleOutlined,
  ArrowRightOutlined,
} from '@ant-design/icons';
import usePageTitle from '@/hooks/usePageTitle';

const { Text, Paragraph } = Typography;

type SummaryMetric = {
  key: string;
  title: string;
  value: number;
  suffix?: string;
  description?: string;
};

type Project = {
  id: string;
  name: string;
  status: 'In Progress' | 'Planning' | 'Completed';
  role: string;
};

type Workspace = {
  id: string;
  name: string;
  participants: number;
  focus: string;
};

type KnowledgeItem = {
  id: string;
  title: string;
  type: string;
  link: string;
};

type Task = {
  id: string;
  title: string;
  due: string;
  priority: 'Low' | 'Medium' | 'High';
};

type NotificationItem = {
  id: string;
  message: string;
  type: 'info' | 'warning' | 'success';
  time: string;
};

type TimelineEvent = {
  id: string;
  time: string;
  description: string;
};

type QuickAction = {
  key: string;
  title: string;
  description: string;
  href: string;
  icon: React.ReactNode;
};

// --- Mock data ---

const summaryMetrics: SummaryMetric[] = [
  {
    key: 'projects',
    title: 'Active Projects',
    value: 7,
    description: 'Across your ecosystems',
  },
  {
    key: 'workspaces',
    title: 'Live Workspaces',
    value: 3,
    description: 'Teams currently collaborating',
  },
  {
    key: 'knowledge',
    title: 'Knowledge Assets',
    value: 32,
    description: 'Docs, methods & playbooks',
  },
  {
    key: 'aiMatches',
    title: 'New AI Matches',
    value: 4,
    description: 'Suggested teams to review',
  },
];

const myProjects: Project[] = [
  {
    id: 'p1',
    name: 'Climate-Resilient Urban Plan',
    status: 'In Progress',
    role: 'Lead Facilitator',
  },
  {
    id: 'p2',
    name: 'Circular Economy Innovation Challenge',
    status: 'Planning',
    role: 'Program Orchestrator',
  },
  {
    id: 'p3',
    name: 'Multi-city Just Transition Portfolio',
    status: 'In Progress',
    role: 'Steward',
  },
];

const activeWorkspaces: Workspace[] = [
  {
    id: 'w1',
    name: 'Regional Sustainability Lab ‚Äì Montreal',
    participants: 24,
    focus: 'Climate & urban resilience',
  },
  {
    id: 'w2',
    name: 'Just Transition Story Lab',
    participants: 18,
    focus: 'Narratives & social impact',
  },
  {
    id: 'w3',
    name: 'Circular Solutions Sprint ‚Äì Q4',
    participants: 12,
    focus: 'Circular economy pilots',
  },
];

const knowledgeItems: KnowledgeItem[] = [
  {
    id: 'k1',
    title: 'Impact Evaluation Framework ‚Äì Urban Resilience',
    type: 'Methodology',
    link: '/keenkonnect/knowledge/browse-repository',
  },
  {
    id: 'k2',
    title: 'Stakeholder Mapping Canvas ‚Äì Just Transition',
    type: 'Template',
    link: '/keenkonnect/knowledge/browse-repository',
  },
  {
    id: 'k3',
    title: 'Systems Story Library ‚Äì Circular Economy',
    type: 'Story Library',
    link: '/keenkonnect/knowledge/browse-repository',
  },
];

const myTasks: Task[] = [
  {
    id: 't1',
    title: 'Finalize proposal for Climate-Resilient Urban Plan',
    due: 'Today',
    priority: 'High',
  },
  {
    id: 't2',
    title: 'Review AI-recommended collaborators for Just Transition Lab',
    due: 'Tomorrow',
    priority: 'Medium',
  },
  {
    id: 't3',
    title: 'Tag and upload new blueprint to repository',
    due: 'This week',
    priority: 'Low',
  },
];

const notifications: NotificationItem[] = [
  {
    id: 'n1',
    message:
      'You have a pending invitation from Team Delta to join "Circular Solutions Sprint ‚Äì Q4".',
    type: 'info',
    time: '2 hours ago',
  },
  {
    id: 'n2',
    message: 'Repository "Sustainable Materials" has 3 new documents.',
    type: 'success',
    time: 'Yesterday',
  },
  {
    id: 'n3',
    message:
      'Workspace "Regional Sustainability Lab ‚Äì Montreal" starts its next cycle on Monday.',
    type: 'warning',
    time: '2 days ago',
  },
];

const activityTimeline: TimelineEvent[] = [
  {
    id: 'a1',
    time: '09:15',
    description: 'You created the project "Climate-Resilient Urban Plan".',
  },
  {
    id: 'a2',
    time: '10:02',
    description:
      'AI Team Matching suggested 2 new collaborators for "Just Transition Story Lab".',
  },
  {
    id: 'a3',
    time: '11:30',
    description:
      'New blueprint uploaded to the repository for "Circular Solutions Sprint ‚Äì Q4".',
  },
  {
    id: 'a4',
    time: '14:05',
    description:
      'Workspace "Regional Sustainability Lab ‚Äì Montreal" scheduled its next session.',
  },
];

const quickActions: QuickAction[] = [
  {
    key: 'newProject',
    title: 'Create project',
    description: 'Set up a new multi-partner initiative.',
    href: '/keenkonnect/projects/create-new-project',
    icon: <PlusOutlined />,
  },
  {
    key: 'launchWorkspace',
    title: 'Launch workspace',
    description: 'Open a collaboration space for your team.',
    href: '/keenkonnect/workspaces/launch-new-workspace',
    icon: <RocketOutlined />,
  },
  {
    key: 'browseRepository',
    title: 'Browse repository',
    description: 'Explore blueprints and shared documents.',
    href: '/keenkonnect/knowledge/browse-repository',
    icon: <AppstoreOutlined />,
  },
  {
    key: 'uploadDocument',
    title: 'Upload document',
    description: 'Add a new asset to the knowledge base.',
    href: '/keenkonnect/knowledge/upload-new-document',
    icon: <FileTextOutlined />,
  },
  {
    key: 'sustainabilityDashboard',
    title: 'Impact dashboard',
    description: 'Track sustainability metrics across projects.',
    href: '/keenkonnect/sustainability-impact/sustainability-dashboard',
    icon: <DashboardOutlined />,
  },
  {
    key: 'viewReputation',
    title: 'View reputation',
    description: 'See your Ethikos reputation profile.',
    href: '/keenkonnect/user-reputation/view-reputation-ekoh',
    icon: <CrownOutlined />,
  },
];

export default function KeenKonnectDashboard(): JSX.Element {
  usePageTitle('KeenKonnect ¬∑ Dashboard');

  return (
    <PageContainer
      ghost
      header={{
        title: 'KeenKonnect Dashboard',
        subTitle:
          'Orchestrate projects, workspaces, and knowledge across your ecosystems ‚Äî and keep an eye on AI matches, impact, and your Ethikos profile.',
        extra: (
          <Space>
            <Link href="/keenkonnect/projects/my-projects">
              <Button>View projects</Button>
            </Link>
            <Link href="/keenkonnect/ai-team-matching/match-preferences">
              <Button type="primary" icon={<TeamOutlined />}>
                AI team matching
              </Button>
            </Link>
          </Space>
        ),
      }}
    >
      {/* KPI band */}
      <ProCard gutter={16} wrap style={{ marginBottom: 16 }}>
        {summaryMetrics.map((metric) => (
          <StatisticCard
            key={metric.key}
            colSpan={{ xs: 24, sm: 12, md: 12, lg: 6 }}
            statistic={{
              title: metric.title,
              value: metric.value,
              suffix: metric.suffix,
              description: metric.description,
            }}
          />
        ))}
      </ProCard>

      {/* Main columns: projects/workspaces vs today-at-a-glance */}
      <ProCard split="vertical" gutter={16} style={{ marginBottom: 16 }}>
        {/* Projects & Workspaces */}
        <ProCard
          colSpan={{ xs: 24, xl: 16 }}
          title="Projects & Workspaces"
          subTitle="Where collaboration actually happens"
        >
          <ProCard split="horizontal" ghost>
            {/* My Projects */}
            <ProCard
              title="My Projects"
              bordered={false}
              extra={
                <Link href="/keenkonnect/projects/my-projects">
                  <Space size={4}>
                    <span>View all</span>
                    <ArrowRightOutlined />
                  </Space>
                </Link>
              }
            >
              <List
                itemLayout="horizontal"
                dataSource={myProjects}
                renderItem={(project) => (
                  <List.Item
                    key={project.id}
                    actions={[
                      <Link key="open" href="/keenkonnect/projects/my-projects">
                        Open
                      </Link>,
                    ]}
                  >
                    <List.Item.Meta
                      title={
                        <Space>
                          <Text strong>{project.name}</Text>
                          <Tag color="blue">{project.role}</Tag>
                        </Space>
                      }
                      description={
                        <Space size="small">
                          <Badge
                            status={
                              project.status === 'In Progress'
                                ? 'processing'
                                : project.status === 'Planning'
                                ? 'warning'
                                : 'success'
                            }
                          />
                          <Text type="secondary">{project.status}</Text>
                        </Space>
                      }
                    />
                  </List.Item>
                )}
              />
            </ProCard>

            <Divider style={{ margin: '12px 0' }} />

            {/* Active Workspaces */}
            <ProCard
              title="Active Workspaces"
              bordered={false}
              extra={
                <Link href="/keenkonnect/workspaces/my-workspaces">
                  <Space size={4}>
                    <span>View all</span>
                    <ArrowRightOutlined />
                  </Space>
                </Link>
              }
            >
              <List
                itemLayout="horizontal"
                dataSource={activeWorkspaces}
                renderItem={(workspace) => (
                  <List.Item
                    key={workspace.id}
                    actions={[
                      <Link key="open" href="/keenkonnect/workspaces/my-workspaces">
                        Open
                      </Link>,
                    ]}
                  >
                    <List.Item.Meta
                      title={
                        <Space>
                          <Text strong>{workspace.name}</Text>
                          <Tag color="geekblue">{workspace.focus}</Tag>
                        </Space>
                      }
                      description={
                        <Text type="secondary">
                          {workspace.participants} participants currently active
                        </Text>
                      }
                    />
                  </List.Item>
                )}
              />
            </ProCard>
          </ProCard>
        </ProCard>

        {/* Today at a Glance */}
        <ProCard
          colSpan={{ xs: 24, xl: 8 }}
          title="Today at a Glance"
          extra={<Badge count={notifications.length} offset={[8, 0]} />}
        >
          {/* My Tasks */}
          <ProCard
            title="My Tasks"
            bordered={false}
            size="small"
            // moved from "extra" to "subTitle" to avoid vertical, super-tall header
            subTitle={<Text type="secondary">Focus on impact-critical items</Text>}
          >
            <List
              size="small"
              dataSource={myTasks}
              renderItem={(task) => (
                <List.Item key={task.id}>
                  <List.Item.Meta
                    title={
                      <Space>
                        <Text>{task.title}</Text>
                        <Tag
                          color={
                            task.priority === 'High'
                              ? 'red'
                              : task.priority === 'Medium'
                              ? 'orange'
                              : 'default'
                          }
                        >
                          {task.priority}
                        </Tag>
                      </Space>
                    }
                    description={
                      <Text type="secondary">
                        Due: <strong>{task.due}</strong>
                      </Text>
                    }
                  />
                </List.Item>
              )}
            />
          </ProCard>

          <Divider style={{ margin: '12px 0' }} />

          {/* Notifications */}
          <ProCard
            title={
              <Space>
                <BellOutlined />
                <span>Notifications</span>
              </Space>
            }
            bordered={false}
            size="small"
          >
            <List
              size="small"
              dataSource={notifications}
              renderItem={(item) => (
                <List.Item key={item.id}>
                  <Space direction="vertical" size={0} style={{ width: '100%' }}>
                    <Text>{item.message}</Text>
                    <Text type="secondary" style={{ fontSize: 12 }}>
                      {item.time}
                    </Text>
                  </Space>
                </List.Item>
              )}
            />
          </ProCard>
        </ProCard>
      </ProCard>

      {/* Knowledge Hub & Recent Activity */}
      <ProCard gutter={16} split="vertical" style={{ marginBottom: 16 }}>
        {/* Knowledge Hub */}
        <ProCard
          colSpan={{ xs: 24, md: 12 }}
          title="Knowledge Hub"
          subTitle="Methods, playbooks, and shared assets"
          extra={
            <Link href="/keenkonnect/knowledge/browse-repository">
              <Space size={4}>
                <span>Open knowledge hub</span>
                <ArrowRightOutlined />
              </Space>
            </Link>
          }
        >
          <List
            itemLayout="horizontal"
            dataSource={knowledgeItems}
            renderItem={(item) => (
              <List.Item
                key={item.id}
                actions={[
                  <Link key="open" href={item.link}>
                    View
                  </Link>,
                ]}
              >
                <List.Item.Meta
                  avatar={
                    <Avatar
                      style={{ backgroundColor: '#f5f5f5', color: '#555' }}
                      icon={<FileTextOutlined />}
                    />
                  }
                  title={
                    <Space>
                      <Text strong>{item.title}</Text>
                      <Tag>{item.type}</Tag>
                    </Space>
                  }
                  description={
                    <Text type="secondary">Recently used in your workspaces</Text>
                  }
                />
              </List.Item>
            )}
          />
        </ProCard>

        {/* Recent Activity */}
        <ProCard
          colSpan={{ xs: 24, md: 12 }}
          title="Recent Activity"
          subTitle="What changed in your ecosystem"
        >
          <Timeline
            mode="left"
            items={activityTimeline.map((event) => ({
              key: event.id,
              dot: <ClockCircleOutlined />,
              children: (
                <Space direction="vertical" size={0}>
                  <Text strong>{event.time}</Text>
                  <Text type="secondary">{event.description}</Text>
                </Space>
              ),
            }))}
          />
        </ProCard>
      </ProCard>

      {/* AI matching + Ethikos Profile & Quick Actions */}
      <ProCard gutter={16} split="vertical">
        {/* AI Team Matching */}
        <ProCard
          colSpan={{ xs: 24, md: 12 }}
          title="AI Team Matching"
          subTitle="Smart suggestions for project teams"
          extra={
            <Space>
              <Link href="/keenkonnect/ai-team-matching/my-matches">
                <Button type="link" size="small">
                  View matches
                </Button>
              </Link>
              <Link href="/keenkonnect/ai-team-matching/match-preferences">
                <Button type="primary" size="small" icon={<TeamOutlined />}>
                  New matching run
                </Button>
              </Link>
            </Space>
          }
        >
          <Paragraph>
            AI matching analyses expertise, diversity, and collaboration patterns across
            your ecosystem to propose high‚Äëimpact teams.
          </Paragraph>
          <List
            size="small"
            header={<Text strong>Highlights</Text>}
            dataSource={[
              '4 new suggested teams for climate resilience projects',
              '2 under‚Äëutilised experts flagged for upcoming workspaces',
              '1 cross‚Äëecosystem collaboration opportunity linking Montreal & Nairobi labs',
            ]}
            renderItem={(text, idx) => (
              <List.Item key={idx}>
                <Text>{text}</Text>
              </List.Item>
            )}
          />
        </ProCard>

        {/* Ethikos Profile & Quick Actions */}
        <ProCard
          colSpan={{ xs: 24, md: 12 }}
          title="Ethikos Profile & Impact"
          subTitle="How your orchestration shows up across the network"
        >
          <Space direction="vertical" size="middle" style={{ width: '100%' }}>
            <Space align="center">
              <Badge.Ribbon text="Beta">
                <Avatar
                  size={56}
                  style={{ backgroundColor: '#faad14', marginRight: 12 }}
                  icon={<CrownOutlined />}
                />
              </Badge.Ribbon>
              <div>
                <Text strong>Ethikos Orchestrator Profile</Text>
                <br />
                <Text type="secondary">
                  Reputation, trust and ethical alignment ‚Äî integrated with KeenKonnect.
                </Text>
              </div>
            </Space>

            <div>
              <Text type="secondary">Profile completeness</Text>
              <Progress percent={68} size="small" />
            </div>

            <div>
              <Text type="secondary">Impact coverage across SDGs</Text>
              <Progress
                percent={72}
                size="small"
                success={{ percent: 40 }}
                format={(percent) => `${percent}% of mapped initiatives`}
              />
            </div>

            <Divider style={{ margin: '8px 0' }} />

            <ProCard
              title="Quick actions"
              bordered={false}
              size="small"
              ghost
              style={{ padding: 0 }}
            >
              <List
                grid={{ gutter: 16, xs: 1, sm: 2 }}
                dataSource={quickActions}
                renderItem={(action) => (
                  <List.Item key={action.key}>
                    <Space direction="vertical" size={4} style={{ width: '100%' }}>
                      <Link href={action.href}>
                        <Button block icon={action.icon}>
                          {action.title}
                        </Button>
                      </Link>
                      <Text type="secondary" style={{ fontSize: 12 }}>
                        {action.description}
                      </Text>
                    </Space>
                  </List.Item>
                )}
              />
            </ProCard>
          </Space>
        </ProCard>
      </ProCard>
    </PageContainer>
  );
}

===== END app/keenkonnect/dashboard/page.tsx =====


===== BEGIN app/keenkonnect/KeenPageShell.tsx =====
'use client';

import React from 'react';
import Head from 'next/head';
import usePageTitle from '@/hooks/usePageTitle';

type KeenPageProps = {
  /** Gros titre de la page, affich√© en <h1> */
  title: string;

  /** Sous-titre / description sous le titre */
  description?: string;

  /** Titre <title> du navigateur. Si non fourni, on g√©n√®re "KeenKonnect ¬∑ {title}" */
  metaTitle?: string;

  /** Contenu principal de la page */
  children: React.ReactNode;

  /**
   * √âl√©ment(s) √† droite du titre (boutons d‚Äôaction, filtres, etc.)
   * ex: <Button type="primary">New</Button>
   */
  toolbar?: React.ReactNode;

  /** Largeur max de la zone centrale */
  maxWidth?: number | string;
};

export default function KeenPage({
  title,
  description,
  metaTitle,
  children,
  toolbar,
  maxWidth = 1200,
}: KeenPageProps) {
  const finalMetaTitle = metaTitle ?? `KeenKonnect ¬∑ ${title}`;

  // Synchronise le titre de l‚Äôonglet (hook existant dans ton codebase)
  usePageTitle(finalMetaTitle);

  return (
    <>
      <Head>
        <title>{finalMetaTitle}</title>
      </Head>

      <div className="container mx-auto p-5" style={{ maxWidth }}>
        {/* Header de page standardis√© */}
        <div className="mb-4 flex flex-wrap items-center justify-between gap-3">
          <div>
            <h1 className="text-2xl font-bold">{title}</h1>
            {description && (
              <p className="mt-1 text-gray-500">{description}</p>
            )}
          </div>

          {toolbar && <div className="flex items-center gap-2">{toolbar}</div>}
        </div>

        {/* Contenu sp√©cifique √† la page */}
        {children}
      </div>
    </>
  );
}

===== END app/keenkonnect/KeenPageShell.tsx =====


===== BEGIN app/keenkonnect/knowledge/browse-repository/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import Head from 'next/head';
import { Card, Row, Col, Tree, Input, Select, Tag, Space, Typography } from 'antd';
import type { DataNode, TreeProps } from 'antd/es/tree';
import { ProTable, type ProColumns } from '@ant-design/pro-components';
import { FolderOpenOutlined, FileTextOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';

const { Search } = Input;
const { Title, Text } = Typography;

/**
 * Vocabulaire du d√©p√¥t de connaissances KeenKonnect
 * (align√© avec la doc : domaines, types, niveaux d'acc√®s, statuts)
 */
const DOMAINS = ['Robotics', 'Healthcare', 'Education', 'Civic Engagement'] as const;
const KINDS = ['Blueprint', 'Protocol', 'Case Study', 'Toolkit'] as const;

type Domain = (typeof DOMAINS)[number];
type Kind = (typeof KINDS)[number];
type AccessLevel = 'Public' | 'Member' | 'Partner';
type Status = 'Published' | 'Draft';

type KnowledgeDocument = {
  id: string;
  title: string;
  domain: Domain;
  kind: Kind;
  access: AccessLevel;
  status: Status;
  updatedAt: string; // ISO date string
  owner: string;
  tags: string[];
};

type TreeKey = 'all' | Domain | `${Domain}|${Kind}`;
type AccessFilter = 'all' | AccessLevel;
type StatusFilter = 'all' | Status;

/**
 * Arborescence du d√©p√¥t : domaine -> type de ressource
 */
const treeData: DataNode[] = [
  {
    key: 'all' as TreeKey,
    title: 'Tous les contenus',
    icon: <FolderOpenOutlined />,
  },
  {
    key: 'Robotics' as TreeKey,
    title: 'Robotics',
    icon: <FolderOpenOutlined />,
    children: [
      { key: 'Robotics|Blueprint' as TreeKey, title: 'Blueprints', icon: <FileTextOutlined /> },
      { key: 'Robotics|Protocol' as TreeKey, title: 'Protocols', icon: <FileTextOutlined /> },
      { key: 'Robotics|Case Study' as TreeKey, title: 'Case Studies', icon: <FileTextOutlined /> },
      { key: 'Robotics|Toolkit' as TreeKey, title: 'Toolkits', icon: <FileTextOutlined /> },
    ],
  },
  {
    key: 'Healthcare' as TreeKey,
    title: 'Healthcare',
    icon: <FolderOpenOutlined />,
    children: [
      { key: 'Healthcare|Blueprint' as TreeKey, title: 'Blueprints', icon: <FileTextOutlined /> },
      { key: 'Healthcare|Protocol' as TreeKey, title: 'Protocols', icon: <FileTextOutlined /> },
      { key: 'Healthcare|Case Study' as TreeKey, title: 'Case Studies', icon: <FileTextOutlined /> },
      { key: 'Healthcare|Toolkit' as TreeKey, title: 'Toolkits', icon: <FileTextOutlined /> },
    ],
  },
  {
    key: 'Education' as TreeKey,
    title: 'Education',
    icon: <FolderOpenOutlined />,
    children: [
      { key: 'Education|Blueprint' as TreeKey, title: 'Blueprints', icon: <FileTextOutlined /> },
      { key: 'Education|Protocol' as TreeKey, title: 'Protocols', icon: <FileTextOutlined /> },
      { key: 'Education|Case Study' as TreeKey, title: 'Case Studies', icon: <FileTextOutlined /> },
      { key: 'Education|Toolkit' as TreeKey, title: 'Toolkits', icon: <FileTextOutlined /> },
    ],
  },
  {
    key: 'Civic Engagement' as TreeKey,
    title: 'Civic Engagement',
    icon: <FolderOpenOutlined />,
    children: [
      {
        key: 'Civic Engagement|Blueprint' as TreeKey,
        title: 'Blueprints',
        icon: <FileTextOutlined />,
      },
      {
        key: 'Civic Engagement|Protocol' as TreeKey,
        title: 'Protocols',
        icon: <FileTextOutlined />,
      },
      {
        key: 'Civic Engagement|Case Study' as TreeKey,
        title: 'Case Studies',
        icon: <FileTextOutlined />,
      },
      {
        key: 'Civic Engagement|Toolkit' as TreeKey,
        title: 'Toolkits',
        icon: <FileTextOutlined />,
      },
    ],
  },
];

/**
 * Donn√©es de d√©monstration align√©es avec KeenKonnect Knowledge
 * (domains, types, tags...).
 */
const MOCK_DOCUMENTS: KnowledgeDocument[] = [
  {
    id: 'doc-001',
    title: 'Blueprint robotique ‚Äì Drone civique open-source',
    domain: 'Robotics',
    kind: 'Blueprint',
    access: 'Public',
    status: 'Published',
    updatedAt: '2025-02-15',
    owner: 'Collectif Drones Montr√©al',
    tags: ['drone', 'mobilit√©', 'open hardware'],
  },
  {
    id: 'doc-002',
    title: 'Toolkit ‚Äì Robots d‚Äôassistance pour biblioth√®ques de quartier',
    domain: 'Robotics',
    kind: 'Toolkit',
    access: 'Member',
    status: 'Published',
    updatedAt: '2025-01-20',
    owner: 'KeenKonnect Robotics Guild',
    tags: ['inclusion', 'accessibilit√©', 'biblioth√®que'],
  },
  {
    id: 'doc-003',
    title: 'Protocole de t√©l√©m√©decine pour cliniques mobiles',
    domain: 'Healthcare',
    kind: 'Protocol',
    access: 'Public',
    status: 'Draft',
    updatedAt: '2025-03-02',
    owner: 'Coop Sant√© Quartier-Nord',
    tags: ['t√©l√©m√©decine', 'clinique mobile', 'sant√©'],
  },
  {
    id: 'doc-004',
    title: '√âtude de cas ‚Äì R√©seau de soins communautaires',
    domain: 'Healthcare',
    kind: 'Case Study',
    access: 'Partner',
    status: 'Published',
    updatedAt: '2025-01-05',
    owner: 'Healthcare Civic Lab',
    tags: ['r√©seau', 'communaut√©', 'sant√©'],
  },
  {
    id: 'doc-005',
    title: 'Toolkit ‚Äì Atelier de litt√©ratie num√©rique pour ados',
    domain: 'Education',
    kind: 'Toolkit',
    access: 'Public',
    status: 'Published',
    updatedAt: '2024-12-18',
    owner: 'KeenKonnect Learning Hub',
    tags: ['√©ducation', 'num√©rique', 'atelier'],
  },
  {
    id: 'doc-006',
    title: 'Blueprint ‚Äì FabLab scolaire low-cost',
    domain: 'Education',
    kind: 'Blueprint',
    access: 'Member',
    status: 'Draft',
    updatedAt: '2025-02-01',
    owner: 'FabLab √âcole-ouverte',
    tags: ['fablab', '√©cole', 'DIY'],
  },
  {
    id: 'doc-007',
    title: '√âtude de cas ‚Äì Budget participatif de quartier',
    domain: 'Civic Engagement',
    kind: 'Case Study',
    access: 'Public',
    status: 'Published',
    updatedAt: '2024-11-30',
    owner: 'Lab Participation Citoyenne',
    tags: ['budget participatif', 'civic tech', 'gouvernance'],
  },
  {
    id: 'doc-008',
    title: 'Protocole ‚Äì Facilitation d‚Äôassembl√©es citoyennes hybrides',
    domain: 'Civic Engagement',
    kind: 'Protocol',
    access: 'Partner',
    status: 'Draft',
    updatedAt: '2025-01-28',
    owner: 'Civic Engagement Studio',
    tags: ['assembl√©e', 'hybride', 'facilitation'],
  },
];

const ACCESS_FILTER_OPTIONS: { label: string; value: AccessFilter }[] = [
  { label: 'Tous les acc√®s', value: 'all' },
  { label: 'Public', value: 'Public' },
  { label: 'Membres', value: 'Member' },
  { label: 'Partenaires', value: 'Partner' },
];

const STATUS_FILTER_OPTIONS: { label: string; value: StatusFilter }[] = [
  { label: 'Tous les statuts', value: 'all' },
  { label: 'Publi√©', value: 'Published' },
  { label: 'Brouillon', value: 'Draft' },
];

function BrowseRepositoryPage(): JSX.Element {
  const router = useRouter();

  const [selectedKey, setSelectedKey] = useState<TreeKey>('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [accessFilter, setAccessFilter] = useState<AccessFilter>('all');
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');

  const handleTreeSelect: TreeProps['onSelect'] = (keys) => {
    if (!keys || !keys.length) return;
    setSelectedKey(keys[0] as TreeKey);
  };

  const filteredData = useMemo(
    () =>
      MOCK_DOCUMENTS.filter((doc) => {
        // 1) Filtre par arborescence (domaine / type)
        if (selectedKey !== 'all') {
          const [domainKey, kindKey] = selectedKey.split('|') as [
            Domain | undefined,
            Kind | undefined,
          ];

          if (domainKey && doc.domain !== domainKey) {
            return false;
          }
          if (kindKey && doc.kind !== kindKey) {
            return false;
          }
        }

        // 2) Filtre par niveau d‚Äôacc√®s
        if (accessFilter !== 'all' && doc.access !== accessFilter) {
          return false;
        }

        // 3) Filtre par statut
        if (statusFilter !== 'all' && doc.status !== statusFilter) {
          return false;
        }

        // 4) Recherche plein texte
        const trimmed = searchTerm.trim();
        if (!trimmed) return true;

        const needle = trimmed.toLowerCase();
        return (
          doc.title.toLowerCase().includes(needle) ||
          doc.owner.toLowerCase().includes(needle) ||
          doc.domain.toLowerCase().includes(needle) ||
          doc.kind.toLowerCase().includes(needle) ||
          doc.tags.some((tag) => tag.toLowerCase().includes(needle))
        );
      }),
    [selectedKey, accessFilter, statusFilter, searchTerm],
  );

  const columns: ProColumns<KnowledgeDocument>[] = useMemo(
    () => [
      {
        title: 'Titre',
        dataIndex: 'title',
        ellipsis: true,
        width: 260,
      },
      {
        title: 'Domaine',
        dataIndex: 'domain',
        width: 150,
        filters: DOMAINS.map((domain) => ({ text: domain, value: domain })),
        onFilter: (value, record) => record.domain === (value as Domain),
      },
      {
        title: 'Type',
        dataIndex: 'kind',
        width: 150,
        filters: KINDS.map((kind) => ({ text: kind, value: kind })),
        onFilter: (value, record) => record.kind === (value as Kind),
      },
      {
        title: 'Acc√®s',
        dataIndex: 'access',
        width: 120,
        render: (_dom, row) => {
          let color: string = 'default';

          if (row.access === 'Public') color = 'green';
          if (row.access === 'Member') color = 'blue';
          if (row.access === 'Partner') color = 'purple';

          return <Tag color={color}>{row.access}</Tag>;
        },
      },
      {
        title: 'Statut',
        dataIndex: 'status',
        width: 120,
        render: (_dom, row) => (
          <Tag color={row.status === 'Published' ? 'green' : 'gold'}>
            {row.status === 'Published' ? 'Publi√©' : 'Brouillon'}
          </Tag>
        ),
      },
      {
        title: 'Mise √† jour',
        dataIndex: 'updatedAt',
        valueType: 'date',
        width: 130,
      },
      {
        title: 'Propri√©taire',
        dataIndex: 'owner',
        width: 180,
      },
      {
        title: 'Tags',
        dataIndex: 'tags',
        search: false,
        render: (_dom, row) => (
          <Space size={4} wrap>
            {row.tags.map((tag) => (
              <Tag key={tag}>{tag}</Tag>
            ))}
          </Space>
        ),
      },
      {
        title: 'Actions',
        valueType: 'option',
        width: 120,
        render: (_dom, row) => [
          <a
            key="open"
            onClick={() =>
              router.push(`/keenkonnect/knowledge/document/${encodeURIComponent(row.id)}`)
            }
          >
            Ouvrir
          </a>,
        ],
      },
    ],
    [router],
  );

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Parcourir le d√©p√¥t de connaissances</title>
        <meta
          name="description"
          content="Parcourir le d√©p√¥t de connaissances KeenKonnect par domaine, type de ressource et filtres avanc√©s."
        />
      </Head>

      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-4">Parcourir le d√©p√¥t de connaissances</h1>

        <Row gutter={[24, 24]}>
          {/* Panneau de gauche : arbre de navigation */}
          <Col xs={24} lg={6}>
            <Card
              size="small"
              bordered={false}
              title="Arborescence du d√©p√¥t"
              headStyle={{ fontWeight: 600 }}
            >
              <Text type="secondary">
                Naviguez par domaine et type de ressource pour filtrer la liste √† droite.
              </Text>

              <div style={{ marginTop: 16 }}>
                <Tree
                  showIcon
                  blockNode
                  defaultExpandAll
                  selectedKeys={[selectedKey]}
                  onSelect={handleTreeSelect}
                  treeData={treeData}
                />
              </div>
            </Card>
          </Col>

          {/* Panneau de droite : recherche + ProTable */}
          <Col xs={24} lg={18}>
            <Card
              size="small"
              bordered={false}
              title={
                <Space direction="vertical" size={0}>
                  <Title level={4} style={{ margin: 0 }}>
                    Parcourir les ressources
                  </Title>
                  <Text type="secondary">
                    Combinez l‚Äôarborescence, la recherche et les filtres pour trouver
                    rapidement les ressources KeenKonnect.
                  </Text>
                </Space>
              }
            >
              <Space direction="vertical" size="large" style={{ width: '100%' }}>
                <Space
                  wrap
                  style={{
                    width: '100%',
                    justifyContent: 'space-between',
                    rowGap: 16,
                  }}
                >
                  <Search
                    placeholder="Rechercher par titre, tag, propri√©taire‚Ä¶"
                    allowClear
                    style={{ maxWidth: 360 }}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    onSearch={(value) => setSearchTerm(value.trim())}
                  />

                  <Space wrap>
                    <Select<AccessFilter>
                      allowClear
                      placeholder="Niveau d'acc√®s"
                      style={{ minWidth: 160 }}
                      value={accessFilter === 'all' ? undefined : accessFilter}
                      onChange={(value) => setAccessFilter(value ?? 'all')}
                      options={ACCESS_FILTER_OPTIONS}
                    />
                    <Select<StatusFilter>
                      allowClear
                      placeholder="Statut"
                      style={{ minWidth: 160 }}
                      value={statusFilter === 'all' ? undefined : statusFilter}
                      onChange={(value) => setStatusFilter(value ?? 'all')}
                      options={STATUS_FILTER_OPTIONS}
                    />
                  </Space>
                </Space>

                <ProTable<KnowledgeDocument>
                  rowKey="id"
                  search={false}
                  options={false}
                  toolBarRender={false}
                  size="small"
                  dataSource={filteredData}
                  columns={columns}
                  pagination={{
                    pageSize: 10,
                    showSizeChanger: false,
                  }}
                />
              </Space>
            </Card>
          </Col>
        </Row>
      </div>
    </>
  );
}

export default BrowseRepositoryPage;

===== END app/keenkonnect/knowledge/browse-repository/page.tsx =====


===== BEGIN app/keenkonnect/knowledge/document-management/page.tsx =====
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Avatar,
  Button,
  Card,
  Col,
  Divider,
  Drawer,
  Input,
  List,
  Row,
  Space,
  Switch,
  Tag,
  Tooltip,
  message,
} from 'antd';
import {
  EyeOutlined,
  PlusOutlined,
  SaveOutlined,
  UploadOutlined,
} from '@ant-design/icons';
import {
  EditableProTable,
  ModalForm,
  ProFormSelect,
  ProFormSwitch,
  ProFormText,
  ProFormTextArea,
  type ProColumns,
} from '@ant-design/pro-components';
import { Comment } from '@ant-design/compatible';
import usePageTitle from '@/hooks/usePageTitle';

const { TextArea } = Input;

type DocumentStatus = 'Draft' | 'Published' | 'Archived';

type ManagedDocument = {
  id: string;
  title: string;
  category: string;
  language: string;
  owner: string;
  status: DocumentStatus;
  aiIndexed: boolean;
  visible: boolean;
  version: string;
  updatedAt: string;
  tags: string[];
  summary: string;
};

type VersionItem = {
  version: string;
  timestamp: string;
  author: string;
  changeSummary: string;
};

type CommentItem = {
  id: number;
  author: string;
  avatar: string;
  content: string;
  datetime: string;
};

type NewDocumentFormValues = {
  title: string;
  category: string;
  language: string;
  owner?: string;
  status?: DocumentStatus;
  aiIndexed?: boolean;
  visible?: boolean;
  tags?: string[];
  summary?: string;
};

const initialDocuments: ManagedDocument[] = [
  {
    id: 'doc-1',
    title: 'Innovative Research Document',
    category: 'Research',
    language: 'English',
    owner: 'Dr. Alice Chen',
    status: 'Published',
    aiIndexed: true,
    visible: true,
    version: '1.4',
    updatedAt: '2025-05-12',
    tags: ['robotics', 'clinical-trials'],
    summary:
      'Over the last three funding cycles, the robotics and clinical teams have collaborated on a shared protocol that aligns safety thresholds and trial milestones across sites.',
  },
  {
    id: 'doc-2',
    title: 'Robotics Safety Guidelines ‚Äì v2',
    category: 'Safety & Compliance',
    language: 'English',
    owner: 'Security Office',
    status: 'Draft',
    aiIndexed: false,
    visible: true,
    version: '2.0-draft',
    updatedAt: '2025-04-30',
    tags: ['safety', 'protocol'],
    summary:
      'Draft revision of robotics safety guidelines, including new proximity sensor checks and human-in-the-loop overrides for high‚Äërisk procedures.',
  },
  {
    id: 'doc-3',
    title: 'Clinical Trial Template (Phase II)',
    category: 'Clinical Protocol',
    language: 'French',
    owner: 'Clinical Ops',
    status: 'Published',
    aiIndexed: true,
    visible: true,
    version: '1.1',
    updatedAt: '2025-03-18',
    tags: ['template', 'phase-II'],
    summary:
      'Standardized template for Phase II clinical trials, ready for localization and site‚Äëspecific amendments.',
  },
  {
    id: 'doc-4',
    title: 'Legacy Device Integration Notes',
    category: 'Design Blueprint',
    language: 'English',
    owner: 'Systems Engineering',
    status: 'Archived',
    aiIndexed: false,
    visible: false,
    version: '0.9',
    updatedAt: '2024-12-02',
    tags: ['legacy', 'integration'],
    summary:
      'Historical notes on integrating first‚Äëgeneration devices with the current control stack. Kept for traceability.',
  },
  {
    id: 'doc-5',
    title: 'Onboarding Learning Module ‚Äì Robotics Basics',
    category: 'Learning Module',
    language: 'French',
    owner: 'People & Culture',
    status: 'Published',
    aiIndexed: true,
    visible: true,
    version: '1.0',
    updatedAt: '2025-01-10',
    tags: ['onboarding', 'training'],
    summary:
      'Introductory learning module that covers robotics fundamentals, safety posture, and escalation paths for new team members.',
  },
];

const versionHistory: VersionItem[] = [
  {
    version: '1.4',
    timestamp: '2025-05-12 10:15',
    author: 'Dr. Alice Chen',
    changeSummary: 'Clarified safety thresholds for Phase II trials.',
  },
  {
    version: '1.3',
    timestamp: '2025-03-28 16:42',
    author: 'Dr. Omar El‚ÄëSayed',
    changeSummary: 'Added cross-site comparison metrics and monitoring hooks.',
  },
  {
    version: '1.2',
    timestamp: '2024-12-09 09:20',
    author: 'Dr. Helena Ruiz',
    changeSummary: 'Aligned terminology with the institutional ethics committee.',
  },
  {
    version: '1.1',
    timestamp: '2024-07-18 14:55',
    author: 'Dr. Alice Chen',
    changeSummary: 'Initial roll‚Äëout for robotics‚Äìclinical protocol harmonization.',
  },
];

const commentsData: CommentItem[] = [
  {
    id: 1,
    author: 'Dr. Alice Chen',
    avatar: 'https://xsgames.co/randomusers/avatar.php?g=female',
    content:
      'Let‚Äôs keep the safety thresholds conservative for the first pilot sites. We can relax them once we have stable telemetry.',
    datetime: '2 hours ago',
  },
  {
    id: 2,
    author: 'Dr. Omar El‚ÄëSayed',
    avatar: 'https://xsgames.co/randomusers/avatar.php?g=male',
    content:
      'Agreed. I‚Äôd also like to add one more metric around post‚Äëop mobility for the robotics‚Äëassisted procedures.',
    datetime: '1 hour ago',
  },
  {
    id: 3,
    author: 'Dr. Helena Ruiz',
    avatar: 'https://xsgames.co/randomusers/avatar.php?g=female',
    content:
      'Once this goes live, I‚Äôll present it to the ethics board. Please tag any sections you expect to change in the next revision.',
    datetime: '25 minutes ago',
  },
];

const getStatusColor = (status: DocumentStatus): string => {
  switch (status) {
    case 'Published':
      return 'green';
    case 'Draft':
      return 'gold';
    case 'Archived':
    default:
      return 'default';
  }
};

export default function DocumentManagementPage() {
  usePageTitle('KeenKonnect ¬∑ Knowledge ¬∑ Document Management');
  const router = useRouter();

  const [dataSource, setDataSource] = useState<ManagedDocument[]>(initialDocuments);
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>([]);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [selectedDocument, setSelectedDocument] =
    useState<ManagedDocument | null>(null);

  const updateDocument = (id: string, patch: Partial<ManagedDocument>) => {
    setDataSource(prev =>
      prev.map(item => (item.id === id ? { ...item, ...patch } : item)),
    );
    setSelectedDocument(prev =>
      prev && prev.id === id ? ({ ...prev, ...patch } as ManagedDocument) : prev,
    );
  };

  const handleSaveChanges = () => {
    if (!selectedDocument) return;
    // Simulation d‚Äôun appel API
    // eslint-disable-next-line no-console
    console.log('Saving changes for document', selectedDocument.id);
    message.success('Changes saved (simulated).');
  };

  const handlePublishNewVersion = () => {
    if (!selectedDocument) return;
    // eslint-disable-next-line no-console
    console.log('Publishing new version for document', selectedDocument.id);
    message.success('New version published (simulated).');
  };

  const handleCreateDocument = async (values: NewDocumentFormValues) => {
    const now = new Date();
    const newDoc: ManagedDocument = {
      id: `doc-${now.getTime()}`,
      title: values.title,
      category: values.category,
      language: values.language,
      owner: values.owner || 'You',
      status: values.status || 'Draft',
      aiIndexed: values.aiIndexed ?? true,
      visible: values.visible ?? true,
      version: '1.0',
      updatedAt: now.toISOString().slice(0, 10),
      tags: values.tags && values.tags.length ? values.tags : ['draft'],
      summary:
        values.summary ||
        'New document created from Document Management. Replace this text with the actual content or link to your storage layer.',
    };

    setDataSource(prev => [...prev, newDoc]);
    setSelectedDocument(newDoc);
    setDrawerOpen(true);
    message.success('Document entry created (local example).');

    return true;
  };

  const columns: ProColumns<ManagedDocument>[] = [
    {
      title: 'Title',
      dataIndex: 'title',
      ellipsis: true,
      copyable: true,
      formItemProps: {
        rules: [{ required: true, message: 'Title is required' }],
      },
    },
    {
      title: 'Category',
      dataIndex: 'category',
      valueType: 'select',
      filters: true,
      onFilter: true,
      valueEnum: {
        Research: { text: 'Research' },
        'Safety & Compliance': { text: 'Safety & Compliance' },
        'Clinical Protocol': { text: 'Clinical Protocol' },
        'Design Blueprint': { text: 'Design Blueprint' },
        'Learning Module': { text: 'Learning Module' },
      },
    },
    {
      title: 'Language',
      dataIndex: 'language',
      valueType: 'select',
      filters: true,
      onFilter: true,
      valueEnum: {
        English: { text: 'English' },
        French: { text: 'French' },
      },
      width: 110,
    },
    {
      title: 'Owner',
      dataIndex: 'owner',
      width: 180,
    },
    {
      title: 'Status',
      dataIndex: 'status',
      valueType: 'select',
      filters: true,
      onFilter: true,
      valueEnum: {
        Draft: { text: 'Draft', status: 'Default' },
        Published: { text: 'Published', status: 'Success' },
        Archived: { text: 'Archived', status: 'Default' },
      },
      render: (_, record) => (
        <Tag color={getStatusColor(record.status)}>{record.status}</Tag>
      ),
      width: 120,
    },
    {
      title: 'AI indexing',
      dataIndex: 'aiIndexed',
      valueType: 'switch',
      render: (_, record) => (
        <Tooltip
          title={
            record.aiIndexed
              ? 'Document is used by assistants and semantic search.'
              : 'Document is excluded from AI‚Äëpowered features.'
          }
        >
          <Switch
            size="small"
            checked={record.aiIndexed}
            onChange={checked => updateDocument(record.id, { aiIndexed: checked })}
          />
        </Tooltip>
      ),
      width: 140,
    },
    {
      title: 'Visible',
      dataIndex: 'visible',
      valueType: 'switch',
      render: (_, record) => (
        <Switch
          size="small"
          checked={record.visible}
          onChange={checked => updateDocument(record.id, { visible: checked })}
        />
      ),
      width: 110,
    },
    {
      title: 'Tags',
      dataIndex: 'tags',
      search: false,
      render: (_, record) =>
        record.tags && record.tags.length ? (
          <Space size={[0, 8]} wrap>
            {record.tags.map(tag => (
              <Tag key={tag}>{tag}</Tag>
            ))}
          </Space>
        ) : (
          <span style={{ color: '#999' }}>‚Äî</span>
        ),
    },
    {
      title: 'Last updated',
      dataIndex: 'updatedAt',
      valueType: 'date',
      sorter: (a, b) =>
        new Date(a.updatedAt).getTime() - new Date(b.updatedAt).getTime(),
      width: 140,
    },
    {
      title: 'Version',
      dataIndex: 'version',
      width: 90,
    },
    {
      title: 'Actions',
      valueType: 'option',
      fixed: 'right',
      width: 170,
      render: (_, record, __, action) => [
        <a
          key="view"
          onClick={() => {
            setSelectedDocument(record);
            setDrawerOpen(true);
          }}
        >
          Details
        </a>,
        <a
          key="edit"
          onClick={() => {
            (action as any)?.startEditable?.(record.id);
          }}
        >
          Edit
        </a>,
      ],
    },
  ];

  return (
    <div className="container mx-auto p-5">
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div>
          <h1 className="text-2xl font-bold">Document Management</h1>
          <p className="text-gray-500">
            Manage your knowledge documents, control AI indexing and visibility, and
            inspect versions and comments from one place.
          </p>
        </div>
        <Space>
          <Button
            onClick={() =>
              router.push('/keenkonnect/knowledge/browse-repository')
            }
          >
            Go to library view
          </Button>
        </Space>
      </div>

      <EditableProTable<ManagedDocument>
        rowKey="id"
        bordered
        size="small"
        value={dataSource}
        // important: value from EditableProTable is readonly, so clone it
        onChange={(value: readonly ManagedDocument[]) =>
          setDataSource([...value])
        }
        maxLength={50}
        recordCreatorProps={{
          position: 'bottom',
          newRecordType: 'dataSource',
          record: () => ({
            id: `temp-${Date.now()}`,
            title: 'New document',
            category: 'Research',
            language: 'English',
            owner: 'You',
            status: 'Draft' as DocumentStatus,
            aiIndexed: true,
            visible: true,
            version: '0.1',
            updatedAt: new Date().toISOString().slice(0, 10),
            tags: ['draft'],
            summary:
              'New draft document created inline from the table. Use the drawer to refine metadata and content.',
          }),
        }}
        toolBarRender={() => [
          <ModalForm<NewDocumentFormValues>
            key="new"
            title="Add document entry"
            trigger={
              <Button type="primary" icon={<PlusOutlined />}>
                New document
              </Button>
            }
            modalProps={{ destroyOnClose: true }}
            initialValues={{
              status: 'Draft',
              language: 'English',
              aiIndexed: true,
              visible: true,
            }}
            onFinish={handleCreateDocument}
          >
            <ProFormText
              name="title"
              label="Title"
              rules={[{ required: true, message: 'Please enter a title' }]}
            />
            <ProFormSelect
              name="category"
              label="Category"
              options={[
                { label: 'Research', value: 'Research' },
                { label: 'Safety & Compliance', value: 'Safety & Compliance' },
                { label: 'Clinical Protocol', value: 'Clinical Protocol' },
                { label: 'Design Blueprint', value: 'Design Blueprint' },
                { label: 'Learning Module', value: 'Learning Module' },
              ]}
              rules={[{ required: true, message: 'Please choose a category' }]}
            />
            <ProFormSelect
              name="language"
              label="Language"
              options={[
                { label: 'English', value: 'English' },
                { label: 'French', value: 'French' },
              ]}
              rules={[{ required: true, message: 'Please choose a language' }]}
            />
            <ProFormText name="owner" label="Owner" />
            <ProFormSelect
              name="status"
              label="Status"
              options={[
                { label: 'Draft', value: 'Draft' },
                { label: 'Published', value: 'Published' },
                { label: 'Archived', value: 'Archived' },
              ]}
            />
            <ProFormSelect
              name="tags"
              label="Tags"
              mode="tags"
              fieldProps={{
                tokenSeparators: [','],
              }}
              placeholder="Add tags (press Enter or comma)"
            />
            <ProFormSwitch
              name="aiIndexed"
              label="Include in AI indexing"
            />
            <ProFormSwitch
              name="visible"
              label="Visible in library"
            />
            <ProFormTextArea
              name="summary"
              label="Short content / summary"
              fieldProps={{ rows: 4 }}
            />
          </ModalForm>,
          <Button
            key="upload"
            icon={<UploadOutlined />}
            onClick={() =>
              router.push('/keenkonnect/knowledge/upload-new-document')
            }
          >
            Upload new file
          </Button>,
        ]}
        columns={columns}
        editable={{
          type: 'multiple',
          editableKeys,
          onChange: setEditableRowKeys,
          onSave: async (_key, row) => {
            setDataSource(prev =>
              prev.map(item => (item.id === row.id ? { ...item, ...row } : item)),
            );
          },
        }}
      />

      <Drawer
        title={selectedDocument ? 'Document details' : undefined}
        open={drawerOpen}
        onClose={() => setDrawerOpen(false)}
        width={1000}
        destroyOnClose
      >
        {selectedDocument && (
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <div className="flex flex-wrap items-center justify-between gap-3">
              <div>
                <h2 className="mb-1 text-xl font-semibold">
                  {selectedDocument.title}
                </h2>
                <div className="text-sm text-gray-500">
                  Last updated {selectedDocument.updatedAt} ¬∑ Owner{' '}
                  {selectedDocument.owner}
                </div>
              </div>
              <Space wrap>
                <Tag color={getStatusColor(selectedDocument.status)}>
                  {selectedDocument.status}
                </Tag>
                {selectedDocument.tags.map(tag => (
                  <Tag key={tag}>{tag}</Tag>
                ))}
              </Space>
            </div>

            <Row gutter={16}>
              <Col xs={24} md={14}>
                <Card
                  title="Real‚Äëtime editing (simulated)"
                  extra={
                    <Tooltip title="Open full editor in Konstruct (future integration)">
                      <Button type="link" icon={<EyeOutlined />}>
                        Open in Konstruct
                      </Button>
                    </Tooltip>
                  }
                >
                  <TextArea
                    rows={10}
                    value={selectedDocument.summary}
                    onChange={e =>
                      updateDocument(selectedDocument.id, {
                        summary: e.target.value,
                      })
                    }
                  />
                  <Divider />
                  <Space>
                    <Button
                      type="primary"
                      icon={<SaveOutlined />}
                      onClick={handleSaveChanges}
                    >
                      Save changes
                    </Button>
                    <Button
                      icon={<UploadOutlined />}
                      onClick={handlePublishNewVersion}
                    >
                      Publish new version
                    </Button>
                  </Space>
                </Card>
              </Col>

              <Col xs={24} md={10}>
                <Card title="Metadata & access control">
                  <p>
                    <strong>Category:</strong> {selectedDocument.category}
                  </p>
                  <p>
                    <strong>Language:</strong> {selectedDocument.language}
                  </p>
                  <p>
                    <strong>Version:</strong> {selectedDocument.version}
                  </p>
                  <p>
                    <strong>AI indexing:</strong>{' '}
                    <Switch
                      size="small"
                      checked={selectedDocument.aiIndexed}
                      onChange={checked =>
                        updateDocument(selectedDocument.id, {
                          aiIndexed: checked,
                        })
                      }
                    />
                  </p>
                  <p>
                    <strong>Visible in library:</strong>{' '}
                    <Switch
                      size="small"
                      checked={selectedDocument.visible}
                      onChange={checked =>
                        updateDocument(selectedDocument.id, {
                          visible: checked,
                        })
                      }
                    />
                  </p>
                  <p>
                    <strong>Tags:</strong>{' '}
                    {selectedDocument.tags.length ? (
                      <Space size={[0, 8]} wrap>
                        {selectedDocument.tags.map(tag => (
                          <Tag key={tag}>{tag}</Tag>
                        ))}
                      </Space>
                    ) : (
                      <span style={{ color: '#999' }}>None</span>
                    )}
                  </p>
                </Card>

                <Card title="Version history" className="mt-4">
                  <List
                    size="small"
                    dataSource={versionHistory}
                    renderItem={item => (
                      <List.Item key={item.version}>
                        <List.Item.Meta
                          title={`${item.version} ¬∑ ${item.timestamp}`}
                          description={
                            <>
                              <div>
                                <strong>{item.author}</strong>
                              </div>
                              <div>{item.changeSummary}</div>
                            </>
                          }
                        />
                      </List.Item>
                    )}
                  />
                  <Button
                    type="link"
                    style={{ padding: 0, marginTop: 8 }}
                  >
                    Compare / restore versions
                  </Button>
                </Card>

                <Card title="Comments (simulated thread)" className="mt-4">
                  <List
                    itemLayout="horizontal"
                    dataSource={commentsData}
                    renderItem={comment => (
                      <Comment
                        key={comment.id}
                        author={comment.author}
                        avatar={<Avatar src={comment.avatar} />}
                        content={comment.content}
                        datetime={comment.datetime}
                      />
                    )}
                  />
                </Card>
              </Col>
            </Row>
          </Space>
        )}
      </Drawer>
    </div>
  );
}

===== END app/keenkonnect/knowledge/document-management/page.tsx =====


===== BEGIN app/keenkonnect/knowledge/search-filter-documents/page.tsx =====
'use client'

import React, { useMemo, useState } from 'react'
import Head from 'next/head'
import { Card, Alert, Pagination, Tag } from 'antd'
import type { PaginationProps } from 'antd'
import dayjs, { Dayjs } from 'dayjs'
import type { ProColumns } from '@ant-design/pro-components'
import {
  ProTable,
  QueryFilter,
  ProFormText,
  ProFormSelect,
  ProFormDateRangePicker,
} from '@ant-design/pro-components'

interface DocumentResource {
  key: string
  title: string
  snippet: string
  author: string
  tags: string[]
  language: string
  version: string
  lastUpdated: string // ISO date
  relevanceScore: number
}

type DateRangeValue = [Dayjs, Dayjs] | undefined
type SortOption = 'relevance' | 'date' | 'popularity'

interface FilterState {
  keyword?: string
  authors?: string[]
  tags?: string[]
  language?: string
  dateRange?: DateRangeValue
  sort: SortOption
}

// Demo data (m√™me contenu que l‚Äôancienne page)
const sampleDocuments: DocumentResource[] = [
  {
    key: '1',
    title: 'Robotics Blueprint',
    snippet: 'Detailed blueprint for advanced robotics design.',
    author: 'Alice',
    tags: ['Robotics', 'Engineering'],
    language: 'English',
    version: '1.0',
    lastUpdated: '2023-09-01',
    relevanceScore: 95,
  },
  {
    key: '2',
    title: 'AI Ethics Guidelines',
    snippet: 'Comprehensive guidelines for ethical AI development.',
    author: 'Bob',
    tags: ['AI', 'Ethics'],
    language: 'English',
    version: '2.0',
    lastUpdated: '2023-08-15',
    relevanceScore: 90,
  },
  {
    key: '3',
    title: 'Healthcare Innovation Report',
    snippet: 'Annual report on innovation in healthcare technologies.',
    author: 'Charlie',
    tags: ['Healthcare', 'Innovation'],
    language: 'French',
    version: '1.2',
    lastUpdated: '2023-07-20',
    relevanceScore: 88,
  },
  {
    key: '4',
    title: 'Environmental Impact Study',
    snippet: 'Study on environmental impact of industrial activities.',
    author: 'Diana',
    tags: ['Environment', 'Sustainability'],
    language: 'English',
    version: '1.3',
    lastUpdated: '2023-06-10',
    relevanceScore: 85,
  },
  {
    key: '5',
    title: 'Quantum Computing Overview',
    snippet: 'Introduction to quantum computing concepts and applications.',
    author: 'Alice',
    tags: ['Quantum', 'Computing'],
    language: 'English',
    version: '1.1',
    lastUpdated: '2023-05-05',
    relevanceScore: 92,
  },
]

const allAuthors = Array.from(new Set(sampleDocuments.map((d) => d.author))).sort()
const allTags = Array.from(
  new Set(sampleDocuments.flatMap((d) => d.tags)),
).sort()
const allLanguages = Array.from(
  new Set(sampleDocuments.map((d) => d.language)),
).sort()

const DEFAULT_SORT: SortOption = 'relevance'

export default function SearchFilterDocumentsPage(): JSX.Element {
  const [filters, setFilters] = useState<FilterState>({
    sort: DEFAULT_SORT,
  })
  const [currentPage, setCurrentPage] = useState<number>(1)
  const [pageSize, setPageSize] = useState<number>(5)

  const handleFilterFinish = async (values: Record<string, any>) => {
    const nextFilters: FilterState = {
      keyword: values.keyword?.trim() || undefined,
      authors: values.authors ?? [],
      tags: values.tags ?? [],
      language: values.language || undefined,
      dateRange: values.dateRange as DateRangeValue,
      sort: (values.sort as SortOption) ?? DEFAULT_SORT,
    }

    setFilters(nextFilters)
    setCurrentPage(1)

    // ProForm attend un bool pour onFinish
    return true
  }

  const handleFilterReset = () => {
    setFilters({ sort: DEFAULT_SORT })
    setCurrentPage(1)
  }

  const filteredDocuments = useMemo(() => {
    const { keyword, authors, tags, language, dateRange } = filters

    return sampleDocuments.filter((doc) => {
      const matchesKeyword =
        !keyword ||
        doc.title.toLowerCase().includes(keyword.toLowerCase()) ||
        doc.snippet.toLowerCase().includes(keyword.toLowerCase())

      const matchesAuthor =
        !authors || authors.length === 0 || authors.includes(doc.author)

      const matchesTags =
        !tags ||
        tags.length === 0 ||
        tags.every((t) => doc.tags.includes(t))

      const matchesLanguage =
        !language || doc.language === language

      let matchesDate = true
      if (dateRange && dateRange[0] && dateRange[1]) {
        const [start, end] = dateRange
        const docDate = dayjs(doc.lastUpdated)

        if (start) {
          matchesDate =
            docDate.isSame(start, 'day') || docDate.isAfter(start, 'day')
        }
        if (matchesDate && end) {
          matchesDate =
            docDate.isSame(end, 'day') || docDate.isBefore(end, 'day')
        }
      }

      return (
        matchesKeyword &&
        matchesAuthor &&
        matchesTags &&
        matchesLanguage &&
        matchesDate
      )
    })
  }, [filters])

  const sortedDocuments = useMemo(() => {
    const docs = [...filteredDocuments]
    const sort = filters.sort

    switch (sort) {
      case 'date':
        docs.sort(
          (a, b) =>
            new Date(b.lastUpdated).getTime() -
            new Date(a.lastUpdated).getTime(),
        )
        break
      case 'popularity':
        // Placeholder : on r√©utilise le score de pertinence
        docs.sort((a, b) => b.relevanceScore - a.relevanceScore)
        break
      case 'relevance':
      default:
        docs.sort((a, b) => b.relevanceScore - a.relevanceScore)
        break
    }

    return docs
  }, [filteredDocuments, filters.sort])

  const paginatedDocuments = useMemo(() => {
    const start = (currentPage - 1) * pageSize
    const end = start + pageSize
    return sortedDocuments.slice(start, end)
  }, [sortedDocuments, currentPage, pageSize])

  const total = sortedDocuments.length

  const activeFilterCount = useMemo(() => {
    let count = 0
    if (filters.keyword && filters.keyword.trim()) count++
    if (filters.authors && filters.authors.length > 0) count++
    if (filters.tags && filters.tags.length > 0) count++
    if (filters.language) count++
    if (
      filters.dateRange &&
      filters.dateRange[0] &&
      filters.dateRange[1]
    ) {
      count++
    }
    return count
  }, [filters])

  const columns: ProColumns<DocumentResource>[] = [
    {
      title: 'Title & Snippet',
      dataIndex: 'title',
      key: 'title',
      ellipsis: true,
      render: (_, record) => (
        <div>
          <div style={{ fontWeight: 500 }}>{record.title}</div>
          <div
            style={{
              fontSize: 12,
              color: 'rgba(0,0,0,0.45)',
              marginTop: 4,
            }}
          >
            {record.snippet}
          </div>
        </div>
      ),
    },
    {
      title: 'Author',
      dataIndex: 'author',
      key: 'author',
      width: 140,
    },
    {
      title: 'Tags',
      dataIndex: 'tags',
      key: 'tags',
      width: 220,
      render: (_, record) => (
        <>
          {record.tags.map((tag) => (
            <Tag key={tag}>{tag}</Tag>
          ))}
        </>
      ),
    },
    {
      title: 'Language',
      dataIndex: 'language',
      key: 'language',
      width: 110,
    },
    {
      title: 'Version',
      dataIndex: 'version',
      key: 'version',
      width: 90,
    },
    {
      title: 'Last Updated',
      dataIndex: 'lastUpdated',
      key: 'lastUpdated',
      width: 140,
    },
    {
      title: 'Relevance',
      dataIndex: 'relevanceScore',
      key: 'relevanceScore',
      width: 120,
      sorter: (a, b) => a.relevanceScore - b.relevanceScore,
    },
  ]

  const paginationProps: PaginationProps = {
    current: currentPage,
    pageSize,
    total,
    showSizeChanger: true,
    pageSizeOptions: ['5', '10', '20'],
    showTotal: (totalItems, range) =>
      `${range[0]}-${range[1]} of ${totalItems} document${
        totalItems > 1 ? 's' : ''
      }`,
    onChange: (page, size) => {
      setCurrentPage(page)
      setPageSize(size || pageSize)
    },
  }

  const sortLabel = filters.sort
    .toString()
    .replace(/^\w/, (c) => c.toUpperCase())

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Search &amp; Filter Documents</title>
        <meta
          name="description"
          content="Advanced search and filtering for knowledge documents in KeenKonnect."
        />
      </Head>

      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-4">
          Search &amp; Filter Documents
        </h1>

        {/* Bloc de filtres avanc√©s (ProForm / QueryFilter) */}
        <Card className="mb-4">
          <QueryFilter
            onFinish={handleFilterFinish}
            onReset={handleFilterReset}
            labelWidth="auto"
            defaultCollapsed={false}
            span={8}
            initialValues={{ sort: DEFAULT_SORT }}
          >
            <ProFormText
              name="keyword"
              label="Keywords"
              placeholder="Search by title or content"
            />

            <ProFormSelect
              name="authors"
              label="Authors"
              placeholder="Select authors"
              mode="multiple"
              options={allAuthors.map((a) => ({
                label: a,
                value: a,
              }))}
            />

            <ProFormSelect
              name="tags"
              label="Tags"
              placeholder="Select tags"
              mode="multiple"
              options={allTags.map((t) => ({
                label: t,
                value: t,
              }))}
            />

            <ProFormSelect
              name="language"
              label="Language"
              placeholder="All languages"
              allowClear
              options={allLanguages.map((lang) => ({
                label: lang,
                value: lang,
              }))}
            />

            <ProFormDateRangePicker
              name="dateRange"
              label="Last Updated"
              placeholder={['From', 'To']}
            />

            <ProFormSelect
              name="sort"
              label="Sort By"
              options={[
                { label: 'Relevance', value: 'relevance' },
                { label: 'Date', value: 'date' },
                { label: 'Popularity', value: 'popularity' },
              ]}
            />
          </QueryFilter>
        </Card>

        {/* Alert de synth√®se des r√©sultats / filtres */}
        <Alert
          type={total === 0 ? 'warning' : 'info'}
          showIcon
          className="mb-4"
          message={
            total === 0
              ? 'No documents match your criteria.'
              : `${total} document${total > 1 ? 's' : ''} match your criteria.`
          }
          description={
            <div style={{ fontSize: 12 }}>
              <div>
                Sort:{' '}
                <strong>
                  {sortLabel}
                </strong>
              </div>
              <div>
                Active filters:{' '}
                <strong>{activeFilterCount}</strong>
              </div>
            </div>
          }
        />

        {/* Tableau principal (ProTable) + Pagination externe */}
        <Card>
          <ProTable<DocumentResource>
            rowKey="key"
            columns={columns}
            dataSource={paginatedDocuments}
            search={false}
            options={false}
            pagination={false} // Pagination g√©r√©e manuellement en dessous
            rowSelection={false}
            toolBarRender={false}
          />

          {total > 0 && (
            <div style={{ marginTop: 16, textAlign: 'right' }}>
              <Pagination {...paginationProps} />
            </div>
          )}
        </Card>
      </div>
    </>
  )
}

===== END app/keenkonnect/knowledge/search-filter-documents/page.tsx =====


===== BEGIN app/keenkonnect/knowledge/upload-new-document/page.tsx =====
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { message as antdMessage } from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import {
  PageContainer,
  ProCard,
  ProForm,
  ProFormText,
  ProFormTextArea,
  ProFormSelect,
  ProFormSwitch,
  ProFormUploadDragger,
} from '@ant-design/pro-components';
import { InboxOutlined } from '@ant-design/icons';
import api from '@/api';
import usePageTitle from '@/hooks/usePageTitle';

type CategoryOption = 'Robotics' | 'Healthcare' | 'Technology' | 'Energy' | 'Education';
type LanguageOption = 'English' | 'French';

interface UploadDocumentFormValues {
  title: string;
  description: string;
  category: CategoryOption;
  version: string;
  language: LanguageOption;
  publishNow: boolean;
  documentFile?: UploadFile[]; // optional in typing, required via rules
}

// Normalise Upload event -> UploadFile[]
const normFile = (e: any): UploadFile[] => {
  if (Array.isArray(e)) {
    return e as UploadFile[];
  }
  return (e?.fileList ?? []) as UploadFile[];
};

export default function UploadNewDocumentPage(): JSX.Element {
  usePageTitle('KeenKonnect ¬∑ Knowledge ¬∑ Upload document');
  const router = useRouter();
  const [submitting, setSubmitting] = useState(false);

  const handleFinish = async (values: UploadDocumentFormValues) => {
    const fileList = values.documentFile ?? [];
    const file = fileList[0]?.originFileObj;

    if (!file) {
      antdMessage.error('Please upload a document file before submitting.');
      return false;
    }

    const formData = new FormData();
    // M√©tadonn√©es principales
    formData.append('title', values.title);
    formData.append('description', values.description);
    formData.append('category', values.category);
    formData.append('version', values.version);
    formData.append('language', values.language);
    formData.append('publishNow', values.publishNow ? 'true' : 'false');
    // Fichier lui‚Äëm√™me
    formData.append('file', file as File);

    try {
      setSubmitting(true);

      await api.post('/knowledge/documents/upload', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });

      antdMessage.success('Document uploaded successfully');
      router.push('/keenkonnect/knowledge/document-management');
      return true;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Document upload error:', error);
      antdMessage.error('Failed to upload document. Please try again.');
      return false;
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <PageContainer
      ghost
      header={{
        title: 'Upload New Document',
        subTitle: 'Add a new knowledge asset to KeenKonnect',
      }}
    >
      <div className="max-w-4xl mx-auto">
        <ProCard>
          <ProForm<UploadDocumentFormValues>
            layout="vertical"
            onFinish={handleFinish}
            initialValues={{
              publishNow: true,
            }}
            submitter={{
              searchConfig: {
                submitText: 'Upload Document',
                resetText: 'Reset',
              },
              submitButtonProps: {
                loading: submitting,
                type: 'primary',
              },
            }}
          >
            <ProFormText
              name="title"
              label="Document Title"
              placeholder="Enter document title"
              rules={[
                { required: true, message: 'Please enter a document title' },
                { max: 200, message: 'Title is too long' },
              ]}
            />

            <ProFormTextArea
              name="description"
              label="Description / Abstract"
              placeholder="Short summary of the document contents"
              fieldProps={{ rows: 4 }}
              rules={[
                { required: true, message: 'Please provide a description or abstract' },
              ]}
            />

            <ProFormSelect<CategoryOption>
              name="category"
              label="Category / Topic"
              placeholder="Select a category"
              rules={[{ required: true, message: 'Please select a category/topic' }]}
              options={[
                { label: 'Robotics', value: 'Robotics' },
                { label: 'Healthcare', value: 'Healthcare' },
                { label: 'Technology', value: 'Technology' },
                { label: 'Energy', value: 'Energy' },
                { label: 'Education', value: 'Education' },
              ]}
            />

            <ProFormText
              name="version"
              label="Version"
              placeholder="e.g. 1.0"
              rules={[
                { required: true, message: 'Please specify the document version' },
              ]}
            />

            <ProFormSelect<LanguageOption>
              name="language"
              label="Language"
              placeholder="Select language"
              rules={[{ required: true, message: 'Please select a language' }]}
              options={[
                { label: 'English', value: 'English' },
                { label: 'French', value: 'French' },
              ]}
            />

            <ProFormUploadDragger
              name="documentFile"
              label="Document File"
              max={1}
              valuePropName="fileList"
              getValueFromEvent={normFile}
              rules={[
                { required: true, message: 'Please upload the document file' },
              ]}
              fieldProps={{
                multiple: false,
                beforeUpload: () => false, // pas d'upload auto, on g√®re tout dans onFinish
                accept: '.pdf,.doc,.docx,.ppt,.pptx,.txt',
              }}
            >
              <div style={{ padding: '24px 0' }}>
                <InboxOutlined style={{ fontSize: 32 }} />
                <div style={{ marginTop: 8 }}>
                  Click or drag file to this area to upload
                </div>
                <div style={{ marginTop: 4, fontSize: 12, color: 'rgba(0,0,0,0.45)' }}>
                  Supported formats: PDF, DOC/DOCX, PPT/PPTX, TXT (single file).
                </div>
              </div>
            </ProFormUploadDragger>

            <ProFormSwitch
              name="publishNow"
              label="Publish Status"
              fieldProps={{
                checkedChildren: 'Publish Now',
                unCheckedChildren: 'Save as Draft',
              }}
            />
          </ProForm>
        </ProCard>
      </div>
    </PageContainer>
  );
}

===== END app/keenkonnect/knowledge/upload-new-document/page.tsx =====


===== BEGIN app/keenkonnect/layout.tsx =====
// app/keenkonnect/layout.tsx
'use client'

import type { ReactNode } from 'react'
import React, { Suspense, useEffect } from 'react'
import { Layout, Spin } from 'antd'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'

import MainLayout from '@/components/layout-components/MainLayout'

const { Content } = Layout

interface SegmentLayoutProps {
  children: ReactNode
}

/**
 * Inner shell that forces the KeenKonnect sidebar to be active
 * via the ?sidebar=keenkonnect query param.
 */
function KeenKonnectShell({ children }: SegmentLayoutProps) {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  useEffect(() => {
    const currentSidebar = searchParams.get('sidebar')

    if (currentSidebar === 'keenkonnect') return

    const params = new URLSearchParams(Array.from(searchParams.entries()))
    params.set('sidebar', 'keenkonnect')

    router.replace(`${pathname}?${params.toString()}`)
  }, [router, pathname, searchParams])

  return <MainLayout>{children}</MainLayout>
}

/**
 * Segment layout for all /keenkonnect/* pages.
 * Reuses the global MainLayout (Ant Design Layout + navigation)
 * and provides an Ant Design‚Äìbased Suspense fallback.
 */
export default function SegmentLayout({ children }: SegmentLayoutProps) {
  return (
    <Suspense
      fallback={
        <Layout style={{ minHeight: '100vh' }}>
          <Content
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <Spin size="large" />
          </Content>
        </Layout>
      }
    >
      <KeenKonnectShell>{children}</KeenKonnectShell>
    </Suspense>
  )
}

===== END app/keenkonnect/layout.tsx =====


===== BEGIN app/keenkonnect/projects/browse-projects/page.tsx =====
// app/keenkonnect/projects/browse-projects/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { PageContainer, ProCard } from '@ant-design/pro-components';
import {
  Avatar,
  Button,
  Card,
  Col,
  Divider,
  Drawer,
  Input,
  Pagination,
  Row,
  Select,
  Space,
  Tabs,
  Tag,
  Tooltip,
} from 'antd';
import { PlusOutlined, SearchOutlined, TeamOutlined, UserOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';

const { Search } = Input;
const { Option } = Select;

type SortCriteria = 'newest' | 'mostMembers';

interface Project {
  id: string;
  name: string;
  description: string;
  owner: string;
  technologies: string[];
  domain: string;
  members: number;
  createdAt: string; // ISO date string
}

// Sample data (replace with API data when ready)
const sampleProjects: Project[] = [
  {
    id: '1',
    name: 'Project Alpha',
    description: 'An innovative project in renewable energy.',
    owner: 'Alice',
    technologies: ['React', 'Node.js'],
    domain: 'Energy',
    members: 8,
    createdAt: '2023-09-01',
  },
  {
    id: '2',
    name: 'Project Beta',
    description: 'A collaborative initiative for modern education.',
    owner: 'Bob',
    technologies: ['Python', 'Django'],
    domain: 'Education',
    members: 12,
    createdAt: '2023-08-15',
  },
  {
    id: '3',
    name: 'Project Gamma',
    description: 'Fintech solution for inclusive banking.',
    owner: 'Charlie',
    technologies: ['React', 'Go'],
    domain: 'Finance',
    members: 5,
    createdAt: '2023-09-10',
  },
  {
    id: '4',
    name: 'Project Delta',
    description: 'Marketing analytics platform with AI insights.',
    owner: 'Diana',
    technologies: ['Vue', 'Node.js'],
    domain: 'Marketing',
    members: 10,
    createdAt: '2023-07-22',
  },
  {
    id: '5',
    name: 'Project Epsilon',
    description: 'Design-centric collaboration hub.',
    owner: 'Eve',
    technologies: ['Figma', 'TypeScript'],
    domain: 'Design',
    members: 6,
    createdAt: '2023-09-05',
  },
];

export default function BrowseProjectsPage(): JSX.Element {
  const router = useRouter();

  const [drawerVisible, setDrawerVisible] = useState(false);
  const [selectedProject, setSelectedProject] = useState<Project | null>(null);

  const [searchText, setSearchText] = useState('');
  const [selectedDomain, setSelectedDomain] = useState<string>('All');
  const [selectedTechnology, setSelectedTechnology] = useState<string>('All');
  const [sortCriteria, setSortCriteria] = useState<SortCriteria>('newest');
  const [activeDomainTabKey, setActiveDomainTabKey] = useState<string>('All');

  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 6;

  const domainOptions = useMemo(() => {
    const unique = Array.from(new Set(sampleProjects.map((p) => p.domain)));
    return ['All', ...unique];
  }, []);

  const technologyOptions = useMemo(() => {
    const allTechs = new Set<string>();
    sampleProjects.forEach((p) => {
      p.technologies.forEach((t) => allTechs.add(t));
    });
    return ['All', ...Array.from(allTechs)];
  }, []);

  const filteredProjects = useMemo(
    () =>
      sampleProjects.filter((project) => {
        const matchesSearch =
          !searchText ||
          project.name.toLowerCase().includes(searchText.toLowerCase()) ||
          project.description.toLowerCase().includes(searchText.toLowerCase());

        const matchesDomain =
          selectedDomain === 'All' || project.domain === selectedDomain;

        const matchesTechnology =
          selectedTechnology === 'All' ||
          project.technologies.includes(selectedTechnology);

        return matchesSearch && matchesDomain && matchesTechnology;
      }),
    [searchText, selectedDomain, selectedTechnology],
  );

  const sortedProjects = useMemo(() => {
    const next = [...filteredProjects];
    if (sortCriteria === 'newest') {
      next.sort(
        (a, b) =>
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
      );
    } else if (sortCriteria === 'mostMembers') {
      next.sort((a, b) => b.members - a.members);
    }
    return next;
  }, [filteredProjects, sortCriteria]);

  const paginatedProjects = useMemo(() => {
    const startIndex = (currentPage - 1) * pageSize;
    return sortedProjects.slice(startIndex, startIndex + pageSize);
  }, [sortedProjects, currentPage]);

  const handleOpenDrawer = (project: Project) => {
    setSelectedProject(project);
    setDrawerVisible(true);
  };

  const handleCloseDrawer = () => {
    setDrawerVisible(false);
    setSelectedProject(null);
  };

  const handleDomainTabChange = (key: string) => {
    setActiveDomainTabKey(key);
    setSelectedDomain(key);
    setCurrentPage(1);
  };

  return (
    <PageContainer
      ghost
      header={{
        title: 'Browse Projects',
        subTitle: 'Discover projects and collaborate through KeenKonnect.',
        extra: [
          <Button
            key="create"
            type="primary"
            icon={<PlusOutlined />}
            onClick={() =>
              router.push('/keenkonnect/projects/create-new-project')
            }
          >
            Create New Project
          </Button>,
        ],
      }}
    >
      <ProCard ghost>
        {/* Tabs + filters */}
        <ProCard bordered={false}>
          {/* Quick domain Tabs */}
          <Tabs
            activeKey={activeDomainTabKey}
            onChange={handleDomainTabChange}
            items={domainOptions.map((domain) => ({
              key: domain,
              label: domain === 'All' ? 'All Domains' : domain,
            }))}
          />

          {/* Filters */}
          <Row gutter={[16, 16]} style={{ marginTop: 8 }}>
            <Col xs={24} md={10}>
              <Search
                placeholder="Search by name or description"
                allowClear
                prefix={<SearchOutlined />}
                value={searchText}
                onChange={(e) => {
                  setSearchText(e.target.value);
                  setCurrentPage(1);
                }}
              />
            </Col>
            <Col xs={24} sm={12} md={7}>
              <Select
                value={selectedDomain}
                style={{ width: '100%' }}
                onChange={(value) => {
                  setSelectedDomain(value);
                  setActiveDomainTabKey(value);
                  setCurrentPage(1);
                }}
              >
                {domainOptions.map((domain) => (
                  <Option key={domain} value={domain}>
                    {domain === 'All' ? 'All Domains' : domain}
                  </Option>
                ))}
              </Select>
            </Col>
            <Col xs={24} sm={12} md={7}>
              <Select
                value={selectedTechnology}
                style={{ width: '100%' }}
                onChange={(value) => {
                  setSelectedTechnology(value);
                  setCurrentPage(1);
                }}
              >
                {technologyOptions.map((tech) => (
                  <Option key={tech} value={tech}>
                    {tech === 'All' ? 'All Technologies' : tech}
                  </Option>
                ))}
              </Select>
            </Col>
          </Row>

          {/* Sort & result count */}
          <Row
            justify="space-between"
            align="middle"
            style={{ marginTop: 16 }}
          >
            <Col>
              <Space size="middle">
                <span>Sort by:</span>
                <Select
                  value={sortCriteria}
                  style={{ width: 200 }}
                  onChange={(value) =>
                    setSortCriteria(value as SortCriteria)
                  }
                >
                  <Option value="newest">Newest</Option>
                  <Option value="mostMembers">Most Members</Option>
                </Select>
              </Space>
            </Col>
            <Col>
              <span>
                {sortedProjects.length} project
                {sortedProjects.length !== 1 ? 's' : ''} found
              </span>
            </Col>
          </Row>
        </ProCard>

        {/* Projects grid */}
        <ProCard ghost style={{ marginTop: 24 }} bodyStyle={{ padding: 0 }}>
          <Row gutter={[24, 24]}>
            {paginatedProjects.map((project) => (
              <Col key={project.id} xs={24} sm={12} lg={8}>
                <Card
                  hoverable
                  title={project.name}
                  onClick={() => handleOpenDrawer(project)}
                  extra={
                    <Space size={8}>
                      <Tag color="blue">{project.domain}</Tag>
                      <Tooltip title={`${project.members} members`}>
                        <Space size={4}>
                          <TeamOutlined />
                          <span>{project.members}</span>
                        </Space>
                      </Tooltip>
                    </Space>
                  }
                >
                  <Space
                    direction="vertical"
                    size="small"
                    style={{ width: '100%' }}
                  >
                    <div style={{ minHeight: 48 }}>{project.description}</div>

                    {/* Technologies */}
                    <Space wrap>
                      {project.technologies.map((tech) => (
                        <Tag key={tech}>{tech}</Tag>
                      ))}
                    </Space>

                    {/* Avatars + owner + CTA */}
                    <Row
                      justify="space-between"
                      align="middle"
                      style={{ marginTop: 8 }}
                    >
                      <Col>
                        <Space size={8}>
                          <Avatar.Group maxCount={3} size="small">
                            <Avatar icon={<UserOutlined />} />
                            <Avatar>
                              {project.owner.charAt(0).toUpperCase()}
                            </Avatar>
                            <Avatar icon={<UserOutlined />} />
                          </Avatar.Group>
                          <span
                            style={{
                              fontSize: 12,
                              color: 'rgba(0,0,0,0.45)',
                            }}
                          >
                            Owner: {project.owner}
                          </span>
                        </Space>
                      </Col>
                      <Col>
                        <Button
                          type="link"
                          size="small"
                          onClick={(e) => {
                            e.stopPropagation();
                            router.push(
                              `/keenkonnect/projects/request-join?id=${project.id}`,
                            );
                          }}
                        >
                          Request to Join
                        </Button>
                      </Col>
                    </Row>
                  </Space>
                </Card>
              </Col>
            ))}

            {paginatedProjects.length === 0 && (
              <Col span={24}>
                <Card>
                  <Space direction="vertical">
                    <span>No projects match your filters.</span>
                    <Button
                      type="primary"
                      icon={<PlusOutlined />}
                      onClick={() =>
                        router.push(
                          '/keenkonnect/projects/create-new-project',
                        )
                      }
                    >
                      Start a New Project
                    </Button>
                  </Space>
                </Card>
              </Col>
            )}
          </Row>
        </ProCard>

        {/* Pagination */}
        {sortedProjects.length > pageSize && (
          <div style={{ textAlign: 'center', marginTop: 24 }}>
            <Pagination
              current={currentPage}
              pageSize={pageSize}
              total={sortedProjects.length}
              showSizeChanger={false}
              onChange={(page) => setCurrentPage(page)}
            />
          </div>
        )}

        {/* Drawer: project details */}
        <Drawer
          title={selectedProject?.name}
          placement="right"
          width={420}
          open={drawerVisible}
          onClose={handleCloseDrawer}
        >
          {selectedProject && (
            <Space
              direction="vertical"
              size="middle"
              style={{ width: '100%' }}
            >
              <Space align="center">
                <Avatar.Group maxCount={3}>
                  <Avatar size="large" icon={<UserOutlined />} />
                  <Avatar>
                    {selectedProject.owner.charAt(0).toUpperCase()}
                  </Avatar>
                  <Avatar icon={<UserOutlined />} />
                </Avatar.Group>
                <div>
                  <div>
                    <strong>Owner: </strong>
                    {selectedProject.owner}
                  </div>
                  <div>
                    <strong>Members: </strong>
                    {selectedProject.members}
                  </div>
                </div>
              </Space>

              <Divider />

              <div>
                <p>
                  <strong>Description</strong>
                </p>
                <p>{selectedProject.description}</p>
              </div>

              <div>
                <p>
                  <strong>Domain</strong>
                </p>
                <Tag color="blue">{selectedProject.domain}</Tag>
              </div>

              <div>
                <p>
                  <strong>Technologies</strong>
                </p>
                <Space wrap>
                  {selectedProject.technologies.map((tech) => (
                    <Tag key={tech}>{tech}</Tag>
                  ))}
                </Space>
              </div>

              <div>
                <p>
                  <strong>Created At</strong>
                </p>
                <span>{selectedProject.createdAt}</span>
              </div>

              <Divider />

              <Button
                type="primary"
                block
                onClick={() =>
                  router.push(
                    `/keenkonnect/projects/request-join?id=${selectedProject.id}`,
                  )
                }
              >
                Request to Join
              </Button>
            </Space>
          )}
        </Drawer>
      </ProCard>
    </PageContainer>
  );
}

===== END app/keenkonnect/projects/browse-projects/page.tsx =====


===== BEGIN app/keenkonnect/projects/create-new-project/page.tsx =====
'use client'

import React, { Suspense, useState } from 'react'
import Head from 'next/head'
import { useRouter } from 'next/navigation'
import { Row, Col, Card, Typography, message } from 'antd'
import {
  StepsForm,
  ProFormText,
  ProFormTextArea,
  ProFormSelect,
  ProFormDatePicker,
  ProFormUploadButton,
} from '@ant-design/pro-components'
import type { UploadFile } from 'antd/es/upload/interface'
import api from '@/api'

const { Paragraph } = Typography

type CreateProjectFormValues = {
  name: string
  description?: string
  team: string
  startDate?: any
  endDate?: any
  attachments?: UploadFile[]
  notes?: string
}

export default function PageWrapper() {
  return (
    <Suspense fallback={null}>
      <Content />
    </Suspense>
  )
}

function Content() {
  const router = useRouter()
  const [submitting, setSubmitting] = useState(false)

  const handleFinish = async (values: CreateProjectFormValues) => {
    try {
      setSubmitting(true)

      // On s√©rialise l√©g√®rement les fichiers pour l‚Äôinstant
      const payload = {
        ...values,
        attachments:
          values.attachments?.map((file) => ({
            uid: file.uid,
            name: file.name,
            size: file.size,
            type: file.type,
          })) ?? [],
      }

      await api.post('/projects/create', payload)

      message.success('Project created successfully!')
      router.push('/keenkonnect/projects/my-projects')
      return true
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Create project error:', err)
      message.error('Failed to create project.')
      return false
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <>
      <Head>
        <title>Create New Project ‚Äì KeenKonnect</title>
      </Head>

      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-2">Create New Project</h1>
        <Paragraph type="secondary" className="mb-4">
          Use this guided wizard to describe your project, configure the team and
          timeline, and attach any supporting files.
        </Paragraph>

        <Row justify="center">
          <Col xs={24} lg={18} xl={16}>
            <Card>
              <StepsForm<CreateProjectFormValues>
                onFinish={handleFinish}
                formProps={{
                  layout: 'vertical',
                }}
                submitter={{
                  // SearchConfig in this version only supports submitText / resetText
                  searchConfig: {
                    submitText: 'Create Project',
                  },
                  submitButtonProps: {
                    loading: submitting,
                  },
                }}
              >
                {/* Step 1 ‚Äì Basic Info */}
                <StepsForm.StepForm name="basic" title="Basic Info">
                  <ProFormText
                    name="name"
                    label="Project Name"
                    placeholder="Enter project name"
                    rules={[
                      { required: true, message: 'Please enter a project name' },
                    ]}
                  />

                  <ProFormTextArea
                    name="description"
                    label="Description"
                    placeholder="Describe your project goals, context, and expected outcomes"
                    fieldProps={{ rows: 4 }}
                  />
                </StepsForm.StepForm>

                {/* Step 2 ‚Äì Team & Timeline (Select + DatePicker) */}
                <StepsForm.StepForm name="team-settings" title="Team & Settings">
                  <ProFormSelect
                    name="team"
                    label="Team"
                    placeholder="Select team"
                    options={[
                      { label: 'Team Alpha', value: 'alpha' },
                      { label: 'Team Beta', value: 'beta' },
                    ]}
                    rules={[{ required: true, message: 'Please select a team' }]}
                  />

                  <Row gutter={16}>
                    <Col xs={24} md={12}>
                      <ProFormDatePicker
                        name="startDate"
                        label="Start Date"
                        fieldProps={{ style: { width: '100%' } }}
                      />
                    </Col>
                    <Col xs={24} md={12}>
                      <ProFormDatePicker
                        name="endDate"
                        label="End Date"
                        fieldProps={{ style: { width: '100%' } }}
                      />
                    </Col>
                  </Row>
                </StepsForm.StepForm>

                {/* Step 3 ‚Äì Attachments & Notes (Upload + TextArea) */}
                <StepsForm.StepForm
                  name="attachments"
                  title="Attachments & Notes"
                >
                  <ProFormUploadButton
                    name="attachments"
                    label="Attachments"
                    max={5}
                    fieldProps={{
                      multiple: true,
                      beforeUpload: () => false, // pas d‚Äôupload auto, on garde dans le form state
                      listType: 'text',
                    }}
                    extra="Optional: upload briefs, specs, or reference documents."
                  />

                  <ProFormTextArea
                    name="notes"
                    label="Additional Notes"
                    placeholder="Anything else your collaborators should know?"
                    fieldProps={{ rows: 4 }}
                  />
                </StepsForm.StepForm>
              </StepsForm>
            </Card>
          </Col>
        </Row>
      </div>
    </>
  )
}

===== END app/keenkonnect/projects/create-new-project/page.tsx =====


===== BEGIN app/keenkonnect/projects/my-projects/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import { Button, Typography, Space, Tag, Select, Dropdown, Progress } from 'antd';
import {
  EyeOutlined,
  EditOutlined,
  RocketOutlined,
  PlusOutlined,
  TeamOutlined,
} from '@ant-design/icons';
import type { ProColumns } from '@ant-design/pro-components';
import { ProTable } from '@ant-design/pro-components';
import { useRouter } from 'next/navigation';
import usePageTitle from '@/hooks/usePageTitle';

const { Text } = Typography;

type ProjectStatus = 'draft' | 'active' | 'archived';

interface Project {
  id: string;
  name: string;
  owner: string;
  members: number;
  status: ProjectStatus;
  createdAt: string; // ISO date string
  progress: number; // 0‚Äì100
}

export default function MyProjectsPage(): JSX.Element {
  const router = useRouter();
  usePageTitle('KeenKonnect ‚Äì My Projects');

  // TODO: remplacer par des donn√©es r√©elles (API / SWR, etc.)
  const [projects] = useState<Project[]>([
    {
      id: 'p-1',
      name: 'Sustainable Plastics',
      owner: 'Alice',
      members: 8,
      status: 'active',
      createdAt: '2025-08-01',
      progress: 72,
    },
    {
      id: 'p-2',
      name: 'AI Team Matching',
      owner: 'Bob',
      members: 5,
      status: 'draft',
      createdAt: '2025-09-15',
      progress: 35,
    },
    {
      id: 'p-3',
      name: 'Energy Dashboard',
      owner: 'Clara',
      members: 12,
      status: 'archived',
      createdAt: '2025-02-10',
      progress: 100,
    },
  ]);

  const [statusFilter, setStatusFilter] = useState<ProjectStatus | 'all'>('all');

  const filtered: Project[] = useMemo(() => {
    if (statusFilter === 'all') return projects;
    return projects.filter((p) => p.status === statusFilter);
  }, [projects, statusFilter]);

  const handleView = (id: string): void => {
    router.push(`/keenkonnect/projects/${id}`);
  };

  const handleEdit = (id: string): void => {
    router.push(`/keenkonnect/projects/${id}/edit`);
  };

  const handleLaunch = (id: string): void => {
    router.push(`/keenkonnect/projects/${id}/launch`);
  };

  const statusColors: Record<
    ProjectStatus,
    'default' | 'processing' | 'success' | 'warning' | 'error'
  > = {
    draft: 'default',
    active: 'success',
    archived: 'warning',
  };

  const columns: ProColumns<Project>[] = [
    {
      title: 'Project',
      dataIndex: 'name',
      key: 'name',
      render: (_, record) => (
        <Space direction="vertical" size={0}>
          <Text strong>{record.name}</Text>
          <Space size="small">
            <Tag icon={<TeamOutlined />}>{record.members} members</Tag>
            <Text type="secondary">Owner: {record.owner}</Text>
          </Space>
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      valueType: 'select',
      valueEnum: {
        draft: { text: 'Draft' },
        active: { text: 'Active' },
        archived: { text: 'Archived' },
      },
      render: (_, record) => (
        <Tag color={statusColors[record.status]}>{record.status}</Tag>
      ),
    },
    {
      title: 'Progress',
      dataIndex: 'progress',
      key: 'progress',
      width: 200,
      // IMPORTANT : on utilise (_, record) pour respecter la signature ProColumns
      render: (_, record) => (
        <Progress
          percent={record.progress}
          size="small"
          status={record.progress === 100 ? 'success' : 'active'}
        />
      ),
    },
    {
      title: 'Created',
      dataIndex: 'createdAt',
      key: 'createdAt',
      valueType: 'date',
    },
    {
      title: 'Actions',
      key: 'actions',
      valueType: 'option',
      render: (_, record) => [
        <Dropdown.Button
          key="actions"
          type="primary"
          icon={<RocketOutlined />}
          onClick={() => handleLaunch(record.id)}
          menu={{
            items: [
              {
                key: 'view',
                label: (
                  <span>
                    <EyeOutlined style={{ marginRight: 8 }} />
                    View
                  </span>
                ),
              },
              {
                key: 'edit',
                label: (
                  <span>
                    <EditOutlined style={{ marginRight: 8 }} />
                    Edit
                  </span>
                ),
              },
              {
                key: 'launch',
                label: (
                  <span>
                    <RocketOutlined style={{ marginRight: 8 }} />
                    Launch
                  </span>
                ),
              },
            ],
            onClick: ({ key }) => {
              if (key === 'view') {
                handleView(record.id);
              } else if (key === 'edit') {
                handleEdit(record.id);
              } else if (key === 'launch') {
                handleLaunch(record.id);
              }
            },
          }}
        >
          Launch
        </Dropdown.Button>,
      ],
    },
  ];

  return (
    <div>
      <ProTable<Project>
        rowKey="id"
        headerTitle="My Projects"
        columns={columns}
        dataSource={filtered}
        pagination={{ pageSize: 10 }}
        search={false}
        options={false}
        cardBordered
        toolBarRender={() => [
          <Space key="filters" align="center">
            <Text>Status:</Text>
            <Select<ProjectStatus | 'all'>
              value={statusFilter}
              onChange={(value) => setStatusFilter(value)}
              style={{ width: 180 }}
            >
              <Select.Option value="all">All</Select.Option>
              <Select.Option value="draft">Draft</Select.Option>
              <Select.Option value="active">Active</Select.Option>
              <Select.Option value="archived">Archived</Select.Option>
            </Select>
          </Space>,
          <Button
            key="create"
            type="primary"
            icon={<PlusOutlined />}
            onClick={() =>
              router.push('/keenkonnect/projects/create-new-project')
            }
          >
            Create New Project
          </Button>,
        ]}
      />
    </div>
  );
}

===== END app/keenkonnect/projects/my-projects/page.tsx =====


===== BEGIN app/keenkonnect/projects/project-workspace/page.tsx =====
'use client';

import React, { Suspense, useEffect, useState } from 'react';
import Head from 'next/head';
import { ProCard } from '@ant-design/pro-components';
import { Comment } from '@ant-design/compatible';
import type { MenuProps } from 'antd';
import {
  Avatar,
  Badge,
  Button,
  Drawer,
  Empty,
  List,
  Menu,
  Spin,
  Tabs,
  Tag,
  Timeline,
  Typography,
  Space,
} from 'antd';
import api from '@/api';

const { Title, Text, Paragraph } = Typography;
const { TabPane } = Tabs;

export default function PageWrapper() {
  return (
    <Suspense fallback={<Spin style={{ marginTop: 40 }} />}>
      <Content />
    </Suspense>
  );
}

function Content(): JSX.Element {
  const [workspace, setWorkspace] = useState<any | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [activeKey, setActiveKey] = useState<string>('overview');
  const [drawerOpen, setDrawerOpen] = useState<boolean>(false);
  const [selectedTask, setSelectedTask] = useState<any | null>(null);

  useEffect(() => {
    const fetchWorkspace = async () => {
      try {
        const data = await api.get('/projects/workspace');
        setWorkspace(data ?? null);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error('Failed to load project workspace', err);
        setError('Error loading workspace. Some information may be unavailable.');
      } finally {
        setLoading(false);
      }
    };

    void fetchWorkspace();
  }, []);

  // Safely derive arrays from the workspace payload
  const tasks: any[] = Array.isArray(workspace?.tasks)
    ? ((workspace?.tasks as any[]) ?? [])
    : [];
  const members: any[] = Array.isArray(workspace?.members)
    ? ((workspace?.members as any[]) ?? [])
    : [];
  const comments: any[] = Array.isArray(workspace?.comments)
    ? ((workspace?.comments as any[]) ?? [])
    : [];

  let activity: any[] = [];
  if (Array.isArray(workspace?.activity)) {
    activity = (workspace?.activity as any[]) ?? [];
  } else if (Array.isArray(workspace?.timeline)) {
    activity = (workspace?.timeline as any[]) ?? [];
  }

  const derivedActivity =
    activity.length > 0
      ? activity
      : tasks.map((task: any, index: number) => ({
          key: task.id || `task-${index}`,
          title: task.title,
          description: task.description,
          status: task.status,
          date: task.dueDate || workspace?.deadline,
        }));

  const statusText: string = workspace?.status || 'Active';

  const statusTagColor =
    statusText === 'On Track'
      ? 'success'
      : statusText === 'At Risk'
      ? 'warning'
      : statusText === 'Blocked'
      ? 'error'
      : 'default';

  const totalTasks = tasks.length;
  const completedTasks = tasks.filter(
    (task) => task.status === 'Done' || task.status === 'Completed',
  ).length;
  const inProgressTasks = tasks.filter(
    (task) => task.status === 'In Progress' || task.status === 'Doing',
  ).length;

  const menuItems: MenuProps['items'] = [
    {
      key: 'overview',
      label: 'Overview',
    },
    {
      key: 'tasks',
      label: 'Tasks & Sprints',
    },
    {
      key: 'timeline',
      label: 'Timeline',
    },
    {
      key: 'discussion',
      label: 'Discussion',
    },
  ];

  const handleMenuClick: MenuProps['onClick'] = ({ key }) => {
    setActiveKey(key as string);
  };

  const handleTabChange = (key: string) => {
    setActiveKey(key);
  };

  const handleTaskClick = (task: any) => {
    setSelectedTask(task);
    setDrawerOpen(true);
  };

  if (loading) {
    return (
      <>
        <Head>
          <title>KeenKonnect ‚Äì Project Workspace</title>
        </Head>
        <div style={{ padding: 24, textAlign: 'center' }}>
          <Spin size="large" />
        </div>
      </>
    );
  }

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Project Workspace</title>
      </Head>

      <div style={{ padding: 24 }}>
        <Title level={2} style={{ marginBottom: 8 }}>
          {workspace?.name || 'Project Workspace'}
        </Title>

        <Paragraph type="secondary" style={{ marginBottom: 24, maxWidth: 720 }}>
          {workspace?.description ||
            'Central hub for coordinating your project, tracking tasks, and collaborating with your team in KeenKonnect.'}
        </Paragraph>

        {error && (
          <Paragraph type="danger" style={{ marginBottom: 16 }}>
            {error}
          </Paragraph>
        )}

        <ProCard split="vertical" gutter={24} bordered>
          {/* Left column: context + menu + team */}
          <ProCard
            colSpan={{ xs: 24, sm: 24, md: 8, lg: 7, xl: 6 }}
            title="Workspace overview"
            bordered={false}
          >
            <Space direction="vertical" size="middle" style={{ width: '100%' }}>
              <div>
                <Text strong>Status:&nbsp;</Text>
                <Tag color={statusTagColor}>{statusText}</Tag>
              </div>

              {workspace?.currentSprint && (
                <div>
                  <Text strong>Current sprint:&nbsp;</Text>
                  <Text>{workspace.currentSprint}</Text>
                </div>
              )}

              {workspace?.deadline && (
                <div>
                  <Text strong>Deadline:&nbsp;</Text>
                  <Text>{workspace.deadline}</Text>
                </div>
              )}

              <Space size="large" style={{ marginTop: 4 }}>
                <Badge
                  color="blue"
                  text={
                    <span>
                      Total tasks:&nbsp;
                      <Text strong>{totalTasks}</Text>
                    </span>
                  }
                />
                <Badge
                  color="green"
                  text={
                    <span>
                      Completed:&nbsp;
                      <Text strong>{completedTasks}</Text>
                    </span>
                  }
                />
                <Badge
                  color="gold"
                  text={
                    <span>
                      In progress:&nbsp;
                      <Text strong>{inProgressTasks}</Text>
                    </span>
                  }
                />
              </Space>

              <div style={{ marginTop: 8 }}>
                <Text strong style={{ display: 'block', marginBottom: 8 }}>
                  Sections
                </Text>
                <Menu
                  mode="inline"
                  selectedKeys={[activeKey]}
                  onClick={handleMenuClick}
                  items={menuItems}
                  style={{ borderRight: 0 }}
                />
              </div>

              <div style={{ marginTop: 16 }}>
                <Text strong style={{ display: 'block', marginBottom: 8 }}>
                  Team members
                </Text>
                <List
                  size="small"
                  dataSource={members}
                  locale={{ emptyText: 'No team members linked to this workspace yet.' }}
                  renderItem={(member: any) => (
                    <List.Item key={member.id || member.name}>
                      <List.Item.Meta
                        avatar={
                          member.avatar ? (
                            <Avatar size="small" src={member.avatar} />
                          ) : (
                            <Avatar size="small">
                              {member.name?.charAt(0)?.toUpperCase() ?? '?'}
                            </Avatar>
                          )
                        }
                        title={member.name}
                        description={member.role || member.title || 'Contributor'}
                      />
                    </List.Item>
                  )}
                />
              </div>
            </Space>
          </ProCard>

          {/* Right column: main content with tabs */}
          <ProCard colSpan="auto" bordered={false}>
            <Tabs activeKey={activeKey} onChange={handleTabChange}>
              {/* OVERVIEW */}
              <TabPane tab="Overview" key="overview">
                <ProCard
                  bordered
                  title="Highlights"
                  style={{ marginBottom: 16 }}
                  bodyStyle={{ padding: 16 }}
                >
                  <List
                    size="small"
                    dataSource={[
                      {
                        key: 'status',
                        label: 'Current status',
                        value: statusText,
                      },
                      {
                        key: 'sprint',
                        label: 'Active sprint',
                        value: workspace?.currentSprint || 'No active sprint configured',
                      },
                      {
                        key: 'deadline',
                        label: 'Next deadline',
                        value: workspace?.deadline || 'No deadline set',
                      },
                    ]}
                    renderItem={(item) => (
                      <List.Item key={item.key}>
                        <Space>
                          <Text type="secondary">{item.label}:</Text>
                          <Text>{item.value}</Text>
                        </Space>
                      </List.Item>
                    )}
                  />
                </ProCard>

                <ProCard
                  bordered
                  title="Recent activity"
                  bodyStyle={{ padding: 16 }}
                  extra={
                    <Button
                      type="link"
                      size="small"
                      onClick={() => setActiveKey('timeline')}
                    >
                      View full timeline
                    </Button>
                  }
                >
                  {derivedActivity.length === 0 ? (
                    <Empty description="No recent activity yet." />
                  ) : (
                    <Timeline
                      style={{ marginTop: 8 }}
                      items={derivedActivity.slice(0, 5).map((item: any) => ({
                        color:
                          item.status === 'Completed' || item.status === 'Done'
                            ? 'green'
                            : item.status === 'Blocked'
                            ? 'red'
                            : 'blue',
                        children: (
                          <div>
                            <Text strong>{item.title}</Text>
                            {item.date && (
                              <div>
                                <Text type="secondary">{item.date}</Text>
                              </div>
                            )}
                            {item.description && (
                              <Paragraph style={{ marginBottom: 0 }}>
                                {item.description}
                              </Paragraph>
                            )}
                          </div>
                        ),
                      }))}
                    />
                  )}
                </ProCard>
              </TabPane>

              {/* TASKS & SPRINTS */}
              <TabPane tab="Tasks & Sprints" key="tasks">
                <List
                  itemLayout="horizontal"
                  dataSource={tasks}
                  locale={{
                    emptyText: 'No tasks configured for this workspace yet.',
                  }}
                  renderItem={(task: any) => (
                    <List.Item
                      key={task.id || task.title}
                      onClick={() => handleTaskClick(task)}
                      style={{ cursor: 'pointer' }}
                    >
                      <List.Item.Meta
                        title={
                          <Space size="small">
                            <Text strong>{task.title}</Text>
                            {task.status && <Tag>{task.status}</Tag>}
                          </Space>
                        }
                        description={
                          <Space direction="vertical" size={2}>
                            {task.description && (
                              <Text type="secondary">{task.description}</Text>
                            )}
                            <Space size="small">
                              {task.assignee && (
                                <Text type="secondary">
                                  Owner:&nbsp;
                                  <Text>{task.assignee}</Text>
                                </Text>
                              )}
                              {task.dueDate && (
                                <Text type="secondary">
                                  ¬∑ Due:&nbsp;
                                  <Text>{task.dueDate}</Text>
                                </Text>
                              )}
                            </Space>
                          </Space>
                        }
                      />
                    </List.Item>
                  )}
                />
              </TabPane>

              {/* TIMELINE */}
              <TabPane tab="Timeline" key="timeline">
                {derivedActivity.length === 0 ? (
                  <Empty description="No timeline events to show yet." />
                ) : (
                  <Timeline
                    style={{ marginTop: 8 }}
                    items={derivedActivity.map((item: any) => ({
                      color:
                        item.status === 'Completed' || item.status === 'Done'
                          ? 'green'
                          : item.status === 'Blocked'
                          ? 'red'
                          : 'blue',
                      children: (
                        <div>
                          <Text strong>{item.title}</Text>
                          {item.date && (
                            <div>
                              <Text type="secondary">{item.date}</Text>
                            </div>
                          )}
                          {item.description && (
                            <Paragraph style={{ marginBottom: 0 }}>
                              {item.description}
                            </Paragraph>
                          )}
                        </div>
                      ),
                    }))}
                  />
                )}
              </TabPane>

              {/* DISCUSSION */}
              <TabPane tab="Discussion" key="discussion">
                {comments.length === 0 ? (
                  <Empty description="No discussion yet. Start the conversation with your team!" />
                ) : (
                  <List
                    dataSource={comments}
                    renderItem={(item: any) => (
                      <li key={item.id || item.createdAt}>
                        <Comment
                          author={item.author || item.user}
                          avatar={
                            item.avatar ? (
                              <Avatar src={item.avatar} />
                            ) : (
                              <Avatar>
                                {(item.author || item.user || '?')
                                  ?.charAt(0)
                                  ?.toUpperCase()}
                              </Avatar>
                            )
                          }
                          content={item.content || item.message}
                          datetime={item.datetime || item.createdAt}
                        />
                      </li>
                    )}
                  />
                )}
              </TabPane>
            </Tabs>
          </ProCard>
        </ProCard>

        {/* Task details drawer */}
        <Drawer
          title={selectedTask?.title || 'Task details'}
          width={480}
          open={drawerOpen}
          onClose={() => setDrawerOpen(false)}
          destroyOnClose
        >
          {selectedTask ? (
            <Space direction="vertical" size="middle" style={{ width: '100%' }}>
              {selectedTask.status && (
                <div>
                  <Text strong>Status:&nbsp;</Text>
                  <Tag>{selectedTask.status}</Tag>
                </div>
              )}

              {selectedTask.assignee && (
                <div>
                  <Text strong>Assignee:&nbsp;</Text>
                  <Text>{selectedTask.assignee}</Text>
                </div>
              )}

              {selectedTask.dueDate && (
                <div>
                  <Text strong>Due date:&nbsp;</Text>
                  <Text>{selectedTask.dueDate}</Text>
                </div>
              )}

              {selectedTask.description && (
                <div>
                  <Text strong>Description</Text>
                  <Paragraph style={{ marginTop: 4 }}>
                    {selectedTask.description}
                  </Paragraph>
                </div>
              )}

              {Array.isArray(selectedTask.subtasks) &&
                selectedTask.subtasks.length > 0 && (
                  <div>
                    <Text strong>Subtasks</Text>
                    <List
                      size="small"
                      style={{ marginTop: 4 }}
                      dataSource={selectedTask.subtasks}
                      renderItem={(sub: any, index: number) => (
                        <List.Item key={sub.id || index}>
                          <List.Item.Meta
                            title={sub.title}
                            description={sub.status || undefined}
                          />
                        </List.Item>
                      )}
                    />
                  </div>
                )}
            </Space>
          ) : (
            <Empty description="No task selected." />
          )}
        </Drawer>
      </div>
    </>
  );
}

===== END app/keenkonnect/projects/project-workspace/page.tsx =====


===== BEGIN app/keenkonnect/sustainability-impact/submit-impact-reports/page.tsx =====
'use client';

import React, { Suspense, useState } from 'react';
import Head from 'next/head';
import Link from 'next/link';
import { StepsForm, ProFormDigit } from '@ant-design/pro-components';
import {
  Button,
  Card,
  DatePicker,
  Form,
  Input,
  Select,
  Upload,
  Result,
  Spin,
  message,
} from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import type { Dayjs } from 'dayjs';
import dayjs from 'dayjs';
import { InboxOutlined } from '@ant-design/icons';
import api from '@/api';

const { Option } = Select;
const { TextArea } = Input;
const { Dragger } = Upload;

type SustainabilityReportFormValues = {
  project: string;
  date: Dayjs;
  category: string;
  co2Reduction?: number;
  energySaved?: number;
  peopleImpacted?: number;
  budgetUsed?: number;
  description: string;
  attachments?: UploadFile[];
};

export default function PageWrapper() {
  return (
    <Suspense fallback={<Spin style={{ marginTop: 40 }} />}>
      <Content />
    </Suspense>
  );
}

function Content(): JSX.Element {
  const [completed, setCompleted] = useState(false);
  const [referenceId, setReferenceId] = useState<string | undefined>();

  const handleFinish = async (
    values: SustainabilityReportFormValues,
  ): Promise<boolean> => {
    try {
      const payload = {
        ...values,
        date: values.date?.format('YYYY-MM-DD'),
        // No real upload here ‚Äì we just serialize metadata:
        attachments: values.attachments?.map((file) => ({
          name: file.name,
          uid: file.uid,
        })),
      };

      const res = await api.post('/impact/sustainability/report', payload);

      if (res && typeof res === 'object' && 'reference' in (res as any)) {
        setReferenceId((res as any).reference as string);
      }

      message.success('Impact report submitted successfully!');
      setCompleted(true);
      return true;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Submit impact report error:', error);
      message.error('Failed to submit impact report. Please try again.');
      return false;
    }
  };

  // Typed helper to normalize Upload value
  const normFile = (e: any): UploadFile[] => {
    if (Array.isArray(e)) {
      return e as UploadFile[];
    }
    return (e?.fileList ?? []) as UploadFile[];
  };

  if (completed) {
    return (
      <>
        <Head>
          <title>KeenKonnect ‚Äì Submit Impact Report</title>
        </Head>

        <Result
          status="success"
          title="Impact report submitted"
          subTitle={
            referenceId
              ? `Reference: ${referenceId}. You can now track this impact in your dashboard.`
              : 'Your report has been saved. You can now track this impact in your dashboard.'
          }
          extra={[
            <Link
              key="track"
              href="/keenkonnect/sustainability-impact/track-project-impact"
            >
              <Button type="primary">Go to Track Project Impact</Button>
            </Link>,
            <Button key="again" onClick={() => setCompleted(false)}>
              Submit another report
            </Button>,
          ]}
        />
      </>
    );
  }

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Submit Impact Report</title>
      </Head>

      <h1 style={{ fontSize: 24, fontWeight: 600, marginBottom: 24 }}>
        Submit Impact Report
      </h1>

      <Card>
        <StepsForm<SustainabilityReportFormValues>
          onFinish={handleFinish}
          submitter={{
            // SearchConfig in ProComponents v2 only supports resetText / submitText
            searchConfig: {
              submitText: 'Submit report',
            },
            render: (props, dom) => (
              <div style={{ marginTop: 24, textAlign: 'right' }}>{dom}</div>
            ),
          }}
        >
          {/* Step 1 ‚Äì Project & timeframe */}
          <StepsForm.StepForm
            name="basic"
            title="Project & timeframe"
            layout="vertical"
            initialValues={{
              date: dayjs(),
            }}
          >
            <Form.Item
              label="Project"
              name="project"
              rules={[{ required: true, message: 'Please select a project' }]}
            >
              <Select placeholder="Select the project">
                {/* TODO: replace with dynamic project list */}
                <Option value="project-a">Project A</Option>
                <Option value="project-b">Project B</Option>
              </Select>
            </Form.Item>

            <Form.Item
              label="Date"
              name="date"
              rules={[{ required: true, message: 'Please select a date' }]}
            >
              <DatePicker style={{ width: '100%' }} />
            </Form.Item>

            <Form.Item
              label="Impact category"
              name="category"
              rules={[{ required: true, message: 'Please choose a category' }]}
            >
              <Select placeholder="Select impact category">
                <Option value="environment">Environment</Option>
                <Option value="social">Social</Option>
                <Option value="governance">Governance</Option>
              </Select>
            </Form.Item>
          </StepsForm.StepForm>

          {/* Step 2 ‚Äì Quantitative metrics */}
          <StepsForm.StepForm
            name="metrics"
            title="Impact metrics"
            layout="vertical"
          >
            <ProFormDigit
              name="co2Reduction"
              label="CO‚ÇÇ reduction (tons)"
              min={0}
              fieldProps={{ precision: 2 }}
              tooltip="Estimated CO‚ÇÇ equivalent reduced by this initiative"
            />

            <ProFormDigit
              name="energySaved"
              label="Energy saved (kWh)"
              min={0}
              fieldProps={{ precision: 0 }}
            />

            <ProFormDigit
              name="peopleImpacted"
              label="People positively impacted"
              min={0}
              fieldProps={{ precision: 0 }}
            />

            <ProFormDigit
              name="budgetUsed"
              label="Budget used (USD)"
              min={0}
              fieldProps={{ precision: 2 }}
            />
          </StepsForm.StepForm>

          {/* Step 3 ‚Äì Evidence & narrative */}
          <StepsForm.StepForm
            name="evidence"
            title="Evidence & narrative"
            layout="vertical"
          >
            <Form.Item
              label="Impact narrative"
              name="description"
              rules={[
                {
                  required: true,
                  message: 'Please describe the impact you observed',
                },
              ]}
            >
              <TextArea
                rows={4}
                placeholder="Describe the impact, context and key outcomes..."
              />
            </Form.Item>

            <Form.Item
              label="Supporting files"
              name="attachments"
              valuePropName="fileList"
              getValueFromEvent={normFile}
            >
              <Dragger
                name="files"
                multiple
                beforeUpload={() => false}
                accept=".pdf,.doc,.docx,.xlsx,.csv,image/*"
              >
                <p className="ant-upload-drag-icon">
                  <InboxOutlined />
                </p>
                <p className="ant-upload-text">
                  Click or drag files to this area to upload
                </p>
                <p className="ant-upload-hint">
                  Attach reports, spreadsheets, dashboards or photos that support
                  your impact.
                </p>
              </Dragger>
            </Form.Item>
          </StepsForm.StepForm>
        </StepsForm>
      </Card>
    </>
  );
}

===== END app/keenkonnect/sustainability-impact/submit-impact-reports/page.tsx =====


===== BEGIN app/keenkonnect/sustainability-impact/sustainability-dashboard/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import Head from 'next/head';
import { Card, Select, Space, Tag, Table, Row, Col, Statistic, Typography } from 'antd';
import type { ColumnsType } from 'antd/es/table';
import { Line, Area, Column } from '@ant-design/plots';
import usePageTitle from '@/hooks/usePageTitle';

const { Title, Paragraph } = Typography;

type TimeRange = '3m' | '6m' | '12m';

type ProjectRow = {
  key: string;
  name: string;
  owner: string;
  co2SavedKg: number;
  energySavedKwh: number;
  impactScore: number;
  tags: string[];
};

// --- Donn√©es simul√©es (placeholder) ---

const overviewStats = {
  totalCo2SavedKg: 28450,
  totalEnergySavedKwh: 19320,
  wasteDivertedKg: 5270,
  activeProjects: 12,
};

const co2TrendBase = [
  { month: '2025-01', value: 1200 },
  { month: '2025-02', value: 1350 },
  { month: '2025-03', value: 1480 },
  { month: '2025-04', value: 1600 },
  { month: '2025-05', value: 1705 },
  { month: '2025-06', value: 1820 },
  { month: '2025-07', value: 1960 },
  { month: '2025-08', value: 2100 },
  { month: '2025-09', value: 2240 },
  { month: '2025-10', value: 2390 },
  { month: '2025-11', value: 2525 },
  { month: '2025-12', value: 2680 },
];

const energyTrendBase = [
  { month: '2025-01', value: 800 },
  { month: '2025-02', value: 950 },
  { month: '2025-03', value: 1020 },
  { month: '2025-04', value: 1100 },
  { month: '2025-05', value: 1200 },
  { month: '2025-06', value: 1300 },
  { month: '2025-07', value: 1380 },
  { month: '2025-08', value: 1450 },
  { month: '2025-09', value: 1525 },
  { month: '2025-10', value: 1600 },
  { month: '2025-11', value: 1680 },
  { month: '2025-12', value: 1760 },
];

const categoryDistribution = [
  { category: 'CO‚ÇÇ reduction', value: 42 },
  { category: 'Energy efficiency', value: 28 },
  { category: 'Waste diversion', value: 18 },
  { category: 'Water savings', value: 12 },
];

const projectLeaderboard: ProjectRow[] = [
  {
    key: 'p1',
    name: 'Green Data Center Optimization',
    owner: 'IT & Infrastructure',
    co2SavedKg: 12000,
    energySavedKwh: 8300,
    impactScore: 96,
    tags: ['Scope 2', 'Cloud', 'Efficiency'],
  },
  {
    key: 'p2',
    name: 'Smart Building Automation',
    owner: 'Facilities',
    co2SavedKg: 7800,
    energySavedKwh: 6200,
    impactScore: 92,
    tags: ['Scope 1', 'IoT'],
  },
  {
    key: 'p3',
    name: 'Remote Work Program',
    owner: 'HR',
    co2SavedKg: 5400,
    energySavedKwh: 2300,
    impactScore: 88,
    tags: ['Commuting', 'Culture'],
  },
  {
    key: 'p4',
    name: 'Waste-to-Value Initiative',
    owner: 'Operations',
    co2SavedKg: 3250,
    energySavedKwh: 520,
    impactScore: 84,
    tags: ['Circularity', 'Waste'],
  },
];

export default function SustainabilityDashboardPage(): JSX.Element {
  usePageTitle('KeenKonnect ¬∑ Sustainability Impact Dashboard');

  const [timeRange, setTimeRange] = useState<TimeRange>('6m');

  const filteredCo2Trend = useMemo(() => {
    if (timeRange === '3m') return co2TrendBase.slice(-3);
    if (timeRange === '6m') return co2TrendBase.slice(-6);
    return co2TrendBase;
  }, [timeRange]);

  const filteredEnergyTrend = useMemo(() => {
    if (timeRange === '3m') return energyTrendBase.slice(-3);
    if (timeRange === '6m') return energyTrendBase.slice(-6);
    return energyTrendBase;
  }, [timeRange]);

  // --- Configs graphiques @ant-design/plots (typed as any to keep TS relaxed) ---

  const co2LineConfig: any = {
    data: filteredCo2Trend,
    xField: 'month',
    yField: 'value',
    height: 260,
    smooth: true,
    xAxis: {
      label: {
        formatter: (v: string) => v.slice(5), // Affiche seulement le mois
      },
    },
    yAxis: {
      label: {
        formatter: (v: number) => `${v} kg`,
      },
    },
    tooltip: {
      formatter: (datum: { month: string; value: number }) => ({
        name: 'CO‚ÇÇ saved',
        value: `${datum.value.toLocaleString()} kg`,
      }),
    },
  };

  const energyAreaConfig: any = {
    data: filteredEnergyTrend,
    xField: 'month',
    yField: 'value',
    height: 260,
    smooth: true,
    xAxis: {
      label: {
        formatter: (v: string) => v.slice(5),
      },
    },
    yAxis: {
      label: {
        formatter: (v: number) => `${v} kWh`,
      },
    },
    areaStyle: {
      fillOpacity: 0.3,
    },
    tooltip: {
      formatter: (datum: { month: string; value: number }) => ({
        name: 'Energy saved',
        value: `${datum.value.toLocaleString()} kWh`,
      }),
    },
  };

  const categoryColumnConfig: any = {
    data: categoryDistribution,
    xField: 'category',
    yField: 'value',
    height: 260,
    columnStyle: {
      radius: [4, 4, 0, 0],
    },
    label: {
      position: 'middle' as const,
      formatter: (datum: { value: number }) => `${datum.value}%`,
    },
    tooltip: {
      formatter: (datum: { category: string; value: number }) => ({
        name: datum.category,
        value: `${datum.value}%`,
      }),
    },
  };

  // --- Tableau des projets ---

  const columns: ColumnsType<ProjectRow> = [
    {
      title: 'Project',
      dataIndex: 'name',
      key: 'name',
      ellipsis: true,
    },
    {
      title: 'Owner',
      dataIndex: 'owner',
      key: 'owner',
    },
    {
      title: 'CO‚ÇÇ saved (kg)',
      dataIndex: 'co2SavedKg',
      key: 'co2SavedKg',
      render: (value: number) => value.toLocaleString(),
    },
    {
      title: 'Energy saved (kWh)',
      dataIndex: 'energySavedKwh',
      key: 'energySavedKwh',
      render: (value: number) => value.toLocaleString(),
    },
    {
      title: 'Impact score',
      dataIndex: 'impactScore',
      key: 'impactScore',
      render: (value: number) => `${value}/100`,
    },
    {
      title: 'Tags',
      dataIndex: 'tags',
      key: 'tags',
      render: (tags: string[]) => (
        <>
          {tags.map((tag) => (
            <Tag key={tag}>{tag}</Tag>
          ))}
        </>
      ),
    },
  ];

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Sustainability Impact Dashboard</title>
      </Head>

      <div className="container mx-auto p-5">
        {/* Header align√© sur search-filter-documents */}
        <div className="mb-4 flex flex-wrap items-center justify-between gap-3">
          <div>
            <Title level={2} style={{ marginBottom: 4 }}>
              Sustainability Impact Dashboard
            </Title>
            <Paragraph type="secondary" style={{ marginBottom: 0 }}>
              High-level dashboard aggregating sustainability impact across KeenKonnect
              projects.
            </Paragraph>
          </div>

          <Space>
            <span>Time range:</span>
            <Select<TimeRange>
              size="small"
              value={timeRange}
              onChange={setTimeRange}
              options={[
                { label: 'Last 3 months', value: '3m' },
                { label: 'Last 6 months', value: '6m' },
                { label: 'Last 12 months', value: '12m' },
              ]}
              style={{ minWidth: 140 }}
            />
          </Space>
        </div>

        {/* KPIs principaux (4 stats) */}
        <Card className="mb-4">
          <Row gutter={[16, 16]}>
            <Col xs={12} md={6}>
              <Statistic
                title="Total CO‚ÇÇ saved"
                value={overviewStats.totalCo2SavedKg}
                suffix="kg"
              />
            </Col>
            <Col xs={12} md={6}>
              <Statistic
                title="Total energy saved"
                value={overviewStats.totalEnergySavedKwh}
                suffix="kWh"
              />
            </Col>
            <Col xs={12} md={6}>
              <Statistic
                title="Waste diverted"
                value={overviewStats.wasteDivertedKg}
                suffix="kg"
              />
            </Col>
            <Col xs={12} md={6}>
              <Statistic
                title="Active projects"
                value={overviewStats.activeProjects}
              />
            </Col>
          </Row>
        </Card>

        {/* Lignes / Colonnes principales */}
        <Row gutter={[16, 16]} className="mb-4">
          <Col xs={24} xl={16}>
            <Card title="Timeline of CO‚ÇÇ saved (kg)">
              <Line {...co2LineConfig} />
            </Card>
          </Col>

          <Col xs={24} xl={8}>
            <Card title="Impact category distribution">
              <Column {...categoryColumnConfig} />
            </Card>
          </Col>
        </Row>

        {/* Area + Leaderboard */}
        <Row gutter={[16, 16]}>
          <Col xs={24} xl={12}>
            <Card title="Energy savings trend (kWh)">
              <Area {...energyAreaConfig} />
            </Card>
          </Col>

          <Col xs={24} xl={12}>
            <Card title="Top projects by impact">
              <Table<ProjectRow>
                size="small"
                rowKey="key"
                columns={columns}
                dataSource={projectLeaderboard}
                pagination={false}
              />
            </Card>
          </Col>
        </Row>
      </div>
    </>
  );
}

===== END app/keenkonnect/sustainability-impact/sustainability-dashboard/page.tsx =====


===== BEGIN app/keenkonnect/sustainability-impact/track-project-impact/page.tsx =====
'use client'

import React, { Suspense, useState, useEffect, useMemo } from 'react'
import Head from 'next/head'
import {
  Row,
  Col,
  Card,
  DatePicker,
  Select,
  Spin,
  Tabs,
  Timeline,
  Descriptions,
  Empty,
} from 'antd'
import {
  PieChart,
  Pie,
  Cell,
  Tooltip as ReTooltip,
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
} from 'recharts'
import api from '@/api'
import dayjs from 'dayjs'

const { RangePicker } = DatePicker
const { TabPane } = Tabs

type ImpactItem = {
  category: string
  value: number
}

type Filters = {
  from: string
  to: string
  team?: string
}

const COLORS = ['#4e91ff', '#34c759', '#ff9f0a', '#ff375f', '#af52de']

export default function PageWrapper() {
  return (
    <Suspense fallback={<Spin style={{ marginTop: 40 }} />}>
      <Content />
    </Suspense>
  )
}

function Content(): JSX.Element {
  const [loading, setLoading] = useState(true)
  const [filters, setFilters] = useState<Filters>({
    from: dayjs().subtract(7, 'days').format('YYYY-MM-DD'),
    to: dayjs().format('YYYY-MM-DD'),
    team: undefined,
  })

  const [impactData, setImpactData] = useState<ImpactItem[]>([])

  useEffect(() => {
    const load = async () => {
      setLoading(true)
      try {
        const res = await api.get<ImpactItem[]>('/impact/sustainability/track', {
          params: {
            fromDate: filters.from,
            toDate: filters.to,
            team: filters.team,
          },
        })
        setImpactData(res ?? [])
      } catch (err) {
        console.error('Track impact load error:', err)
      } finally {
        setLoading(false)
      }
    }

    void load()
  }, [filters])

  const chartData = useMemo(
    () =>
      (impactData ?? []).map((item) => ({
        name: item.category,
        value: item.value,
      })),
    [impactData],
  )

  const totalImpact = useMemo(
    () => (impactData ?? []).reduce((sum, item) => sum + (item.value ?? 0), 0),
    [impactData],
  )

  const topCategory = useMemo(() => {
    if (!impactData || impactData.length === 0) return undefined

    // ImpactItem is guaranteed by the length check; use non-null assertion on index 0
    return impactData.reduce<ImpactItem>(
      (max, item) => (item.value > max.value ? item : max),
      impactData[0]!,
    )
  }, [impactData])

  if (loading) {
    return (
      <div style={{ textAlign: 'center', padding: 40 }}>
        <Spin size="large" />
      </div>
    )
  }

  const hasData = chartData.length > 0

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Track Project Impact</title>
      </Head>

      <h1 style={{ fontSize: 24, fontWeight: 600, marginBottom: 24 }}>
        Track Project Impact
      </h1>

      {/* Filtres principaux */}
      <Card style={{ marginBottom: 24 }}>
        <Row gutter={24}>
          <Col xs={24} md={12}>
            <RangePicker
              defaultValue={[dayjs(filters.from), dayjs(filters.to)]}
              style={{ width: '100%' }}
              onChange={(range) => {
                if (!range || !range[0] || !range[1]) return
                const [start, end] = range
                setFilters((f) => ({
                  ...f,
                  from: start.format('YYYY-MM-DD'),
                  to: end.format('YYYY-MM-DD'),
                }))
              }}
            />
          </Col>

          <Col xs={24} md={12}>
            <Select
              placeholder="Filter by team"
              style={{ width: '100%' }}
              allowClear
              value={filters.team}
              onChange={(value) =>
                setFilters((f) => ({
                  ...f,
                  team: value || undefined,
                }))
              }
              options={[
                { label: 'Team A', value: 'team-a' },
                { label: 'Team B', value: 'team-b' },
                { label: 'Team C', value: 'team-c' },
              ]}
            />
          </Col>
        </Row>
      </Card>

      {!hasData ? (
        <Card>
          <Empty description="No impact data for the selected filters" />
        </Card>
      ) : (
        <Tabs defaultActiveKey="overview">
          {/* === Onglet OVERVIEW : pie chart + Descriptions === */}
          <TabPane tab="Overview" key="overview">
            <Row gutter={[24, 24]}>
              <Col xs={24} md={14}>
                <Card title="Impact by Category">
                  <ResponsiveContainer width="100%" height={320}>
                    <PieChart>
                      <Pie
                        data={chartData}
                        dataKey="value"
                        nameKey="name"
                        cx="50%"
                        cy="50%"
                        outerRadius={110}
                      >
                        {chartData.map((_, i) => (
                          <Cell key={i} fill={COLORS[i % COLORS.length]} />
                        ))}
                      </Pie>
                      <ReTooltip />
                    </PieChart>
                  </ResponsiveContainer>
                </Card>
              </Col>

              <Col xs={24} md={10}>
                <Card title="Summary">
                  <Descriptions column={1} size="small" bordered>
                    <Descriptions.Item label="Total impact value">
                      {totalImpact}
                    </Descriptions.Item>
                    <Descriptions.Item label="Number of categories">
                      {impactData.length}
                    </Descriptions.Item>
                    <Descriptions.Item label="Top category">
                      {topCategory?.category ?? '‚Äî'}
                    </Descriptions.Item>
                    <Descriptions.Item label="Top category value">
                      {topCategory?.value ?? '‚Äî'}
                    </Descriptions.Item>
                  </Descriptions>
                </Card>
              </Col>
            </Row>
          </TabPane>

          {/* === Onglet TIMELINE : visualisation s√©quentielle === */}
          <TabPane tab="Timeline" key="timeline">
            <Card title="Impact Timeline">
              <Timeline>
                {impactData.map((item, index) => (
                  <Timeline.Item key={`${item.category}-${index}`}>
                    <div style={{ fontWeight: 500 }}>{item.category}</div>
                    <div style={{ color: '#666' }}>
                      Impact value: {item.value}
                    </div>
                  </Timeline.Item>
                ))}
              </Timeline>
            </Card>
          </TabPane>

          {/* === Onglet BREAKDOWN : bar chart + d√©tails compl√©mentaires === */}
          <TabPane tab="Category Breakdown" key="breakdown">
            <Row gutter={[24, 24]}>
              <Col xs={24} md={16}>
                <Card title="Impact by Category (Bar Chart)">
                  <ResponsiveContainer width="100%" height={320}>
                    <BarChart data={chartData}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="name" />
                      <YAxis />
                      <ReTooltip />
                      <Bar dataKey="value">
                        {chartData.map((_, index) => (
                          <Cell
                            key={index}
                            fill={COLORS[index % COLORS.length]}
                          />
                        ))}
                      </Bar>
                    </BarChart>
                  </ResponsiveContainer>
                </Card>
              </Col>

              <Col xs={24} md={8}>
                <Card title="Category Details">
                  <Descriptions column={1} size="small" bordered>
                    {impactData.map((item, index) => (
                      <Descriptions.Item
                        key={`${item.category}-${index}`}
                        label={item.category}
                      >
                        {item.value}
                      </Descriptions.Item>
                    ))}
                  </Descriptions>
                </Card>
              </Col>
            </Row>
          </TabPane>
        </Tabs>
      )}
    </>
  )
}

===== END app/keenkonnect/sustainability-impact/track-project-impact/page.tsx =====


===== BEGIN app/keenkonnect/user-reputation/account-preferences/page.tsx =====
Ôªø'use client';

import React, { useState } from 'react';
import {
  Tabs,
  Upload,
  Switch,
  Checkbox,
  Button,
  Modal,
  Radio,
  Form,
  Input,
  message as antdMessage,
} from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import { UploadOutlined } from '@ant-design/icons';

const { TabPane } = Tabs;
const { TextArea } = Input;

type NotificationTypeValue =
  | 'team-invites'
  | 'project-matches'
  | 'reputation-updates'
  | 'comments-mentions';

type PrivacyShareValue = 'teams' | 'org' | 'public';

type ProfileFormValues = {
  name: string;
  headline?: string;
  email: string;
  bio?: string;
  avatar?: UploadFile[];
  discoverable?: boolean;
};

type SecurityFormValues = {
  currentPassword: string;
  newPassword: string;
  confirmNewPassword: string;
  twoFactorEnabled?: boolean;
  loginAlerts?: boolean;
};

type NotificationFormValues = {
  emailNotifications?: boolean;
  inAppNotifications?: boolean;
  notificationTypes: NotificationTypeValue[];
};

type PrivacyFormValues = {
  visibility: 'public' | 'private';
  shareReputationWith?: PrivacyShareValue[];
  showInSearch?: boolean;
};

const notificationEventOptions = [
  { label: 'Team invitations & join requests', value: 'team-invites' as const },
  { label: 'New project matches', value: 'project-matches' as const },
  {
    label: 'Reputation badges & level changes',
    value: 'reputation-updates' as const,
  },
  { label: 'Comments & mentions', value: 'comments-mentions' as const },
];

const privacySharingOptions = [
  { label: 'My teams & collaborators', value: 'teams' as const },
  { label: 'Organization admins', value: 'org' as const },
  { label: 'Everyone on KeenKonnect', value: 'public' as const },
];

// ‚úÖ Fix: make sure this always returns UploadFile[]
const normFile = (e: any): UploadFile[] => {
  if (Array.isArray(e)) {
    return e as UploadFile[];
  }
  return (e?.fileList ?? []) as UploadFile[];
};

export default function AccountPreferencesPage(): JSX.Element {
  const [isModalVisible, setIsModalVisible] = useState(false);

  // === Submit handlers =======================================================

  const onFinishProfile = (values: ProfileFormValues) => {
    // eslint-disable-next-line no-console
    console.log('Profile info submitted:', values);
    antdMessage.success('Profile information updated successfully.');
  };

  const onFinishSecurity = (values: SecurityFormValues) => {
    // eslint-disable-next-line no-console
    console.log('Security settings submitted:', values);
    antdMessage.success('Security settings updated successfully.');
  };

  const onFinishNotifications = (values: NotificationFormValues) => {
    // eslint-disable-next-line no-console
    console.log('Notification settings submitted:', values);
    antdMessage.success('Notification preferences updated successfully.');
  };

  const onFinishPrivacy = (values: PrivacyFormValues) => {
    // eslint-disable-next-line no-console
    console.log('Privacy settings submitted:', values);
    antdMessage.success('Privacy preferences updated successfully.');
  };

  // === Danger zone modal =====================================================

  const showDeleteModal = () => {
    setIsModalVisible(true);
  };

  const handleDeleteCancel = () => {
    setIsModalVisible(false);
  };

  const handleDeleteConfirm = () => {
    // eslint-disable-next-line no-console
    console.log('Account deletion requested');
    antdMessage.success(
      'Account deletion requested. We will contact you shortly.',
    );
    setIsModalVisible(false);
  };

  return (
    <div className="container mx-auto p-5">
      <h1 className="text-2xl font-bold mb-4">Account &amp; Preferences</h1>

      <Tabs defaultActiveKey="profile">
        {/* ================= Profile Info ================= */}
        <TabPane tab="Profile Info" key="profile">
          <Form<ProfileFormValues>
            layout="vertical"
            onFinish={onFinishProfile}
            initialValues={{
              name: 'Jane Doe',
              email: 'jane.doe@example.com',
              discoverable: true,
            }}
          >
            <Form.Item
              name="name"
              label="Name"
              rules={[{ required: true, message: 'Please enter your name' }]}
            >
              <Input placeholder="Your display name on KeenKonnect" />
            </Form.Item>

            <Form.Item
              name="headline"
              label="Headline"
              tooltip="Short headline shown in suggestions and team matching."
            >
              <Input placeholder="Product leader, open to cross‚Äëteam collaboration" />
            </Form.Item>

            <Form.Item name="email" label="Email">
              <Input disabled />
            </Form.Item>

            <Form.Item
              name="bio"
              label="Short bio"
              tooltip="Explain how you like to work, preferred domains, or collaboration style."
            >
              <TextArea
                autoSize={{ minRows: 3, maxRows: 5 }}
                placeholder="Tell collaborators a bit about how you like to work."
              />
            </Form.Item>

            <Form.Item
              name="avatar"
              label="Profile picture"
              valuePropName="fileList"
              getValueFromEvent={normFile}
              extra="This picture is visible to collaborators across Ekoh & KeenKonnect."
            >
              <Upload
                name="avatar"
                listType="picture-card"
                maxCount={1}
                beforeUpload={() => false}
              >
                <div>
                  <UploadOutlined />
                  <div style={{ marginTop: 8 }}>Upload</div>
                </div>
              </Upload>
            </Form.Item>

            <Form.Item
              name="discoverable"
              label="Profile discoverability"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Make my KeenKonnect profile discoverable in search & suggestions
                </span>
              </div>
            </Form.Item>

            <Form.Item>
              <Button type="primary" htmlType="submit">
                Save Profile
              </Button>
            </Form.Item>
          </Form>
        </TabPane>

        {/* ================= Security ===================== */}
        <TabPane tab="Security" key="security">
          <Form<SecurityFormValues>
            layout="vertical"
            onFinish={onFinishSecurity}
            initialValues={{
              loginAlerts: true,
            }}
          >
            <Form.Item
              name="currentPassword"
              label="Current password"
              rules={[
                { required: true, message: 'Please enter your current password' },
              ]}
            >
              <Input.Password />
            </Form.Item>

            <Form.Item
              name="newPassword"
              label="New password"
              rules={[
                { required: true, message: 'Please enter your new password' },
              ]}
            >
              <Input.Password />
            </Form.Item>

            <Form.Item
              name="confirmNewPassword"
              label="Confirm new password"
              dependencies={['newPassword']}
              rules={[
                { required: true, message: 'Please confirm your new password' },
                ({ getFieldValue }) => ({
                  validator(_, value) {
                    if (!value || getFieldValue('newPassword') === value) {
                      return Promise.resolve();
                    }
                    return Promise.reject(
                      new Error(
                        'The new password and confirmation do not match.',
                      ),
                    );
                  },
                }),
              ]}
            >
              <Input.Password />
            </Form.Item>

            <Form.Item
              name="twoFactorEnabled"
              label="Two‚Äëfactor authentication"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Require a second step when signing in from a new device
                </span>
              </div>
            </Form.Item>

            <Form.Item
              name="loginAlerts"
              label="Login alerts"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Send me an alert when my account is accessed from a new location
                </span>
              </div>
            </Form.Item>

            <Form.Item>
              <Button type="primary" htmlType="submit">
                Save Security Settings
              </Button>
            </Form.Item>
          </Form>
        </TabPane>

        {/* ================= Notifications ================= */}
        <TabPane tab="Notifications" key="notifications">
          <Form<NotificationFormValues>
            layout="vertical"
            onFinish={onFinishNotifications}
            initialValues={{
              emailNotifications: true,
              inAppNotifications: true,
              notificationTypes: ['team-invites', 'reputation-updates'],
            }}
          >
            <Form.Item
              name="emailNotifications"
              label="Email notifications"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Receive important updates by email
                </span>
              </div>
            </Form.Item>

            <Form.Item
              name="inAppNotifications"
              label="In‚Äëapp notifications"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Show notifications inside Ekoh & KeenKonnect
                </span>
              </div>
            </Form.Item>

            <Form.Item
              name="notificationTypes"
              label="Notify me about"
              rules={[
                {
                  required: true,
                  message: 'Select at least one type of notification',
                },
              ]}
            >
              <Checkbox.Group options={notificationEventOptions} />
            </Form.Item>

            <Form.Item>
              <Button type="primary" htmlType="submit">
                Save Notification Settings
              </Button>
            </Form.Item>
          </Form>
        </TabPane>

        {/* ================= Privacy ======================= */}
        <TabPane tab="Privacy" key="privacy">
          <Form<PrivacyFormValues>
            layout="vertical"
            onFinish={onFinishPrivacy}
            initialValues={{
              visibility: 'public',
              shareReputationWith: ['teams', 'org'],
              showInSearch: true,
            }}
          >
            <Form.Item name="visibility" label="Profile visibility">
              <Radio.Group>
                <Radio value="public">
                  Public ‚Äì visible to all KeenKonnect users
                </Radio>
                <Radio value="private">
                  Private ‚Äì only visible to you
                </Radio>
              </Radio.Group>
            </Form.Item>

            <Form.Item
              name="shareReputationWith"
              label="Share my reputation details with"
            >
              <Checkbox.Group options={privacySharingOptions} />
            </Form.Item>

            <Form.Item
              name="showInSearch"
              label="Search visibility"
              valuePropName="checked"
            >
              <div>
                <Switch />
                <span style={{ marginLeft: 8 }}>
                  Allow my profile to appear in team matching & collaborator search
                </span>
              </div>
            </Form.Item>

            <Form.Item>
              <Button type="primary" htmlType="submit">
                Save Privacy Settings
              </Button>
            </Form.Item>
          </Form>
        </TabPane>

        {/* ================= Danger Zone =================== */}
        <TabPane tab="Danger Zone" key="danger">
          <div
            style={{
              border: '1px solid #ffccc7',
              borderRadius: 8,
              padding: 24,
              background: '#fff1f0',
            }}
          >
            <h3 style={{ color: '#cf1322', marginBottom: 8 }}>Delete Account</h3>
            <p style={{ marginBottom: 16 }}>
              Deleting your account will permanently remove your KeenKonnect profile,
              reputation data and collaboration history. This action cannot be undone.
            </p>
            <Button danger type="primary" onClick={showDeleteModal}>
              Delete my account
            </Button>

            <Modal
              title="Confirm Account Deletion"
              open={isModalVisible}
              okText="Yes, delete my account"
              okButtonProps={{ danger: true }}
              onOk={handleDeleteConfirm}
              onCancel={handleDeleteCancel}
            >
              <p>
                Are you sure you want to delete your account? This will remove your
                KeenKonnect profile and unlink your reputation from any teams.
              </p>
            </Modal>
          </div>
        </TabPane>
      </Tabs>
    </div>
  );
}

===== END app/keenkonnect/user-reputation/account-preferences/page.tsx =====


===== BEGIN app/keenkonnect/user-reputation/manage-expertise-areas/page.tsx =====
Ôªø'use client';

import React, { useMemo, useState } from 'react';
import { Form, Alert, Divider, Typography, List, Tag, Rate, Space } from 'antd';
import { ProForm, ProFormSelect } from '@ant-design/pro-components';
import PageContainer from '@/components/PageContainer';

const { Text, Paragraph } = Typography;
const { CheckableTag } = Tag;

type Visibility = 'public' | 'team-only' | 'private';

type FormValues = {
  currentExpertise: string[];
  newFields?: string[];
  visibility: Visibility;
};

interface ExpertiseItem {
  key: string;
  label: string;
  description: string;
  defaultLevel: number; // 1‚Äì5, for Rate
}

// Catalogue d‚Äôexpertises disponibles dans KeenKonnect
const EXPERTISE_CATALOG: ExpertiseItem[] = [
  {
    key: 'frontend',
    label: 'Frontend Development',
    description: 'React, TypeScript, modern component patterns and design systems.',
    defaultLevel: 4.5,
  },
  {
    key: 'backend',
    label: 'Backend Development',
    description: 'APIs, microservices, Node.js / Python, data modelling & reliability.',
    defaultLevel: 4,
  },
  {
    key: 'uiux',
    label: 'UI/UX Design',
    description: 'User journeys, wireframes, interactive prototypes, design systems.',
    defaultLevel: 4.5,
  },
  {
    key: 'data-science',
    label: 'Data Science',
    description: 'Exploratory analysis, ML models, dashboards, decision support.',
    defaultLevel: 3.5,
  },
  {
    key: 'devops',
    label: 'DevOps',
    description: 'CI/CD, observability, infrastructure-as-code, cloud environments.',
    defaultLevel: 3.5,
  },
  {
    key: 'mobile',
    label: 'Mobile Development',
    description: 'Native & cross‚Äëplatform apps, performance and offline patterns.',
    defaultLevel: 3,
  },
  {
    key: 'qa',
    label: 'QA',
    description: 'Testing strategy, automation, regression & release quality.',
    defaultLevel: 3.5,
  },
  {
    key: 'pm',
    label: 'Project Management',
    description: 'Roadmapping, stakeholder alignment, agile delivery and rituals.',
    defaultLevel: 4,
  },
];

const CURRENT_EXPERTISE_INITIAL: string[] = ['Frontend Development', 'UI/UX Design'];

const SELECTABLE_FIELDS: string[] = [
  'React',
  'Next.js',
  'TypeScript',
  'Figma',
  'GraphQL',
  'Node.js',
  'Cypress',
  'Jest',
];

const VISIBILITY_OPTIONS = [
  { label: 'Public', value: 'public' as const },
  { label: 'Team only', value: 'team-only' as const },
  { label: 'Private', value: 'private' as const },
];

export default function ManageExpertiseAreasPage(): JSX.Element {
  const [form] = Form.useForm<FormValues>();

  // Gestion interne de la s√©lection via Tag.CheckableTag
  const [selectedTags, setSelectedTags] = useState<string[]>(CURRENT_EXPERTISE_INITIAL);

  // Liste pour l‚Äôaper√ßu (List + Rate) bas√©e sur les tags s√©lectionn√©s
  const previewExpertise = useMemo(
    () => EXPERTISE_CATALOG.filter((item) => selectedTags.includes(item.label)),
    [selectedTags],
  );

  const handleTagChange = (label: string, checked: boolean) => {
    const nextSelected = checked
      ? Array.from(new Set([...selectedTags, label]))
      : selectedTags.filter((tag) => tag !== label);

    setSelectedTags(nextSelected);
    form.setFieldsValue({ currentExpertise: nextSelected });
  };

  const handleFinish = async (values: FormValues): Promise<boolean> => {
    // Stub : √† brancher sur l‚ÄôAPI de profil / Ekoh plus tard
    // eslint-disable-next-line no-console
    console.log('Manage Expertise Areas ‚Äì submit:', values);
    return true;
  };

  return (
    <PageContainer title="Manage Expertise Areas">
      {/* ‚úÖ description moved inside instead of using a PageContainer prop */}
      <Paragraph type="secondary" style={{ marginBottom: 16 }}>
        Declare and fine‚Äëtune the expertise areas used by Ekoh, KeenKonnect matching, and Smart Vote.
      </Paragraph>

      <Divider orientation="left">Your expertise profile</Divider>

      <Alert
        type="info"
        showIcon
        style={{ marginBottom: 16 }}
        message="Your declared expertise influences Ekoh reputation, KeenKonnect matching, and Smart Vote weight."
      />

      {/* Formulaire principal avec ProForm + ProFormSelect */}
      <ProForm<FormValues>
        form={form}
        layout="vertical"
        initialValues={{
          currentExpertise: CURRENT_EXPERTISE_INITIAL,
          visibility: 'team-only',
          newFields: [],
        }}
        submitter={{
          searchConfig: {
            submitText: 'Save Changes',
          },
          render: (_, dom) => <div style={{ marginTop: 16 }}>{dom}</div>,
        }}
        onFinish={handleFinish}
      >
        {/* S√©lection des expertises actuelles via Tag.CheckableTag */}
        <Form.Item
          name="currentExpertise"
          label="Current expertise areas"
          rules={[
            {
              required: true,
              message: 'Please select at least one expertise area.',
            },
          ]}
        >
          <div style={{ marginBottom: 8 }}>
            {EXPERTISE_CATALOG.map((item) => (
              <CheckableTag
                key={item.key}
                checked={selectedTags.includes(item.label)}
                onChange={(checked) => handleTagChange(item.label, checked)}
                style={{ marginBottom: 8 }}
              >
                {item.label}
              </CheckableTag>
            ))}
          </div>
        </Form.Item>

        {/* ProFormSelect pour affiner / ajouter des champs pr√©cis */}
        <ProFormSelect
          name="newFields"
          label="Add or refine fields (optional)"
          mode="multiple"
          placeholder="Select specific technologies, tools, or domains"
          allowClear
          options={SELECTABLE_FIELDS.map((field) => ({
            label: field,
            value: field,
          }))}
        />

        {/* ProFormSelect pour la visibilit√© du profil d‚Äôexpertise */}
        <ProFormSelect
          name="visibility"
          label="Visibility of your expertise"
          placeholder="Choose who can view your expertise profile"
          options={VISIBILITY_OPTIONS}
          rules={[
            {
              required: true,
              message: 'Please choose a visibility level.',
            },
          ]}
        />

        <Alert
          style={{ marginTop: 16 }}
          type="info"
          showIcon
          message="Note: New expertise or fields may need validation through activity and peer endorsements before they impact your Ekoh score."
        />
      </ProForm>

      <Divider orientation="left">Preview: how others see your expertise</Divider>

      {/* Aper√ßu des domaines s√©lectionn√©s via List + Rate */}
      <List
        bordered
        itemLayout="vertical"
        dataSource={previewExpertise}
        locale={{
          emptyText: 'Select at least one expertise area above to see the preview.',
        }}
        renderItem={(item) => (
          <List.Item key={item.key}>
            <List.Item.Meta
              title={
                <Space>
                  <Text strong>{item.label}</Text>
                  <Tag color="blue">Core expertise</Tag>
                </Space>
              }
              description={item.description}
            />
            <div>
              <Text type="secondary" style={{ marginRight: 8 }}>
                Typical expertise level
              </Text>
              {/* Rate utilis√© ici en lecture seule pour l‚Äôaper√ßu */}
              <Rate allowHalf disabled defaultValue={item.defaultLevel} />
            </div>
          </List.Item>
        )}
      />
    </PageContainer>
  );
}

===== END app/keenkonnect/user-reputation/manage-expertise-areas/page.tsx =====


===== BEGIN app/keenkonnect/user-reputation/view-reputation-ekoh/page.tsx =====
'use client';

import React, { type ReactNode } from 'react';
import Head from 'next/head';
import {
  Avatar,
  Card,
  Descriptions,
  Timeline,
  List,
  Tag,
  Typography,
  Space,
  Row,
  Col,
} from 'antd';
import {
  TrophyOutlined,
  StarFilled,
  ThunderboltOutlined,
  ExperimentOutlined,
  TeamOutlined,
} from '@ant-design/icons';
import usePageTitle from '@/hooks/usePageTitle';

const { Title, Text } = Typography;

type ReputationSummary = {
  ekohScore: number;
  smartVoteWeight: number;
  trustTier: string;
  totalVotes: number;
  domains: string[];
  lastSync: string;
};

type ExpertiseArea = {
  id: string;
  label: string;
  domain: string;
  level: 'core' | 'supporting';
};

type ReputationEvent = {
  id: string;
  when: string;
  title: string;
  detail: string;
};

type Badge = {
  id: string;
  name: string;
  description: string;
  category: string;
  icon: ReactNode;
  color: string;
};

const reputation: ReputationSummary = {
  ekohScore: 1234,
  smartVoteWeight: 2.7,
  trustTier: 'Emerging Expert',
  totalVotes: 148,
  domains: ['Sustainability', 'Product Strategy', 'AI Ethics'],
  lastSync: '2024-10-15',
};

const expertiseAreas: ExpertiseArea[] = [
  {
    id: 'exp-1',
    label: 'Sustainable product roadmapping',
    domain: 'Sustainability',
    level: 'core',
  },
  {
    id: 'exp-2',
    label: 'Experimentation & A/B testing',
    domain: 'Product Strategy',
    level: 'core',
  },
  {
    id: 'exp-3',
    label: 'AI fairness & guardrails',
    domain: 'AI Ethics',
    level: 'supporting',
  },
];

const reputationTimeline: ReputationEvent[] = [
  {
    id: 'evt-1',
    when: '2024-03-15',
    title: 'Ekoh profile linked to KeenKonnect',
    detail: 'Your existing Ekoh trust score is now visible inside KeenKonnect.',
  },
  {
    id: 'evt-2',
    when: '2024-05-02',
    title: 'First project created from Ekoh contacts',
    detail:
      'You started a sustainability-focused project with 4 contributors you interacted with on Ekoh.',
  },
  {
    id: 'evt-3',
    when: '2024-07-21',
    title: 'Smart vote weight increased',
    detail:
      'Your consistent high-quality contributions raised your smart vote weight above 2√ó.',
  },
  {
    id: 'evt-4',
    when: '2024-09-10',
    title: 'Emerging Expert tier unlocked',
    detail:
      'You crossed the threshold to be highlighted in team matching for Sustainability & Product Strategy.',
  },
];

const badges: Badge[] = [
  {
    id: 'badge-1',
    name: 'Emerging Expert',
    description:
      'Recognized as an emerging expert in at least one core domain. Your profile is surfaced more often in KeenKonnect team search.',
    category: 'Expertise',
    icon: <StarFilled />,
    color: 'gold',
  },
  {
    id: 'badge-2',
    name: 'High-Impact Contributor',
    description:
      'Your votes and contributions frequently shift consensus. Used to weigh your input more strongly in collaborative decisions.',
    category: 'Impact',
    icon: <ThunderboltOutlined />,
    color: 'volcano',
  },
  {
    id: 'badge-3',
    name: 'Experimentation Champion',
    description:
      'You consistently propose and document experiments. Teams looking for experimentation skills see you higher in results.',
    category: 'Practice',
    icon: <ExperimentOutlined />,
    color: 'geekblue',
  },
  {
    id: 'badge-4',
    name: 'Trusted Collaborator',
    description:
      'Peers repeatedly endorse your reliability. This badge boosts your visibility for long-running KeenKonnect projects.',
    category: 'Collaboration',
    icon: <TeamOutlined />,
    color: 'green',
  },
  {
    id: 'badge-5',
    name: 'Top 5% in Sustainability',
    description:
      'Your Ekoh score in Sustainability sits in the top 5%. Used when teams search for climate & impact-related expertise.',
    category: 'Domain signal',
    icon: <TrophyOutlined />,
    color: 'purple',
  },
];

export default function ViewReputationEkohPage(): JSX.Element {
  usePageTitle('KeenKonnect ¬∑ Ekoh reputation');

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Ekoh reputation</title>
      </Head>

      <div className="container mx-auto p-5">
        {/* Titre align√© sur la page de r√©f√©rence */}
        <header className="mb-6">
          <h1 className="text-2xl font-bold mb-1">Ekoh reputation</h1>
          <p className="text-gray-500">
            How your Ekoh trust &amp; expertise are used inside KeenKonnect.
          </p>
        </header>

        {/* Bloc principal : r√©sum√© + timeline */}
        <Row gutter={[24, 24]}>
          {/* Colonne gauche : profil + r√©sum√© Ekoh */}
          <Col xs={24} lg={8}>
            <Card>
              <Space
                direction="vertical"
                align="center"
                style={{ width: '100%' }}
              >
                <Avatar size={80} style={{ backgroundColor: '#1677ff' }}>
                  EK
                </Avatar>

                <div style={{ textAlign: 'center' }}>
                  <Title level={4} style={{ marginBottom: 4 }}>
                    Ekoh profile signal
                  </Title>
                  <Text type="secondary">
                    Imported reputation used for matching &amp; project discovery
                    in KeenKonnect.
                  </Text>
                </div>
              </Space>

              <Descriptions
                size="small"
                column={1}
                style={{ marginTop: 24 }}
                labelStyle={{ width: 160 }}
              >
                <Descriptions.Item label="Ekoh score">
                  <Text strong>{reputation.ekohScore}</Text>
                </Descriptions.Item>
                <Descriptions.Item label="Smart vote weight">
                  <Text strong>{reputation.smartVoteWeight.toFixed(1)}√ó</Text>{' '}
                  <Text type="secondary">(relative influence)</Text>
                </Descriptions.Item>
                <Descriptions.Item label="Tier">
                  <Tag color="blue">{reputation.trustTier}</Tag>
                </Descriptions.Item>
                <Descriptions.Item label="Primary domains">
                  <Space size={4} wrap>
                    {reputation.domains.map((d) => (
                      <Tag key={d}>{d}</Tag>
                    ))}
                  </Space>
                </Descriptions.Item>
                <Descriptions.Item label="Last sync from Ekoh">
                  <Text type="secondary">{reputation.lastSync}</Text>
                </Descriptions.Item>
              </Descriptions>
            </Card>
          </Col>

          {/* Colonne droite : stats + timeline */}
          <Col xs={24} lg={16}>
            {/* Stats en 3 colonnes */}
            <Card className="mb-4">
              <Row gutter={[16, 16]}>
                <Col xs={24} md={8}>
                  <Space direction="vertical">
                    <Text type="secondary">Global Ekoh score</Text>
                    <Title level={3} style={{ margin: 0 }}>
                      {reputation.ekohScore}
                    </Title>
                    <Text type="secondary">
                      Used as a global trust signal across all KeenKonnect
                      workspaces.
                    </Text>
                  </Space>
                </Col>
                <Col xs={24} md={8}>
                  <Space direction="vertical">
                    <Text type="secondary">Smart vote weight</Text>
                    <Title level={3} style={{ margin: 0 }}>
                      {reputation.smartVoteWeight.toFixed(1)}√ó
                    </Title>
                    <Text type="secondary">
                      Your votes weigh more when teams use Ekoh-backed decisions.
                    </Text>
                  </Space>
                </Col>
                <Col xs={24} md={8}>
                  <Space direction="vertical">
                    <Text type="secondary">Validated interactions</Text>
                    <Title level={3} style={{ margin: 0 }}>
                      {reputation.totalVotes}
                    </Title>
                    <Text type="secondary">
                      Conversations, votes &amp; reviews used to compute your
                      reputation.
                    </Text>
                  </Space>
                </Col>
              </Row>
            </Card>

            {/* Timeline */}
            <Card title="Reputation timeline">
              <Timeline
                mode="left"
                items={reputationTimeline.map((item) => ({
                  key: item.id,
                  label: item.when,
                  children: (
                    <div>
                      <Text strong>{item.title}</Text>
                      <div>
                        <Text type="secondary">{item.detail}</Text>
                      </div>
                    </div>
                  ),
                }))}
              />
            </Card>
          </Col>
        </Row>

        {/* Expertise import√©e depuis Ekoh */}
        <Card
          title="Expertise imported from Ekoh"
          className="mt-6"
        >
          <List
            size="small"
            dataSource={expertiseAreas}
            renderItem={(area) => (
              <List.Item key={area.id}>
                <Space direction="vertical" style={{ width: '100%' }}>
                  <Space>
                    <Tag color={area.level === 'core' ? 'geekblue' : 'default'}>
                      {area.level === 'core' ? 'Core domain' : 'Supporting'}
                    </Tag>
                    <Text strong>{area.label}</Text>
                  </Space>
                  <Text type="secondary">
                    Domain:{' '}
                    <Text type="secondary" strong>
                      {area.domain}
                    </Text>{' '}
                    ‚Äì used for project matching &amp; workspace recommendations.
                  </Text>
                </Space>
              </List.Item>
            )}
          />
        </Card>

        {/* Badges & achievements */}
        <Card
          title="Badges & achievements from Ekoh"
          extra={
            <Text type="secondary">
              Displayed in KeenKonnect when teams browse your profile.
            </Text>
          }
          className="mt-6"
        >
          <List
            grid={{ gutter: 16, xs: 1, sm: 2, md: 3 }}
            dataSource={badges}
            renderItem={(badge) => (
              <List.Item key={badge.id}>
                <Card hoverable>
                  <Space align="start">
                    <Avatar
                      shape="square"
                      size={40}
                      style={{
                        backgroundColor: 'var(--ant-color-primary-bg)',
                      }}
                      icon={badge.icon}
                    />
                    <div>
                      <Space style={{ marginBottom: 4 }}>
                        <Text strong>{badge.name}</Text>
                        <Tag color={badge.color}>{badge.category}</Tag>
                      </Space>
                      <Text type="secondary">{badge.description}</Text>
                    </div>
                  </Space>
                </Card>
              </List.Item>
            )}
          />
        </Card>
      </div>
    </>
  );
}

===== END app/keenkonnect/user-reputation/view-reputation-ekoh/page.tsx =====


===== BEGIN app/keenkonnect/workspaces/browse-available-workspaces/page.tsx =====
// File: app/keenkonnect/workspaces/browse-available-workspaces/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import {
  List,
  Card,
  Input,
  Select,
  Button,
  Row,
  Col,
  Pagination,
  Divider,
  Tag,
  Typography,
  Tabs,
  Avatar,
  Space,
  Badge,
} from 'antd';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Search } = Input;
const { Text } = Typography;

type WorkspaceCategory = 'focus' | 'collaboration' | 'creative' | 'innovation';

interface Workspace {
  id: string;
  name: string;
  owner: string;
  purpose: string;
  tools: string[];
  category: WorkspaceCategory;
  currentUsers: number;
  lastActive: string;
  isJoinable: boolean;
  participants: string[];
}

const sampleWorkspaces: Workspace[] = [
  {
    id: '1',
    name: 'Data Science Hub',
    owner: 'Alice',
    purpose: 'Collaborative workspace for data analysis and machine learning projects.',
    tools: ['Data Science Notebook', 'Python'],
    category: 'focus',
    currentUsers: 10,
    lastActive: '2023-09-06 10:00',
    isJoinable: true,
    participants: ['Alice', 'Noah', 'Luc'],
  },
  {
    id: '2',
    name: 'VR Collaboration Space',
    owner: 'Bob',
    purpose: 'Virtual reality space for immersive teamwork.',
    tools: ['VR', '3D Modeling'],
    category: 'collaboration',
    currentUsers: 5,
    lastActive: '2023-09-06 09:30',
    isJoinable: false,
    participants: ['Bob', 'Ravi'],
  },
  {
    id: '3',
    name: 'Programming Lab',
    owner: 'Charlie',
    purpose: 'Workspace for coding projects and software development.',
    tools: ['Programming', 'Collaboration Tools'],
    category: 'focus',
    currentUsers: 8,
    lastActive: '2023-09-06 11:15',
    isJoinable: true,
    participants: ['Charlie', 'Mia', 'Jon'],
  },
  {
    id: '4',
    name: 'Design Studio',
    owner: 'Diana',
    purpose: 'Creative space for design brainstorming and UI/UX work.',
    tools: ['Design Tools', 'Whiteboard'],
    category: 'creative',
    currentUsers: 3,
    lastActive: '2023-09-06 08:45',
    isJoinable: true,
    participants: ['Diana', 'Lea'],
  },
  {
    id: '5',
    name: 'Innovators Room',
    owner: 'Edward',
    purpose: 'Workspace for innovative projects and ideation.',
    tools: ['Brainstorming', 'Prototyping'],
    category: 'innovation',
    currentUsers: 12,
    lastActive: '2023-09-06 10:30',
    isJoinable: false,
    participants: ['Edward', 'Sara', 'Tom', 'Yasmin'],
  },
];

const workspaceTabs = [
  { key: 'all', label: 'All Workspaces' },
  { key: 'focus', label: 'Focus Pods' },
  { key: 'collaboration', label: 'Collaboration Spaces' },
  { key: 'creative', label: 'Creative Studios' },
  { key: 'innovation', label: 'Innovation Labs' },
];

export default function BrowseAvailableWorkspaces(): JSX.Element {
  const router = useRouter();

  const [searchText, setSearchText] = useState('');
  const [selectedTool, setSelectedTool] = useState<string>('All');
  const [activeTab, setActiveTab] = useState<string>('all');
  const [currentPage, setCurrentPage] = useState(1);
  const pageSize = 4;

  const filteredWorkspaces = useMemo(() => {
    const lowerSearch = searchText.toLowerCase();

    return sampleWorkspaces.filter((workspace) => {
      const matchesTab =
        activeTab === 'all' ||
        workspace.category === (activeTab as WorkspaceCategory);

      const matchesSearch =
        !lowerSearch ||
        workspace.name.toLowerCase().includes(lowerSearch) ||
        workspace.purpose.toLowerCase().includes(lowerSearch);

      const matchesTool =
        selectedTool === 'All' || workspace.tools.includes(selectedTool);

      return matchesTab && matchesSearch && matchesTool;
    });
  }, [searchText, selectedTool, activeTab]);

  const paginatedWorkspaces = useMemo(() => {
    const startIndex = (currentPage - 1) * pageSize;
    return filteredWorkspaces.slice(startIndex, startIndex + pageSize);
  }, [filteredWorkspaces, currentPage, pageSize]);

  const handleJoinAction = (workspace: Workspace) => {
    if (workspace.isJoinable) {
      router.push(`/keenkonnect/workspaces/join?id=${workspace.id}`);
    } else {
      router.push(`/keenkonnect/workspaces/request-access?id=${workspace.id}`);
    }
  };

  const handleTabChange = (key: string) => {
    setActiveTab(key);
    setCurrentPage(1);
  };

  return (
    <PageContainer title="Browse Available Workspaces">
      {/* Top-right CTA (inside page content for consistency) */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'flex-end',
          marginBottom: 16,
        }}
      >
        <Button
          type="primary"
          onClick={() =>
            router.push('/keenkonnect/workspaces/launch-new-workspace')
          }
        >
          Launch New Workspace
        </Button>
      </div>

      {/* Search & filters */}
      <Row gutter={[16, 16]} style={{ marginBottom: 16 }}>
        <Col xs={24} sm={12}>
          <Search
            placeholder="Search workspaces"
            allowClear
            onSearch={(value) => {
              setSearchText(value);
              setCurrentPage(1);
            }}
          />
        </Col>
        <Col xs={24} sm={12}>
          <Select
            value={selectedTool}
            style={{ width: '100%' }}
            onChange={(value: string) => {
              setSelectedTool(value);
              setCurrentPage(1);
            }}
            options={[
              { value: 'All', label: 'All Tools' },
              { value: 'Data Science Notebook', label: 'Data Science Notebook' },
              { value: 'VR', label: 'VR' },
              { value: 'Programming', label: 'Programming' },
              { value: 'Design Tools', label: 'Design Tools' },
              { value: '3D Modeling', label: '3D Modeling' },
              { value: 'Whiteboard', label: 'Whiteboard' },
              { value: 'Brainstorming', label: 'Brainstorming' },
              { value: 'Prototyping', label: 'Prototyping' },
            ]}
          />
        </Col>
      </Row>

      {/* Category tabs */}
      <Tabs
        items={workspaceTabs}
        activeKey={activeTab}
        onChange={handleTabChange}
        style={{ marginBottom: 16 }}
      />

      <Divider />

      {/* Workspaces list */}
      <List
        grid={{ gutter: 16, xs: 1, sm: 2, md: 3, lg: 3 }}
        dataSource={paginatedWorkspaces}
        renderItem={(workspace: Workspace) => (
          <List.Item key={workspace.id}>
            <Card
              hoverable
              title={workspace.name}
              extra={
                <Space size="small">
                  <Text type="secondary">Host: {workspace.owner}</Text>
                  <Badge
                    status={workspace.isJoinable ? 'success' : 'warning'}
                    text={workspace.isJoinable ? 'Joinable' : 'Request only'}
                  />
                </Space>
              }
              actions={[
                <Button
                  key="join"
                  type="primary"
                  onClick={() => handleJoinAction(workspace)}
                >
                  {workspace.isJoinable ? 'Join' : 'Request Access'}
                </Button>,
              ]}
            >
              <Space direction="vertical" style={{ width: '100%' }}>
                <Text>{workspace.purpose}</Text>

                <Space wrap>
                  <Tag color="blue">{workspace.category.toUpperCase()}</Tag>
                  {workspace.tools.map((tool) => (
                    <Tag key={tool}>{tool}</Tag>
                  ))}
                </Space>

                <Divider style={{ margin: '12px 0' }} />

                <Row justify="space-between" align="middle">
                  <Col>
                    <Space direction="vertical" size={0}>
                      <Text type="secondary">Currently online</Text>
                      <Tag color="geekblue">
                        {workspace.currentUsers} users
                      </Tag>
                    </Space>
                  </Col>
                  <Col>
                    <Space
                      direction="vertical"
                      size={0}
                      style={{ textAlign: 'right' }}
                    >
                      <Text type="secondary">Last active</Text>
                      <Text>{workspace.lastActive}</Text>
                    </Space>
                  </Col>
                </Row>

                <Divider style={{ margin: '12px 0' }} />

                {/* Avatar.Group showing sample participants */}
                <Space direction="vertical" size={4}>
                  <Text type="secondary">Active collaborators</Text>
                  <Avatar.Group maxCount={3}>
                    {workspace.participants.map((name) => (
                      <Avatar key={name}>
                        {name.charAt(0).toUpperCase()}
                      </Avatar>
                    ))}
                  </Avatar.Group>
                </Space>
              </Space>
            </Card>
          </List.Item>
        )}
      />

      <Row justify="center" style={{ marginTop: 24 }}>
        <Pagination
          current={currentPage}
          pageSize={pageSize}
          total={filteredWorkspaces.length}
          onChange={(page) => setCurrentPage(page)}
        />
      </Row>
    </PageContainer>
  );
}

===== END app/keenkonnect/workspaces/browse-available-workspaces/page.tsx =====


===== BEGIN app/keenkonnect/workspaces/launch-new-workspace/page.tsx =====
'use client';

import React, { Suspense, useState } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/navigation';
import { Card, Result, Button, message } from 'antd';
import {
  ProForm,
  ProFormText,
  ProFormSelect,
  ProFormSwitch,
} from '@ant-design/pro-components';
import api from '@/api';

type LaunchWorkspaceFormValues = {
  name: string;
  team: string;
  tools: string[];
  isPublic: boolean;
};

function Content() {
  const router = useRouter();
  const [submitted, setSubmitted] = useState(false);
  const [lastValues, setLastValues] = useState<LaunchWorkspaceFormValues | null>(null);

  const handleFinish = async (values: LaunchWorkspaceFormValues) => {
    try {
      await api.post('/workspaces/launch', values);
      setLastValues(values);
      setSubmitted(true);
      return true;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error(error);
      message.error("√âchec du lancement de l'espace de travail. Veuillez r√©essayer.");
      return false;
    }
  };

  const handleLaunchAnother = () => {
    setSubmitted(false);
    setLastValues(null);
  };

  const pageTitle = 'Launch a New Workspace';
  const pageDescription =
    "Configurez un nouvel espace de travail collaboratif pour votre √©quipe : choisissez l‚Äô√©quipe responsable, les outils inclus et la visibilit√© de l‚Äôespace.";

  return (
    <>
      <Head>
        <title>KeenKonnect ‚Äì Launch New Workspace</title>
      </Head>

      <div className="container mx-auto p-5">
        <h1 className="text-2xl font-bold mb-4">{pageTitle}</h1>
        <p className="text-gray-500 mb-6">{pageDescription}</p>

        <Card>
          {submitted && lastValues ? (
            <Result
              status="success"
              title="Espace de travail lanc√© avec succ√®s"
              subTitle={`L'espace ¬´ ${lastValues.name} ¬ª est maintenant pr√™t pour votre √©quipe.`}
              extra={[
                <Button type="primary" key="again" onClick={handleLaunchAnother}>
                  Lancer un autre espace
                </Button>,
                <Button
                  key="workspaces"
                  onClick={() => router.push('/keenkonnect/workspaces/my-workspaces')}
                >
                  Voir mes espaces de travail
                </Button>,
              ]}
            />
          ) : (
            <ProForm<LaunchWorkspaceFormValues>
              layout="vertical"
              onFinish={handleFinish}
              initialValues={{
                isPublic: true,
              }}
              submitter={{
                searchConfig: {
                  submitText: "Lancer l'espace",
                },
              }}
            >
              {/* Nom de l‚Äôespace */}
              <ProFormText
                name="name"
                label="Nom de l‚Äôespace de travail"
                placeholder="ex. KeenKonnect Quantum Strategy Lab"
                rules={[
                  { required: true, message: 'Veuillez donner un nom √† cet espace.' },
                ]}
              />

              {/* √âquipe responsable */}
              <ProFormSelect
                name="team"
                label="√âquipe responsable"
                placeholder="S√©lectionnez une √©quipe"
                options={[
                  { label: 'Team Alpha ‚Äì Strategic Vision', value: 'Team Alpha' },
                  { label: 'Team Beta ‚Äì Quantum Strategists', value: 'Team Beta' },
                  { label: 'Team Gamma ‚Äì Innovation Pod', value: 'Team Gamma' },
                  { label: 'Special Guests ‚Äì Invited Fellows', value: 'Special Guests' },
                ]}
                rules={[
                  {
                    required: true,
                    message: 'Veuillez s√©lectionner une √©quipe responsable.',
                  },
                ]}
              />

              {/* Outils & environnements (multi‚Äëselect) */}
              <ProFormSelect
                name="tools"
                label="Outils & environnements inclus"
                placeholder="Choisissez un ou plusieurs environnements"
                fieldProps={{
                  mode: 'multiple',
                }}
                options={[
                  { label: 'Data Science Notebook', value: 'Data Science Notebook' },
                  { label: 'VR Lab', value: 'VR Lab' },
                  { label: 'Programming Workspace', value: 'Programming Workspace' },
                  { label: 'Design Studio', value: 'Design Studio' },
                  { label: '3D Modeling', value: '3D Modeling' },
                  { label: 'Virtual Whiteboard', value: 'Virtual Whiteboard' },
                  { label: 'Brainstorming Hub', value: 'Brainstorming Hub' },
                  { label: 'Prototyping Area', value: 'Prototyping Area' },
                ]}
                rules={[
                  {
                    required: true,
                    message: 'Veuillez choisir au moins un outil ou environnement.',
                  },
                ]}
              />

              {/* Visibilit√© */}
              <ProFormSwitch
                name="isPublic"
                label="Espace visible √† l‚Äôensemble de KeenKonnect"
                tooltip="Quand activ√©, les membres de KeenKonnect pourront d√©couvrir cet espace et demander √† le rejoindre."
              />
            </ProForm>
          )}
        </Card>
      </div>
    </>
  );
}

export default function PageWrapper() {
  return (
    <Suspense fallback={null}>
      <Content />
    </Suspense>
  );
}

===== END app/keenkonnect/workspaces/launch-new-workspace/page.tsx =====


===== BEGIN app/keenkonnect/workspaces/my-workspaces/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Row,
  Col,
  Select,
  Divider,
  Typography,
  Tag,
  Dropdown,
  Popconfirm,
  message,
  Button,
} from 'antd';
import type { MenuProps } from 'antd';
import { DownOutlined } from '@ant-design/icons';
import { ProTable, type ProColumns } from '@ant-design/pro-components';

const { Title, Text } = Typography;

interface Workspace {
  id: string;
  name: string;
  project: string;
  status: 'active' | 'inactive';
  description: string;
  environment: string; // e.g. "Python environment", "Design whiteboard"
}

const sampleWorkspaces: Workspace[] = [
  {
    id: '1',
    name: 'Workspace Alpha',
    project: 'Project Alpha',
    status: 'active',
    description: 'Interactive Python coding environment for data analysis.',
    environment: 'Python environment',
  },
  {
    id: '2',
    name: 'Workspace Beta',
    project: 'Project Beta',
    status: 'inactive',
    description: 'Digital whiteboard for design brainstorming.',
    environment: 'Design whiteboard',
  },
  {
    id: '3',
    name: 'Workspace Gamma',
    project: 'Project Alpha',
    status: 'active',
    description: 'Collaborative space for real-time coding and testing.',
    environment: 'Development environment',
  },
  {
    id: '4',
    name: 'Workspace Delta',
    project: 'Project Delta',
    status: 'inactive',
    description: 'Project planning and management space.',
    environment: 'Planning Board',
  },
];

export default function MyWorkspaces() {
  const router = useRouter();

  // Filter by project
  const [selectedProject, setSelectedProject] = useState<string>('All');
  // Local list so we can "remove" a workspace from the view (Popconfirm action)
  const [visibleWorkspaces, setVisibleWorkspaces] =
    useState<Workspace[]>(sampleWorkspaces);

  const filteredWorkspaces = useMemo(() => {
    const base = visibleWorkspaces;
    if (selectedProject === 'All') return base;
    return base.filter((ws) => ws.project === selectedProject);
  }, [selectedProject, visibleWorkspaces]);

  const activeCount = useMemo(
    () => visibleWorkspaces.filter((ws) => ws.status === 'active').length,
    [visibleWorkspaces],
  );

  const projectOptions = useMemo(() => {
    const projects = Array.from(
      new Set(visibleWorkspaces.map((ws) => ws.project)),
    );
    return ['All', ...projects];
  }, [visibleWorkspaces]);

  const handleWorkspacePrimaryAction = (ws: Workspace) => {
    router.push(`/keenkonnect/workspaces/launch-new-workspace?id=${ws.id}`);
  };

  const handleManageSettings = (ws: Workspace) => {
    // corrig√© : "launch-new-workspace" (sans "s")
    router.push(
      `/keenkonnect/workspaces/launch-new-workspace?id=${ws.id}&manage=1`,
    );
  };

  const handleRemoveFromMyWorkspaces = (ws: Workspace) => {
    setVisibleWorkspaces((prev) => prev.filter((item) => item.id !== ws.id));
    message.success(`Workspace "${ws.name}" removed from your list.`);
  };

  const columns: ProColumns<Workspace>[] = [
    {
      title: 'Workspace',
      dataIndex: 'name',
      key: 'name',
      render: (_dom, record) => (
        <div>
          <div style={{ fontWeight: 500 }}>{record.name}</div>
          <Text type="secondary">{record.description}</Text>
        </div>
      ),
    },
    {
      title: 'Project',
      dataIndex: 'project',
      key: 'project',
    },
    {
      title: 'Environment',
      dataIndex: 'environment',
      key: 'environment',
      // IMPORTANT : on respecte la signature (dom, entity, index, action, schema)
      render: (_dom, record) => <Tag>{record.environment}</Tag>,
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (_dom, record) =>
        record.status === 'active' ? (
          <Tag color="green">Active</Tag>
        ) : (
          <Tag color="default">Inactive</Tag>
        ),
    },
    {
      title: 'Actions',
      key: 'actions',
      valueType: 'option',
      render: (_dom, record) => {
        const isActive = record.status === 'active';
        const primaryLabel = isActive ? 'Join Now' : 'Launch';

        const menuItems: MenuProps['items'] = [
          {
            key: 'manage',
            label: 'Manage Settings',
          },
          {
            key: 'remove',
            label: (
              <Popconfirm
                title="Remove from My Workspaces?"
                description="This will remove the workspace from your list (the workspace itself is not deleted)."
                okText="Yes, remove"
                cancelText="Cancel"
                onConfirm={() => handleRemoveFromMyWorkspaces(record)}
              >
                <span>Remove from list</span>
              </Popconfirm>
            ),
          },
        ];

        const onMenuClick: MenuProps['onClick'] = ({ key }) => {
          if (key === 'manage') {
            handleManageSettings(record);
          }
        };

        return (
          <Dropdown.Button
            type="primary"
            size="small"
            menu={{ items: menuItems, onClick: onMenuClick }}
            onClick={() => handleWorkspacePrimaryAction(record)}
            icon={<DownOutlined />}
          >
            {primaryLabel}
          </Dropdown.Button>
        );
      },
    },
  ];

  return (
    <div className="container mx-auto p-5">
      <Title level={2}>My Workspaces</Title>
      <Divider />

      <Row gutter={[16, 16]} className="mb-4">
        <Col xs={24} sm={12}>
          <Text strong>Total Active Workspaces: {activeCount}</Text>
        </Col>
        <Col
          xs={24}
          sm={12}
          style={{ textAlign: 'right', marginTop: 8, marginBottom: 8 }}
        >
          <Button
            type="default"
            style={{ marginRight: 8 }}
            onClick={() =>
              router.push('/keenkonnect/workspaces/browse-available-workspaces')
            }
          >
            Browse Available Workspaces
          </Button>
          <Button
            type="primary"
            onClick={() =>
              router.push('/keenkonnect/workspaces/launch-new-workspace')
            }
          >
            Launch New Workspace
          </Button>
        </Col>
      </Row>

      <Row gutter={[16, 16]} className="mb-4">
        <Col xs={24} sm={12}>
          <Text>Filter by Project:</Text>
          <Select
            value={selectedProject}
            onChange={(value) => setSelectedProject(value)}
            style={{ width: '100%', marginTop: 4 }}
            options={projectOptions.map((p) => ({ label: p, value: p }))}
          />
        </Col>
      </Row>

      <Divider />

      <ProTable<Workspace>
        rowKey="id"
        columns={columns}
        dataSource={filteredWorkspaces}
        search={false}
        pagination={{
          pageSize: 5,
          showSizeChanger: false,
        }}
        options={false}
      />
    </div>
  );
}

===== END app/keenkonnect/workspaces/my-workspaces/page.tsx =====


===== BEGIN app/konnected/certifications/certification-programs/page.tsx =====
Ôªø'use client';

import React, { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import { PageContainer, ProCard } from '@ant-design/pro-components';
import {
  Alert,
  Badge,
  Button,
  Card,
  Col,
  Drawer,
  Empty,
  Input,
  Progress,
  Row,
  Space,
  Statistic,
  Tag,
  Tooltip,
} from 'antd';
import {
  ArrowRightOutlined,
  InfoCircleOutlined,
  SafetyCertificateOutlined,
  SearchOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';

import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import usePageTitle from '@/hooks/usePageTitle';
import { get } from '@/services/_request';
import { normalizeError } from '@/shared/errors';

const CERT_PASS_PERCENT = 80;

type ProgramDifficulty = 'beginner' | 'intermediate' | 'advanced' | 'expert';

type ProgramStatus = 'not_started' | 'in_progress' | 'completed';

interface ProgramSkill {
  id: string;
  name: string;
  category?: string;
}

interface ProgramUserProgress {
  status: ProgramStatus;
  completionPercent: number;
  lastActivityAt?: string;
  nextRecommendedStep?: string;
}

interface CertificationProgram {
  id: string;
  code: string;
  title: string;
  description: string;
  difficulty: ProgramDifficulty;
  estimatedHours?: number;
  category?: string;
  tags?: string[];
  skills?: ProgramSkill[];
  requiresProctoring?: boolean;
  attemptsAllowed?: number;
  passPercent?: number;
  isFeatured?: boolean;
  kpi_enrolledCount?: number;
  kpi_completionRate?: number;
  userProgress?: ProgramUserProgress;
}

interface ProgramsResponse {
  items: CertificationProgram[];
}

/**
 * API client for the CertifiKation catalog.
 * Adjust the path string to match your actual backend route if needed.
 */
async function fetchCertificationPrograms(): Promise<ProgramsResponse> {
  // Backend path is derived from the CertifiKation / KonnectED API spec.
  // Update if your OpenAPI uses a slightly different route.
  return get<ProgramsResponse>('certs/programs');
}

export default function CertificationProgramsPage(): JSX.Element {
  usePageTitle('KonnectED ¬∑ Certification Programs');
  const router = useRouter();

  const [search, setSearch] = useState('');
  const [difficultyFilter, setDifficultyFilter] = useState<ProgramDifficulty | 'all'>('all');
  const [statusFilter, setStatusFilter] = useState<ProgramStatus | 'all'>('all');
  const [categoryFilter, setCategoryFilter] = useState<string | 'all'>('all');
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(6);
  const [selectedProgram, setSelectedProgram] = useState<CertificationProgram | null>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);

  const { data, loading, error, refresh } = useRequest<ProgramsResponse, []>(
    fetchCertificationPrograms,
  );

  const programs = data?.items ?? [];

  const categories = useMemo(() => {
    const set = new Set<string>();
    programs.forEach((p) => {
      if (p.category) set.add(p.category);
    });
    return Array.from(set).sort();
  }, [programs]);

  const filteredPrograms = useMemo(() => {
    const query = search.trim().toLowerCase();

    return programs.filter((program) => {
      const matchesSearch =
        !query ||
        program.title.toLowerCase().includes(query) ||
        program.description.toLowerCase().includes(query) ||
        (program.code && program.code.toLowerCase().includes(query)) ||
        (program.tags ?? []).some((t) => t.toLowerCase().includes(query));

      const matchesDifficulty =
        difficultyFilter === 'all' || program.difficulty === difficultyFilter;

      const matchesCategory =
        categoryFilter === 'all' || program.category === categoryFilter;

      const status = program.userProgress?.status ?? 'not_started';
      const matchesStatus = statusFilter === 'all' || status === statusFilter;

      return matchesSearch && matchesDifficulty && matchesCategory && matchesStatus;
    });
  }, [programs, search, difficultyFilter, categoryFilter, statusFilter]);

  const total = filteredPrograms.length;
  const startIndex = (currentPage - 1) * pageSize;
  const paginatedPrograms = filteredPrograms.slice(startIndex, startIndex + pageSize);

  const stats = useMemo(() => {
    if (!programs.length) {
      return {
        totalPrograms: 0,
        activePrograms: 0,
        completedPrograms: 0,
        averageCompletion: 0,
      };
    }

    let active = 0;
    let completed = 0;
    let sumCompletion = 0;
    let counted = 0;

    programs.forEach((p) => {
      const progress = p.userProgress;
      if (!progress) return;

      if (progress.status === 'in_progress') active += 1;
      if (progress.status === 'completed') completed += 1;
      if (typeof progress.completionPercent === 'number') {
        sumCompletion += progress.completionPercent;
        counted += 1;
      }
    });

    return {
      totalPrograms: programs.length,
      activePrograms: active,
      completedPrograms: completed,
      averageCompletion: counted ? Math.round(sumCompletion / counted) : 0,
    };
  }, [programs]);

  const handleOpenDetails = (program: CertificationProgram) => {
    setSelectedProgram(program);
    setDrawerOpen(true);
  };

  const handleStartOrContinue = (program: CertificationProgram) => {
    const status = program.userProgress?.status ?? 'not_started';

    if (status === 'not_started') {
      router.push(`/konnected/certifications/exam-registration?pathId=${program.id}`);
      return;
    }

    if (status === 'in_progress') {
      router.push(`/konnected/certifications/exam-preparation?pathId=${program.id}`);
      return;
    }

    if (status === 'completed') {
      router.push(`/konnected/certifications/exam-dashboard-results?pathId=${program.id}`);
    }
  };

  const renderStatusTag = (program: CertificationProgram) => {
    const progress = program.userProgress;

    if (!progress || progress.status === 'not_started') {
      return <Tag>Not started</Tag>;
    }

    if (progress.status === 'in_progress') {
      return <Tag color="blue">In progress</Tag>;
    }

    if (progress.status === 'completed') {
      return <Tag color="green">Completed</Tag>;
    }

    return null;
  };

  const renderDifficultyTag = (difficulty: ProgramDifficulty) => {
    switch (difficulty) {
      case 'beginner':
        return <Tag color="green">Beginner</Tag>;
      case 'intermediate':
        return <Tag color="blue">Intermediate</Tag>;
      case 'advanced':
        return <Tag color="orange">Advanced</Tag>;
      case 'expert':
        return <Tag color="red">Expert</Tag>;
      default:
        return null;
    }
  };

  const errorState = error ? normalizeError(error) : null;
  const errorMessage = errorState?.message ?? null;

  return (
    <KonnectedPageShell
      title="Certification Programs"
      subtitle="Browse certification paths, track your progress, and launch formal evaluations."
      primaryAction={
        <Button
          type="primary"
          icon={<SafetyCertificateOutlined />}
          onClick={() => {
            // Simple heuristic: jump to first in-progress or featured program
            const target =
              programs.find((p) => p.userProgress?.status === 'in_progress') ??
              programs.find((p) => p.isFeatured) ??
              programs[0];

            if (target) {
              handleStartOrContinue(target);
            }
          }}
          disabled={!programs.length}
        >
          Go to my next certification
        </Button>
      }
    >
      <PageContainer ghost loading={loading}>
        <Row gutter={[16, 16]}>
          {/* Stats */}
          <Col xs={24} md={10} lg={8}>
            <ProCard
              ghost
              title="My CertifiKation overview"
              extra={
                <Tooltip title={`Global pass threshold is ${CERT_PASS_PERCENT}% for most exams.`}>
                  <InfoCircleOutlined />
                </Tooltip>
              }
            >
              <Row gutter={[16, 16]}>
                <Col span={12}>
                  <Statistic title="Total programs" value={stats.totalPrograms} />
                </Col>
                <Col span={12}>
                  <Statistic title="Active" value={stats.activePrograms} />
                </Col>
                <Col span={12}>
                  <Statistic title="Completed" value={stats.completedPrograms} />
                </Col>
                <Col span={12}>
                  <Statistic
                    title="Avg. completion"
                    value={stats.averageCompletion}
                    suffix="%"
                  />
                </Col>
              </Row>
              <div style={{ marginTop: 16 }}>
                <div
                  style={{
                    marginBottom: 4,
                    display: 'flex',
                    justifyContent: 'space-between',
                  }}
                >
                  <span>Overall progress toward certifications</span>
                  <span>{stats.averageCompletion}%</span>
                </div>
                <Progress percent={stats.averageCompletion} size="small" />
              </div>
            </ProCard>
          </Col>

          {/* Filters */}
          <Col xs={24} md={14} lg={16}>
            <ProCard ghost title="Filter programs">
              <Row gutter={[12, 12]}>
                <Col span={24}>
                  <Input
                    allowClear
                    prefix={<SearchOutlined />}
                    placeholder="Search by name, code, tag, or description"
                    value={search}
                    onChange={(e) => {
                      setSearch(e.target.value);
                      setCurrentPage(1);
                    }}
                  />
                </Col>

                <Col xs={24} sm={8}>
                  <Space direction="vertical" size={4} style={{ width: '100%' }}>
                    <span>Difficulty</span>
                    <Space wrap>
                      <Button
                        size="small"
                        type={difficultyFilter === 'all' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('all');
                          setCurrentPage(1);
                        }}
                      >
                        All
                      </Button>
                      <Button
                        size="small"
                        type={difficultyFilter === 'beginner' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('beginner');
                          setCurrentPage(1);
                        }}
                      >
                        Beginner
                      </Button>
                      <Button
                        size="small"
                        type={difficultyFilter === 'intermediate' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('intermediate');
                          setCurrentPage(1);
                        }}
                      >
                        Intermediate
                      </Button>
                      <Button
                        size="small"
                        type={difficultyFilter === 'advanced' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('advanced');
                          setCurrentPage(1);
                        }}
                      >
                        Advanced
                      </Button>
                      <Button
                        size="small"
                        type={difficultyFilter === 'expert' ? 'primary' : 'default'}
                        onClick={() => {
                          setDifficultyFilter('expert');
                          setCurrentPage(1);
                        }}
                      >
                        Expert
                      </Button>
                    </Space>
                  </Space>
                </Col>

                <Col xs={24} sm={8}>
                  <Space direction="vertical" size={4} style={{ width: '100%' }}>
                    <span>Status</span>
                    <Space wrap>
                      <Button
                        size="small"
                        type={statusFilter === 'all' ? 'primary' : 'default'}
                        onClick={() => {
                          setStatusFilter('all');
                          setCurrentPage(1);
                        }}
                      >
                        All
                      </Button>
                      <Button
                        size="small"
                        type={statusFilter === 'not_started' ? 'primary' : 'default'}
                        onClick={() => {
                          setStatusFilter('not_started');
                          setCurrentPage(1);
                        }}
                      >
                        Not started
                      </Button>
                      <Button
                        size="small"
                        type={statusFilter === 'in_progress' ? 'primary' : 'default'}
                        onClick={() => {
                          setStatusFilter('in_progress');
                          setCurrentPage(1);
                        }}
                      >
                        In progress
                      </Button>
                      <Button
                        size="small"
                        type={statusFilter === 'completed' ? 'primary' : 'default'}
                        onClick={() => {
                          setStatusFilter('completed');
                          setCurrentPage(1);
                        }}
                      >
                        Completed
                      </Button>
                    </Space>
                  </Space>
                </Col>

                <Col xs={24} sm={8}>
                  <Space direction="vertical" size={4} style={{ width: '100%' }}>
                    <span>Category</span>
                    <Space wrap>
                      <Button
                        size="small"
                        type={categoryFilter === 'all' ? 'primary' : 'default'}
                        onClick={() => {
                          setCategoryFilter('all');
                          setCurrentPage(1);
                        }}
                      >
                        All
                      </Button>
                      {categories.map((cat) => (
                        <Button
                          key={cat}
                          size="small"
                          type={categoryFilter === cat ? 'primary' : 'default'}
                          onClick={() => {
                            setCategoryFilter(cat);
                            setCurrentPage(1);
                          }}
                        >
                          {cat}
                        </Button>
                      ))}
                    </Space>
                  </Space>
                </Col>
              </Row>
            </ProCard>
          </Col>
        </Row>

        {/* Error state */}
        {errorMessage && (
          <Alert
            type="error"
            showIcon
            style={{ marginTop: 16 }}
            message="Unable to load certification programs"
            description={
              <Space align="start">
                <span>{errorMessage}</span>
                <Button size="small" onClick={() => refresh()}>
                  Retry
                </Button>
              </Space>
            }
          />
        )}

        {/* Catalog */}
        <Row gutter={[16, 16]} style={{ marginTop: 16 }}>
          {paginatedPrograms.length === 0 && !loading ? (
            <Col span={24}>
              <Card>
                <Empty
                  description={
                    search ||
                    difficultyFilter !== 'all' ||
                    statusFilter !== 'all' ||
                    categoryFilter !== 'all'
                      ? 'No certification programs match your filters.'
                      : 'No certification programs are available yet.'
                  }
                >
                  {(search ||
                    difficultyFilter !== 'all' ||
                    statusFilter !== 'all' ||
                    categoryFilter !== 'all') && (
                    <Button
                      onClick={() => {
                        setSearch('');
                        setDifficultyFilter('all');
                        setStatusFilter('all');
                        setCategoryFilter('all');
                        setCurrentPage(1);
                      }}
                    >
                      Clear filters
                    </Button>
                  )}
                </Empty>
              </Card>
            </Col>
          ) : (
            paginatedPrograms.map((program) => {
              const progress = program.userProgress;
              const percent = progress?.completionPercent ?? 0;
              const passPercent = program.passPercent ?? CERT_PASS_PERCENT;

              return (
                <Col key={program.id} xs={24} md={12} lg={8}>
                  <Badge.Ribbon
                    text={program.isFeatured ? 'Featured' : undefined}
                    color={program.isFeatured ? 'gold' : undefined}
                  >
                    <Card
                      hoverable
                      title={
                        <Space>
                          <SafetyCertificateOutlined />
                          <span>{program.title}</span>
                        </Space>
                      }
                      extra={renderStatusTag(program)}
                    >
                      <Space direction="vertical" size={8} style={{ width: '100%' }}>
                        <div>
                          <div style={{ marginBottom: 4 }}>
                            <Space size={8} wrap>
                              {program.code && <Tag bordered={false}>{program.code}</Tag>}
                              {renderDifficultyTag(program.difficulty)}
                              {program.category && (
                                <Tag color="default">{program.category}</Tag>
                              )}
                              {program.requiresProctoring && (
                                <Tag color="purple">Proctored</Tag>
                              )}
                            </Space>
                          </div>
                          <div style={{ minHeight: 48 }}>{program.description}</div>
                        </div>

                        <Space
                          direction="vertical"
                          size={4}
                          style={{ width: '100%' }}
                        >
                          <div
                            style={{
                              display: 'flex',
                              justifyContent: 'space-between',
                            }}
                          >
                            <span>My progress</span>
                            <span>{percent}%</span>
                          </div>
                          <Progress
                            percent={percent}
                            size="small"
                            status={percent >= passPercent ? 'success' : 'active'}
                          />
                        </Space>

                        <Space
                          size={8}
                          wrap
                          style={{
                            width: '100%',
                            justifyContent: 'space-between',
                          }}
                        >
                          <Space size={4} wrap>
                            {program.skills?.slice(0, 3).map((skill) => (
                              <Tag key={skill.id}>{skill.name}</Tag>
                            ))}
                            {program.skills && program.skills.length > 3 && (
                              <Tag>+{program.skills.length - 3} more</Tag>
                            )}
                          </Space>

                          {typeof program.estimatedHours === 'number' && (
                            <Tooltip title="Estimated total learning time for this path">
                              <span style={{ fontSize: 12, color: '#888' }}>
                                ~{program.estimatedHours}h
                              </span>
                            </Tooltip>
                          )}
                        </Space>

                        <Space
                          style={{
                            marginTop: 8,
                            width: '100%',
                            justifyContent: 'space-between',
                          }}
                        >
                          <Button
                            size="small"
                            type="link"
                            onClick={() => handleOpenDetails(program)}
                          >
                            View details
                          </Button>

                          <Button
                            type="primary"
                            size="small"
                            icon={<ArrowRightOutlined />}
                            onClick={() => handleStartOrContinue(program)}
                          >
                            {program.userProgress?.status === 'completed'
                              ? 'View results'
                              : program.userProgress?.status === 'in_progress'
                              ? 'Continue'
                              : 'Start'}
                          </Button>
                        </Space>
                      </Space>
                    </Card>
                  </Badge.Ribbon>
                </Col>
              );
            })
          )}
        </Row>

        {/* Pagination */}
        {total > 0 && (
          <div
            style={{
              marginTop: 16,
              display: 'flex',
              justifyContent: 'flex-end',
            }}
          >
            <Space>
              <span style={{ fontSize: 12, color: '#888' }}>
                Showing {startIndex + 1}-{Math.min(startIndex + pageSize, total)} of {total}{' '}
                programs
              </span>
              <Input
                type="number"
                min={3}
                max={24}
                value={pageSize}
                style={{ width: 80 }}
                onChange={(e) => {
                  const value = Number(e.target.value) || 6;
                  setPageSize(value);
                  setCurrentPage(1);
                }}
                addonBefore="Page size"
              />
            </Space>
          </div>
        )}

        {/* Drawer: full program details */}
        <Drawer
          open={drawerOpen}
          width={520}
          title={
            <Space>
              <SafetyCertificateOutlined />
              <span>{selectedProgram?.title ?? 'Certification details'}</span>
            </Space>
          }
          onClose={() => {
            setDrawerOpen(false);
            setSelectedProgram(null);
          }}
          destroyOnClose
        >
          {selectedProgram && (
            <Space direction="vertical" size={16} style={{ width: '100%' }}>
              <Space size={8} wrap>
                {selectedProgram.code && <Tag>{selectedProgram.code}</Tag>}
                {renderDifficultyTag(selectedProgram.difficulty)}
                {selectedProgram.category && (
                  <Tag color="default">{selectedProgram.category}</Tag>
                )}
                {selectedProgram.requiresProctoring && (
                  <Tag color="purple">Proctored exam</Tag>
                )}
              </Space>

              <div>
                <h3>Description</h3>
                <p>{selectedProgram.description}</p>
              </div>

              {!!selectedProgram.skills?.length && (
                <div>
                  <h3>Key skills verified</h3>
                  <Space wrap>
                    {selectedProgram.skills.map((skill) => (
                      <Tag key={skill.id}>{skill.name}</Tag>
                    ))}
                  </Space>
                </div>
              )}

              <div>
                <h3>Assessment rules</h3>
                <ul style={{ paddingLeft: 20 }}>
                  <li>
                    Passing threshold:{' '}
                    <strong>
                      {selectedProgram.passPercent ?? CERT_PASS_PERCENT}%
                    </strong>
                  </li>
                  {selectedProgram.attemptsAllowed && (
                    <li>
                      Attempts allowed:{' '}
                      <strong>{selectedProgram.attemptsAllowed}</strong>
                    </li>
                  )}
                  {typeof selectedProgram.estimatedHours === 'number' && (
                    <li>
                      Estimated learning time:{' '}
                      <strong>~{selectedProgram.estimatedHours} hours</strong>
                    </li>
                  )}
                </ul>
              </div>

              {selectedProgram.userProgress && (
                <div>
                  <h3>My current status</h3>
                  <Space direction="vertical" size={8} style={{ width: '100%' }}>
                    <Space>
                      {renderStatusTag(selectedProgram)}
                      {typeof selectedProgram.userProgress.completionPercent ===
                        'number' && (
                        <span>
                          {selectedProgram.userProgress.completionPercent}
                          % complete
                        </span>
                      )}
                    </Space>
                    <Progress
                      percent={selectedProgram.userProgress.completionPercent}
                      status={
                        selectedProgram.userProgress.status === 'completed'
                          ? 'success'
                          : 'active'
                      }
                    />
                    {selectedProgram.userProgress.nextRecommendedStep && (
                      <Alert
                        type="info"
                        showIcon
                        message="Next recommended step"
                        description={selectedProgram.userProgress.nextRecommendedStep}
                      />
                    )}
                  </Space>
                </div>
              )}

              <Space style={{ marginTop: 8 }}>
                <Button
                  type="primary"
                  icon={<ArrowRightOutlined />}
                  onClick={() => handleStartOrContinue(selectedProgram)}
                >
                  {selectedProgram.userProgress?.status === 'completed'
                    ? 'View results'
                    : selectedProgram.userProgress?.status === 'in_progress'
                    ? 'Continue certification'
                    : 'Start certification'}
                </Button>
              </Space>
            </Space>
          )}
        </Drawer>
      </PageContainer>
    </KonnectedPageShell>
  );
}

===== END app/konnected/certifications/certification-programs/page.tsx =====


===== BEGIN app/konnected/certifications/exam-dashboard-results/page.tsx =====
'use client'

import React, { useMemo, useState } from 'react'
import {
  Alert,
  Badge,
  Button,
  Card,
  Col,
  Drawer,
  Empty,
  List,
  Result,
  Row,
  Space,
  Spin,
  Statistic,
  Table,
  Tag,
  Tooltip,
  Typography,
  message,
} from 'antd'
import type { ColumnsType } from 'antd/es/table'
import {
  CheckCircleOutlined,
  ClockCircleOutlined,
  ExclamationCircleOutlined,
  FilePdfOutlined,
  ReloadOutlined,
  WarningOutlined,
  EyeOutlined,
} from '@ant-design/icons'
import { useRequest } from 'ahooks'
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell'
import api from '@/services/_request'

const { Title, Text, Paragraph } = Typography

// NOTE: These thresholds mirror the global params from the CertifiKation spec.
// Keep in sync with backend/global-params.
const CERT_PASS_PERCENT = 80
const EXAM_RETRY_COOLDOWN_MIN = 30

// -----------------------------------------------------------------------------
// Domain types (aligned with Evaluation / CertificationPath / Portfolio models)
// -----------------------------------------------------------------------------

export type EvaluationStatus =
  | 'passed'
  | 'failed'
  | 'pending_peer'
  | 'under_review'
  | 'scheduled'
  | 'in_progress'

export interface ExamAttempt {
  id: string
  certificationPathId: string
  certificationPathName: string
  attemptNumber: number
  takenAt: string // ISO date
  deliveryMode: 'online' | 'offline' | 'blended'
  proctored: boolean
  scorePercent: number | null
  maxScore: number | null
  status: EvaluationStatus

  // Peer validation / review
  peerValidationRequired: boolean
  peerValidationStatus?: 'approved' | 'rejected' | 'pending'
  appealStatus?: 'none' | 'open' | 'resolved' | 'rejected'

  // Portfolio / certificate linkage
  certificateId?: string
  certificateUrl?: string
  portfolioItemId?: string
  portfolioUrl?: string

  // Retry & cooldown metadata
  canRetry: boolean
  nextRetryAt?: string // ISO date if blocked by cooldown
}

interface ExamAttemptsResponse {
  attempts: ExamAttempt[]
}

// -----------------------------------------------------------------------------
// API endpoint helpers
// -----------------------------------------------------------------------------

const EXAM_ATTEMPTS_ENDPOINT = '/konnected/certifications/exam-attempts/me'
const EXAM_ATTEMPT_DETAIL_ENDPOINT = (attemptId: string) =>
  `/konnected/certifications/exam-attempts/${attemptId}`
const EXAM_APPEAL_ENDPOINT = (attemptId: string) =>
  `/konnected/certifications/exam-attempts/${attemptId}/appeal`
const EXAM_RETRY_ENDPOINT = (attemptId: string) =>
  `/konnected/certifications/exam-attempts/${attemptId}/retry`

async function fetchExamAttempts(): Promise<ExamAttemptsResponse> {
  return api.get<ExamAttemptsResponse>(EXAM_ATTEMPTS_ENDPOINT)
}

// -----------------------------------------------------------------------------
// Utility helpers
// -----------------------------------------------------------------------------

const formatDateTime = (iso: string | undefined) => {
  if (!iso) return '‚Äî'
  const date = new Date(iso)
  if (Number.isNaN(date.getTime())) return iso
  return date.toLocaleString()
}

const getStatusTag = (attempt: ExamAttempt) => {
  if (attempt.status === 'scheduled') {
    return (
      <Tag icon={<ClockCircleOutlined />} color="default">
        Scheduled
      </Tag>
    )
  }

  if (attempt.status === 'in_progress') {
    return (
      <Tag icon={<ClockCircleOutlined />} color="processing">
        In progress
      </Tag>
    )
  }

  if (attempt.status === 'passed') {
    if (attempt.peerValidationRequired && attempt.peerValidationStatus !== 'approved') {
      // Passed automated evaluation but still waiting on peers
      return (
        <Tag icon={<ClockCircleOutlined />} color="processing">
          Pending peer validation
        </Tag>
      )
    }
    return (
      <Tag icon={<CheckCircleOutlined />} color="success">
        Passed
      </Tag>
    )
  }

  if (attempt.status === 'failed') {
    return (
      <Tag icon={<ExclamationCircleOutlined />} color="error">
        Not passed
      </Tag>
    )
  }

  if (attempt.status === 'pending_peer') {
    return (
      <Tag icon={<ClockCircleOutlined />} color="processing">
        Pending peer validation
      </Tag>
    )
  }

  if (attempt.status === 'under_review') {
    return (
      <Tag icon={<ClockCircleOutlined />} color="warning">
        Under review
      </Tag>
    )
  }

  return <Tag>Unknown</Tag>
}

const getAppealTag = (attempt: ExamAttempt) => {
  if (!attempt.appealStatus || attempt.appealStatus === 'none') {
    return null
  }

  if (attempt.appealStatus === 'open') {
    return (
      <Tag color="processing" icon={<ClockCircleOutlined />}>
        Appeal open
      </Tag>
    )
  }

  if (attempt.appealStatus === 'resolved') {
    return (
      <Tag color="success" icon={<CheckCircleOutlined />}>
        Appeal resolved
      </Tag>
    )
  }

  if (attempt.appealStatus === 'rejected') {
    return (
      <Tag color="error" icon={<ExclamationCircleOutlined />}>
        Appeal rejected
      </Tag>
    )
  }

  return null
}

const getScoreColor = (percent: number | null) => {
  if (percent == null) return undefined as
    | 'success'
    | 'warning'
    | 'danger'
    | undefined
  if (percent >= CERT_PASS_PERCENT) return 'success' as const
  if (percent >= CERT_PASS_PERCENT - 10) return 'warning' as const
  return 'danger' as const
}

// -----------------------------------------------------------------------------
// Main component
// -----------------------------------------------------------------------------

const ExamDashboardResultsPage: React.FC = () => {
  const [selectedAttempt, setSelectedAttempt] = useState<ExamAttempt | null>(null)
  const [appealLoadingId, setAppealLoadingId] = useState<string | null>(null)
  const [retryLoadingId, setRetryLoadingId] = useState<string | null>(null)

  const {
    data,
    loading,
    error,
    refresh: refreshAttempts,
  } = useRequest(fetchExamAttempts, {
    retryCount: 1,
  })

  const attempts = data?.attempts ?? []

  const stats = useMemo(() => {
    if (!attempts.length) {
      return {
        totalAttempts: 0,
        passedCount: 0,
        passRate: 0,
        avgScore: 0,
        uniqueCerts: 0,
      }
    }

    const totalAttempts = attempts.length
    const scoredAttempts = attempts.filter(
      (a) => typeof a.scorePercent === 'number',
    ) as Array<ExamAttempt & { scorePercent: number }>
    const passedCount = scoredAttempts.filter((a) => a.scorePercent >= CERT_PASS_PERCENT).length
    const passRate = totalAttempts ? Math.round((passedCount / totalAttempts) * 100) : 0
    const avgScore = scoredAttempts.length
      ? Math.round(
          scoredAttempts.reduce((sum, a) => sum + (a.scorePercent ?? 0), 0) /
            scoredAttempts.length,
        )
      : 0
    const uniqueCerts = new Set(
      attempts.map((a) => a.certificationPathId || a.certificationPathName),
    ).size

    return { totalAttempts, passedCount, passRate, avgScore, uniqueCerts }
  }, [attempts])

  const handleOpenDetails = async (attempt: ExamAttempt) => {
    try {
      const detail = await api.get<ExamAttempt>(EXAM_ATTEMPT_DETAIL_ENDPOINT(attempt.id))
      setSelectedAttempt(detail)
    } catch {
      // Fallback to row data if detail endpoint is not yet wired.
      setSelectedAttempt(attempt)
    }
  }

  const handleCloseDetails = () => {
    setSelectedAttempt(null)
  }

  const handleOpenCertificate = (attempt: ExamAttempt) => {
    if (attempt.certificateUrl) {
      window.open(attempt.certificateUrl, '_blank')
    } else {
      message.info('Certificate is not yet available for this attempt.')
    }
  }

  const handleOpenPortfolio = (attempt: ExamAttempt) => {
    if (attempt.portfolioUrl) {
      window.open(attempt.portfolioUrl, '_blank')
    } else {
      message.info('This attempt is not yet linked to your portfolio.')
    }
  }

  const handleOpenAppeal = async (attempt: ExamAttempt) => {
    setAppealLoadingId(attempt.id)
    try {
      await api.post(EXAM_APPEAL_ENDPOINT(attempt.id))
      message.success('Appeal request submitted. You will be notified when it is reviewed.')
      await refreshAttempts()
    } catch {
      message.error('Unable to submit appeal. Please try again or contact support.')
    } finally {
      setAppealLoadingId(null)
    }
  }

  const handleRetry = async (attempt: ExamAttempt) => {
    setRetryLoadingId(attempt.id)
    try {
      await api.post(EXAM_RETRY_ENDPOINT(attempt.id))
      message.success('Retry triggered. You will be redirected to the registration flow.')
      // In a later iteration you might push to /konnected/certifications/exam-registration
    } catch {
      message.error('Unable to start a new attempt. Please try again or contact support.')
    } finally {
      setRetryLoadingId(null)
    }
  }

  const columns: ColumnsType<ExamAttempt> = [
    {
      title: 'Certification path',
      dataIndex: 'certificationPathName',
      key: 'certificationPathName',
      render: (text: string, record) => (
        <Space direction="vertical" size={0}>
          <Text strong>{text}</Text>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Attempt #{record.attemptNumber}
          </Text>
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      filters: [
        { text: 'Passed', value: 'passed' },
        { text: 'Not passed', value: 'failed' },
        { text: 'Pending peer validation', value: 'pending_peer' },
        { text: 'Under review', value: 'under_review' },
      ],
      onFilter: (value, record) => record.status === value,
      render: (_value, record) => (
        <Space direction="vertical" size={2}>
          {getStatusTag(record)}
          {getAppealTag(record)}
        </Space>
      ),
    },
    {
      title: 'Score',
      dataIndex: 'scorePercent',
      key: 'scorePercent',
      render: (value: number | null) => {
        if (value == null) {
          return <Text type="secondary">Pending</Text>
        }
        const color = getScoreColor(value)
        return (
          <Space direction="vertical" size={0}>
            <Text
              strong
              type={
                color === 'success'
                  ? 'success'
                  : color === 'danger'
                  ? 'danger'
                  : color === 'warning'
                  ? 'warning'
                  : undefined
              }
            >
              {value}%
            </Text>
            <Text type="secondary" style={{ fontSize: 12 }}>
              Pass threshold: {CERT_PASS_PERCENT}%
            </Text>
          </Space>
        )
      },
    },
    {
      title: 'Date',
      dataIndex: 'takenAt',
      key: 'takenAt',
      render: (value: string) => <Text>{formatDateTime(value)}</Text>,
      sorter: (a, b) => {
        const aTime = new Date(a.takenAt).getTime()
        const bTime = new Date(b.takenAt).getTime()
        return aTime - bTime
      },
      defaultSortOrder: 'descend',
    },
    {
      title: 'Delivery',
      dataIndex: 'deliveryMode',
      key: 'deliveryMode',
      render: (_value, record) => (
        <Space direction="vertical" size={0}>
          <Text>{record.deliveryMode === 'online' ? 'Online' : record.deliveryMode}</Text>
          {record.proctored && (
            <Text type="secondary" style={{ fontSize: 12 }}>
              Proctored
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'Validation',
      key: 'validation',
      render: (_value, record) => {
        if (!record.peerValidationRequired) {
          return <Text type="secondary">Not required</Text>
        }
        if (!record.peerValidationStatus || record.peerValidationStatus === 'pending') {
          return (
            <Tag icon={<ClockCircleOutlined />} color="processing">
              Waiting for peers
            </Tag>
          )
        }
        if (record.peerValidationStatus === 'approved') {
          return (
            <Tag icon={<CheckCircleOutlined />} color="success">
              Peer-approved
            </Tag>
          )
        }
        if (record.peerValidationStatus === 'rejected') {
          return (
            <Tag icon={<ExclamationCircleOutlined />} color="error">
              Peer-rejected
            </Tag>
          )
        }
        return <Text type="secondary">‚Äî</Text>
      },
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_value, record) => (
        <Space>
          <Tooltip title="View attempt details">
            <Button
              size="small"
              icon={<EyeOutlined />}
              onClick={() => handleOpenDetails(record)}
            />
          </Tooltip>
          <Tooltip title="Open certificate (if available)">
            <Button
              size="small"
              icon={<FilePdfOutlined />}
              onClick={() => handleOpenCertificate(record)}
              disabled={!record.certificateUrl}
            />
          </Tooltip>
          <Tooltip title="Open portfolio entry (if available)">
            <Button
              size="small"
              onClick={() => handleOpenPortfolio(record)}
              disabled={!record.portfolioUrl}
            >
              Portfolio
            </Button>
          </Tooltip>
          <Tooltip title="Request a manual review of this attempt">
            <Button
              size="small"
              type="default"
              icon={<WarningOutlined />}
              loading={appealLoadingId === record.id}
              onClick={() => handleOpenAppeal(record)}
              disabled={record.appealStatus === 'open'}
            >
              Appeal
            </Button>
          </Tooltip>
          <Tooltip title="Start a new attempt (if allowed)">
            <Button
              size="small"
              type="primary"
              icon={<ReloadOutlined />}
              loading={retryLoadingId === record.id}
              onClick={() => handleRetry(record)}
              disabled={!record.canRetry}
            >
              Retry
            </Button>
          </Tooltip>
        </Space>
      ),
    },
  ]

  // ---------------------------------------------------------------------------
  // Derived blocks
  // ---------------------------------------------------------------------------

  const kpiCards = (
    <Row gutter={[16, 16]}>
      <Col xs={24} sm={12} md={6}>
        <Card>
          <Statistic title="Total attempts" value={stats.totalAttempts} />
        </Card>
      </Col>
      <Col xs={24} sm={12} md={6}>
        <Card>
          <Statistic
            title="Paths passed"
            value={stats.passedCount}
            suffix={`/ ${stats.uniqueCerts || stats.totalAttempts || 0}`}
          />
        </Card>
      </Col>
      <Col xs={24} sm={12} md={6}>
        <Card>
          <Statistic title="Pass rate" value={stats.passRate} suffix="%" />
        </Card>
      </Col>
      <Col xs={24} sm={12} md={6}>
        <Card>
          <Statistic title="Average score" value={stats.avgScore} suffix="%" />
        </Card>
      </Col>
    </Row>
  )

  const cooldownAlerts = (() => {
    const blockedAttempts = attempts.filter(
      (a) => !a.canRetry && a.nextRetryAt && a.status === 'failed',
    )
    if (!blockedAttempts.length) return null

    return (
      <Alert
        type="info"
        showIcon
        style={{ marginBottom: 16 }}
        message="Retry cooldown in effect"
        description={
          <Space direction="vertical">
            <Text>
              Some attempts are temporarily blocked from retries to prevent burnout and
              encourage reflection.
            </Text>
            <List
              size="small"
              dataSource={blockedAttempts}
              renderItem={(a) => (
                <List.Item>
                  <Space direction="vertical" size={0}>
                    <Text strong>{a.certificationPathName}</Text>
                    <Text type="secondary" style={{ fontSize: 12 }}>
                      Next retry available: {formatDateTime(a.nextRetryAt)}
                    </Text>
                  </Space>
                </List.Item>
              )}
            />
            <Text type="secondary">
              Global policy: {EXAM_RETRY_COOLDOWN_MIN} minutes minimum between failed attempts
              on the same path (configurable per tenant).
            </Text>
          </Space>
        }
      />
    )
  })()

  // ---------------------------------------------------------------------------
  // Global loading / error / empty handling
  // ---------------------------------------------------------------------------

  if (loading && !data) {
    return (
      <KonnectedPageShell
        title="Exam Dashboard & Results"
        subtitle="Track your certification exam attempts, scores, and outcomes."
      >
        <div style={{ padding: 24, textAlign: 'center' }}>
          <Spin size="large" />
        </div>
      </KonnectedPageShell>
    )
  }

  if (error) {
    return (
      <KonnectedPageShell
        title="Exam Dashboard & Results"
        subtitle="Track your certification exam attempts, scores, and outcomes."
      >
        <div style={{ padding: 24 }}>
          <Result
            status="error"
            title="We could not load your exam results."
            subTitle="There was a problem contacting the CertifiKation service. Please try again in a few seconds."
            extra={
              <Button type="primary" onClick={() => refreshAttempts()}>
                Retry loading
              </Button>
            }
          />
        </div>
      </KonnectedPageShell>
    )
  }

  if (!attempts.length) {
    return (
      <KonnectedPageShell
        title="Exam Dashboard & Results"
        subtitle="Track your certification exam attempts, scores, and outcomes."
      >
        <Row gutter={24}>
          <Col xs={24} md={16}>
            <Card>
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description={
                  <Space direction="vertical">
                    <Text>You have not attempted any certification exams yet.</Text>
                    <Text type="secondary">
                      Once you complete an exam in the CertifiKation module, it will appear
                      here with your score, status, and certificate links.
                    </Text>
                  </Space>
                }
              >
                <Button
                  type="primary"
                  href="/konnected/certifications/exam-registration"
                >
                  Browse certification exams
                </Button>
              </Empty>
            </Card>
          </Col>
          <Col xs={24} md={8}>
            <Card title="How this dashboard works">
              <Space direction="vertical">
                <Text>
                  This dashboard consolidates all your exam attempts from the CertifiKation
                  module.
                </Text>
                <List
                  size="small"
                  dataSource={[
                    'Each attempt shows your score, pass/fail status, and validation state.',
                    'If peer validation is required, you will see when it is pending or approved.',
                    'Once a certification is granted, you can open the official certificate and any portfolio entry.',
                  ]}
                  renderItem={(item) => (
                    <List.Item>
                      <Text type="secondary">{item}</Text>
                    </List.Item>
                  )}
                />
              </Space>
            </Card>
          </Col>
        </Row>
      </KonnectedPageShell>
    )
  }

  // ---------------------------------------------------------------------------
  // Main content (normal case with attempts)
  // ---------------------------------------------------------------------------

  return (
    <KonnectedPageShell
      title="Exam Dashboard & Results"
      subtitle="Track your certification exam attempts, scores, and outcomes."
    >
      <Space direction="vertical" size={24} style={{ width: '100%' }}>
        {cooldownAlerts}

        {kpiCards}

        <Row gutter={24}>
          <Col xs={24} lg={16}>
            <Card
              title="Recent exam attempts"
              extra={
                <Space>
                  <Badge color="success" text="Passed" />
                  <Badge color="error" text="Not passed" />
                  <Badge color="processing" text="Pending / In progress" />
                </Space>
              }
            >
              <Table<ExamAttempt>
                rowKey="id"
                columns={columns}
                dataSource={attempts}
                loading={loading}
                pagination={{ pageSize: 10, showSizeChanger: false }}
                onRow={(record) => ({
                  onClick: () => handleOpenDetails(record),
                })}
              />
            </Card>
          </Col>

          <Col xs={24} lg={8}>
            <Space direction="vertical" size={16} style={{ width: '100%' }}>
              <Card title="Certification outcomes">
                <Space direction="vertical" size={8} style={{ width: '100%' }}>
                  <Paragraph>
                    When you pass a CertifiKation path (and, if required, peer validation is
                    approved), your certification is:
                  </Paragraph>
                  <List
                    size="small"
                    dataSource={[
                      'Recorded in the Evaluation & CertificationPath tables.',
                      'Linked to your Portfolio as a verifiable achievement.',
                      'Exposed as a downloadable/shareable certificate.',
                    ]}
                    renderItem={(item) => (
                      <List.Item>
                        <Text type="secondary">{item}</Text>
                      </List.Item>
                    )}
                  />
                </Space>
              </Card>

              <Card title="Tips for improving your score">
                <List
                  size="small"
                  dataSource={[
                    'Review the learning path content linked to this certification.',
                    'Use the Exam Preparation page to practice with sample questions.',
                    'Respect cooldowns between attempts to avoid rushed retries.',
                  ]}
                  renderItem={(item) => (
                    <List.Item>
                      <Text type="secondary">{item}</Text>
                    </List.Item>
                  )}
                />
              </Card>
            </Space>
          </Col>
        </Row>

        {/* Details drawer */}
        <Drawer
          title="Exam attempt details"
          width={520}
          open={!!selectedAttempt}
          onClose={handleCloseDetails}
          destroyOnClose
        >
          {selectedAttempt ? (
            <Space direction="vertical" size={16} style={{ width: '100%' }}>
              <div>
                <Title level={4}>{selectedAttempt.certificationPathName}</Title>
                <Text type="secondary">
                  Attempt #{selectedAttempt.attemptNumber} ¬∑{' '}
                  {formatDateTime(selectedAttempt.takenAt)}
                </Text>
              </div>

              <Space size={16}>
                <Statistic
                  title="Score"
                  value={selectedAttempt.scorePercent ?? 0}
                  suffix="%"
                />
                <Statistic
                  title="Pass threshold"
                  value={CERT_PASS_PERCENT}
                  suffix="%"
                />
              </Space>

              <Space direction="vertical" size={8}>
                <Text strong>Status</Text>
                {getStatusTag(selectedAttempt)}
                {getAppealTag(selectedAttempt)}
              </Space>

              <Space direction="vertical" size={8}>
                <Text strong>Validation & review</Text>
                <Space direction="vertical" size={4}>
                  <Text>
                    Peer validation required:{' '}
                    {selectedAttempt.peerValidationRequired ? 'Yes' : 'No'}
                  </Text>
                  <Text>
                    Peer validation status:{' '}
                    {selectedAttempt.peerValidationStatus ?? '‚Äî'}
                  </Text>
                  <Text>Appeal status: {selectedAttempt.appealStatus ?? 'none'}</Text>
                </Space>
              </Space>

              <Space direction="vertical" size={8}>
                <Text strong>Delivery & conditions</Text>
                <Space direction="vertical" size={4}>
                  <Text>Mode: {selectedAttempt.deliveryMode}</Text>
                  <Text>Proctored: {selectedAttempt.proctored ? 'Yes' : 'No'}</Text>
                </Space>
              </Space>

              <Space direction="vertical" size={8}>
                <Text strong>Linked assets</Text>
                <Space>
                  <Button
                    icon={<FilePdfOutlined />}
                    onClick={() => handleOpenCertificate(selectedAttempt)}
                    disabled={!selectedAttempt.certificateUrl}
                  >
                    Open certificate
                  </Button>
                  <Button
                    onClick={() => handleOpenPortfolio(selectedAttempt)}
                    disabled={!selectedAttempt.portfolioUrl}
                  >
                    View portfolio entry
                  </Button>
                </Space>
              </Space>

              {selectedAttempt.nextRetryAt && (
                <Alert
                  type={selectedAttempt.canRetry ? 'success' : 'info'}
                  showIcon
                  message={
                    selectedAttempt.canRetry
                      ? 'You can start a new attempt now.'
                      : 'Retry cooldown in effect for this path.'
                  }
                  description={
                    <Space direction="vertical" size={4}>
                      <Text>
                        Next retry available: {formatDateTime(selectedAttempt.nextRetryAt)}
                      </Text>
                      <Text type="secondary">
                        Global cooldown: {EXAM_RETRY_COOLDOWN_MIN} minutes between attempts
                        on the same path.
                      </Text>
                    </Space>
                  }
                />
              )}

              <Space>
                <Button
                  type="default"
                  icon={<WarningOutlined />}
                  loading={appealLoadingId === selectedAttempt.id}
                  onClick={() => handleOpenAppeal(selectedAttempt)}
                  disabled={selectedAttempt.appealStatus === 'open'}
                >
                  Open appeal
                </Button>
                <Button
                  type="primary"
                  icon={<ReloadOutlined />}
                  loading={retryLoadingId === selectedAttempt.id}
                  onClick={() => handleRetry(selectedAttempt)}
                  disabled={!selectedAttempt.canRetry}
                >
                  Start new attempt
                </Button>
              </Space>
            </Space>
          ) : (
            <Spin />
          )}
        </Drawer>
      </Space>
    </KonnectedPageShell>
  )
}

export default ExamDashboardResultsPage

===== END app/konnected/certifications/exam-dashboard-results/page.tsx =====


===== BEGIN app/konnected/certifications/exam-preparation/page.tsx =====
Ôªø// app/konnected/certifications/exam-preparation/page.tsx
'use client';

import React, { useMemo } from 'react';
import { useRouter } from 'next/navigation';
import {
  Alert,
  Button,
  Card,
  Col,
  List,
  Progress,
  Row,
  Statistic,
  Steps,
  Tabs,
  Tag,
  Typography,
  Skeleton,
  Space,
} from 'antd';
import {
  ArrowRightOutlined,
  CalendarOutlined,
  CheckCircleTwoTone,
  ClockCircleOutlined,
  FileSearchOutlined,
  FlagOutlined,
  PlayCircleOutlined,
  WarningTwoTone,
} from '@ant-design/icons';
import { useQuery } from '@tanstack/react-query';
import dayjs from 'dayjs';

import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import { get } from '@/services/_request';

const { Text } = Typography;
const { Step } = Steps;

const CERT_PASS_PERCENT = 80; // from CertifiKation spec
const QUIZ_RETRY_COOLDOWN_MIN = 30; // from CertifiKation spec

// TODO: align this with the actual OpenAPI path in schema-endpoints.json
const EXAM_PREPARATION_ENDPOINT = 'certs/exam-preparation/plan';

type PrepModuleType = 'content' | 'practice_quiz' | 'project' | 'checkpoint';

type PrepModuleStatus = 'not_started' | 'in_progress' | 'completed';

interface PrepModule {
  id: string;
  title: string;
  type: PrepModuleType;
  status: PrepModuleStatus;
  progressPercent: number;
  estimatedMinutes?: number | null;
  lastTouchedAt?: string | null;
  isCriticalWeakness?: boolean;
}

interface FocusArea {
  id: string;
  label: string;
  description?: string | null;
  recommendedResourcesCount?: number | null;
}

interface ExamPreparationPathInfo {
  id: number | string;
  name: string;
  description?: string | null;
}

interface ExamPreparationExamInfo {
  targetDate?: string | null;
  recommendedStudyHours?: number | null;
  lastScorePercent?: number | null;
  lastResult?: 'pass' | 'fail' | null;
  lastAttemptAt?: string | null;
  attemptsUsed?: number | null;
  attemptsAllowed?: number | null;
  isCooldownActive?: boolean;
  cooldownEndsAt?: string | null;
  passPercent?: number | null;
  retryCooldownMinutes?: number | null;
}

interface ExamPreparationResponse {
  path?: ExamPreparationPathInfo | null;
  exam?: ExamPreparationExamInfo | null;
  overallProgressPercent?: number | null;
  modules?: PrepModule[] | null;
  focusAreas?: FocusArea[] | null;
}

function computeOverallProgress(modules: PrepModule[] | undefined | null): number {
  if (!modules || modules.length === 0) {
    return 0;
  }
  const sum = modules.reduce((acc, m) => acc + (m.progressPercent ?? 0), 0);
  return Math.round(sum / modules.length);
}

function computeStepIndex(progress: number): number {
  if (progress >= 90) return 3;
  if (progress >= 60) return 2;
  if (progress >= 30) return 1;
  return 0;
}

function getReadinessBadge(
  progress: number,
  lastScore: number | null | undefined,
  passPercent: number,
): { status: 'ready' | 'almost' | 'not_ready'; label: string; color: 'green' | 'gold' | 'red' } {
  if (lastScore != null && lastScore >= passPercent) {
    return { status: 'ready', label: 'Ready based on last score', color: 'green' };
  }
  if (progress >= passPercent - 10) {
    return { status: 'almost', label: 'Almost ready ‚Äì focus on weak areas', color: 'gold' };
  }
  return { status: 'not_ready', label: 'Not ready yet ‚Äì keep studying', color: 'red' };
}

async function fetchExamPreparation(): Promise<ExamPreparationResponse> {
  // Uses the shared _request helper which already knows the /api base URL
  return get<ExamPreparationResponse>(EXAM_PREPARATION_ENDPOINT);
}

export default function ExamPreparationPage(): JSX.Element {
  const router = useRouter();

  const { data, isLoading, error } = useQuery<ExamPreparationResponse>({
    queryKey: ['certs', 'exam-preparation'],
    queryFn: fetchExamPreparation,
  });

  const modules: PrepModule[] = data?.modules ?? [];
  const focusAreas: FocusArea[] = data?.focusAreas ?? [];

  const overallProgress = useMemo(() => {
    return data?.overallProgressPercent != null
      ? Math.round(data.overallProgressPercent)
      : computeOverallProgress(modules);
  }, [data?.overallProgressPercent, modules]);

  const passPercent = data?.exam?.passPercent ?? CERT_PASS_PERCENT;
  const retryCooldownMinutes =
    data?.exam?.retryCooldownMinutes ?? QUIZ_RETRY_COOLDOWN_MIN;

  const lastScore = data?.exam?.lastScorePercent ?? null;
  const targetDate = data?.exam?.targetDate ?? null;
  const isCooldownActive = data?.exam?.isCooldownActive ?? false;
  const cooldownEndsAt = data?.exam?.cooldownEndsAt ?? null;

  const readiness = getReadinessBadge(overallProgress, lastScore, passPercent);
  const currentStepIndex = computeStepIndex(overallProgress);

  const recommendedStudyHours = data?.exam?.recommendedStudyHours ?? null;

  const handleGoToExamRegistration = () => {
    router.push('/konnected/certifications/exam-registration');
  };

  const handleGoToExamDashboard = () => {
    router.push('/konnected/certifications/exam-dashboard-results');
  };

  const handleStartPracticeExam = () => {
    // TODO: plug into automated_evaluation ‚Äúpractice mode‚Äù endpoint / route
    router.push('/konnected/certifications/exam-dashboard-results');
  };

  const subtitle = (
    <>
      Get an at-a-glance view of your preparation for this certification path:
      study modules, focus areas, readiness vs. the {passPercent}% pass threshold,
      and next steps.
    </>
  );

  const renderModulesList = () => {
    if (!isLoading && modules.length === 0) {
      return (
        <Alert
          type="info"
          showIcon
          message="No study modules are defined yet."
          description="Once your CertificationPath is configured with learning units, they will appear here as a guided preparation plan."
        />
      );
    }

    if (isLoading) {
      return <Skeleton active paragraph={{ rows: 4 }} />;
    }

    return (
      <List
        itemLayout="horizontal"
        dataSource={modules}
        renderItem={(module) => (
          <List.Item
            actions={[
              <Button
                type="link"
                key="view"
                icon={<ArrowRightOutlined />}
                // TODO: route to the actual learning unit detail, once available
                onClick={() => {
                  // eslint-disable-next-line no-console
                  console.log('Open module', module.id);
                }}
              >
                View module
              </Button>,
            ]}
          >
            <List.Item.Meta
              title={
                <Space size="small">
                  <span>{module.title}</span>
                  {module.status === 'completed' && (
                    <CheckCircleTwoTone twoToneColor="#52c41a" />
                  )}
                  {module.isCriticalWeakness && (
                    <Tag color="volcano" icon={<WarningTwoTone twoToneColor="#fa541c" />}>
                      Focus area
                    </Tag>
                  )}
                </Space>
              }
              description={
                <Space direction="vertical" size={2}>
                  <Space size="small" wrap>
                    <Tag>
                      {module.type === 'content'
                        ? 'Content'
                        : module.type === 'practice_quiz'
                        ? 'Practice quiz'
                        : module.type === 'project'
                        ? 'Project'
                        : 'Checkpoint'}
                    </Tag>
                    <Text type="secondary">
                      {module.status === 'completed'
                        ? 'Completed'
                        : module.status === 'in_progress'
                        ? `In progress ‚Äì ${module.progressPercent}%`
                        : 'Not started yet'}
                    </Text>
                    {module.estimatedMinutes != null && (
                      <Text type="secondary">
                        ‚Ä¢ ~{module.estimatedMinutes} min
                      </Text>
                    )}
                  </Space>
                  <Progress
                    percent={Math.round(module.progressPercent)}
                    size="small"
                    status={module.status === 'completed' ? 'success' : 'active'}
                  />
                  {module.lastTouchedAt && (
                    <Text type="secondary" style={{ fontSize: 12 }}>
                      Last worked on:{' '}
                      {dayjs(module.lastTouchedAt).format('MMM D, YYYY HH:mm')}
                    </Text>
                  )}
                </Space>
              }
            />
          </List.Item>
        )}
      />
    );
  };

  const renderFocusAreas = () => {
    if (!isLoading && focusAreas.length === 0) {
      return (
        <Alert
          type="info"
          showIcon
          message="No specific focus areas identified yet."
          description="Once you complete some evaluations, the system will highlight weak domains to prioritize in your study time."
        />
      );
    }

    if (isLoading) {
      return <Skeleton active paragraph={{ rows: 3 }} />;
    }

    return (
      <List
        dataSource={focusAreas}
        renderItem={(area) => (
          <List.Item>
            <List.Item.Meta
              title={
                <Space>
                  <FlagOutlined />
                  <span>{area.label}</span>
                </Space>
              }
              description={
                <>
                  {area.description && (
                    <Text type="secondary" style={{ display: 'block' }}>
                      {area.description}
                    </Text>
                  )}
                  {area.recommendedResourcesCount != null && (
                    <Text type="secondary" style={{ fontSize: 12 }}>
                      {area.recommendedResourcesCount} recommended resources
                      {area.recommendedResourcesCount === 1 ? '' : 's'} in Knowledge
                    </Text>
                  )}
                </>
              }
            />
          </List.Item>
        )}
      />
    );
  };

  const mainTabsItems = [
    {
      key: 'plan',
      label: 'Study plan & progress',
      children: (
        <Card bordered={false}>
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <div>
              <Text strong>Your overall preparation progress</Text>
              <Progress
                percent={overallProgress}
                status={overallProgress >= passPercent ? 'success' : 'active'}
              />
              <Text type="secondary" style={{ fontSize: 12 }}>
                Based on all study modules in this CertificationPath.
              </Text>
            </div>

            <div>
              <Text strong>Recommended sequence</Text>
              <Steps
                direction="vertical"
                size="small"
                current={currentStepIndex}
                style={{ marginTop: 8 }}
              >
                <Step title="Study core content" description="Work through required modules and lessons." />
                <Step
                  title="Complete practice activities"
                  description="Interactive exercises, quizzes, and projects."
                />
                <Step
                  title="Attempt a practice evaluation"
                  description={`Use automated_evaluation in ‚Äúpractice mode‚Äù to benchmark against ${passPercent}%.`}
                />
                <Step
                  title="Review feedback & focus areas"
                  description="Revisit weak domains before booking the official exam."
                />
              </Steps>
            </div>

            <Button
              type="primary"
              icon={<PlayCircleOutlined />}
              onClick={handleStartPracticeExam}
              disabled={isCooldownActive}
            >
              Start practice exam
            </Button>

            {isCooldownActive && cooldownEndsAt && (
              <Alert
                type="warning"
                showIcon
                message="Practice exam on cooldown"
                description={
                  <>
                    You recently attempted a practice evaluation. You can try again after{' '}
                    {dayjs(cooldownEndsAt).format('MMM D, YYYY HH:mm')} (cooldown{' '}
                    {retryCooldownMinutes} minutes).
                  </>
                }
              />
            )}
          </Space>
        </Card>
      ),
    },
    {
      key: 'focus',
      label: 'Focus areas',
      children: <Card bordered={false}>{renderFocusAreas()}</Card>,
    },
  ];

  return (
    <KonnectedPageShell
      title={data?.path?.name ?? 'Exam Preparation'}
      subtitle={subtitle}
      primaryAction={
        <Button
          type="primary"
          icon={<CalendarOutlined />}
          onClick={handleGoToExamRegistration}
        >
          Exam registration
        </Button>
      }
      secondaryActions={
        <Button
          icon={<FileSearchOutlined />}
          onClick={handleGoToExamDashboard}
        >
          Exam dashboard
        </Button>
      }
    >
      {error && (
        <Alert
          type="error"
          showIcon
          style={{ marginBottom: 16 }}
          message="Unable to load your exam preparation data"
          description="Please try again in a moment. If the problem persists, contact an administrator."
        />
      )}

      <Row gutter={[24, 24]}>
        {/* Left: modules + plan */}
        <Col xs={24} lg={16}>
          <Card
            title={
              data?.path?.name
                ? `Study modules for: ${data.path.name}`
                : 'Study modules'
            }
            extra={
              <Tag color={readiness.color} icon={<FlagOutlined />}>
                {readiness.label}
              </Tag>
            }
            style={{ marginBottom: 24 }}
          >
            {renderModulesList()}
          </Card>

          <Tabs
            defaultActiveKey="plan"
            items={mainTabsItems}
            destroyInactiveTabPane={false}
          />
        </Col>

        {/* Right: metrics + focus summary */}
        <Col xs={24} lg={8}>
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <Card>
              {isLoading ? (
                <Skeleton active paragraph={{ rows: 3 }} />
              ) : (
                <>
                  <Row gutter={[16, 16]}>
                    <Col span={12}>
                      <Statistic
                        title="Overall progress"
                        value={overallProgress}
                        suffix="%"
                      />
                    </Col>
                    <Col span={12}>
                      <Statistic
                        title="Pass threshold"
                        value={passPercent}
                        suffix="%"
                      />
                    </Col>
                  </Row>

                  <Row gutter={[16, 16]} style={{ marginTop: 16 }}>
                    <Col span={12}>
                      <Statistic
                        title="Recommended study time"
                        value={
                          recommendedStudyHours != null
                            ? recommendedStudyHours
                            : '‚Äî'
                        }
                        suffix={recommendedStudyHours != null ? 'hrs' : undefined}
                        prefix={<ClockCircleOutlined />}
                      />
                    </Col>
                    <Col span={12}>
                      <Statistic
                        title="Retry cooldown"
                        value={retryCooldownMinutes}
                        suffix="min"
                        prefix={<ClockCircleOutlined />}
                      />
                    </Col>
                  </Row>

                  <div style={{ marginTop: 16 }}>
                    <Text type="secondary" style={{ display: 'block' }}>
                      Pass/fail uses a frozen threshold ({passPercent}%), and
                      failed attempts are throttled by a{' '}
                      {retryCooldownMinutes}-minute cooldown.
                    </Text>
                  </div>
                </>
              )}
            </Card>

            <Card title="Upcoming exam">
              {isLoading ? (
                <Skeleton active paragraph={{ rows: 2 }} />
              ) : targetDate ? (
                <>
                  <Space direction="vertical" size="small">
                    <Space>
                      <CalendarOutlined />
                      <Text strong>
                        {dayjs(targetDate).format('MMMM D, YYYY')}
                      </Text>
                    </Space>
                    <Text type="secondary">
                      Make sure your preparation progress and practice scores are
                      comfortably above {passPercent}% before this date.
                    </Text>
                  </Space>
                  <Button
                    type="link"
                    icon={<CalendarOutlined />}
                    style={{ marginTop: 12, paddingLeft: 0 }}
                    onClick={handleGoToExamRegistration}
                  >
                    Adjust exam session
                  </Button>
                </>
              ) : (
                <>
                  <Alert
                    type="info"
                    showIcon
                    message="No exam date scheduled"
                    description="Book a session to lock in your target exam date and align your study plan."
                  />
                  <Button
                    type="primary"
                    icon={<CalendarOutlined />}
                    style={{ marginTop: 12 }}
                    onClick={handleGoToExamRegistration}
                  >
                    Schedule exam
                  </Button>
                </>
              )}
            </Card>

            <Card title="Focus summary">
              {isLoading ? (
                <Skeleton active paragraph={{ rows: 3 }} />
              ) : (
                <>
                  {focusAreas.length > 0 ? (
                    <>
                      <Text>
                        You have {focusAreas.length} identified focus{' '}
                        {focusAreas.length === 1 ? 'area' : 'areas'} based on your
                        evaluations.
                      </Text>
                      <div style={{ marginTop: 12 }}>{renderFocusAreas()}</div>
                      <Button
                        type="link"
                        style={{ marginTop: 8, paddingLeft: 0 }}
                        onClick={handleGoToExamDashboard}
                      >
                        View detailed breakdown in Exam Dashboard
                      </Button>
                    </>
                  ) : (
                    <Text type="secondary">
                      Once you complete your first practice or official exam,
                      we will highlight weak domains and recommended topics
                      here.
                    </Text>
                  )}
                </>
              )}
            </Card>
          </Space>
        </Col>
      </Row>
    </KonnectedPageShell>
  );
}

===== END app/konnected/certifications/exam-preparation/page.tsx =====


===== BEGIN app/konnected/certifications/exam-registration/page.tsx =====
Ôªø'use client';

import React, { useEffect, useMemo, useState } from 'react';
import {
  Alert,
  Button,
  Card,
  Checkbox,
  Empty,
  Form,
  Input,
  Result,
  Select,
  Space,
  Spin,
  Steps,
  Typography,
  message as antdMessage,
} from 'antd';
import type { FormInstance } from 'antd/es/form';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import PageContainer from '@/components/PageContainer';

const { Step } = Steps;
const { Option } = Select;
const { Title, Paragraph, Text } = Typography;

/**
 * NOTE ABOUT ENDPOINTS
 *
 * These constants assume the backend OpenAPI (schema-endpoints.json) exposes
 * KonnectED ‚Üí CertifiKation endpoints under `/api/konnected/certifications/...`.
 * Adjust the paths to your actual routes if they differ.
 */
const EXAM_PATHS_ENDPOINT = '/api/konnected/certifications/paths/';
const EXAM_SESSIONS_ENDPOINT = (pathId: number | string) =>
  `/api/konnected/certifications/paths/${pathId}/sessions/`;
const EXAM_REGISTRATION_ENDPOINT = '/api/konnected/certifications/evaluations/';
const EXAM_ELIGIBILITY_ENDPOINT = (pathId: number | string) =>
  `/api/konnected/certifications/paths/${pathId}/eligibility/`;

/**
 * Domain types derived from CertifiKation & Knowledge specs + API schema.
 * Adjust the shapes to match your generated types from schema-endpoints.json.
 */
type CertificationPath = {
  id: number;
  name: string;
  description?: string;
  level?: string;
  tags?: string[];
  already_passed?: boolean;
  cooldown_remaining_minutes?: number | null;
};

type ExamSession = {
  id: number;
  start_at: string; // ISO datetime
  end_at?: string | null;
  timezone?: string | null;
  modality?: string | null; // e.g. 'online', 'remote_proctored', 'in_person'
  location?: string | null;
  capacity?: number | null;
  seats_remaining?: number | null;
  registration_deadline?: string | null;
};

type ExamEligibility = {
  already_passed: boolean;
  cooldown_remaining_minutes: number;
};

interface ExamRegistrationFormValues {
  examPathId?: number;
  sessionId?: number;
  fullName?: string;
  agreeTerms?: boolean;
}

type StepKey = 0 | 1 | 2;

const steps: { key: StepKey; title: string; description?: string }[] = [
  { key: 0, title: 'Choose exam', description: 'Select the certification you want to attempt.' },
  {
    key: 1,
    title: 'Schedule & details',
    description: 'Pick an exam session and confirm your details.',
  },
  { key: 2, title: 'Confirm', description: 'Review and submit your registration.' },
];

const ExamRegistrationPage: React.FC = () => {
  const [form] = Form.useForm<ExamRegistrationFormValues>();

  const [currentStep, setCurrentStep] = useState<StepKey>(0);
  const [paths, setPaths] = useState<CertificationPath[]>([]);
  const [pathsLoading, setPathsLoading] = useState<boolean>(false);
  const [pathsError, setPathsError] = useState<string | null>(null);

  const [sessions, setSessions] = useState<ExamSession[]>([]);
  const [sessionsLoading, setSessionsLoading] = useState<boolean>(false);
  const [sessionsError, setSessionsError] = useState<string | null>(null);

  const [eligibility, setEligibility] = useState<ExamEligibility | null>(null);
  const [eligibilityLoading, setEligibilityLoading] = useState<boolean>(false);

  const [submitting, setSubmitting] = useState<boolean>(false);
  const [registrationCompleted, setRegistrationCompleted] = useState<boolean>(false);

  /**
   * Load available certification paths (exams) on mount.
   */
  useEffect(() => {
    const fetchPaths = async () => {
      setPathsLoading(true);
      setPathsError(null);
      try {
        const res = await fetch(EXAM_PATHS_ENDPOINT, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
        });

        if (!res.ok) {
          throw new Error(`Failed to load certification programs (${res.status})`);
        }

        const data = (await res.json()) as CertificationPath[];
        setPaths(data);
      } catch (err: any) {
        const msg = err?.message ?? 'Failed to load certification programs.';
        setPathsError(msg);
        antdMessage.error(msg);
      } finally {
        setPathsLoading(false);
      }
    };

    void fetchPaths();
  }, []);

  const selectedPathId = Form.useWatch('examPathId', form);
  const selectedSessionId = Form.useWatch('sessionId', form);
  const fullName = Form.useWatch('fullName', form);

  const selectedPath = useMemo(
    () => paths.find((p) => p.id === selectedPathId),
    [paths, selectedPathId],
  );
  const selectedSession = useMemo(
    () => sessions.find((s) => s.id === selectedSessionId),
    [sessions, selectedSessionId],
  );

  /**
   * When the selected path changes, load sessions and eligibility.
   */
  useEffect(() => {
    if (!selectedPathId) {
      setSessions([]);
      setEligibility(null);
      return;
    }

    const fetchEligibility = async () => {
      setEligibilityLoading(true);
      try {
        const res = await fetch(EXAM_ELIGIBILITY_ENDPOINT(selectedPathId), {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
        });
        if (res.ok) {
          const data = (await res.json()) as ExamEligibility;
          setEligibility(data);
        } else if (res.status === 404) {
          // eligibility not implemented; fall back to path fields
          setEligibility(null);
        } else {
          throw new Error(`Failed to load eligibility (${res.status})`);
        }
      } catch {
        // Non-fatal: we can still continue with path-level info
        setEligibility(null);
      } finally {
        setEligibilityLoading(false);
      }
    };

    const fetchSessions = async () => {
      setSessionsLoading(true);
      setSessionsError(null);
      try {
        const res = await fetch(EXAM_SESSIONS_ENDPOINT(selectedPathId), {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
        });

        if (!res.ok) {
          throw new Error(`Failed to load exam sessions (${res.status})`);
        }

        const data = (await res.json()) as ExamSession[];
        setSessions(data);
      } catch (err: any) {
        const msg = err?.message ?? 'Failed to load exam sessions.';
        setSessionsError(msg);
        antdMessage.error(msg);
      } finally {
        setSessionsLoading(false);
      }
    };

    void fetchEligibility();
    void fetchSessions();
  }, [selectedPathId]);

  const isPathAlreadyPassed =
    eligibility?.already_passed ?? (selectedPath?.already_passed ?? false);
  const cooldownMinutes =
    eligibility?.cooldown_remaining_minutes ?? (selectedPath?.cooldown_remaining_minutes ?? 0);
  const isUnderCooldown = !!cooldownMinutes && cooldownMinutes > 0;

  const cannotRegisterForPath = isPathAlreadyPassed || isUnderCooldown;

  const handleNext = async () => {
    try {
      if (currentStep === 0) {
        await form.validateFields(['examPathId']);
      } else if (currentStep === 1) {
        await form.validateFields(['sessionId', 'fullName', 'agreeTerms']);
      }
      setCurrentStep((prev) => (prev + 1) as StepKey);
    } catch {
      // errors are displayed by antd Form
    }
  };

  const handlePrev = () => {
    setCurrentStep((prev) => (prev - 1) as StepKey);
  };

  const handleSubmit = async () => {
    try {
      await form.validateFields();
    } catch {
      return;
    }

    const values = form.getFieldsValue() as Required<ExamRegistrationFormValues>;

    // Basic safety checks
    if (!values.examPathId || !values.sessionId) {
      antdMessage.error('Please select an exam and session before submitting.');
      return;
    }

    const payload = {
      path_id: values.examPathId,
      session_id: values.sessionId,
      full_name: values.fullName,
      agreed_terms: values.agreeTerms === true,
    };

    setSubmitting(true);
    try {
      const res = await fetch(EXAM_REGISTRATION_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(payload),
      });

      if (res.ok || res.status === 201) {
        setRegistrationCompleted(true);
        antdMessage.success('Exam registration completed successfully.');
        return;
      }

      if (res.status === 409) {
        // Conflict: cooldown, already passed, capacity reached, etc.
        const errorBody = (await res.json().catch(() => null)) as any;
        const detail: string =
          errorBody?.detail ||
          errorBody?.message ||
          'You cannot register for this exam at the moment.';

        antdMessage.error(detail);
        return;
      }

      // Other errors
      const errorBody = (await res.json().catch(() => null)) as any;
      const detail: string =
        errorBody?.detail || errorBody?.message || 'Failed to complete registration.';
      antdMessage.error(detail);
    } catch (err: any) {
      const msg = err?.message ?? 'Unexpected error while registering for the exam.';
      antdMessage.error(msg);
    } finally {
      setSubmitting(false);
    }
  };

  const renderExamChoiceStep = () => {
    if (pathsLoading) {
      return (
        <div className="flex justify-center py-8">
          <Spin tip="Loading certification programs..." />
        </div>
      );
    }

    if (pathsError) {
      return (
        <Alert
          type="error"
          message="Unable to load certification programs"
          description={pathsError}
          showIcon
        />
      );
    }

    if (!paths.length) {
      return (
        <Empty
          description="No certification programs are available for registration at this time."
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        />
      );
    }

    return (
      <Space direction="vertical" size="large" className="w-full">
        <Form.Item
          name="examPathId"
          label="Certification exam"
          rules={[{ required: true, message: 'Please select a certification exam.' }]}
        >
          <Select
            placeholder="Select an exam to register for"
            optionFilterProp="children"
            showSearch
          >
            {paths.map((path) => (
              <Option key={path.id} value={path.id}>
                {path.name}
                {path.level ? ` ¬∑ ${path.level}` : ''}
              </Option>
            ))}
          </Select>
        </Form.Item>

        {selectedPath && (
          <Card title={selectedPath.name} bordered>
            {selectedPath.description && <Paragraph>{selectedPath.description}</Paragraph>}
            {selectedPath.tags && selectedPath.tags.length > 0 && (
              <Paragraph>
                {selectedPath.tags.map((tag) => (
                  <Text key={tag} code className="mr-2">
                    {tag}
                  </Text>
                ))}
              </Paragraph>
            )}

            <Space direction="vertical" size="small" style={{ marginTop: 8 }}>
              {isPathAlreadyPassed && (
                <Alert
                  type="success"
                  message="You are already certified for this path."
                  description="Creating new attempts is not allowed because you already hold this certification."
                  showIcon
                />
              )}

              {isUnderCooldown && (
                <Alert
                  type="warning"
                  message="Retry cooldown active"
                  description={`You must wait ${cooldownMinutes} more minutes before registering another attempt for this exam.`}
                  showIcon
                />
              )}
            </Space>
          </Card>
        )}
      </Space>
    );
  };

  const renderScheduleStep = () => {
    if (!selectedPathId) {
      return (
        <Alert
          type="info"
          message="Select an exam first"
          description="Choose a certification exam in the previous step before picking a session."
          showIcon
        />
      );
    }

    return (
      <Space direction="vertical" size="large" className="w-full">
        {sessionsLoading && (
          <div className="flex justify-center py-4">
            <Spin tip="Loading exam sessions..." />
          </div>
        )}

        {sessionsError && (
          <Alert
            type="error"
            message="Unable to load exam sessions"
            description={sessionsError}
            showIcon
          />
        )}

        {!sessionsLoading && !sessionsError && sessions.length === 0 && (
          <Alert
            type="warning"
            message="No sessions available"
            description="There are currently no upcoming sessions for this exam. Please check back later or contact your administrator."
            showIcon
          />
        )}

        <Form.Item
          name="sessionId"
          label="Exam session"
          rules={[{ required: true, message: 'Please select an exam session.' }]}
        >
          <Select placeholder="Select a session" disabled={sessions.length === 0}>
            {sessions.map((session) => {
              const start = new Date(session.start_at);
              const end = session.end_at ? new Date(session.end_at) : null;
              const timeLabel = `${start.toLocaleString()}${
                end ? ` ‚Äì ${end.toLocaleTimeString()}` : ''
              }`;
              const seats =
                typeof session.seats_remaining === 'number'
                  ? `${session.seats_remaining} seats left`
                  : 'Capacity info unavailable';

              const labelParts = [
                timeLabel,
                session.modality ? ` ¬∑ ${session.modality}` : '',
                session.location ? ` ¬∑ ${session.location}` : '',
                ` ¬∑ ${seats}`,
              ];

              return (
                <Option key={session.id} value={session.id}>
                  {labelParts.join('')}
                </Option>
              );
            })}
          </Select>
        </Form.Item>

        <Form.Item
          name="fullName"
          label="Full name"
          rules={[{ required: true, message: 'Please enter your full name.' }]}
        >
          <Input placeholder="This will be used on your exam record and certificate" />
        </Form.Item>

        <Form.Item
          name="agreeTerms"
          valuePropName="checked"
          rules={[
            {
              validator: (_, value) =>
                value
                  ? Promise.resolve()
                  : Promise.reject(
                      new Error('You must agree to the exam policies to continue.'),
                    ),
            },
          ]}
        >
          <Checkbox>
            I confirm that I have read and agree to the exam terms, proctoring rules, and
            integrity policies.
          </Checkbox>
        </Form.Item>

        <Alert
          type="info"
          showIcon
          message="Before you register"
          description={
            <span>
              You will be able to view this exam and its status in your Exam Dashboard after
              registration. You must achieve at least <b>80%</b> to pass, and there is a{' '}
              <b>30-minute retry cooldown</b> if you fail an attempt.
            </span>
          }
        />
      </Space>
    );
  };

  const renderConfirmStep = () => {
    if (!selectedPath || !selectedSessionId) {
      return (
        <Alert
          type="info"
          message="Incomplete registration"
          description="Please select an exam and session in the previous steps before confirming."
          showIcon
        />
      );
    }

    const session = selectedSession!;
    const start = new Date(session.start_at);
    const end = session.end_at ? new Date(session.end_at) : null;

    return (
      <Space direction="vertical" size="large" className="w-full">
        <Card title="Review your registration">
          <Space direction="vertical" size="middle">
            <div>
              <Text type="secondary">Certification exam</Text>
              <br />
              <Text strong>{selectedPath.name}</Text>
              {selectedPath.level && (
                <>
                  {' '}
                  <Text type="secondary">¬∑ {selectedPath.level}</Text>
                </>
              )}
            </div>

            <div>
              <Text type="secondary">Session</Text>
              <br />
              <Text strong>
                {start.toLocaleString()}
                {end && <> ‚Äì {end.toLocaleTimeString()}</>}
              </Text>
              {session.modality && (
                <>
                  <br />
                  <Text type="secondary">Mode: {session.modality}</Text>
                </>
              )}
              {session.location && (
                <>
                  <br />
                  <Text type="secondary">Location: {session.location}</Text>
                </>
              )}
            </div>

            <div>
              <Text type="secondary">Name on record</Text>
              <br />
              <Text strong>{fullName || 'Not provided'}</Text>
            </div>
          </Space>
        </Card>

        <Alert
          type="warning"
          showIcon
          message="Please confirm"
          description="Once you submit, this session will be reserved for you, subject to capacity and eligibility checks. You may need to contact support to change or cancel your booking."
        />
      </Space>
    );
  };

  const renderStepContent = () => {
    if (registrationCompleted) {
      return null;
    }

    switch (currentStep) {
      case 0:
        return renderExamChoiceStep();
      case 1:
        return renderScheduleStep();
      case 2:
        return renderConfirmStep();
      default:
        return null;
    }
  };

  const renderFooterButtons = () => {
    if (registrationCompleted) {
      return null;
    }

    const isFirstStep = currentStep === 0;
    const isLastStep = currentStep === steps.length - 1;

    const nextDisabled =
      currentStep === 0
        ? !selectedPathId || cannotRegisterForPath
        : currentStep === 1
        ? !selectedSessionId
        : false;

    return (
      <Space style={{ marginTop: 24 }}>
        {!isFirstStep && (
          <Button onClick={handlePrev} disabled={submitting}>
            Back
          </Button>
        )}
        {!isLastStep && (
          <Button
            type="primary"
            onClick={handleNext}
            disabled={nextDisabled || (currentStep === 0 && cannotRegisterForPath)}
          >
            Next
          </Button>
        )}
        {isLastStep && (
          <Button
            type="primary"
            onClick={handleSubmit}
            loading={submitting}
            disabled={cannotRegisterForPath}
          >
            Submit registration
          </Button>
        )}
      </Space>
    );
  };

  if (registrationCompleted) {
    return (
      <KonnectedPageShell
        title="Exam registration completed"
        subtitle="Your exam attempt has been scheduled. You can review your registrations and outcomes in the Exam Dashboard."
      >
        <PageContainer title="Exam registration completed">
          <Result
            status="success"
            title="Your exam registration is confirmed"
            subTitle="You will receive a confirmation with details by email. You can also review this exam under your Exam Dashboard."
            extra={
              <Space>
                <Button type="primary" href="/konnected/certifications/exam-dashboard-results">
                  Go to Exam Dashboard
                </Button>
                <Button href="/konnected/certifications/exam-preparation">
                  View preparation resources
                </Button>
              </Space>
            }
          />
        </PageContainer>
      </KonnectedPageShell>
    );
  }

  return (
    <KonnectedPageShell
      title="Register for an exam"
      subtitle="Choose a certification exam, pick a session, and confirm your registration."
    >
      <PageContainer title="Register for an exam">
        <Card>
          <Space direction="vertical" size="large" className="w-full">
            <div>
              <Steps current={currentStep} responsive>
                {steps.map((step) => (
                  <Step key={step.key} title={step.title} description={step.description} />
                ))}
              </Steps>
            </div>

            {(eligibilityLoading || pathsLoading) && (
              <Alert
                type="info"
                showIcon
                message="Loading exam options"
                description="We are loading the available certification programs and checking your eligibility."
              />
            )}

            <Form<ExamRegistrationFormValues> layout="vertical" form={form}>
              {renderStepContent()}
            </Form>

            {renderFooterButtons()}
          </Space>
        </Card>
      </PageContainer>
    </KonnectedPageShell>
  );
};

export default ExamRegistrationPage;

===== END app/konnected/certifications/exam-registration/page.tsx =====


===== BEGIN app/konnected/community-discussions/active-threads/page.tsx =====
Ôªø// C:\MyCode\Konnaxionv14\frontend\app\konnected\community-discussions\active-threads\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Alert,
  Avatar,
  Badge,
  Button,
  Card,
  Empty,
  Input,
  List,
  Pagination,
  Select,
  Skeleton,
  Space,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import {
  FireOutlined,
  MessageTwoTone,
  QuestionCircleOutlined,
  ReloadOutlined,
  SearchOutlined,
  TeamOutlined,
} from '@ant-design/icons';
import { useQuery } from '@tanstack/react-query';
import { api } from '@/shared/api';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text, Title, Paragraph } = Typography;
const { Option } = Select;

const ACTIVE_THREADS_ENDPOINT =
  '/api/konnected/community-discussions/active-threads';

type TopicKind = 'question' | 'discussion';

type TopicStatus = 'open' | 'closed' | 'archived';

export interface ForumTopicSummary {
  id: string;
  title: string;
  category?: string | null;
  kind?: TopicKind | null; // question vs discussion
  status?: TopicStatus | null;
  tags?: string[];
  replies_count: number;
  participants_count?: number;
  last_activity_at: string;
  last_activity_by?: string | null;
  last_activity_snippet?: string | null;
  created_by_name?: string | null;
  created_by_avatar_url?: string | null;
  is_pinned?: boolean;
  is_unread?: boolean;
  linked_resource_title?: string | null; // if tied to a KnowledgeResource
}

interface ActiveThreadsResponse {
  results: ForumTopicSummary[];
  page: number;
  page_size: number;
  total: number;
}

/** Local UI state ‚Üí query params mapping */
type TopicFilter = 'all' | 'questions' | 'discussions';
type SortOption = 'recent' | 'most_replies' | 'most_active';

function useActiveThreads(params: {
  page: number;
  pageSize: number;
  search: string;
  topicFilter: TopicFilter;
  sort: SortOption;
}) {
  const queryParams = useMemo(() => {
    const base: Record<string, string | number | undefined> = {
      page: params.page,
      page_size: params.pageSize,
      q: params.search.trim() || undefined,
      sort:
        params.sort === 'recent'
          ? 'last_activity_desc'
          : params.sort === 'most_replies'
          ? 'replies_desc'
          : 'participants_desc',
    };

    if (params.topicFilter === 'questions') {
      base.kind = 'question';
    } else if (params.topicFilter === 'discussions') {
      base.kind = 'discussion';
    }

    return base;
  }, [params.page, params.pageSize, params.search, params.topicFilter, params.sort]);

  return useQuery<ActiveThreadsResponse, Error, ActiveThreadsResponse, [string, typeof queryParams]>({
    queryKey: ['konnected-active-threads', queryParams],
    staleTime: 60_000,
    queryFn: async () => {
      const res = await api.get<ActiveThreadsResponse>(ACTIVE_THREADS_ENDPOINT, {
        params: queryParams,
      });
      // FIX: api.get returns an AxiosResponse; we need the data payload
      return res.data;
    },
  });
}

export default function ActiveThreadsPage() {
  const router = useRouter();

  // Paging + filters
  const [page, setPage] = useState(1);
  const [pageSize] = useState(10);
  const [search, setSearch] = useState('');
  const [pendingSearch, setPendingSearch] = useState('');
  const [topicFilter, setTopicFilter] = useState<TopicFilter>('all');
  const [sort, setSort] = useState<SortOption>('recent');

  const { data, isLoading, isFetching, isError, error, refetch } = useActiveThreads({
    page,
    pageSize,
    search,
    topicFilter,
    sort,
  });

  const threads = (data?.results ?? []) as ForumTopicSummary[];
  const total = data?.total ?? 0;

  const hasResults = threads.length > 0;

  const headerPrimaryAction = (
    <Button
      type="primary"
      icon={<QuestionCircleOutlined />}
      onClick={() =>
        router.push('/konnected/community-discussions/start-new-discussion')
      }
    >
      Start new discussion
    </Button>
  );

  const headerSecondaryActions = (
    <Space>
      <Tooltip title="Refresh active threads">
        <Button icon={<ReloadOutlined />} onClick={() => refetch()} loading={isFetching} />
      </Tooltip>
    </Space>
  );

  const handleSearchSubmit = (value: string) => {
    setSearch(value.trim());
    setPage(1);
  };

  const handleClickThread = (topic: ForumTopicSummary) => {
    // NOTE: adjust route if your thread detail URL differs
    router.push(`/konnected/community-discussions/thread/${topic.id}`);
  };

  const renderHeaderFilters = () => (
    <Card style={{ marginBottom: 16 }}>
      <Space direction="vertical" style={{ width: '100%' }} size="middle">
        <Space style={{ width: '100%' }} wrap>
          <Input
            allowClear
            placeholder="Search by title, category, or keyword"
            prefix={<SearchOutlined />}
            value={pendingSearch}
            onChange={(e) => setPendingSearch(e.target.value)}
            onPressEnter={(e) =>
              handleSearchSubmit((e.target as HTMLInputElement).value)
            }
            style={{ maxWidth: 360 }}
          />
          <Button
            onClick={() => handleSearchSubmit(pendingSearch)}
            icon={<SearchOutlined />}
            type="default"
          >
            Search
          </Button>
        </Space>

        <Space wrap>
          <Space>
            <Text type="secondary">Thread type:</Text>
            <Select<TopicFilter>
              value={topicFilter}
              onChange={(val) => {
                setTopicFilter(val);
                setPage(1);
              }}
              style={{ width: 180 }}
            >
              <Option value="all">All threads</Option>
              <Option value="questions">Questions only</Option>
              <Option value="discussions">Open discussions</Option>
            </Select>
          </Space>

          <Space>
            <Text type="secondary">Sort by:</Text>
            <Select<SortOption>
              value={sort}
              onChange={(val) => {
                setSort(val);
                setPage(1);
              }}
              style={{ width: 200 }}
            >
              <Option value="recent">Most recent activity</Option>
              <Option value="most_replies">Most replies</Option>
              <Option value="most_active">Most participants</Option>
            </Select>
          </Space>
        </Space>

        <Paragraph type="secondary" style={{ marginBottom: 0 }}>
          Active Threads shows forum topics with recent replies and engagement across
          KonnectED‚Äôs knowledge forums. Use filters to focus on questions needing
          answers or heavily active thematic discussions.
        </Paragraph>
      </Space>
    </Card>
  );

  const renderListItemMeta = (item: ForumTopicSummary) => {
    const lastActivity = new Date(item.last_activity_at);

    return (
      <Space direction="vertical" style={{ width: '100%' }} size={4}>
        <Space wrap>
          {item.is_pinned && (
            <Tag color="gold">
              <FireOutlined style={{ marginRight: 4 }} />
              Pinned
            </Tag>
          )}
          {item.kind === 'question' && (
            <Tag color="blue">
              <QuestionCircleOutlined style={{ marginRight: 4 }} />
              Question
            </Tag>
          )}
          {item.category && <Tag>{item.category}</Tag>}
          {item.tags?.map((tag) => (
            <Tag key={tag} bordered={false}>
              {tag}
            </Tag>
          ))}
        </Space>

        <Space align="center" style={{ justifyContent: 'space-between', width: '100%' }}>
          <Space wrap>
            <Space>
              <MessageTwoTone />
              <Text strong>{item.replies_count}</Text>
              <Text type="secondary">replies</Text>
            </Space>
            {item.participants_count != null && (
              <Space>
                <TeamOutlined />
                <Text strong>{item.participants_count}</Text>
                <Text type="secondary">participants</Text>
              </Space>
            )}
          </Space>

          <Space wrap>
            {item.status && (
              <Tag
                color={
                  item.status === 'open'
                    ? 'green'
                    : item.status === 'closed'
                    ? 'default'
                    : 'red'
                }
              >
                {item.status === 'open'
                  ? 'Open'
                  : item.status === 'closed'
                  ? 'Closed'
                  : 'Archived'}
              </Tag>
            )}
            <Text type="secondary">
              Last activity{' '}
              {Number.isNaN(lastActivity.getTime())
                ? 'recently'
                : lastActivity.toLocaleString()}
              {item.last_activity_by ? ` ‚Ä¢ by ${item.last_activity_by}` : ''}
            </Text>
          </Space>
        </Space>

        {item.linked_resource_title && (
          <Text type="secondary">
            Linked resource: <strong>{item.linked_resource_title}</strong>
          </Text>
        )}

        {item.last_activity_snippet && (
          <Text type="secondary" ellipsis>
            ‚Äú{item.last_activity_snippet}‚Äù
          </Text>
        )}
      </Space>
    );
  };

  const renderList = () => {
    if (isLoading && !data) {
      // Skeleton list while first load
      return (
        <Card>
          <List
            itemLayout="vertical"
            dataSource={[1, 2, 3, 4, 5]}
            renderItem={(key) => (
              <List.Item key={key}>
                <Skeleton active avatar paragraph={{ rows: 2 }} />
              </List.Item>
            )}
          />
        </Card>
      );
    }

    if (isError) {
      return (
        <Alert
          type="error"
          message="Unable to load active threads"
          description={error?.message ?? 'An unexpected error occurred.'}
          showIcon
          action={
            <Button size="small" onClick={() => refetch()} icon={<ReloadOutlined />}>
              Retry
            </Button>
          }
          style={{ marginBottom: 16 }}
        />
      );
    }

    if (!hasResults) {
      return (
        <Card>
          <Empty
            image={Empty.PRESENTED_IMAGE_SIMPLE}
            description={
              <>
                <div>No active threads match your filters.</div>
                <div>
                  You can adjust filters or{' '}
                  <Button
                    type="link"
                    onClick={() =>
                      router.push(
                        '/konnected/community-discussions/start-new-discussion',
                      )
                    }
                  >
                    start a new discussion
                  </Button>
                  .
                </div>
              </>
            }
          />
        </Card>
      );
    }

    return (
      <Card>
        <List<ForumTopicSummary>
          itemLayout="vertical"
          dataSource={threads}
          rowKey={(item) => item.id}
          renderItem={(item) => (
            <List.Item
              key={item.id}
              style={{ cursor: 'pointer' }}
              onClick={() => handleClickThread(item)}
              actions={[
                <Space key="stats">
                  <MessageTwoTone />
                  <Text>{item.replies_count} replies</Text>
                  {item.participants_count != null && (
                    <>
                      <TeamOutlined />
                      <Text>{item.participants_count} participants</Text>
                    </>
                  )}
                </Space>,
              ]}
              extra={
                item.is_unread ? (
                  <Badge status="processing" text="New activity" />
                ) : undefined
              }
            >
              <List.Item.Meta
                avatar={
                  <Avatar src={item.created_by_avatar_url ?? undefined}>
                    {item.created_by_name?.charAt(0) ?? '?'}
                  </Avatar>
                }
                title={
                  <Space>
                    <Text strong>{item.title}</Text>
                    {item.is_pinned && (
                      <Tag color="gold" icon={<FireOutlined />}>
                        Pinned
                      </Tag>
                    )}
                  </Space>
                }
                description={
                  <Space
                    direction="vertical"
                    size={4}
                    style={{ width: '100%', marginTop: 4 }}
                  >
                    {item.created_by_name && (
                      <Text type="secondary">
                        Started by <strong>{item.created_by_name}</strong>
                      </Text>
                    )}
                    {renderListItemMeta(item)}
                  </Space>
                }
              />
            </List.Item>
          )}
        />

        <div style={{ marginTop: 16, textAlign: 'right' }}>
          <Pagination
            current={page}
            pageSize={pageSize}
            total={total}
            showSizeChanger={false}
            onChange={(p) => setPage(p)}
          />
        </div>
      </Card>
    );
  };

  return (
    <KonnectedPageShell
      title="Community Discussions ‚Äì Active Threads"
      subtitle="Subject-based forums for learners and educators. These threads show recent activity across KonnectED‚Äôs thematic forums."
      primaryAction={headerPrimaryAction}
      secondaryActions={headerSecondaryActions}
    >
      <Space direction="vertical" style={{ width: '100%' }} size="large">
        {renderHeaderFilters()}
        {renderList()}
      </Space>
    </KonnectedPageShell>
  );
}

===== END app/konnected/community-discussions/active-threads/page.tsx =====


===== BEGIN app/konnected/community-discussions/moderation/page.tsx =====
Ôªø'use client';

import React, { useMemo, useState } from 'react';
import type { ReactNode } from 'react';
import { useRequest } from 'ahooks';
import { ProTable } from '@ant-design/pro-components';
import type { ProColumns } from '@ant-design/pro-components';
import {
  Alert,
  Badge,
  Button,
  Drawer,
  Modal,
  Popconfirm,
  Space,
  Tag,
  Tooltip,
  Typography,
  message as antdMessage,
} from 'antd';
import {
  CheckCircleOutlined,
  ExclamationCircleOutlined,
  EyeOutlined,
  ReloadOutlined,
  StopOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import { fetchModerationQueue, actOnReport } from '@/services/admin';

const { Text, Paragraph } = Typography;

type ModerationStatus = 'Pending' | 'Resolved' | 'Escalated';

type ModerationTargetType = 'topic' | 'post' | 'user';

type Severity = 'low' | 'medium' | 'high';

interface ModerationQueueItem {
  id: string;
  /** Post / Topic / User */
  targetType: ModerationTargetType;
  /** ID of the target (postId, topicId, userId, etc.) */
  targetId: string;
  /** Human-readable context, e.g. thread title */
  contextTitle?: string;
  /** Short preview of offending content */
  contentPreview?: string;
  /** Who authored the offending content */
  authorName?: string;
  authorId?: string;
  /** Who reported */
  reporterName?: string;
  reporterId?: string;
  /** Primary reason label */
  reason?: string;
  /** Free-text notes / message from reporter */
  reporterMessage?: string;
  /** Number of merged reports for same target */
  reportCount?: number;
  /** When the first report was created (ISO string) */
  createdAt?: string;
  /** When last action occurred (ISO string) */
  lastActionAt?: string;
  /** Current status in queue */
  status: ModerationStatus;
  /** Rough severity bucket */
  severity?: Severity;
}

/**
 * Adapt the existing admin moderation payload into the richer
 * ModerationQueueItem shape expected by the KonnectED UI.
 *
 * This is defensive: it works with the current minimal shape
 * (id, content, reporter, type, status) and can absorb future
 * backend fields with zero changes on the frontend.
 */
function adaptModerationItems(raw: unknown): ModerationQueueItem[] {
  const items = Array.isArray(raw)
    ? raw
    : Array.isArray((raw as any)?.items)
    ? (raw as any).items
    : [];

  return items.map((item: any): ModerationQueueItem => {
    const status: ModerationStatus =
      item.status === 'Resolved' || item.status === 'Escalated'
        ? item.status
        : 'Pending';

    // Basic heuristics to enrich from whatever the backend gives us
    const targetType: ModerationTargetType =
      (item.targetType as ModerationTargetType) ??
      (item.entityType as ModerationTargetType) ??
      'post';

    const severity: Severity =
      (item.severity as Severity) ??
      (item.priority as Severity) ??
      'medium';

    return {
      id: String(item.id),
      targetType,
      targetId: String(item.targetId ?? item.postId ?? item.topicId ?? item.userId ?? item.id),
      contextTitle: item.contextTitle ?? item.threadTitle ?? item.topicTitle,
      contentPreview: item.content ?? item.contentSnippet ?? item.preview,
      authorName: item.authorName ?? item.offenderName ?? item.user,
      authorId: item.authorId ?? item.offenderId,
      reporterName: item.reporterName ?? item.reporter,
      reporterId: item.reporterId,
      reason: item.type ?? item.reason,
      reporterMessage: item.message ?? item.notes,
      reportCount: item.reportCount ?? item.count ?? 1,
      createdAt: item.createdAt ?? item.created_at ?? item.timestamp,
      lastActionAt: item.lastActionAt ?? item.updated_at,
      status,
      severity,
    };
  });
}

export default function CommunityModerationPage(): JSX.Element {
  const [selectedRowKeys, setSelectedRowKeys] = useState<React.Key[]>([]);
  const [activeStatusFilter, setActiveStatusFilter] = useState<ModerationStatus | 'all'>('Pending');
  const [detailDrawerItem, setDetailDrawerItem] = useState<ModerationQueueItem | null>(null);
  const [globalActionLoading, setGlobalActionLoading] = useState(false);

  const {
    data: rawData,
    loading,
    error,
    refresh,
  } = useRequest(fetchModerationQueue);

  const items: ModerationQueueItem[] = useMemo(
    () => adaptModerationItems(rawData),
    [rawData],
  );

  const filteredItems = useMemo(() => {
    if (activeStatusFilter === 'all') return items;
    return items.filter((item) => item.status === activeStatusFilter);
  }, [items, activeStatusFilter]);

  const unauthorized =
    (error as any)?.response?.status === 403 ||
    (error as any)?.status === 403;

  const onSingleAction = async (
    record: ModerationQueueItem,
    action: 'approve' | 'remove',
  ) => {
    try {
      setGlobalActionLoading(true);
      // actOnReport: remove = true => delete, false => keep
      const remove = action === 'remove';
      await actOnReport(record.id, remove);
      antdMessage.success(
        remove
          ? 'Content removed and report resolved.'
          : 'Content approved and report resolved.',
      );
      await refresh();
    } catch (e) {
      antdMessage.error('Unable to process moderation action. Please try again.');
    } finally {
      setGlobalActionLoading(false);
    }
  };

  const onBulkAction = async (action: 'approve' | 'remove') => {
    if (!selectedRowKeys.length) {
      antdMessage.info('Select at least one item to apply a bulk action.');
      return;
    }

    setGlobalActionLoading(true);
    try {
      const remove = action === 'remove';

      const promises = selectedRowKeys.map((id) =>
        actOnReport(String(id), remove).catch((err) => err),
      );

      const results = await Promise.all(promises);
      const failures = results.filter((r) => r instanceof Error);

      if (failures.length === 0) {
        antdMessage.success(
          remove
            ? 'Selected content removed and reports resolved.'
            : 'Selected content approved and reports resolved.',
        );
      } else if (failures.length === selectedRowKeys.length) {
        antdMessage.error('Bulk action failed for all selected items.');
      } else {
        antdMessage.warning(
          'Bulk action completed with some failures. Check the queue and retry if needed.',
        );
      }

      setSelectedRowKeys([]);
      await refresh();
    } catch {
      antdMessage.error('Unexpected error while processing bulk action.');
    } finally {
      setGlobalActionLoading(false);
    }
  };

  const severityTag = (severity?: Severity): ReactNode => {
    switch (severity) {
      case 'high':
        return (
          <Tag color="red" icon={<ExclamationCircleOutlined />}>
            High
          </Tag>
        );
      case 'low':
        return <Tag color="green">Low</Tag>;
      case 'medium':
      default:
        return <Tag color="gold">Medium</Tag>;
    }
  };

  const statusBadge = (status: ModerationStatus): ReactNode => {
    switch (status) {
      case 'Resolved':
        return <Badge status="success" text="Resolved" />;
      case 'Escalated':
        return <Badge status="warning" text="Escalated" />;
      case 'Pending':
      default:
        return <Badge status="processing" text="Pending" />;
    }
  };

  const targetTag = (record: ModerationQueueItem): ReactNode => {
    const label =
      record.targetType === 'topic'
        ? 'Topic'
        : record.targetType === 'user'
        ? 'User'
        : 'Post';

    return <Tag>{label}</Tag>;
  };

  const columns: ProColumns<ModerationQueueItem>[] = [
    {
      title: 'Content',
      dataIndex: 'contentPreview',
      width: 320,
      ellipsis: true,
      render: (_, record) => (
        <Space direction="vertical" size={2}>
          <Space size={6}>
            {targetTag(record)}
            {record.reason && <Tag>{record.reason}</Tag>}
          </Space>
          {record.contextTitle && (
            <Text strong ellipsis={{ tooltip: record.contextTitle }}>
              {record.contextTitle}
            </Text>
          )}
          {record.contentPreview && (
            <Text type="secondary" ellipsis={{ tooltip: record.contentPreview }}>
              {record.contentPreview}
            </Text>
          )}
          {record.reporterMessage && (
            <Text type="secondary" italic ellipsis={{ tooltip: record.reporterMessage }}>
              Reporter note: {record.reporterMessage}
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'People',
      dataIndex: 'authorName',
      width: 220,
      render: (_, record) => (
        <Space direction="vertical" size={2}>
          {record.authorName && (
            <Text>
              Author: <Text strong>{record.authorName}</Text>
            </Text>
          )}
          {record.reporterName && (
            <Text type="secondary">
              Reported by {record.reporterName}
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'Reports',
      dataIndex: 'reportCount',
      width: 120,
      align: 'center',
      render: (value, record) => (
        <Space direction="vertical" size={2}>
          <Badge
            count={value ?? 1}
            style={{ backgroundColor: '#722ed1' }}
            overflowCount={99}
          />
          {severityTag(record.severity)}
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      width: 140,
      render: (_, record) => statusBadge(record.status),
      filters: true,
      valueEnum: {
        Pending: { text: 'Pending' },
        Escalated: { text: 'Escalated' },
        Resolved: { text: 'Resolved' },
      },
    },
    {
      title: 'Timeline',
      dataIndex: 'createdAt',
      width: 220,
      render: (_, record) => (
        <Space direction="vertical" size={2}>
          {record.createdAt && (
            <Text type="secondary">
              Reported{' '}
              {new Date(record.createdAt).toLocaleString(undefined, {
                dateStyle: 'medium',
                timeStyle: 'short',
              })}
            </Text>
          )}
          {record.lastActionAt && (
            <Text type="secondary">
              Last action{' '}
              {new Date(record.lastActionAt).toLocaleString(undefined, {
                dateStyle: 'medium',
                timeStyle: 'short',
              })}
            </Text>
          )}
        </Space>
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 220,
      fixed: 'right',
      render: (_, record) => {
        const disabled = unauthorized || globalActionLoading || record.status === 'Resolved';

        return (
          <Space>
            <Tooltip title="Review full report details">
              <Button
                icon={<EyeOutlined />}
                size="small"
                onClick={() => setDetailDrawerItem(record)}
              />
            </Tooltip>

            <Tooltip title="Content is acceptable, resolve report">
              <Button
                size="small"
                icon={<CheckCircleOutlined />}
                type="default"
                disabled={disabled}
                onClick={() => onSingleAction(record, 'approve')}
              >
                Approve
              </Button>
            </Tooltip>

            <Popconfirm
              title="Remove content?"
              description="This will remove the content for everyone and resolve all associated reports."
              okText="Remove"
              okType="danger"
              icon={<ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />}
              disabled={disabled}
              onConfirm={() => onSingleAction(record, 'remove')}
            >
              <Tooltip title="Remove content and resolve report">
                <Button
                  size="small"
                  icon={<StopOutlined />}
                  danger
                  disabled={disabled}
                >
                  Remove
                </Button>
              </Tooltip>
            </Popconfirm>
          </Space>
        );
      },
    },
  ];

  const bulkActions = (
    <Space>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('Pending')}
        type={activeStatusFilter === 'Pending' ? 'primary' : 'default'}
      >
        Pending
      </Button>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('Escalated')}
        type={activeStatusFilter === 'Escalated' ? 'primary' : 'default'}
      >
        Escalated
      </Button>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('Resolved')}
        type={activeStatusFilter === 'Resolved' ? 'primary' : 'default'}
      >
        Resolved
      </Button>
      <Button
        size="small"
        onClick={() => setActiveStatusFilter('all')}
        type={activeStatusFilter === 'all' ? 'primary' : 'default'}
      >
        All
      </Button>
    </Space>
  );

  return (
    <KonnectedPageShell
      title="Community Moderation"
      subtitle="Review and act on reports for forum topics, posts, and users across KonnectED."
      primaryAction={
        <Button
          icon={<ReloadOutlined />}
          onClick={() => refresh()}
          loading={loading || globalActionLoading}
        >
          Refresh Queue
        </Button>
      }
      secondaryActions={bulkActions}
    >
      {unauthorized && (
        <Alert
          type="error"
          showIcon
          style={{ marginBottom: 16 }}
          message="You do not have permission to moderate community discussions."
          description="If you believe this is an error, contact your KonnectED administrator to be granted a moderator role."
        />
      )}

      {!unauthorized && (
        <Alert
          type="info"
          showIcon
          style={{ marginBottom: 16 }}
          message="Moderation guidelines"
          description={
            <>
              Approve content that aligns with your community guidelines, remove
              content that is harmful or off-topic, and escalate edge cases to
              your administrator. Bulk actions are available for high-volume
              periods.
            </>
          }
        />
      )}

      {error && !unauthorized && (
        <Alert
          type="error"
          showIcon
          style={{ marginBottom: 16 }}
          message="Unable to load moderation queue."
          description="Check your connection or try again. If the problem persists, the moderation service may be unavailable."
        />
      )}

      {items.length === 0 && !loading && !error && (
        <Alert
          type="success"
          showIcon
          style={{ marginBottom: 16 }}
          message="No open reports."
          description="Your community is all clear. New reports will show up here as they are created."
        />
      )}

      <ProTable<ModerationQueueItem>
        rowKey="id"
        search={false}
        options={false}
        loading={loading || globalActionLoading}
        columns={columns}
        dataSource={filteredItems}
        pagination={{
          pageSize: 10,
          showSizeChanger: true,
          showTotal: (total) => `${total} reports`,
        }}
        sticky
        rowSelection={{
          selectedRowKeys,
          onChange: setSelectedRowKeys,
        }}
        tableAlertRender={({ selectedRowKeys: keys }) => (
          <Space size={8}>
            <Text strong>{keys.length}</Text>
            <Text>selected</Text>
          </Space>
        )}
        tableAlertOptionRender={() => (
          <Space>
            <Tooltip title="Resolve and keep content">
              <Button
                size="small"
                icon={<CheckCircleOutlined />}
                disabled={!selectedRowKeys.length || unauthorized}
                onClick={() => onBulkAction('approve')}
              >
                Bulk approve
              </Button>
            </Tooltip>
            <Tooltip title="Remove content and resolve reports">
              <Popconfirm
                title="Remove selected content?"
                description="This will remove content for all selected reports and resolve them."
                okText="Remove"
                okType="danger"
                icon={<ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />}
                disabled={!selectedRowKeys.length || unauthorized}
                onConfirm={() => onBulkAction('remove')}
              >
                <Button
                  size="small"
                  danger
                  icon={<StopOutlined />}
                  disabled={!selectedRowKeys.length || unauthorized}
                >
                  Bulk remove
                </Button>
              </Popconfirm>
            </Tooltip>
          </Space>
        )}
        scroll={{ x: 1100 }}
      />

      <Drawer
        title="Report details"
        width={480}
        open={!!detailDrawerItem}
        onClose={() => setDetailDrawerItem(null)}
      >
        {detailDrawerItem && (
          <Space direction="vertical" style={{ width: '100%' }} size="middle">
            <Space>
              {targetTag(detailDrawerItem)}
              {severityTag(detailDrawerItem.severity)}
              {statusBadge(detailDrawerItem.status)}
              {detailDrawerItem.reason && <Tag>{detailDrawerItem.reason}</Tag>}
            </Space>

            {detailDrawerItem.contextTitle && (
              <div>
                <Text strong>Thread / context</Text>
                <Paragraph>{detailDrawerItem.contextTitle}</Paragraph>
              </div>
            )}

            {detailDrawerItem.contentPreview && (
              <div>
                <Text strong>Content preview</Text>
                <Paragraph>{detailDrawerItem.contentPreview}</Paragraph>
              </div>
            )}

            <div>
              <Text strong>People</Text>
              <Paragraph>
                {detailDrawerItem.authorName && (
                  <>
                    Author: <Text strong>{detailDrawerItem.authorName}</Text>
                    <br />
                  </>
                )}
                {detailDrawerItem.reporterName && (
                  <>
                    Reporter: <Text>{detailDrawerItem.reporterName}</Text>
                    <br />
                  </>
                )}
                {detailDrawerItem.reportCount && (
                  <>Reports merged: {detailDrawerItem.reportCount}</>
                )}
              </Paragraph>
            </div>

            {detailDrawerItem.reporterMessage && (
              <div>
                <Text strong>Reporter note</Text>
                <Paragraph>{detailDrawerItem.reporterMessage}</Paragraph>
              </div>
            )}

            <div>
              <Text strong>Timeline</Text>
              <Paragraph type="secondary">
                {detailDrawerItem.createdAt && (
                  <>
                    Reported:{' '}
                    {new Date(detailDrawerItem.createdAt).toLocaleString(
                      undefined,
                      { dateStyle: 'medium', timeStyle: 'short' },
                    )}
                    <br />
                  </>
                )}
                {detailDrawerItem.lastActionAt && (
                  <>
                    Last action:{' '}
                    {new Date(detailDrawerItem.lastActionAt).toLocaleString(
                      undefined,
                      { dateStyle: 'medium', timeStyle: 'short' },
                    )}
                  </>
                )}
              </Paragraph>
            </div>

            <Alert
              type="info"
              showIcon
              message="Next steps"
              description="Use the actions in the table to approve or remove this content. For complex cases, escalate through your admin tools or document decisions in your internal playbook."
            />
          </Space>
        )}
      </Drawer>

      <Modal
        open={false}
        footer={null}
        closable={false}
        destroyOnClose
        // Reserved for future: escalation / mute / ban workflows
      />
    </KonnectedPageShell>
  );
}

===== END app/konnected/community-discussions/moderation/page.tsx =====


===== BEGIN app/konnected/community-discussions/start-new-discussion/page.tsx =====
ÔªøÔªø'use client';

import React, { useState } from 'react';
import {
  Alert,
  Button,
  Card,
  Col,
  Form,
  Input,
  message as antdMessage,
  Row,
  Select,
  Space,
  Switch,
  Tag,
  Typography,
  Upload,
  Radio,
} from 'antd';
import type { FormProps } from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import { InfoCircleOutlined, MessageOutlined, QuestionCircleOutlined, UploadOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { TextArea } = Input;
const { Paragraph, Text } = Typography;

type ThreadType = 'question' | 'discussion';

type FormValues = {
  title: string;
  content?: string;
  category: string;
  threadType: ThreadType;
  tags?: string[];
  subscribeToReplies?: boolean;
  attachments?: UploadFile[];
};

type CreateTopicPayload = {
  title: string;
  category: string;
  threadType: ThreadType;
  isQuestion: boolean;
  tags?: string[];
  initialPost?: {
    content?: string;
    attachments?: string[];
  };
  subscribeToReplies?: boolean;
};

/**
 * Start New Discussion page for KonnectED ‚Üí Community Discussions.
 * Creates a ForumTopic + initial ForumPost against the backend API.
 */
export default function StartNewDiscussionPage(): JSX.Element {
  const [form] = Form.useForm<FormValues>();
  const router = useRouter();
  const [submitting, setSubmitting] = useState(false);

  const buildPayload = (values: FormValues): CreateTopicPayload => {
    const attachments = (values.attachments ?? []).map((file) => file.name);

    return {
      title: values.title.trim(),
      category: values.category,
      threadType: values.threadType,
      isQuestion: values.threadType === 'question',
      tags: values.tags?.map((t) => t.trim()).filter(Boolean),
      initialPost: {
        content: values.content?.trim() || undefined,
        attachments: attachments.length ? attachments : undefined,
      },
      subscribeToReplies: values.subscribeToReplies ?? true,
    };
  };

  const onFinish: FormProps<FormValues>['onFinish'] = async (values) => {
    setSubmitting(true);
    try {
      const payload = buildPayload(values);

      // TODO: align this path & payload with schema-endpoints.json
      const res = await fetch('/api/konnected/community-discussions/topics', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!res.ok) {
        let backendMessage = 'Unable to create discussion.';
        try {
          const data = (await res.json()) as { message?: string };
          if (data?.message) backendMessage = data.message;
        } catch {
          // ignore JSON parse errors
        }
        if (res.status === 403) {
          antdMessage.error(backendMessage || 'You do not have permission to start a new discussion.');
        } else if (res.status === 429) {
          antdMessage.error(
            backendMessage || 'You have created too many discussions in a short time. Please try again later.',
          );
        } else {
          antdMessage.error(backendMessage);
        }
        return;
      }

      antdMessage.success('Discussion created successfully.');
      router.push('/konnected/community-discussions/active-threads');
    } catch (error) {
      // Network or unexpected error
      // eslint-disable-next-line no-console
      console.error('Error creating discussion', error);
      antdMessage.error('Something went wrong while creating the discussion. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  const onFinishFailed: FormProps<FormValues>['onFinishFailed'] = () => {
    antdMessage.error('Please fix the highlighted fields and try again.');
  };

  // Categories aligned with the Active Threads dummy data for now.
  const CATEGORY_OPTIONS: { label: string; value: string }[] = [
    { label: 'Math', value: 'Math' },
    { label: 'Science', value: 'Science' },
    { label: 'General', value: 'General' },
  ];

  const TAG_SUGGESTIONS = ['Exam prep', 'Project help', 'Tips & tricks', 'Resources', 'Mentoring'];

  return (
    <KonnectedPageShell
      title="Start a New Discussion"
      subtitle={
        <span>
          Share a question or topic with the KonnectED community. Your post may be surfaced in learning paths and
          thematic forums.
        </span>
      }
    >
      <Row gutter={[24, 24]}>
        {/* Main form column */}
        <Col xs={24} md={16}>
          <Card>
            <Space direction="vertical" size="large" style={{ width: '100%' }}>
              <Alert
                type="info"
                showIcon
                icon={<InfoCircleOutlined />}
                message="Reminder: keep it constructive and on-topic"
                description={
                  <span>
                    Discussions are visible across teams. Content may be routed to moderators before publication for
                    low-trust accounts.
                  </span>
                }
              />

              <Form<FormValues>
                form={form}
                layout="vertical"
                onFinish={onFinish}
                onFinishFailed={onFinishFailed}
                initialValues={{
                  threadType: 'discussion',
                  subscribeToReplies: true,
                }}
              >
                {/* Title */}
                <Form.Item
                  label="Title"
                  name="title"
                  rules={[
                    { required: true, message: 'Please enter a title' },
                    { min: 10, message: 'The title should be at least 10 characters long.' },
                    { max: 150, message: 'The title should be at most 150 characters.' },
                    {
                      validator: (_, value) => {
                        if (typeof value === 'string' && !value.trim()) {
                          return Promise.reject(new Error('The title cannot be empty or just spaces.'));
                        }
                        return Promise.resolve();
                      },
                    },
                  ]}
                >
                  <Input placeholder="e.g. How do we measure impact across teams in cross-faculty projects?" />
                </Form.Item>

                {/* Thread type */}
                <Form.Item
                  label="Type of thread"
                  name="threadType"
                  rules={[{ required: true, message: 'Please select the type of discussion.' }]}
                >
                  <Radio.Group>
                    <Radio.Button value="question">
                      <Space>
                        <QuestionCircleOutlined />
                        <span>Question (Q&amp;A)</span>
                      </Space>
                    </Radio.Button>
                    <Radio.Button value="discussion">
                      <Space>
                        <MessageOutlined />
                        <span>Open discussion</span>
                      </Space>
                    </Radio.Button>
                  </Radio.Group>
                </Form.Item>

                {/* Category */}
                <Form.Item
                  label="Category / subject area"
                  name="category"
                  rules={[{ required: true, message: 'Please select a category.' }]}
                >
                  <Select
                    placeholder="Select a category"
                    options={CATEGORY_OPTIONS}
                    allowClear
                    showSearch
                    optionFilterProp="label"
                  />
                </Form.Item>

                {/* Content */}
                <Form.Item
                  label="Content"
                  name="content"
                  rules={[
                    {
                      max: 5000,
                      message: 'The content is too long (max 5000 characters).',
                    },
                  ]}
                  extra="Provide enough context so that others can give meaningful answers or contributions."
                >
                  <TextArea
                    rows={6}
                    placeholder="Describe your question or topic. You can mention specific courses, projects, or resources‚Ä¶"
                    showCount
                    maxLength={5000}
                  />
                </Form.Item>

                {/* Tags */}
                <Form.Item
                  label="Tags"
                  name="tags"
                  tooltip="Use tags so your discussion can be surfaced in thematic forums and learning paths."
                >
                  <Select
                    mode="tags"
                    tokenSeparators={[',']}
                    placeholder="Add tags (press Enter to confirm)‚Ä¶"
                    options={TAG_SUGGESTIONS.map((t) => ({ label: t, value: t }))}
                  />
                </Form.Item>

                {/* Attachments */}
                <Form.Item
                  label="Attachments"
                  name="attachments"
                  valuePropName="fileList"
                  getValueFromEvent={(e: { fileList: UploadFile[] }) => e?.fileList}
                  extra="Attach optional supporting files (e.g. PDF instructions, slides)."
                >
                  <Upload.Dragger
                    multiple
                    beforeUpload={() => false} // prevent auto-upload; backend integration can be wired later
                    accept=".pdf,.doc,.docx,.ppt,.pptx,.png,.jpg,.jpeg"
                  >
                    <p className="ant-upload-drag-icon">
                      <UploadOutlined />
                    </p>
                    <p className="ant-upload-text">Click or drag files to this area to attach</p>
                    <p className="ant-upload-hint">Files will be included with your initial post when supported.</p>
                  </Upload.Dragger>
                </Form.Item>

                {/* Notification / subscription */}
                <Form.Item
                  label="Notify me about replies"
                  name="subscribeToReplies"
                  valuePropName="checked"
                  tooltip="You will receive notifications when someone replies or your post is updated."
                >
                  <Switch />
                </Form.Item>

                {/* Submit button */}
                <Form.Item>
                  <Space>
                    <Button type="primary" htmlType="submit" loading={submitting}>
                      Post discussion
                    </Button>
                    <Button
                      htmlType="button"
                      onClick={() =>
                        router.push('/konnected/community-discussions/active-threads')
                      }
                    >
                      Cancel
                    </Button>
                  </Space>
                </Form.Item>
              </Form>
            </Space>
          </Card>
        </Col>

        {/* Right-hand guidance / meta column */}
        <Col xs={24} md={8}>
          <Space direction="vertical" size="large" style={{ width: '100%' }}>
            <Card title="Good discussion practices">
              <Space direction="vertical">
                <Text>
                  <Tag color="blue">Be specific</Tag> Clearly describe the context (course, team, project, tool).
                </Text>
                <Text>
                  <Tag color="green">Show your attempt</Tag> For questions, explain what you already tried or
                  understood.
                </Text>
                <Text>
                  <Tag color="gold">Respect privacy</Tag> Avoid sharing sensitive personal or institutional data.
                </Text>
                <Text>
                  <Tag color="purple">Use tags</Tag> Tags help link the discussion to Knowledge units and learning
                  paths.
                </Text>
              </Space>
            </Card>

            <Card title="Moderation and visibility">
              <Paragraph>
                Posts may be queued for moderation based on your trust level or if they match sensitive topics.
              </Paragraph>
              <Paragraph>
                If moderation is required, you&apos;ll see your topic as{' '}
                <Text strong>‚ÄúPending review‚Äù</Text> until a moderator approves it.
              </Paragraph>
              <Paragraph>
                You can later edit your post, close a question, or mark an answer as accepted from the thread detail
                page (when implemented).
              </Paragraph>
            </Card>
          </Space>
        </Col>
      </Row>
    </KonnectedPageShell>
  );
}

===== END app/konnected/community-discussions/start-new-discussion/page.tsx =====


===== BEGIN app/konnected/dashboard/page.tsx =====
Ôªø"use client";

import React from "react";
import { useQuery } from "@tanstack/react-query";
import {
  Alert,
  Avatar,
  Badge,
  Button,
  Col,
  Empty,
  List,
  Progress,
  Row,
  Skeleton,
  Space,
  Tabs,
  Tag,
  Tooltip,
  Typography,
} from "antd";
import {
  CheckCircleOutlined,
  ExclamationCircleOutlined,
  FileTextOutlined,
  LineChartOutlined,
  ReadOutlined,
  TeamOutlined,
} from "@ant-design/icons";
import { PageContainer, ProCard, StatisticCard } from "@ant-design/pro-components";
import KonnectedPageShell from "../KonnectedPageShell";

const { Text, Title } = Typography;

// ---------- Types ----------

type CertificationSummary = {
  activePaths: number;
  completedPaths: number;
  certificatesCount: number;
  upcomingEvaluations: number;
  pendingPeerValidations: number;
  nextEvaluationDate?: string | null;
};

type LearningResourceSummaryItem = {
  id: string;
  title: string;
  type: "article" | "video" | "lesson" | "quiz" | "dataset" | string;
  progressPercent?: number;
};

type LearningSummary = {
  startedCount: number;
  completedCount: number;
  averageProgressPercent: number;
  inProgress: LearningResourceSummaryItem[];
  recommended: LearningResourceSummaryItem[];
};

type LearningPathSummary = {
  myActivePaths: number;
  myCompletedPaths: number;
  myCurrentPathTitle?: string | null;
  myCurrentPathProgressPercent?: number | null;
  isEducator: boolean;
  managedPathsCount: number;
};

type CommunityTopicSummary = {
  id: string;
  title: string;
  lastActivity: string;
  unreadCount: number;
};

type CoCreationProjectSummary = {
  id: string;
  title: string;
  role: "owner" | "contributor" | "reviewer" | string;
  status: "draft" | "active" | "archived" | string;
};

type CommunitySummary = {
  activeThreadsCount: number;
  recentTopics: CommunityTopicSummary[];
  activeCoCreationProjects: CoCreationProjectSummary[];
};

type TeamSummaryItem = {
  id: string;
  name: string;
  memberCount: number;
};

type TeamsSummary = {
  myTeamsCount: number;
  teams: TeamSummaryItem[];
  nextTeamActivityTitle?: string | null;
  nextTeamActivityDate?: string | null;
};

type UsageSummary = {
  daysActiveLast30: number;
  resourcesCompletedLast30: number;
  certificationsEarnedLast30: number;
};

// ---------- Data hooks (best-effort; adjust endpoints to your OpenAPI) ----------

async function fetchJSON<T>(url: string): Promise<T> {
  const res = await fetch(url, { credentials: "include" });
  if (!res.ok) {
    throw new Error(`Failed to fetch ${url}: ${res.status}`);
  }
  return res.json() as Promise<T>;
}

function useCertificationSummary() {
  return useQuery<CertificationSummary>({
    queryKey: ["konnected", "dashboard", "certificationSummary"],
    queryFn: () =>
      fetchJSON<CertificationSummary>(
        // Replace with your real aggregate endpoint or client-side aggregation route
        "/api/konnected/certification/summary/"
      ),
  });
}

function useLearningSummary() {
  return useQuery<LearningSummary>({
    queryKey: ["konnected", "dashboard", "learningSummary"],
    queryFn: () =>
      fetchJSON<LearningSummary>(
        "/api/konnected/knowledge/dashboard-summary/"
      ),
  });
}

function useLearningPathSummary() {
  return useQuery<LearningPathSummary>({
    queryKey: ["konnected", "dashboard", "learningPathSummary"],
    queryFn: () =>
      fetchJSON<LearningPathSummary>(
        "/api/konnected/learning-paths/dashboard-summary/"
      ),
  });
}

function useCommunitySummary() {
  return useQuery<CommunitySummary>({
    queryKey: ["konnected", "dashboard", "communitySummary"],
    queryFn: () =>
      fetchJSON<CommunitySummary>(
        "/api/konnected/community/dashboard-summary/"
      ),
  });
}

function useTeamsSummary() {
  return useQuery<TeamsSummary>({
    queryKey: ["konnected", "dashboard", "teamsSummary"],
    queryFn: () =>
      fetchJSON<TeamsSummary>(
        "/api/konnected/teams/dashboard-summary/"
      ),
  });
}

function useUsageSummary() {
  return useQuery<UsageSummary>({
    queryKey: ["konnected", "dashboard", "usageSummary"],
    queryFn: () =>
      fetchJSON<UsageSummary>(
        "/api/reports/usage/konnected-summary/"
      ),
  });
}

// ---------- Tiles ----------

function CertificationsTile() {
  const { data, isLoading, isError } = useCertificationSummary();

  if (isLoading) {
    return (
      <ProCard title="Certifications" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Certifications"
        bordered
        extra={
          <Button type="link" href="/konnected/certifications/certification-programs">
            View programs
          </Button>
        }
      >
        <Alert
          type="warning"
          showIcon
          message="Unable to load certification summary."
        />
      </ProCard>
    );
  }

  const hasAny =
    data.activePaths > 0 ||
    data.completedPaths > 0 ||
    data.certificatesCount > 0;

  return (
    <ProCard
      title="Certifications"
      bordered
      extra={
        <Space>
          <Button type="default" href="/konnected/certifications/exam-dashboard-results">
            Exam results
          </Button>
          <Button type="primary" href="/konnected/certifications/certification-programs">
            View programs
          </Button>
        </Space>
      }
    >
      {!hasAny ? (
        <Empty
          description="No certifications yet"
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        >
          <Button type="primary" href="/konnected/certifications/certification-programs">
            Explore certification programs
          </Button>
        </Empty>
      ) : (
        <>
          <Space size="large" wrap>
            <StatisticCard
              statistic={{
                title: "Active paths",
                value: data.activePaths,
                prefix: <ReadOutlined />,
              }}
            />
            <StatisticCard
              statistic={{
                title: "Completed paths",
                value: data.completedPaths,
                prefix: <CheckCircleOutlined />,
              }}
            />
            <StatisticCard
              statistic={{
                title: "Certificates",
                value: data.certificatesCount,
                prefix: <FileTextOutlined />,
              }}
            />
          </Space>

          <Space style={{ marginTop: 16 }} direction="vertical">
            <Space size="large" wrap>
              <Space>
                <Text strong>Upcoming evaluations:</Text>
                <Badge count={data.upcomingEvaluations} />
              </Space>
              <Space>
                <Text strong>Pending peer validations:</Text>
                <Badge
                  count={data.pendingPeerValidations}
                  status={data.pendingPeerValidations > 0 ? "warning" : "default"}
                />
              </Space>
            </Space>
            {data.nextEvaluationDate && (
              <Text type="secondary">
                Next scheduled evaluation:{" "}
                <Text code>{data.nextEvaluationDate}</Text>
              </Text>
            )}
          </Space>
        </>
      )}
    </ProCard>
  );
}

function LearningTile() {
  const { data, isLoading, isError } = useLearningSummary();

  if (isLoading) {
    return (
      <ProCard title="Learning progress & recommendations" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Learning progress & recommendations"
        bordered
        extra={
          <Button type="link" href="/konnected/learning-library/browse-resources">
            Browse library
          </Button>
        }
      >
        <Alert
          type="warning"
          showIcon
          message="Unable to load learning summary."
        />
      </ProCard>
    );
  }

  const hasProgress =
    data.startedCount > 0 || data.completedCount > 0 || data.inProgress.length > 0;

  return (
    <ProCard
      title="Learning progress & recommendations"
      bordered
      extra={
        <Space>
          <Button type="default" href="/konnected/learning-library/recommended-resources">
            Recommendations
          </Button>
          <Button type="primary" href="/konnected/learning-library/browse-resources">
            Browse library
          </Button>
        </Space>
      }
    >
      <Row gutter={[16, 16]}>
        <Col xs={24} md={10}>
          <Space direction="vertical" size="large" style={{ width: "100%" }}>
            <Space size="large" wrap>
              <StatisticCard
                statistic={{
                  title: "Started",
                  value: data.startedCount,
                  prefix: <ReadOutlined />,
                }}
              />
              <StatisticCard
                statistic={{
                  title: "Completed",
                  value: data.completedCount,
                  prefix: <CheckCircleOutlined />,
                }}
              />
            </Space>
            <div>
              <Text strong>Average completion</Text>
              <Progress
                percent={Math.round(data.averageProgressPercent)}
                status="normal"
              />
            </div>
          </Space>
        </Col>
        <Col xs={24} md={14}>
          <Tabs
            defaultActiveKey="in-progress"
            items={[
              {
                key: "in-progress",
                label: "In progress",
                children: hasProgress ? (
                  <List
                    size="small"
                    dataSource={data.inProgress}
                    locale={{ emptyText: "No resources in progress" }}
                    renderItem={(item) => (
                      <List.Item
                        actions={[
                          <Button
                            key="continue"
                            type="link"
                            href={`/course/${encodeURIComponent(item.id)}`}
                          >
                            Continue
                          </Button>,
                        ]}
                      >
                        <List.Item.Meta
                          title={
                            <Space>
                              <Text strong>{item.title}</Text>
                              <Tag>{item.type}</Tag>
                            </Space>
                          }
                          description={
                            <Progress
                              percent={Math.round(item.progressPercent ?? 0)}
                              size="small"
                              status="active"
                            />
                          }
                        />
                      </List.Item>
                    )}
                  />
                ) : (
                  <Empty
                    image={Empty.PRESENTED_IMAGE_SIMPLE}
                    description="No learning progress yet"
                  >
                    <Button
                      type="primary"
                      href="/konnected/learning-library/recommended-resources"
                    >
                      Start with recommendations
                    </Button>
                  </Empty>
                ),
              },
              {
                key: "recommended",
                label: "Recommended",
                children: (
                  <List
                    size="small"
                    dataSource={data.recommended}
                    locale={{ emptyText: "No recommendations available" }}
                    renderItem={(item) => (
                      <List.Item
                        actions={[
                          <Button
                            key="start"
                            type="link"
                            href={`/course/${encodeURIComponent(item.id)}`}
                          >
                            Open
                          </Button>,
                        ]}
                      >
                        <List.Item.Meta
                          title={
                            <Space>
                              <Text strong>{item.title}</Text>
                              <Tag color="blue">Recommended</Tag>
                              <Tag>{item.type}</Tag>
                            </Space>
                          }
                        />
                      </List.Item>
                    )}
                  />
                ),
              },
            ]}
          />
        </Col>
      </Row>
    </ProCard>
  );
}

function LearningPathsTile() {
  const { data, isLoading, isError } = useLearningPathSummary();

  if (isLoading) {
    return (
      <ProCard title="Learning paths" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Learning paths"
        bordered
        extra={
          <Button type="link" href="/konnected/learning-paths/my-learning-path">
            My learning paths
          </Button>
        }
      >
        <Alert type="warning" showIcon message="Unable to load learning paths." />
      </ProCard>
    );
  }

  const hasPaths =
    data.myActivePaths > 0 || data.myCompletedPaths > 0 || !!data.myCurrentPathTitle;

  return (
    <ProCard
      title="Learning paths"
      bordered
      extra={
        <Space>
          {data.isEducator && (
            <Button
              type="default"
              href="/konnected/learning-paths/manage-existing-paths"
            >
              Manage paths
            </Button>
          )}
          {data.isEducator && (
            <Button
              type="primary"
              href="/konnected/learning-paths/create-learning-path"
            >
              Create path
            </Button>
          )}
          {!data.isEducator && (
            <Button
              type="primary"
              href="/konnected/learning-paths/my-learning-path"
            >
              View my paths
            </Button>
          )}
        </Space>
      }
    >
      {!hasPaths ? (
        <Empty
          description="No learning paths yet"
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        >
          <Button type="primary" href="/konnected/learning-library/browse-resources">
            Start from library
          </Button>
        </Empty>
      ) : (
        <Space direction="vertical" size="large" style={{ width: "100%" }}>
          <Space size="large" wrap>
            <StatisticCard
              statistic={{
                title: "My active paths",
                value: data.myActivePaths,
                prefix: <ReadOutlined />,
              }}
            />
            <StatisticCard
              statistic={{
                title: "Completed paths",
                value: data.myCompletedPaths,
                prefix: <CheckCircleOutlined />,
              }}
            />
            {data.isEducator && (
              <StatisticCard
                statistic={{
                  title: "Paths I manage",
                  value: data.managedPathsCount,
                  prefix: <FileTextOutlined />,
                }}
              />
            )}
          </Space>
          {data.myCurrentPathTitle && (
            <div>
              <Space align="center">
                <Text strong>Current path:</Text>
                <Text>{data.myCurrentPathTitle}</Text>
                <Badge status="processing" text="In progress" />
              </Space>
              {typeof data.myCurrentPathProgressPercent === "number" && (
                <div style={{ marginTop: 8 }}>
                  <Progress
                    percent={Math.round(data.myCurrentPathProgressPercent)}
                    status="active"
                  />
                </div>
              )}
            </div>
          )}
        </Space>
      )}
    </ProCard>
  );
}

function CommunityTile() {
  const { data, isLoading, isError } = useCommunitySummary();

  if (isLoading) {
    return (
      <ProCard title="Community & co-creation" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Community & co-creation"
        bordered
        extra={
          <Button type="link" href="/konnected/community-discussions/active-threads">
            View community
          </Button>
        }
      >
        <Alert
          type="warning"
          showIcon
          message="Unable to load community activity."
        />
      </ProCard>
    );
  }

  const hasAny =
    data.activeThreadsCount > 0 ||
    data.recentTopics.length > 0 ||
    data.activeCoCreationProjects.length > 0;

  return (
    <ProCard
      title="Community & co-creation"
      bordered
      extra={
        <Space>
          <Button
            type="default"
            href="/konnected/community-discussions/active-threads"
          >
            Active threads
          </Button>
          <Button
            type="primary"
            href="/konnected/community-discussions/start-new-discussion"
          >
            Start discussion
          </Button>
        </Space>
      }
    >
      {!hasAny ? (
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description="No community activity yet"
        >
          <Button
            type="primary"
            href="/konnected/community-discussions/start-new-discussion"
          >
            Start the first discussion
          </Button>
        </Empty>
      ) : (
        <Tabs
          defaultActiveKey="forums"
          items={[
            {
              key: "forums",
              label: "Forums",
              children: (
                <List
                  size="small"
                  dataSource={data.recentTopics}
                  locale={{ emptyText: "No recent topics" }}
                  renderItem={(topic) => (
                    <List.Item
                      actions={[
                        topic.unreadCount > 0 ? (
                          <Badge
                            key="unread"
                            count={topic.unreadCount}
                            style={{ backgroundColor: "#faad14" }}
                          />
                        ) : null,
                        <Button
                          key="open"
                          type="link"
                          href="/konnected/community-discussions/active-threads"
                        >
                          Open
                        </Button>,
                      ]}
                    >
                      <List.Item.Meta
                        avatar={
                          <Avatar icon={<TeamOutlined />} />
                        }
                        title={topic.title}
                        description={
                          <Text type="secondary">
                            Last activity: {topic.lastActivity}
                          </Text>
                        }
                      />
                    </List.Item>
                  )}
                />
              ),
            },
            {
              key: "cocreation",
              label: "Co-creation",
              children: (
                <List
                  size="small"
                  dataSource={data.activeCoCreationProjects}
                  locale={{ emptyText: "No active co-creation projects" }}
                  renderItem={(proj) => (
                    <List.Item
                      actions={[
                        <Tag key="role">{proj.role}</Tag>,
                        <Tag key="status" color="blue">
                          {proj.status}
                        </Tag>,
                      ]}
                    >
                      <List.Item.Meta
                        avatar={<Avatar icon={<ReadOutlined />} />}
                        title={proj.title}
                      />
                    </List.Item>
                  )}
                />
              ),
            },
          ]}
        />
      )}
    </ProCard>
  );
}

function TeamsTile() {
  const { data, isLoading, isError } = useTeamsSummary();

  if (isLoading) {
    return (
      <ProCard title="Teams & collaboration" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Teams & collaboration"
        bordered
        extra={
          <Button type="link" href="/konnected/teams-collaboration/my-teams">
            My teams
          </Button>
        }
      >
        <Alert type="warning" showIcon message="Unable to load teams summary." />
      </ProCard>
    );
  }

  const hasTeams = data.myTeamsCount > 0 || data.teams.length > 0;

  return (
    <ProCard
      title="Teams & collaboration"
      bordered
      extra={
        <Space>
          <Button type="default" href="/konnected/teams-collaboration/my-teams">
            My teams
          </Button>
          <Button
            type="primary"
            href="/konnected/teams-collaboration/team-builder"
          >
            Team builder
          </Button>
        </Space>
      }
    >
      {!hasTeams ? (
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description="You are not in any team yet"
        >
          <Button
            type="primary"
            href="/konnected/teams-collaboration/team-builder"
          >
            Discover teams
          </Button>
        </Empty>
      ) : (
        <>
          <Space size="large" wrap>
            <StatisticCard
              statistic={{
                title: "My teams",
                value: data.myTeamsCount,
                prefix: <TeamOutlined />,
              }}
            />
          </Space>
          {data.nextTeamActivityTitle && (
            <div style={{ marginTop: 16 }}>
              <Space>
                <Text strong>Next team activity:</Text>
                <Text>{data.nextTeamActivityTitle}</Text>
                {data.nextTeamActivityDate && (
                  <Tag icon={<LineChartOutlined />}>
                    {data.nextTeamActivityDate}
                  </Tag>
                )}
              </Space>
            </div>
          )}
          <List
            style={{ marginTop: 16 }}
            size="small"
            dataSource={data.teams}
            locale={{ emptyText: "No teams to display" }}
            renderItem={(team) => (
              <List.Item
                actions={[
                  <Button
                    key="open"
                    type="link"
                    href="/konnected/teams-collaboration/project-workspaces"
                  >
                    Open workspace
                  </Button>,
                ]}
              >
                <List.Item.Meta
                  avatar={
                    <Avatar.Group>
                      <Avatar icon={<TeamOutlined />} />
                    </Avatar.Group>
                  }
                  title={team.name}
                  description={`${team.memberCount} members`}
                />
              </List.Item>
            )}
          />
        </>
      )}
    </ProCard>
  );
}

function UsageTile() {
  const { data, isLoading, isError } = useUsageSummary();

  if (isLoading) {
    return (
      <ProCard title="Your usage in KonnectED" bordered>
        <Skeleton active />
      </ProCard>
    );
  }

  if (isError || !data) {
    return (
      <ProCard
        title="Your usage in KonnectED"
        bordered
        extra={
          <Tooltip title="Usage analytics provided by the Insights module">
            <ExclamationCircleOutlined />
          </Tooltip>
        }
      >
        <Alert
          type="info"
          showIcon
          message="Usage analytics are temporarily unavailable."
        />
      </ProCard>
    );
  }

  return (
    <ProCard
      title="Your usage in KonnectED"
      bordered
      extra={
        <Tooltip title="Usage analytics provided by the Insights module">
          <ExclamationCircleOutlined />
        </Tooltip>
      }
    >
      <Space size="large" wrap>
        <StatisticCard
          statistic={{
            title: "Active days (last 30)",
            value: data.daysActiveLast30,
            prefix: <LineChartOutlined />,
          }}
        />
        <StatisticCard
          statistic={{
            title: "Resources completed (last 30)",
            value: data.resourcesCompletedLast30,
            prefix: <ReadOutlined />,
          }}
        />
        <StatisticCard
          statistic={{
            title: "Certifications earned (last 30)",
            value: data.certificationsEarnedLast30,
            prefix: <CheckCircleOutlined />,
          }}
        />
      </Space>
    </ProCard>
  );
}

// ---------- Page ----------

export default function KonnectedDashboardPage() {
  return (
    <KonnectedPageShell
      title="KonnectED dashboard"
      subtitle="Overview of your certifications, learning, community, and teams."
      primaryAction={
        <Button type="primary" href="/konnected/learning-library/recommended-resources">
          Continue learning
        </Button>
      }
      secondaryActions={
        <Space>
          <Button href="/konnected/certifications/certification-programs">
            Certifications
          </Button>
          <Button href="/konnected/learning-library/browse-resources">
            Library
          </Button>
        </Space>
      }
    >
      <PageContainer>
        <Row gutter={[16, 16]}>
          <Col xs={24} xl={16}>
            <CertificationsTile />
          </Col>
          <Col xs={24} xl={8}>
            <UsageTile />
          </Col>

          <Col xs={24} xl={16}>
            <LearningTile />
          </Col>
          <Col xs={24} xl={8}>
            <LearningPathsTile />
          </Col>

          <Col xs={24} xl={12}>
            <CommunityTile />
          </Col>
          <Col xs={24} xl={12}>
            <TeamsTile />
          </Col>
        </Row>
      </PageContainer>
    </KonnectedPageShell>
  );
}

===== END app/konnected/dashboard/page.tsx =====


===== BEGIN app/konnected/KonnectedPageShell.tsx =====
// app/konnected/KonnectedPageShell.tsx
'use client';

import React, { ReactNode } from 'react';
import { Typography, Space } from 'antd';

const { Title, Paragraph } = Typography;

export type KonnectedPageShellProps = {
  /** Main page title (big, H1-equivalent) */
  title: string;
  /** Optional subtitle / helper text under the title */
  subtitle?: ReactNode;
  /** Main CTA on the right (e.g. primary button) */
  primaryAction?: ReactNode;
  /** Secondary actions on the right (e.g. ghost buttons, filters) */
  secondaryActions?: ReactNode;
  /** Main page content */
  children: ReactNode;
};

/**
 * Central layout wrapper for KonnectED pages (Konnected segment).
 *
 * Usage rules:
 * - Do not render another top-level <h1> / Typography.Title outside this shell.
 * - Do not render breadcrumbs here (those belong to the global/MainLayout shell).
 * - All /konnected/* pages should use this for consistent padding & header.
 */
export default function KonnectedPageShell({
  title,
  subtitle,
  primaryAction,
  secondaryActions,
  children,
}: KonnectedPageShellProps): JSX.Element {
  const hasActions = Boolean(primaryAction || secondaryActions);

  return (
    <div className="container mx-auto p-5">
      {/* Header: title + subtitle + actions */}
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div className="min-w-0">
          <Title level={2} className="!mb-1">
            {title}
          </Title>
          {subtitle && (
            <Paragraph type="secondary" className="!mb-0">
              {subtitle}
            </Paragraph>
          )}
        </div>

        {hasActions && (
          <Space wrap>
            {secondaryActions}
            {primaryAction}
          </Space>
        )}
      </div>

      {/* Main content */}
      {children}
    </div>
  );
}

===== END app/konnected/KonnectedPageShell.tsx =====


===== BEGIN app/konnected/layout.tsx =====
// app/konnected/layout.tsx
'use client'

import type { ReactNode } from 'react'
import React, { Suspense, useEffect } from 'react'
import { Layout, Spin } from 'antd'
import { usePathname, useRouter, useSearchParams } from 'next/navigation'

import MainLayout from '@/components/layout-components/MainLayout'

const { Content } = Layout

interface SegmentLayoutProps {
  children: ReactNode
}

/**
 * Inner shell that forces the KonnectED sidebar to be active
 * via the ?sidebar=konnected query param.
 *
 * Responsibilities:
 * - Ensure that when a user is under /konnected/*, the "KonnectED" suite
 *   is selected in MainLayout (so the correct routes and label show up).
 * - Delegate all global chrome (sidebar, header, breadcrumbs) to MainLayout.
 * - Do NOT handle page-level titles or actions; those belong to KonnectedPageShell.
 */
function KonnectedShell({ children }: SegmentLayoutProps) {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  useEffect(() => {
    const currentSidebar = searchParams.get('sidebar')

    if (currentSidebar === 'konnected') return

    const params = new URLSearchParams(Array.from(searchParams.entries()))
    params.set('sidebar', 'konnected')

    router.replace(`${pathname}?${params.toString()}`)
  }, [router, pathname, searchParams])

  return <MainLayout>{children}</MainLayout>
}

/**
 * Segment layout for all /konnected/* pages.
 *
 * - Wraps content in MainLayout (global Ant Design layout + navigation).
 * - Provides an Ant Design‚Äìbased Suspense fallback while children load.
 * - Keeps page-level layout concerns in KonnectedPageShell (used by pages themselves).
 */
export default function SegmentLayout({ children }: SegmentLayoutProps) {
  return (
    <Suspense
      fallback={
        <Layout style={{ minHeight: '100vh' }}>
          <Content
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <Spin size="large" />
          </Content>
        </Layout>
      }
    >
      <KonnectedShell>{children}</KonnectedShell>
    </Suspense>
  )
}

===== END app/konnected/layout.tsx =====


===== BEGIN app/konnected/learning-library/browse-resources/page.tsx =====
// app/konnected/learning-library/browse-resources/page.tsx
'use client';

import React, { useCallback, useEffect, useMemo, useState } from 'react';
import axios from 'axios';
import { useRouter } from 'next/navigation';
import {
  Row,
  Col,
  Card,
  Typography,
  Input,
  Select,
  Tag,
  Rate,
  Space,
  Table,
  Pagination,
  Button,
  Alert,
  Spin,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import {
  SearchOutlined,
  FilterOutlined,
  DownloadOutlined,
  ShareAltOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text } = Typography;
const { Search } = Input;

/* ------------------------------------------------------------------ */
/*  Domain types (aligned with KnowledgeResource + list API)          */
/* ------------------------------------------------------------------ */

type KnowledgeLevel = 'beginner' | 'intermediate' | 'advanced';

type SortOption = 'relevance' | 'newest' | 'popular' | 'shortest' | 'longest';

interface KnowledgeResource {
  id: string | number;
  title: string;
  description?: string;
  subject: string;
  level: KnowledgeLevel;
  language: string;
  resource_type: string; // e.g. 'video' | 'article' | 'course' | 'quiz'
  average_rating?: number | null;
  tags?: string[];
  estimated_minutes?: number | null;
  is_offline_available?: boolean;
  user_progress_percent?: number | null;
}

interface KnowledgeResourceListResponse {
  count: number;
  results: KnowledgeResource[];
}

interface KnowledgeMetadataResponse {
  subjects: string[];
  levels: KnowledgeLevel[];
  languages: string[];
  resource_types: string[];
}

/* ------------------------------------------------------------------ */
/*  API endpoints (adapt path segments to match your OpenAPI)         */
/* ------------------------------------------------------------------ */

const KNOWLEDGE_RESOURCES_ENDPOINT = '/api/konnected/knowledge/resources/';
const KNOWLEDGE_METADATA_ENDPOINT = '/api/konnected/knowledge/resources-meta/';

interface FiltersState {
  query: string;
  subject?: string;
  level?: KnowledgeLevel;
  language?: string;
  resourceType?: string;
  sort: SortOption;
}

/* Map UI sort options to backend ordering query param */
function mapSortToOrdering(sort: SortOption): string | undefined {
  switch (sort) {
    case 'relevance':
      return '-search_score'; // typical search backend field
    case 'newest':
      return '-created_at';
    case 'popular':
      return '-popularity';
    case 'shortest':
      return 'estimated_minutes';
    case 'longest':
      return '-estimated_minutes';
    default:
      return undefined;
  }
}

/* ------------------------------------------------------------------ */
/*  Page component                                                     */
/* ------------------------------------------------------------------ */

export default function BrowseResourcesPage(): JSX.Element {
  const router = useRouter();

  // Filters & pagination
  const [filters, setFilters] = useState<FiltersState>({
    query: '',
    sort: 'relevance',
  });
  const [page, setPage] = useState<number>(1);
  const [pageSize, setPageSize] = useState<number>(12);

  // Data
  const [resources, setResources] = useState<KnowledgeResource[]>([]);
  const [total, setTotal] = useState<number>(0);

  // Metadata for filters
  const [subjects, setSubjects] = useState<string[]>([]);
  const [levels, setLevels] = useState<KnowledgeLevel[]>([]);
  const [languages, setLanguages] = useState<string[]>([]);
  const [resourceTypes, setResourceTypes] = useState<string[]>([]);

  // UI state
  const [loading, setLoading] = useState<boolean>(false);
  const [loadingMeta, setLoadingMeta] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  /* -------------------------------------------------------------- */
  /*  Load metadata (subjects, levels, languages, types)            */
  /* -------------------------------------------------------------- */

  useEffect(() => {
    let cancelled = false;

    const loadMetadata = async () => {
      setLoadingMeta(true);
      try {
        const res = await axios.get<KnowledgeMetadataResponse>(
          KNOWLEDGE_METADATA_ENDPOINT,
        );
        if (cancelled) return;

        setSubjects(res.data.subjects ?? []);
        setLevels(res.data.levels ?? []);
        setLanguages(res.data.languages ?? []);
        setResourceTypes(res.data.resource_types ?? []);
      } catch (e) {
        // Non-blocking error: filters still work with empty options
        // eslint-disable-next-line no-console
        console.warn('Failed to load Knowledge metadata', e);
      } finally {
        if (!cancelled) {
          setLoadingMeta(false);
        }
      }
    };

    loadMetadata();

    return () => {
      cancelled = true;
    };
  }, []);

  /* -------------------------------------------------------------- */
  /*  Load resources list                                           */
  /* -------------------------------------------------------------- */

  const fetchResources = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const ordering = mapSortToOrdering(filters.sort);

      const res = await axios.get<KnowledgeResourceListResponse>(
        KNOWLEDGE_RESOURCES_ENDPOINT,
        {
          params: {
            page,
            page_size: pageSize,
            q: filters.query || undefined,
            subject: filters.subject || undefined,
            level: filters.level || undefined,
            language: filters.language || undefined,
            resource_type: filters.resourceType || undefined,
            ordering: ordering || undefined,
          },
        },
      );

      setResources(res.data.results ?? []);
      setTotal(res.data.count ?? 0);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error('Failed to load Knowledge resources', e);
      setError('Unable to load resources. Please try again.');
      setResources([]);
      setTotal(0);
    } finally {
      setLoading(false);
    }
  }, [filters, page, pageSize]);

  useEffect(() => {
    fetchResources();
  }, [fetchResources]);

  /* -------------------------------------------------------------- */
  /*  Handlers                                                      */
  /* -------------------------------------------------------------- */

  const handleSearch = (value: string) => {
    setPage(1);
    setFilters((prev) => ({ ...prev, query: value.trim() }));
  };

  const handleFilterChange = <K extends keyof FiltersState>(
    key: K,
    value: FiltersState[K],
  ) => {
    setPage(1);
    setFilters((prev) => ({ ...prev, [key]: value }));
  };

  const handleTableChangePage = (nextPage: number, nextPageSize?: number) => {
    setPage(nextPage);
    if (nextPageSize && nextPageSize !== pageSize) {
      setPageSize(nextPageSize);
    }
  };

  const handleOpenResource = (record: KnowledgeResource) => {
    router.push(`/konnected/learning-library/resource/${record.id}`);
  };

  const handleSaveOffline = (record: KnowledgeResource) => {
    // Placeholder behaviour; plug into Offline Content API later
    // eslint-disable-next-line no-console
    console.info('Save offline requested for resource', record.id);
  };

  const handleShare = (record: KnowledgeResource) => {
    // Placeholder behaviour; plug into share/clipboard API later
    // eslint-disable-next-line no-console
    console.info('Share requested for resource', record.id);
  };

  /* -------------------------------------------------------------- */
  /*  Table configuration                                           */
  /* -------------------------------------------------------------- */

  const columns: ColumnsType<KnowledgeResource> = useMemo(
    () => [
      {
        title: 'Title',
        dataIndex: 'title',
        key: 'title',
        width: 280,
        render: (value: string, record) => (
          <Space direction="vertical" size={2}>
            <Button
              type="link"
              style={{ padding: 0 }}
              onClick={() => handleOpenResource(record)}
            >
              {value}
            </Button>
            {record.description && (
              <Text type="secondary" ellipsis={{ tooltip: record.description }}>
                {record.description}
              </Text>
            )}
          </Space>
        ),
      },
      {
        title: 'Subject',
        dataIndex: 'subject',
        key: 'subject',
        width: 140,
        render: (value: string) => <Tag>{value}</Tag>,
      },
      {
        title: 'Type',
        dataIndex: 'resource_type',
        key: 'resource_type',
        width: 120,
        render: (value: string) => (
          <Tag color="default">{value.charAt(0).toUpperCase() + value.slice(1)}</Tag>
        ),
      },
      {
        title: 'Level',
        dataIndex: 'level',
        key: 'level',
        width: 120,
        render: (value: KnowledgeLevel) => (
          <Tag>
            {value === 'beginner'
              ? 'Beginner'
              : value === 'intermediate'
              ? 'Intermediate'
              : 'Advanced'}
          </Tag>
        ),
      },
      {
        title: 'Language',
        dataIndex: 'language',
        key: 'language',
        width: 120,
      },
      {
        title: 'Rating',
        dataIndex: 'average_rating',
        key: 'average_rating',
        width: 160,
        render: (value: number | null | undefined) =>
          value != null ? (
            <Space size={4}>
              <Rate allowHalf disabled value={value} />
              <Text type="secondary">{value.toFixed(1)}</Text>
            </Space>
          ) : (
            <Text type="secondary">Not rated</Text>
          ),
      },
      {
        title: 'Tags',
        dataIndex: 'tags',
        key: 'tags',
        width: 220,
        render: (tags?: string[]) => {
          if (!tags || !tags.length) {
            return <Text type="secondary">‚Äî</Text>;
          }
          const maxVisible = 3;
          const visible = tags.slice(0, maxVisible);
          const remaining = tags.length - visible.length;

          return (
            <Space size={[4, 4]} wrap>
              {visible.map((tag) => (
                <Tag key={tag}>{tag}</Tag>
              ))}
              {remaining > 0 && <Tag>+{remaining}</Tag>}
            </Space>
          );
        },
      },
      {
        title: 'Progress',
        dataIndex: 'user_progress_percent',
        key: 'user_progress_percent',
        width: 130,
        render: (value: number | null | undefined) =>
          value != null ? (
            <Text>{`${Math.round(value)}%`}</Text>
          ) : (
            <Text type="secondary">Not started</Text>
          ),
      },
      {
        title: 'Actions',
        key: 'actions',
        fixed: 'right',
        width: 190,
        render: (_: unknown, record) => (
          <Space>
            <Button type="primary" size="small" onClick={() => handleOpenResource(record)}>
              Open
            </Button>
            {record.is_offline_available && (
              <Button
                size="small"
                icon={<DownloadOutlined />}
                onClick={() => handleSaveOffline(record)}
              >
                Offline
              </Button>
            )}
            <Button
              size="small"
              icon={<ShareAltOutlined />}
              onClick={() => handleShare(record)}
            />
          </Space>
        ),
      },
    ],
    [],
  );

  /* -------------------------------------------------------------- */
  /*  Derived UI bits                                               */
  /* -------------------------------------------------------------- */

  const hasResults = resources.length > 0;
  const showTotalLabel =
    total > 0 ? `${total} resource${total > 1 ? 's' : ''} found` : undefined;

  /* -------------------------------------------------------------- */
  /*  Render                                                        */
  /* -------------------------------------------------------------- */

  return (
    <KonnectedPageShell
      title="KonnectED ¬∑ Knowledge ¬∑ Browse resources"
      subtitle="Explore the shared learning library by subject, level, language, and content type."
      secondaryActions={
        <Space>
          <Button icon={<FilterOutlined />}>Filters</Button>
        </Space>
      }
      primaryAction={
        <Button
          type="primary"
          onClick={() => router.push('/konnected/learning-library/recommended-resources')}
        >
          View recommended
        </Button>
      }
    >
      <Row gutter={[24, 24]}>
        {/* Left column: Filters */}
        <Col xs={24} md={8} lg={7}>
          <Card
            title={
              <Space>
                <FilterOutlined />
                <span>Filter resources</span>
              </Space>
            }
          >
            <Space direction="vertical" size="middle" style={{ width: '100%' }}>
              <Search
                placeholder="Search by title, keywords, or description"
                allowClear
                enterButton={<SearchOutlined />}
                defaultValue={filters.query}
                onSearch={handleSearch}
              />

              <div>
                <Text strong>Subject</Text>
                <Select
                  style={{ width: '100%', marginTop: 4 }}
                  placeholder={loadingMeta ? 'Loading subjects‚Ä¶' : 'All subjects'}
                  loading={loadingMeta}
                  allowClear
                  value={filters.subject}
                  onChange={(value) => handleFilterChange('subject', value || undefined)}
                  options={subjects.map((s) => ({ label: s, value: s }))}
                />
              </div>

              <div>
                <Text strong>Level</Text>
                <Select
                  style={{ width: '100%', marginTop: 4 }}
                  placeholder="All levels"
                  allowClear
                  value={filters.level}
                  onChange={(value) => handleFilterChange('level', value || undefined)}
                  options={
                    levels.length
                      ? levels.map((lvl) => ({
                          label:
                            lvl === 'beginner'
                              ? 'Beginner'
                              : lvl === 'intermediate'
                              ? 'Intermediate'
                              : 'Advanced',
                          value: lvl,
                        }))
                      : [
                          { label: 'Beginner', value: 'beginner' },
                          { label: 'Intermediate', value: 'intermediate' },
                          { label: 'Advanced', value: 'advanced' },
                        ]
                  }
                />
              </div>

              <div>
                <Text strong>Language</Text>
                <Select
                  style={{ width: '100%', marginTop: 4 }}
                  placeholder="All languages"
                  allowClear
                  value={filters.language}
                  onChange={(value) => handleFilterChange('language', value || undefined)}
                  options={languages.map((lang) => ({ label: lang, value: lang }))}
                />
              </div>

              <div>
                <Text strong>Type</Text>
                <Select
                  style={{ width: '100%', marginTop: 4 }}
                  placeholder="All content types"
                  allowClear
                  value={filters.resourceType}
                  onChange={(value) =>
                    handleFilterChange('resourceType', value || undefined)
                  }
                  options={resourceTypes.map((t) => ({
                    label: t.charAt(0).toUpperCase() + t.slice(1),
                    value: t,
                  }))}
                />
              </div>

              <div>
                <Text strong>Sort by</Text>
                <Select<SortOption>
                  style={{ width: '100%', marginTop: 4 }}
                  value={filters.sort}
                  onChange={(value) => handleFilterChange('sort', value)}
                  options={[
                    { label: 'Relevance', value: 'relevance' },
                    { label: 'Newest first', value: 'newest' },
                    { label: 'Most popular', value: 'popular' },
                    { label: 'Shortest duration', value: 'shortest' },
                    { label: 'Longest duration', value: 'longest' },
                  ]}
                />
              </div>
            </Space>
          </Card>
        </Col>

        {/* Right column: Results table */}
        <Col xs={24} md={16} lg={17}>
          <Card
            title="Browse resources"
            extra={
              showTotalLabel && (
                <Text type="secondary" style={{ whiteSpace: 'nowrap' }}>
                  {showTotalLabel}
                </Text>
              )
            }
          >
            {error && (
              <div style={{ marginBottom: 16 }}>
                <Alert
                  type="error"
                  showIcon
                  message="Error loading resources"
                  description={error}
                />
              </div>
            )}

            {loading && !hasResults ? (
              <div
                style={{
                  minHeight: 200,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Spin tip="Loading resources‚Ä¶" />
              </div>
            ) : (
              <>
                <Table<KnowledgeResource>
                  rowKey={(row) => row.id}
                  size="middle"
                  bordered
                  columns={columns}
                  dataSource={resources}
                  loading={loading}
                  pagination={false}
                  scroll={{ x: 1100 }}
                  locale={{
                    emptyText: (
                      <div style={{ padding: '24px 0' }}>
                        <Text type="secondary">
                          No resources match your filters yet. Try adjusting your search
                          terms or filter options.
                        </Text>
                      </div>
                    ),
                  }}
                />

                <div
                  style={{
                    marginTop: 16,
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    flexWrap: 'wrap',
                    gap: 12,
                  }}
                >
                  <Text type="secondary">
                    Page {page} of {Math.max(1, Math.ceil(total / pageSize))}
                  </Text>

                  <Pagination
                    current={page}
                    total={total}
                    pageSize={pageSize}
                    showSizeChanger
                    pageSizeOptions={['6', '12', '24', '48']}
                    showTotal={(t) => `${t} item${t === 1 ? '' : 's'}`}
                    onChange={handleTableChangePage}
                  />
                </div>
              </>
            )}
          </Card>
        </Col>
      </Row>
    </KonnectedPageShell>
  );
}

===== END app/konnected/learning-library/browse-resources/page.tsx =====


===== BEGIN app/konnected/learning-library/offline-content/page.tsx =====
// app/konnected/learning-library/offline-content/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import Head from 'next/head';
import {
  Row,
  Col,
  Card,
  Typography,
  Button,
  Tag,
  Progress,
  Table,
  Switch,
  Space,
  Modal,
  Form,
  Input,
  Select,
  Tooltip,
  message as antdMessage,
  Empty,
  Alert,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import { ProCard, StatisticCard } from '@ant-design/pro-components';
import {
  DownloadOutlined,
  SyncOutlined,
  DeleteOutlined,
  PlusOutlined,
  WarningOutlined,
} from '@ant-design/icons';
import { useRequest } from 'ahooks';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import api from '@/api';

const { Paragraph, Text } = Typography;
const { Option } = Select;
const { Statistic } = StatisticCard;

// ---- Domain types ---------------------------------------------------------

type OfflinePackageStatus = 'scheduled' | 'building' | 'ready' | 'failed';

interface OfflinePackage {
  id: number | string;
  name: string;
  description?: string;
  status: OfflinePackageStatus;
  itemCount: number;
  totalSizeMb: number;
  lastBuiltAt?: string | null;
  targetDeviceType?: 'laptop' | 'tablet' | 'usb' | 'other';
  autoSync?: boolean;
  // Optional: when a build is in progress
  buildProgressPercent?: number;
  lastErrorMessage?: string | null;
}

type ResourceType = 'article' | 'video' | 'lesson' | 'quiz' | 'dataset';

interface OfflineableResource {
  id: number | string;
  title: string;
  type: ResourceType;
  subject?: string;
  level?: string;
  language?: string;
  sizeMb?: number;
  offlineEligible: boolean;
  includedInPackages?: string[]; // package names / IDs for quick display
}

interface CreateOfflinePackagePayload {
  name: string;
  description?: string;
  targetDeviceType?: OfflinePackage['targetDeviceType'];
  maxSizeMb?: number;
  includeTypes?: ResourceType[];
  subjectFilter?: string;
  levelFilter?: string;
  languageFilter?: string;
}

// ---- API helpers ----------------------------------------------------------
// NOTE: Endpoint paths/response wrappers are inferred.
// Align them with schema-endpoints.json when wiring to the real backend.

const OFFLINE_PACKAGE_LIST_ENDPOINT =
  '/konnected/knowledge/offline-packages/';
const OFFLINE_PACKAGE_DETAIL_ENDPOINT = (id: OfflinePackage['id']) =>
  `/konnected/knowledge/offline-packages/${id}/`;
const OFFLINE_PACKAGE_SYNC_ENDPOINT = (id: OfflinePackage['id']) =>
  `/konnected/knowledge/offline-packages/${id}/sync/`;
const OFFLINE_RESOURCES_ENDPOINT =
  '/konnected/knowledge/offline-resources/';

function normalizeList<T>(raw: unknown): T[] {
  if (Array.isArray(raw)) return raw as T[];

  if (raw && typeof raw === 'object') {
    const obj = raw as { results?: unknown; items?: unknown };
    if (Array.isArray(obj.results)) return obj.results as T[];
    if (Array.isArray(obj.items)) return obj.items as T[];
  }

  return [];
}

async function fetchOfflinePackages(): Promise<OfflinePackage[]> {
  const res = await api.get(OFFLINE_PACKAGE_LIST_ENDPOINT);
  // res is treated as having a `data` field of unknown shape
  return normalizeList<OfflinePackage>((res as { data: unknown }).data);
}

async function fetchOfflineableResources(): Promise<OfflineableResource[]> {
  const res = await api.get(OFFLINE_RESOURCES_ENDPOINT);
  return normalizeList<OfflineableResource>((res as { data: unknown }).data);
}

async function createOfflinePackage(
  payload: CreateOfflinePackagePayload,
): Promise<void> {
  await api.post(OFFLINE_PACKAGE_LIST_ENDPOINT, payload);
}

async function deleteOfflinePackage(id: OfflinePackage['id']): Promise<void> {
  await api.delete(OFFLINE_PACKAGE_DETAIL_ENDPOINT(id));
}

async function syncOfflinePackage(id: OfflinePackage['id']): Promise<void> {
  await api.post(OFFLINE_PACKAGE_SYNC_ENDPOINT(id));
}

// ---- Component ------------------------------------------------------------

export default function OfflineContentPage(): JSX.Element {
  // Data fetching
  const {
    data: packages,
    loading: loadingPackages,
    refresh: reloadPackages,
  } = useRequest<OfflinePackage[], []>(fetchOfflinePackages);

  const {
    data: resources,
    loading: loadingResources,
  } = useRequest<OfflineableResource[], []>(fetchOfflineableResources);

  // Local UI state
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [creating, setCreating] = useState(false);
  const [syncingId, setSyncingId] = useState<OfflinePackage['id'] | null>(null);
  const [deletingId, setDeletingId] = useState<OfflinePackage['id'] | null>(
    null,
  );
  const [autoSyncEnabled, setAutoSyncEnabled] = useState(true);

  const [createForm] = Form.useForm<CreateOfflinePackagePayload>();

  const packageList = packages ?? [];
  const resourceList = resources ?? [];

  // ---- Derived stats ------------------------------------------------------

  const totalPackages = packageList.length;
  const readyPackages = packageList.filter((p) => p.status === 'ready').length;
  const buildingPackages = packageList.filter(
    (p) => p.status === 'building' || p.status === 'scheduled',
  ).length;
  const failedPackages = packageList.filter(
    (p) => p.status === 'failed',
  ).length;

  const totalSizeMb = useMemo(
    () =>
      packageList.reduce(
        (acc, pkg) => acc + (Number(pkg.totalSizeMb) || 0),
        0,
      ),
    [packageList],
  );

  const eligibleResourcesCount = resourceList.filter(
    (r) => r.offlineEligible,
  ).length;

  // ---- Handlers -----------------------------------------------------------

  const handleOpenCreateModal = () => {
    createForm.resetFields();
    setIsCreateModalOpen(true);
  };

  const handleCreatePackage = async (values: CreateOfflinePackagePayload) => {
    try {
      setCreating(true);
      await createOfflinePackage(values);
      antdMessage.success('Offline package scheduled successfully.');
      setIsCreateModalOpen(false);
      await reloadPackages();
    } catch (err) {
      antdMessage.error('Failed to create offline package. Please try again.');
    } finally {
      setCreating(false);
    }
  };

  const handleConfirmDelete = async (pkg: OfflinePackage) => {
    Modal.confirm({
      title: 'Remove offline package?',
      content:
        'This will remove the offline package configuration. Already-cached content on devices may remain until cleared manually.',
      okText: 'Remove',
      okButtonProps: { danger: true, loading: deletingId === pkg.id },
      onOk: async () => {
        try {
          setDeletingId(pkg.id);
          await deleteOfflinePackage(pkg.id);
          antdMessage.success('Offline package removed.');
          await reloadPackages();
        } catch (err) {
          antdMessage.error(
            'Failed to remove the offline package. Please try again.',
          );
        } finally {
          setDeletingId(null);
        }
      },
    });
  };

  const handleSyncPackage = async (pkg: OfflinePackage) => {
    try {
      setSyncingId(pkg.id);
      await syncOfflinePackage(pkg.id);
      antdMessage.success('Sync started. It will continue in the background.');
      await reloadPackages();
    } catch (err) {
      antdMessage.error('Failed to start sync. Please try again.');
    } finally {
      setSyncingId(null);
    }
  };

  const handleSyncAll = async () => {
    if (!packageList.length) {
      antdMessage.info('There are no offline packages to sync yet.');
      return;
    }

    try {
      setSyncingId('__all__');
      await Promise.all(packageList.map((pkg) => syncOfflinePackage(pkg.id)));
      antdMessage.success('Sync started for all packages.');
      await reloadPackages();
    } catch (err) {
      antdMessage.error('Failed to start sync for all packages.');
    } finally {
      setSyncingId(null);
    }
  };

  const hasAnySyncInProgress =
    syncingId !== null ||
    packageList.some((p) => p.status === 'building' || p.status === 'scheduled');

  const handleToggleDeviceAutoSync = (checked: boolean) => {
    // This flag is local to this device for now.
    setAutoSyncEnabled(checked);
    antdMessage.success(
      checked
        ? 'Auto-sync enabled on this device.'
        : 'Auto-sync disabled on this device.',
    );
  };

  // ---- Table columns ------------------------------------------------------

  const resourceColumns: ColumnsType<OfflineableResource> = [
    {
      title: 'Title',
      dataIndex: 'title',
      ellipsis: true,
    },
    {
      title: 'Type',
      dataIndex: 'type',
      width: 110,
      render: (value: ResourceType) => (
        <Tag color="blue" key={value}>
          {value}
        </Tag>
      ),
    },
    {
      title: 'Subject',
      dataIndex: 'subject',
      width: 140,
      ellipsis: true,
    },
    {
      title: 'Level',
      dataIndex: 'level',
      width: 110,
    },
    {
      title: 'Language',
      dataIndex: 'language',
      width: 110,
    },
    {
      title: 'Size (MB)',
      dataIndex: 'sizeMb',
      width: 110,
      render: (value?: number) =>
        typeof value === 'number' ? value.toFixed(1) : '‚Äî',
    },
    {
      title: 'Offline status',
      dataIndex: 'offlineEligible',
      width: 160,
      render: (_: unknown, row: OfflineableResource) =>
        row.offlineEligible ? (
          <Tag color="green">Eligible</Tag>
        ) : (
          <Tag color="default">Online only</Tag>
        ),
    },
    {
      title: 'Packages',
      dataIndex: 'includedInPackages',
      width: 200,
      ellipsis: true,
      render: (value?: string[]) =>
        value && value.length ? value.join(', ') : '‚Äî',
    },
  ];

  // ---- Rendering helpers --------------------------------------------------

  const renderStatusTag = (status: OfflinePackageStatus) => {
    switch (status) {
      case 'ready':
        return <Tag color="green">Ready</Tag>;
      case 'building':
        return <Tag color="processing">Building</Tag>;
      case 'scheduled':
        return <Tag color="gold">Scheduled</Tag>;
      case 'failed':
        return (
          <Tag color="red">
            <WarningOutlined /> Failed
          </Tag>
        );
      default:
        return <Tag>{status}</Tag>;
    }
  };

  const renderDeviceLabel = (pkg: OfflinePackage) => {
    const type = pkg.targetDeviceType ?? 'other';
    const labelMap: Record<NonNullable<OfflinePackage['targetDeviceType']>, string> =
      {
        laptop: 'Laptop or desktop',
        tablet: 'Tablet',
        usb: 'USB drive / external media',
        other: 'Generic device',
      };
    return labelMap[type] ?? 'Device';
  };

  // ---- JSX ----------------------------------------------------------------

  return (
    <>
      <Head>
        <title>KonnectED ‚Äì Offline Content</title>
      </Head>

      <KonnectedPageShell
        title="Offline Content Packages"
        subtitle={
          <>
            Define and monitor offline bundles for low-connectivity environments.
            Packages are built on the server using the weekly cron schedule
            (currently <code>OFFLINE_PACKAGE_CRON = 0 3 * * SUN</code>).
          </>
        }
        primaryAction={
          <Button type="primary" icon={<PlusOutlined />} onClick={handleOpenCreateModal}>
            New offline package
          </Button>
        }
        secondaryActions={
          <Space size="middle">
            <Tooltip title="When enabled, this device will automatically pull updates for ready packages.">
              <Space>
                <Text>Auto-sync on this device</Text>
                <Switch checked={autoSyncEnabled} onChange={handleToggleDeviceAutoSync} />
              </Space>
            </Tooltip>
            <Button
              icon={<SyncOutlined />}
              onClick={handleSyncAll}
              disabled={hasAnySyncInProgress || !packageList.length}
              loading={syncingId === '__all__'}
            >
              {hasAnySyncInProgress ? 'Sync in progress‚Ä¶' : 'Sync all'}
            </Button>
          </Space>
        }
      >
        {/* Top statistics panel */}
        <ProCard ghost gutter={16} style={{ marginBottom: 24 }}>
          <StatisticCard
            statistic={{
              title: 'Total packages',
              value: totalPackages,
            }}
          />
          <StatisticCard
            statistic={{
              title: 'Ready for download',
              value: readyPackages,
            }}
          />
          <StatisticCard
            statistic={{
              title: 'Building / scheduled',
              value: buildingPackages,
            }}
          />
          <StatisticCard
            statistic={{
              title: 'Failed',
              value: failedPackages,
              valueStyle: failedPackages ? { color: 'red' } : undefined,
            }}
          />
          <StatisticCard
            statistic={{
              title: 'Approx. disk usage (MB)',
              value: totalSizeMb.toFixed(1),
            }}
          />
        </ProCard>

        {/* Layout: left = packages, right = resources */}
        <Row gutter={[24, 24]}>
          <Col xs={24} lg={10}>
            <Card
              title="Offline packages"
              extra={
                <Tag icon={<DownloadOutlined />} color="blue">
                  Offline mode
                </Tag>
              }
              loading={loadingPackages}
            >
              {packageList.length === 0 ? (
                <Empty
                  description={
                    <>
                      <div>No offline packages yet.</div>
                      <div>
                        Use ‚ÄúNew offline package‚Äù to schedule content bundles for
                        schools or communities with limited connectivity.
                      </div>
                    </>
                  }
                />
              ) : (
                <Space direction="vertical" size="large" style={{ width: '100%' }}>
                  {packageList.map((pkg) => (
                    <Card
                      key={pkg.id}
                      size="small"
                      bordered
                      title={
                        <Space direction="vertical" size={0}>
                          <Text strong>{pkg.name}</Text>
                          {pkg.description && (
                            <Text type="secondary" ellipsis>
                              {pkg.description}
                            </Text>
                          )}
                        </Space>
                      }
                      extra={renderStatusTag(pkg.status)}
                    >
                      <Space
                        direction="vertical"
                        size="small"
                        style={{ width: '100%' }}
                      >
                        <Space size="middle" wrap>
                          <Text type="secondary">
                            Target device: {renderDeviceLabel(pkg)}
                          </Text>
                          <Text type="secondary">
                            Items: <Text strong>{pkg.itemCount}</Text>
                          </Text>
                          <Text type="secondary">
                            Size: <Text strong>{pkg.totalSizeMb.toFixed(1)} MB</Text>
                          </Text>
                        </Space>

                        {pkg.lastBuiltAt && (
                          <Text type="secondary">
                            Last built: {new Date(pkg.lastBuiltAt).toLocaleString()}
                          </Text>
                        )}

                        {pkg.status === 'building' &&
                          typeof pkg.buildProgressPercent === 'number' && (
                            <Progress
                              percent={pkg.buildProgressPercent}
                              status="active"
                              size="small"
                            />
                          )}

                        {pkg.status === 'failed' && pkg.lastErrorMessage && (
                          <Alert
                            type="error"
                            showIcon
                            message="Last build failed"
                            description={pkg.lastErrorMessage}
                          />
                        )}

                        <Space style={{ marginTop: 8 }}>
                          <Button
                            type="primary"
                            icon={<SyncOutlined />}
                            onClick={() => handleSyncPackage(pkg)}
                            disabled={
                              pkg.status === 'building' ||
                              pkg.status === 'scheduled' ||
                              syncingId === pkg.id
                            }
                            loading={syncingId === pkg.id}
                          >
                            {pkg.status === 'ready' ? 'Sync updates' : 'Build now'}
                          </Button>
                          <Button
                            danger
                            icon={<DeleteOutlined />}
                            onClick={() => handleConfirmDelete(pkg)}
                            disabled={deletingId === pkg.id}
                          >
                            Remove
                          </Button>
                        </Space>
                      </Space>
                    </Card>
                  ))}
                </Space>
              )}
            </Card>
          </Col>

          <Col xs={24} lg={14}>
            <Card
              title="Offline-eligible resources"
              loading={loadingResources}
              extra={
                <Text type="secondary">
                  Eligible for bundling: {eligibleResourcesCount} resources
                </Text>
              }
            >
              {resourceList.length === 0 ? (
                <Empty description="No resources found yet." />
              ) : (
                <Table<OfflineableResource>
                  rowKey="id"
                  size="small"
                  columns={resourceColumns}
                  dataSource={resourceList}
                  pagination={{ pageSize: 8 }}
                />
              )}
            </Card>
          </Col>
        </Row>

        {/* Creation modal */}
        <Modal
          title="New offline package"
          open={isCreateModalOpen}
          onCancel={() => setIsCreateModalOpen(false)}
          destroyOnClose
          okText="Create package"
          okButtonProps={{ loading: creating }}
          onOk={() => createForm.submit()}
        >
          <Paragraph type="secondary" style={{ marginBottom: 16 }}>
            Select filters and constraints for this offline bundle. The backend
            will resolve concrete resources and schedule builds according to the
            global offline cron.
          </Paragraph>

          <Form<CreateOfflinePackagePayload>
            form={createForm}
            layout="vertical"
            onFinish={handleCreatePackage}
            initialValues={{
              targetDeviceType: 'laptop',
              maxSizeMb: 2048,
              includeTypes: ['article', 'video', 'lesson'],
            }}
          >
            <Form.Item
              label="Package name"
              name="name"
              rules={[{ required: true, message: 'Please enter a package name.' }]}
            >
              <Input placeholder="e.g. Robotics basics ‚Äì offline pack for School A" />
            </Form.Item>

            <Form.Item label="Description" name="description">
              <Input.TextArea
                rows={3}
                placeholder="Short description for administrators and field teams."
              />
            </Form.Item>

            <Form.Item label="Target device type" name="targetDeviceType">
              <Select>
                <Option value="laptop">Laptop / desktop (lab PCs)</Option>
                <Option value="tablet">Tablet devices</Option>
                <Option value="usb">USB drive / external media</Option>
                <Option value="other">Other / mixed devices</Option>
              </Select>
            </Form.Item>

            <Form.Item
              label={
                <Space>
                  Maximum bundle size (MB)
                  <Tooltip title="Helps avoid exceeding storage on low-spec devices. Backend enforces final limits.">
                    <WarningOutlined />
                  </Tooltip>
                </Space>
              }
              name="maxSizeMb"
              rules={[
                {
                  type: 'number',
                  transform: (v) => (v === '' ? undefined : Number(v)),
                  min: 0,
                  message: 'Please enter a valid size in MB.',
                },
              ]}
            >
              <Input placeholder="e.g. 2048" type="number" min={0} />
            </Form.Item>

            <Form.Item label="Include resource types" name="includeTypes">
              <Select mode="multiple" placeholder="Select one or more types">
                <Option value="article">Articles</Option>
                <Option value="video">Videos</Option>
                <Option value="lesson">Lessons</Option>
                <Option value="quiz">Quizzes</Option>
                <Option value="dataset">Datasets</Option>
              </Select>
            </Form.Item>

            <Form.Item label="Subject filter" name="subjectFilter">
              <Input placeholder="Optional subject filter, e.g. Robotics" />
            </Form.Item>

            <Form.Item label="Level filter" name="levelFilter">
              <Input placeholder="Optional level filter, e.g. Beginner" />
            </Form.Item>

            <Form.Item label="Language filter" name="languageFilter">
              <Input placeholder="Optional language filter, e.g. English" />
            </Form.Item>
          </Form>
        </Modal>
      </KonnectedPageShell>
    </>
  );
}

===== END app/konnected/learning-library/offline-content/page.tsx =====


===== BEGIN app/konnected/learning-library/recommended-resources/page.tsx =====
// app/konnected/learning-library/recommended-resources/page.tsx
'use client';

import React, { useCallback, useEffect, useMemo, useState } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/navigation';
import {
  Alert,
  Button,
  Card,
  Col,
  Empty,
  List,
  Progress,
  Row,
  Skeleton,
  Space,
  Tag,
  Typography,
  message,
} from 'antd';
import {
  ReloadOutlined,
  SettingOutlined,
  LikeOutlined,
  DislikeOutlined,
  StarFilled,
  ArrowRightOutlined,
  BookOutlined,
  FireOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text } = Typography;

type ResourceType = 'article' | 'video' | 'lesson' | 'quiz' | 'dataset';

interface KnowledgeResource {
  id: string;
  title: string;
  summary: string;
  subject?: string;
  level?: 'Beginner' | 'Intermediate' | 'Advanced';
  language?: string;
  type: ResourceType;
  tags?: string[];
  estimatedDurationMinutes?: number;
  viewerUrl?: string; // e.g. /course/[slug] or /konnected/learning-library/resource/[id]
  offlineAvailable?: boolean;
  partOfPathTitle?: string; // e.g. certification/learning-path label
}

interface LearningProgress {
  resourceId: string;
  progressPercent: number; // 0..100
  lastTouchedAt?: string;
}

type RecommendationSource = 'ml' | 'editorial' | 'trend';

interface KnowledgeRecommendationItem {
  recommendationId: string;
  score?: number;
  reason?: string;
  recommendedAt: string;
  source?: RecommendationSource;
  resource: KnowledgeResource;
  progress?: LearningProgress;
}

interface RecommendationsResponse {
  results: KnowledgeRecommendationItem[];
  count: number;
}

/**
 * Fetch personalized recommendations from backend.
 * Intended endpoint: GET /api/learn/recommendations
 * You can later move this into services/learn.ts and reuse it.
 */
async function fetchRecommendations(): Promise<RecommendationsResponse> {
  const res = await fetch('/api/learn/recommendations', {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include',
  });

  if (!res.ok) {
    throw new Error(`Failed to load recommendations (${res.status})`);
  }

  return (await res.json()) as RecommendationsResponse;
}

/**
 * Send lightweight feedback about a recommendation.
 * Intended endpoint: POST /api/learn/recommendations/feedback
 */
async function sendRecommendationFeedback(opts: {
  recommendationId: string;
  resourceId: string;
  action: 'like' | 'dislike' | 'dismiss' | 'save_for_later';
  rating?: number;
}) {
  // Fire-and-forget; errors are surfaced via message but do not break the UI.
  const res = await fetch('/api/learn/recommendations/feedback', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include',
    body: JSON.stringify(opts),
  });

  if (!res.ok) {
    throw new Error('Could not record feedback');
  }
}

export default function RecommendedResourcesPage(): JSX.Element {
  const router = useRouter();

  const [recommendations, setRecommendations] = useState<KnowledgeRecommendationItem[] | null>(
    null,
  );
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [hasOfflineFallback, setHasOfflineFallback] = useState<boolean>(false);

  const loadRecommendations = useCallback(async () => {
    setError(null);
    setLoading(true);

    try {
      const data = await fetchRecommendations();
      setRecommendations(data.results ?? []);
      setHasOfflineFallback(false);

      // Optionally cache the last successful payload for offline use.
      try {
        localStorage.setItem('konnected:recommended-resources:last', JSON.stringify(data));
      } catch {
        // ignore localStorage failures
      }
    } catch (err) {
      const msg =
        err instanceof Error ? err.message : 'Unable to load personalized recommendations.';
      setError(msg);

      // Try to recover from a cached result (offline / backend down).
      try {
        const cached = localStorage.getItem('konnected:recommended-resources:last');
        if (cached) {
          const parsed = JSON.parse(cached) as RecommendationsResponse;
          setRecommendations(parsed.results ?? []);
          setHasOfflineFallback(true);
        }
      } catch {
        // ignore cache errors
      }
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadRecommendations();
  }, [loadRecommendations]);

  const refreshSuggestions = useCallback(async () => {
    setIsRefreshing(true);
    try {
      await loadRecommendations();
    } finally {
      setIsRefreshing(false);
    }
  }, [loadRecommendations]);

  const handleOpenPreferences = useCallback(() => {
    // Placeholder for a full preferences drawer / page
    message.info('Learning preferences editor will allow tuning recommendations (coming soon).');
  }, []);

  const handleViewResource = useCallback(
    (resource: KnowledgeResource) => {
      if (resource.viewerUrl) {
        router.push(resource.viewerUrl);
      } else {
        // Fallback: keep existing pattern for now
        router.push(`/konnected/learning-library/resource/${resource.id}`);
      }
    },
    [router],
  );

  const handleGoToCatalog = useCallback(() => {
    router.push('/konnected/learning-library/browse-resources');
  }, [router]);

  const handleGoToMyLearningPath = useCallback(() => {
    router.push('/konnected/learning-paths/my-learning-path');
  }, [router]);

  const handleFeedback = useCallback(
    async (
      rec: KnowledgeRecommendationItem,
      action: 'like' | 'dislike' | 'dismiss' | 'save_for_later',
      rating?: number,
    ) => {
      // Optimistic local update for "dismiss": remove card immediately.
      if (action === 'dismiss') {
        setRecommendations(prev => prev?.filter(r => r.recommendationId !== rec.recommendationId) ?? null);
      }

      try {
        await sendRecommendationFeedback({
          recommendationId: rec.recommendationId,
          resourceId: rec.resource.id,
          action,
          rating,
        });

        if (action === 'like') {
          message.success('Thanks for your feedback.');
        } else if (action === 'dislike') {
          message.info("We'll show fewer resources like this.");
        } else if (action === 'save_for_later') {
          message.success('Saved to your list.');
        }
      } catch (err) {
        const msg =
          err instanceof Error ? err.message : 'Could not record your feedback. Please try again.';
        message.error(msg);

        // Rollback optimistic dismiss if it failed
        if (action === 'dismiss') {
          // Reload from cache/server
          loadRecommendations();
        }
      }
    },
    [loadRecommendations],
  );

  // Derive "continue your learning" items (non-complete progress entries).
  const continueItems = useMemo(
    () =>
      (recommendations ?? []).filter(
        rec =>
          rec.progress &&
          rec.progress.progressPercent > 0 &&
          rec.progress.progressPercent < 100,
      ),
    [recommendations],
  );

  // Simple KPI strip at the top.
  const kpis = useMemo(() => {
    const items = recommendations ?? [];
    const total = items.length;
    const inProgress = continueItems.length;
    const newOnly = total - inProgress;

    const totalMinutes = items.reduce(
      (sum, rec) => sum + (rec.resource.estimatedDurationMinutes ?? 0),
      0,
    );

    return {
      total,
      inProgress,
      newOnly,
      totalMinutes,
    };
  }, [recommendations, continueItems]);

  const hasAnyData = (recommendations?.length ?? 0) > 0;

  return (
    <>
      <Head>
        <title>KonnectED ‚Äì Recommended Resources</title>
      </Head>

      <KonnectedPageShell
        title="Recommended Resources"
        subtitle={
          <>
            Curated suggestions based on your activity, interests, and learning progress.{' '}
            <Text type="secondary">
              Recommendations blend your profile, subjects you engage with, and global trends.
            </Text>
          </>
        }
        primaryAction={
          <Button
            type="primary"
            icon={<SettingOutlined />}
            onClick={handleOpenPreferences}
          >
            Tune recommendations
          </Button>
        }
        secondaryActions={
          <Space>
            <Button
              icon={<ReloadOutlined />}
              onClick={refreshSuggestions}
              loading={isRefreshing}
            >
              Refresh
            </Button>
            <Button icon={<BookOutlined />} onClick={handleGoToCatalog}>
              Browse catalog
            </Button>
          </Space>
        }
      >
        {/* Error & offline notice */}
        {error && !hasAnyData && (
          <div style={{ marginBottom: 16 }}>
            <Alert
              type="error"
              message="Unable to load personalized recommendations"
              description={error}
              showIcon
            />
          </div>
        )}

        {hasOfflineFallback && (
          <div style={{ marginBottom: 16 }}>
            <Alert
              type="warning"
              showIcon
              message="Showing last known recommendations"
              description="We couldn't reach the recommendation service, so you're seeing the most recent cached suggestions."
            />
          </div>
        )}

        {/* KPI strip */}
        <Row gutter={[16, 16]} style={{ marginBottom: 24 }}>
          <Col xs={24} sm={12} md={6}>
            <Card size="small">
              <Space direction="vertical" size={4}>
                <Text type="secondary">Total suggestions</Text>
                <Text strong>{kpis.total}</Text>
              </Space>
            </Card>
          </Col>
          <Col xs={24} sm={12} md={6}>
            <Card size="small">
              <Space direction="vertical" size={4}>
                <Text type="secondary">Continue in progress</Text>
                <Text strong>{kpis.inProgress}</Text>
              </Space>
            </Card>
          </Col>
          <Col xs={24} sm={12} md={6}>
            <Card size="small">
              <Space direction="vertical" size={4}>
                <Text type="secondary">New suggestions</Text>
                <Space size={4}>
                  <FireOutlined />
                  <Text strong>{kpis.newOnly}</Text>
                </Space>
              </Space>
            </Card>
          </Col>
          <Col xs={24} sm={12} md={6}>
            <Card size="small">
              <Space direction="vertical" size={4}>
                <Text type="secondary">Total learning time (approx.)</Text>
                <Text strong>
                  {kpis.totalMinutes > 0 ? `${kpis.totalMinutes} min` : '‚Äî'}
                </Text>
              </Space>
            </Card>
          </Col>
        </Row>

        {/* "Continue your learning" section */}
        {loading && !hasAnyData ? (
          <Skeleton active paragraph={{ rows: 4 }} />
        ) : continueItems.length > 0 ? (
          <div style={{ marginBottom: 32 }}>
            <Space
              align="center"
              style={{ marginBottom: 12, justifyContent: 'space-between', width: '100%' }}
            >
              <Text strong>Continue your learning</Text>
              <Button type="link" size="small" onClick={handleGoToMyLearningPath}>
                Go to My Learning Path <ArrowRightOutlined />
              </Button>
            </Space>

            <Row gutter={[16, 16]}>
              {continueItems.map(rec => (
                <Col xs={24} sm={12} md={8} key={rec.recommendationId}>
                  <Card
                    size="small"
                    hoverable
                    onClick={() => handleViewResource(rec.resource)}
                    extra={
                      <Button
                        type="link"
                        size="small"
                        onClick={e => {
                          e.stopPropagation();
                          handleViewResource(rec.resource);
                        }}
                      >
                        Continue
                      </Button>
                    }
                    title={rec.resource.title}
                  >
                    {rec.resource.subject && (
                      <Text type="secondary">{rec.resource.subject}</Text>
                    )}
                    <div style={{ marginTop: 8 }}>
                      <Progress
                        percent={rec.progress?.progressPercent ?? 0}
                        size="small"
                        status="active"
                      />
                    </div>
                    <div style={{ marginTop: 8 }}>
                      {rec.resource.tags?.slice(0, 3).map(tag => (
                        <Tag key={tag}>{tag}</Tag>
                      ))}
                    </div>
                  </Card>
                </Col>
              ))}
            </Row>
          </div>
        ) : null}

        {/* Main recommendation grid */}
        <div style={{ marginBottom: 16 }}>
          <Text strong style={{ fontSize: 16 }}>
            Personalized suggestions
          </Text>
        </div>

        {loading && !hasAnyData ? (
          <List
            grid={{ gutter: 16, xs: 1, sm: 2, md: 2, lg: 3, xl: 3 }}
            dataSource={Array.from({ length: 6 })}
            renderItem={(_, idx) => (
              <List.Item key={idx}>
                <Card>
                  <Skeleton active paragraph={{ rows: 4 }} />
                </Card>
              </List.Item>
            )}
          />
        ) : !hasAnyData ? (
          <Card>
            <Empty
              description={
                <>
                  <div>No personalized recommendations yet.</div>
                  <Text type="secondary">
                    Start by exploring the catalog or telling us your interests.
                  </Text>
                </>
              }
            >
              <Space>
                <Button type="primary" onClick={handleGoToCatalog}>
                  Browse catalog
                </Button>
                <Button onClick={handleOpenPreferences} icon={<SettingOutlined />}>
                  Tell us your interests
                </Button>
              </Space>
            </Empty>
          </Card>
        ) : (
          <List
            grid={{ gutter: 16, xs: 1, sm: 2, md: 2, lg: 3, xl: 3 }}
            dataSource={recommendations ?? []}
            renderItem={rec => (
              <List.Item key={rec.recommendationId}>
                <Card
                  hoverable
                  title={rec.resource.title}
                  onClick={() => handleViewResource(rec.resource)}
                  extra={
                    <Button
                      type="link"
                      size="small"
                      onClick={e => {
                        e.stopPropagation();
                        handleViewResource(rec.resource);
                      }}
                    >
                      View <ArrowRightOutlined />
                    </Button>
                  }
                >
                  {/* Meta line: subject / level / type */}
                  <Space size={4} wrap style={{ marginBottom: 8 }}>
                    {rec.resource.subject && (
                      <Tag color="blue">{rec.resource.subject}</Tag>
                    )}
                    {rec.resource.level && (
                      <Tag color="geekblue">{rec.resource.level}</Tag>
                    )}
                    <Tag>{rec.resource.type}</Tag>
                    {rec.resource.language && (
                      <Tag color="default">{rec.resource.language}</Tag>
                    )}
                    {rec.resource.partOfPathTitle && (
                      <Tag color="purple">
                        <BookOutlined /> {rec.resource.partOfPathTitle}
                      </Tag>
                    )}
                    {rec.resource.offlineAvailable && (
                      <Tag color="green">Available offline</Tag>
                    )}
                  </Space>

                  {/* Summary */}
                  {rec.resource.summary && (
                    <Text style={{ display: 'block', marginBottom: 8 }}>
                      {rec.resource.summary}
                    </Text>
                  )}

                  {/* Reason / source */}
                  {rec.reason && (
                    <Text type="secondary" style={{ fontSize: 12, display: 'block' }}>
                      {rec.reason}
                    </Text>
                  )}

                  {/* Progress & score */}
                  <Space
                    style={{ marginTop: 12, width: '100%', justifyContent: 'space-between' }}
                    align="center"
                  >
                    <Space size={4} align="center">
                      {rec.progress && rec.progress.progressPercent > 0 ? (
                        <>
                          <Progress
                            percent={rec.progress.progressPercent}
                            size="small"
                            style={{ minWidth: 80 }}
                          />
                          <Text type="secondary" style={{ fontSize: 12 }}>
                            In progress
                          </Text>
                        </>
                      ) : (
                        <Text type="secondary" style={{ fontSize: 12 }}>
                          Not started yet
                        </Text>
                      )}
                    </Space>

                    {typeof rec.score === 'number' && (
                      <Space size={4} align="center">
                        <StarFilled style={{ color: '#faad14' }} />
                        <Text type="secondary" style={{ fontSize: 12 }}>
                          Relevance {(rec.score * 100).toFixed(0)}%
                        </Text>
                      </Space>
                    )}
                  </Space>

                  {/* Actions row: feedback & save */}
                  <Space
                    style={{ marginTop: 12, width: '100%', justifyContent: 'space-between' }}
                  >
                    <Space size={8}>
                      <Button
                        size="small"
                        icon={<LikeOutlined />}
                        onClick={e => {
                          e.stopPropagation();
                          handleFeedback(rec, 'like');
                        }}
                      >
                        Helpful
                      </Button>
                      <Button
                        size="small"
                        icon={<DislikeOutlined />}
                        onClick={e => {
                          e.stopPropagation();
                          handleFeedback(rec, 'dislike');
                        }}
                      >
                        Not relevant
                      </Button>
                    </Space>

                    <Space size={8}>
                      <Button
                        size="small"
                        type="link"
                        onClick={e => {
                          e.stopPropagation();
                          handleFeedback(rec, 'save_for_later');
                        }}
                      >
                        Save for later
                      </Button>
                      <Button
                        size="small"
                        type="text"
                        onClick={e => {
                          e.stopPropagation();
                          handleFeedback(rec, 'dismiss');
                        }}
                      >
                        Dismiss
                      </Button>
                    </Space>
                  </Space>
                </Card>
              </List.Item>
            )}
          />
        )}
      </KonnectedPageShell>
    </>
  );
}

===== END app/konnected/learning-library/recommended-resources/page.tsx =====


===== BEGIN app/konnected/learning-library/search-filters/page.tsx =====
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Alert,
  Button,
  Card,
  Col,
  DatePicker,
  Form,
  Input,
  Row,
  Select,
  Space,
  Table,
  Tag,
  Typography,
} from 'antd';
import type { ColumnsType, TableProps } from 'antd/es/table';
import { SearchOutlined, FilterOutlined, ReloadOutlined } from '@ant-design/icons';
import dayjs from 'dayjs';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { RangePicker } = DatePicker;
const { Text } = Typography;
const { Search } = Input;
const { Option } = Select;

// Keep in sync with backend OpenAPI for Knowledge / library_resource_management search
const KNOWLEDGE_SEARCH_ENDPOINT =
  '/api/konnected/knowledge/resources/search';

type KnowledgeContentType = 'article' | 'video' | 'lesson' | 'quiz' | 'dataset';

interface KnowledgeResource {
  id: number | string;
  title: string;
  type: KnowledgeContentType | string;
  url?: string | null;
  subject?: string | null;
  level?: string | null;
  language?: string | null;
  created_at?: string | null;
  tags?: string[] | null;
}

interface KnowledgeSearchResponse {
  count: number;
  results: KnowledgeResource[];
}

interface SearchFormValues {
  q?: string;
  types?: KnowledgeContentType[];
  subjects?: string[];
  levels?: string[];
  languages?: string[];
  createdAt?: [dayjs.Dayjs, dayjs.Dayjs];
}

interface QueryState {
  q?: string;
  types?: KnowledgeContentType[];
  subjects?: string[];
  levels?: string[];
  languages?: string[];
  created_from?: string;
  created_to?: string;
  page: number;
  page_size: number;
}

const DEFAULT_PAGE_SIZE = 10;

const CONTENT_TYPES: KnowledgeContentType[] = [
  'article',
  'video',
  'lesson',
  'quiz',
  'dataset',
];

// Seed taxonomies for now; can be driven by backend dictionaries later
const SUBJECT_OPTIONS = [
  'AI & Data',
  'Sustainability & Climate',
  'Healthcare & Wellbeing',
  'Civic Innovation',
  'Education & Skills',
  'Design & Creativity',
];

const LEVEL_OPTIONS = ['Beginner', 'Intermediate', 'Advanced'];

const LANGUAGE_OPTIONS = ['English', 'French', 'Spanish', 'Other'];

async function searchKnowledgeResources(query: QueryState): Promise<KnowledgeSearchResponse> {
  const params = new URLSearchParams();

  if (query.q) params.set('q', query.q);
  if (query.types && query.types.length > 0) {
    params.set('type', query.types.join(','));
  }
  if (query.subjects && query.subjects.length > 0) {
    params.set('subject', query.subjects.join(','));
  }
  if (query.levels && query.levels.length > 0) {
    params.set('level', query.levels.join(','));
  }
  if (query.languages && query.languages.length > 0) {
    params.set('language', query.languages.join(','));
  }
  if (query.created_from) {
    params.set('created_from', query.created_from);
  }
  if (query.created_to) {
    params.set('created_to', query.created_to);
  }

  params.set('page', String(query.page));
  params.set('page_size', String(query.page_size));

  const res = await fetch(`${KNOWLEDGE_SEARCH_ENDPOINT}?${params.toString()}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
    // Include credentials if your API relies on cookies/session
    credentials: 'include',
  });

  if (!res.ok) {
    const body = await res.text().catch(() => '');
    throw new Error(
      body || `Knowledge search failed with status ${res.status}`,
    );
  }

  const data = (await res.json()) as KnowledgeSearchResponse;
  return data;
}

export default function KonnectedKnowledgeSearchFiltersPage(): JSX.Element {
  const router = useRouter();
  const [form] = Form.useForm<SearchFormValues>();

  const [resources, setResources] = useState<KnowledgeResource[]>([]);
  const [total, setTotal] = useState<number>(0);
  const [page, setPage] = useState<number>(1);
  const [pageSize, setPageSize] = useState<number>(DEFAULT_PAGE_SIZE);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [lastQuery, setLastQuery] = useState<QueryState | null>(null);

  const columns: ColumnsType<KnowledgeResource> = useMemo(
    () => [
      {
        title: 'Title',
        dataIndex: 'title',
        key: 'title',
        render: (value, record) => {
          const href = record.url || '#';
          const isClickable = Boolean(record.url);
          return (
            <Space direction="vertical" size={0}>
              {isClickable ? (
                <a
                  href={href as string}
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  {value}
                </a>
              ) : (
                <Text strong>{value}</Text>
              )}
              <Space size="small" wrap>
                {record.subject && (
                  <Tag color="blue">{record.subject}</Tag>
                )}
                {record.level && (
                  <Tag color="purple">{record.level}</Tag>
                )}
                {record.language && (
                  <Tag color="geekblue">{record.language}</Tag>
                )}
              </Space>
            </Space>
          );
        },
      },
      {
        title: 'Type',
        dataIndex: 'type',
        key: 'type',
        width: 140,
        render: (value: KnowledgeResource['type']) => (
          <Tag>{String(value).toUpperCase()}</Tag>
        ),
      },
      {
        title: 'Tags',
        dataIndex: 'tags',
        key: 'tags',
        width: 220,
        render: (tags?: string[] | null) =>
          tags && tags.length > 0 ? (
            <Space size="small" wrap>
              {tags.map((tag) => (
                <Tag key={tag}>{tag}</Tag>
              ))}
            </Space>
          ) : (
            <Text type="secondary">No tags</Text>
          ),
      },
      {
        title: 'Added',
        dataIndex: 'created_at',
        key: 'created_at',
        width: 140,
        render: (value?: string | null) =>
          value ? dayjs(value).format('YYYY-MM-DD') : '‚Äî',
      },
      {
        title: 'Actions',
        key: 'actions',
        fixed: 'right',
        width: 160,
        render: (_: unknown, record) => (
          <Space>
            {record.url && (
              <Button
                type="link"
                size="small"
                onClick={() => {
                  window.open(record.url as string, '_blank', 'noopener');
                }}
              >
                Open
              </Button>
            )}
            <Button
              size="small"
              onClick={() =>
                router.push(
                  `/konnected/learning-library/resource/${record.id}`,
                )
              }
            >
              View details
            </Button>
          </Space>
        ),
      },
    ],
    [router],
  );

  const runSearch = async (
    overridePage?: number,
    overridePageSize?: number,
  ) => {
    const formValues = form.getFieldsValue();

    const pageToUse = overridePage ?? page;
    const pageSizeToUse = overridePageSize ?? pageSize;

    const query: QueryState = {
      q: formValues.q?.trim() || undefined,
      types: formValues.types,
      subjects: formValues.subjects,
      levels: formValues.levels,
      languages: formValues.languages,
      created_from: formValues.createdAt?.[0]
        ? formValues.createdAt[0].startOf('day').toISOString()
        : undefined,
      created_to: formValues.createdAt?.[1]
        ? formValues.createdAt[1].endOf('day').toISOString()
        : undefined,
      page: pageToUse,
      page_size: pageSizeToUse,
    };

    setLoading(true);
    setError(null);

    try {
      const response = await searchKnowledgeResources(query);
      setResources(response.results || []);
      setTotal(response.count ?? response.results.length);
      setPage(pageToUse);
      setPageSize(pageSizeToUse);
      setLastQuery(query);
    } catch (e) {
      const message =
        e instanceof Error ? e.message : 'Unexpected error during search';
      setError(message);
      setResources([]);
      setTotal(0);
    } finally {
      setLoading(false);
    }
  };

  const onFinish = () => {
    // Reset to first page when filters change
    runSearch(1, pageSize);
  };

  const handleQuickSearch = (value: string) => {
    form.setFieldsValue({ q: value });
    runSearch(1, pageSize);
  };

  const handleResetFilters = () => {
    form.resetFields();
    runSearch(1, DEFAULT_PAGE_SIZE);
  };

  const handleTableChange: TableProps<KnowledgeResource>['onChange'] = (
    pagination,
  ) => {
    const nextPage = pagination.current || 1;
    const nextPageSize = pagination.pageSize || DEFAULT_PAGE_SIZE;
    runSearch(nextPage, nextPageSize);
  };

  useEffect(() => {
    // Initial search on mount with default filters
    runSearch(1, DEFAULT_PAGE_SIZE);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const hasActiveFilters = useMemo(() => {
    const v = form.getFieldsValue();
    return Boolean(
      v.q ||
        (v.types && v.types.length > 0) ||
        (v.subjects && v.subjects.length > 0) ||
        (v.levels && v.levels.length > 0) ||
        (v.languages && v.languages.length > 0) ||
        (v.createdAt && v.createdAt.length === 2),
    );
  }, [form]);

  const secondaryActions = (
    <Space>
      <Search
        placeholder="Quick search by title or description"
        allowClear
        enterButton={<SearchOutlined />}
        onSearch={handleQuickSearch}
        style={{ width: 280 }}
      />
      <Button
        icon={<ReloadOutlined />}
        onClick={handleResetFilters}
        disabled={!hasActiveFilters && !lastQuery}
      >
        Reset filters
      </Button>
    </Space>
  );

  const primaryAction = (
    <Button
      type="primary"
      icon={<FilterOutlined />}
      onClick={() => runSearch(page, pageSize)}
    >
      Apply filters
    </Button>
  );

  return (
    <KonnectedPageShell
      title="Search the Learning Library"
      subtitle="Run advanced searches across Knowledge resources using full-text and structured filters."
      primaryAction={primaryAction}
      secondaryActions={secondaryActions}
    >
      <Card style={{ marginBottom: 16 }}>
        <Form<SearchFormValues>
          form={form}
          layout="vertical"
          onFinish={onFinish}
        >
          <Row gutter={[16, 16]}>
            <Col xs={24} md={12} lg={8}>
              <Form.Item
                label="Keywords"
                name="q"
                tooltip="Searches over title and description using the PostgreSQL full-text backend."
              >
                <Input
                  placeholder="e.g. data visualization, climate, robotics"
                  prefix={<SearchOutlined />}
                  allowClear
                />
              </Form.Item>
            </Col>

            <Col xs={24} md={12} lg={8}>
              <Form.Item
                label="Content type"
                name="types"
              >
                <Select
                  mode="multiple"
                  allowClear
                  placeholder="Select content types"
                >
                  {CONTENT_TYPES.map((t) => (
                    <Option key={t} value={t}>
                      {t.charAt(0).toUpperCase() + t.slice(1)}
                    </Option>
                  ))}
                </Select>
              </Form.Item>
            </Col>

            <Col xs={24} md={12} lg={8}>
              <Form.Item
                label="Subjects"
                name="subjects"
              >
                <Select
                  mode="multiple"
                  allowClear
                  placeholder="Filter by subject or theme"
                >
                  {SUBJECT_OPTIONS.map((s) => (
                    <Option key={s} value={s}>
                      {s}
                    </Option>
                  ))}
                </Select>
              </Form.Item>
            </Col>

            <Col xs={24} md={12} lg={8}>
              <Form.Item
                label="Level"
                name="levels"
              >
                <Select
                  mode="multiple"
                  allowClear
                  placeholder="Beginner, Intermediate, Advanced"
                >
                  {LEVEL_OPTIONS.map((l) => (
                    <Option key={l} value={l}>
                      {l}
                    </Option>
                  ))}
                </Select>
              </Form.Item>
            </Col>

            <Col xs={24} md={12} lg={8}>
              <Form.Item
                label="Language"
                name="languages"
              >
                <Select
                  mode="multiple"
                  allowClear
                  placeholder="Resource language"
                >
                  {LANGUAGE_OPTIONS.map((lang) => (
                    <Option key={lang} value={lang}>
                      {lang}
                    </Option>
                  ))}
                </Select>
              </Form.Item>
            </Col>

            <Col xs={24} md={12} lg={8}>
              <Form.Item
                label="Added to library"
                name="createdAt"
              >
                <RangePicker
                  style={{ width: '100%' }}
                  allowEmpty={[true, true]}
                />
              </Form.Item>
            </Col>
          </Row>

          <Row justify="end">
            <Col>
              <Space>
                <Button onClick={handleResetFilters}>Clear all</Button>
                <Button
                  type="primary"
                  icon={<SearchOutlined />}
                  htmlType="submit"
                >
                  Search
                </Button>
              </Space>
            </Col>
          </Row>
        </Form>
      </Card>

      {error && (
        <Alert
          type="error"
          showIcon
          message="Unable to run search"
          description={error}
          style={{ marginBottom: 16 }}
        />
      )}

      <Card>
        <Space
          direction="vertical"
          style={{ width: '100%' }}
          size="large"
        >
          <Space
            style={{ width: '100%', justifyContent: 'space-between' }}
          >
            <Text type="secondary">
              {loading
                ? 'Searching‚Ä¶'
                : `Showing ${resources.length} of ${total} result${
                    total === 1 ? '' : 's'
                  }`}
            </Text>
          </Space>

          <Table<KnowledgeResource>
            rowKey={(record) => String(record.id)}
            columns={columns}
            dataSource={resources}
            loading={loading}
            onChange={handleTableChange}
            pagination={{
              current: page,
              total,
              pageSize,
              showSizeChanger: true,
              pageSizeOptions: [10, 20, 50],
              showTotal: (t, range) =>
                `${range[0]}‚Äì${range[1]} of ${t} resources`,
            }}
            locale={{
              emptyText: loading
                ? 'Loading resources‚Ä¶'
                : 'No resources match your current filters.',
            }}
            scroll={{ x: 900 }}
            bordered
            size="middle"
          />
        </Space>
      </Card>
    </KonnectedPageShell>
  );
}

===== END app/konnected/learning-library/search-filters/page.tsx =====


===== BEGIN app/konnected/learning-paths/create-learning-path/page.tsx =====
"use client";

import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  Alert,
  Button,
  Drawer,
  Empty,
  Input,
  Select,
  Space,
  Spin,
  Table,
  Tag,
  Typography,
  message,
} from "antd";
import type { ColumnsType } from "antd/es/table";
import type { Key } from "react";
import {
  PageContainer,
  ProCard,
  ProDescriptions,
  ProFormDependency,
  ProFormInstance,
  ProFormList,
  ProFormSelect,
  ProFormText,
  ProFormTextArea,
  StepsForm,
} from "@ant-design/pro-components";
import KonnectedPageShell from "../../KonnectedPageShell";

const { Title, Paragraph } = Typography;
const { Search } = Input;

const API_BASE = process.env.NEXT_PUBLIC_API_BASE ?? "";

type LearningPathStatus = "draft" | "published";

type LearningPathStepForm = {
  title: string;
  type: "lesson" | "quiz" | "assignment";
  objective?: string;
  resourceIds?: number[];
};

type LearningPathFormValues = {
  name: string;
  description: string;
  difficulty: "Beginner" | "Intermediate" | "Advanced";
  tags?: string[];
  steps?: LearningPathStepForm[];
};

type KnowledgeResource = {
  id: number;
  title: string;
  type: "article" | "video" | "lesson" | "quiz" | "dataset";
  author?: string | null;
  subject?: string | null;
  estimated_duration_minutes?: number | null;
};

type ResourceSearchParams = {
  q?: string;
  type?: KnowledgeResource["type"] | "all";
};

type ErrorResponse = {
  detail?: string;
};

type KnowledgeResourceListResponse =
  | KnowledgeResource[]
  | {
      results?: KnowledgeResource[];
    };

const buildUrl = (path: string) => {
  if (API_BASE) return `${API_BASE}${path}`;
  return path;
};

async function createLearningPath(
  values: LearningPathFormValues,
  status: LearningPathStatus
) {
  const response = await fetch(buildUrl("/api/konnected/learning-paths/"), {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      name: values.name,
      description: values.description,
      difficulty: values.difficulty,
      tags: values.tags ?? [],
      status,
      steps: (values.steps ?? []).map((step, index) => ({
        order: index + 1,
        title: step.title,
        type: step.type,
        objective: step.objective,
        resource_ids: step.resourceIds ?? [],
      })),
    }),
  });

  if (!response.ok) {
    let detail = "Failed to save learning path.";
    try {
      const data = (await response.json()) as ErrorResponse;
      if (typeof data.detail === "string") detail = data.detail;
      // If backend returns field-level errors, you could handle them here as well.
    } catch {
      // ignore JSON parse errors
    }
    throw new Error(detail);
  }

  return response.json().catch(() => null);
}

async function fetchKnowledgeResources(
  params: ResourceSearchParams
): Promise<KnowledgeResource[]> {
  const search = new URLSearchParams();
  if (params.q) search.set("q", params.q);
  if (params.type && params.type !== "all") search.set("type", params.type);

  const response = await fetch(
    buildUrl(`/api/knowledge/resources/${search.toString() ? `?${search}` : ""}`)
  );

  if (!response.ok) {
    throw new Error("Failed to load resources.");
  }

  const data = (await response.json()) as KnowledgeResourceListResponse;

  if (Array.isArray(data)) return data as KnowledgeResource[];
  if (Array.isArray(data.results)) return data.results as KnowledgeResource[];
  return [];
}

const CONTENT_TYPE_OPTIONS: {
  label: string;
  value: ResourceSearchParams["type"];
}[] = [
  { label: "All types", value: "all" },
  { label: "Articles", value: "article" },
  { label: "Videos", value: "video" },
  { label: "Lessons", value: "lesson" },
  { label: "Quizzes", value: "quiz" },
  { label: "Datasets", value: "dataset" },
];

const difficultyOptions = [
  { label: "Beginner", value: "Beginner" },
  { label: "Intermediate", value: "Intermediate" },
  { label: "Advanced", value: "Advanced" },
];

const stepTypeOptions = [
  { label: "Lesson", value: "lesson" },
  { label: "Quiz", value: "quiz" },
  { label: "Assignment", value: "assignment" },
];

const CreateLearningPathPage: React.FC = () => {
  const formRef = useRef<ProFormInstance<LearningPathFormValues>>();
  const [submitMode, setSubmitMode] = useState<LearningPathStatus>("draft");
  const [submitting, setSubmitting] = useState(false);

  const [resourceDrawerOpen, setResourceDrawerOpen] = useState(false);
  const [resourceDrawerStepIndex, setResourceDrawerStepIndex] = useState<
    number | null
  >(null);
  const [resourceSearchParams, setResourceSearchParams] =
    useState<ResourceSearchParams>({});
  const [resourcesLoading, setResourcesLoading] = useState(false);
  const [resources, setResources] = useState<KnowledgeResource[]>([]);
  const [selectedResourceIds, setSelectedResourceIds] = useState<Key[]>([]);

  const openResourceDrawer = useCallback((stepIndex: number) => {
    setResourceDrawerStepIndex(stepIndex);

    const steps = formRef.current?.getFieldValue("steps") as
      | LearningPathStepForm[]
      | undefined;

    if (steps && steps[stepIndex]?.resourceIds?.length) {
      setSelectedResourceIds(steps[stepIndex].resourceIds as Key[]);
    } else {
      setSelectedResourceIds([]);
    }

    // Initial fetch
    setResourcesLoading(true);
    fetchKnowledgeResources({})
      .then(setResources)
      .catch((err) => {
        message.error(err.message || "Failed to load resources.");
        setResources([]);
      })
      .finally(() => setResourcesLoading(false));

    setResourceDrawerOpen(true);
  }, []);

  const closeResourceDrawer = () => {
    setResourceDrawerOpen(false);
    setResourceDrawerStepIndex(null);
  };

  const handleResourceSearch = useCallback(
    (q?: string) => {
      const nextParams: ResourceSearchParams = {
        ...resourceSearchParams,
        q: q || undefined,
      };
      setResourceSearchParams(nextParams);

      setResourcesLoading(true);
      fetchKnowledgeResources(nextParams)
        .then(setResources)
        .catch((err) => {
          message.error(err.message || "Failed to load resources.");
          setResources([]);
        })
        .finally(() => setResourcesLoading(false));
    },
    [resourceSearchParams]
  );

  const handleResourceTypeChange = (
    type: ResourceSearchParams["type"]
  ): void => {
    const nextParams: ResourceSearchParams = {
      ...resourceSearchParams,
      type,
    };
    setResourceSearchParams(nextParams);

    setResourcesLoading(true);
    fetchKnowledgeResources(nextParams)
      .then(setResources)
      .catch((err) => {
        message.error(err.message || "Failed to load resources.");
        setResources([]);
      })
      .finally(() => setResourcesLoading(false));
  };

  const handleResourceDrawerOk = () => {
    if (resourceDrawerStepIndex == null) {
      closeResourceDrawer();
      return;
    }

    const currentSteps =
      (formRef.current?.getFieldValue("steps") as LearningPathStepForm[]) ?? [];

    const updatedSteps = currentSteps.map((step, index) =>
      index === resourceDrawerStepIndex
        ? { ...step, resourceIds: selectedResourceIds as number[] }
        : step
    );

    formRef.current?.setFieldsValue({ steps: updatedSteps });
    closeResourceDrawer();
  };

  const resourceColumns: ColumnsType<KnowledgeResource> = useMemo(
    () => [
      {
        title: "Title",
        dataIndex: "title",
        key: "title",
      },
      {
        title: "Type",
        dataIndex: "type",
        key: "type",
        render: (value) => <Tag>{value}</Tag>,
      },
      {
        title: "Author",
        dataIndex: "author",
        key: "author",
        render: (value) => value || "‚Äî",
      },
      {
        title: "Subject",
        dataIndex: "subject",
        key: "subject",
        render: (value) => value || "‚Äî",
      },
      {
        title: "Estimated time",
        dataIndex: "estimated_duration_minutes",
        key: "estimated_duration_minutes",
        render: (value) => (value ? `${value} min` : "‚Äî"),
      },
    ],
    []
  );

  const handleFinish = async (values: LearningPathFormValues) => {
    // Additional client-side publish-time rules:
    if (submitMode === "published") {
      if (!values.steps || values.steps.length === 0) {
        message.error("You must add at least one step before publishing.");
        return false;
      }

      const missingResources = values.steps.some(
        (step) => !step.resourceIds || step.resourceIds.length === 0
      );
      if (missingResources) {
        message.error(
          "Each step must have at least one resource attached before publishing."
        );
        return false;
      }
    }

    setSubmitting(true);
    try {
      await createLearningPath(values, submitMode);
      message.success(
        submitMode === "published"
          ? "Learning path published."
          : "Learning path saved as draft."
      );
      return true;
    } catch (error: any) {
      message.error(error?.message || "Failed to save learning path.");
      return false;
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <KonnectedPageShell
      title="Create learning path"
      subtitle="Author a structured sequence of resources that learners can follow."
      primaryAction={null}
    >
      <PageContainer>
        <ProCard>
          <Alert
            type="info"
            showIcon
            style={{ marginBottom: 16 }}
            message="Use this wizard to define metadata, steps, and resources for a new learning path. You can save it as a draft or publish it when complete."
          />

          <StepsForm<LearningPathFormValues>
            formRef={formRef}
            onFinish={handleFinish}
            submitter={{
              render: (props) => {
                const { onSubmit, onPre } = props;
                return [
                  <Button
                    key="pre"
                    onClick={() => {
                      onPre?.();
                    }}
                  >
                    Previous
                  </Button>,
                  <Button
                    key="save-draft"
                    onClick={() => {
                      setSubmitMode("draft");
                      onSubmit?.();
                    }}
                    loading={submitting}
                  >
                    Save draft
                  </Button>,
                  <Button
                    key="publish"
                    type="primary"
                    onClick={() => {
                      setSubmitMode("published");
                      onSubmit?.();
                    }}
                    loading={submitting}
                  >
                    Publish
                  </Button>,
                ];
              },
            }}
          >
            <StepsForm.StepForm<LearningPathFormValues>
              name="basic"
              title="Basics"
            >
              <ProFormText
                name="name"
                label="Path name"
                placeholder="e.g. Web fundamentals for new team members"
                rules={[
                  { required: true, message: "Please enter a path name." },
                  {
                    min: 4,
                    message: "Name should be at least 4 characters long.",
                  },
                ]}
              />
              <ProFormTextArea
                name="description"
                label="Description"
                placeholder="Describe who this path is for and what it covers."
                fieldProps={{ autoSize: { minRows: 3, maxRows: 6 } }}
                rules={[
                  {
                    required: true,
                    message: "Please enter a description.",
                  },
                  {
                    min: 20,
                    message:
                      "Description should be at least 20 characters long.",
                  },
                ]}
              />
              <ProFormSelect
                name="difficulty"
                label="Difficulty"
                options={difficultyOptions}
                placeholder="Select difficulty level"
                rules={[
                  { required: true, message: "Please select a difficulty." },
                ]}
              />
              <ProFormSelect
                name="tags"
                label="Tags"
                mode="tags"
                placeholder="Add tags (optional)"
                fieldProps={{ tokenSeparators: [","] }}
              />
            </StepsForm.StepForm>

            <StepsForm.StepForm<LearningPathFormValues>
              name="steps"
              title="Steps"
            >
              <ProFormList
                name="steps"
                label="Path steps"
                creatorButtonProps={{
                  position: "bottom",
                  creatorButtonText: "Add step",
                }}
                rules={[
                  {
                    validator: async (_, value) => {
                      if (!value || value.length === 0) {
                        throw new Error(
                          "You must add at least one step to the path."
                        );
                      }
                    },
                  },
                ]}
              >
                {(field, index) => (
                  <ProCard
                    bordered
                    style={{ marginBottom: 8 }}
                    title={`Step ${index + 1}`}
                  >
                    <ProFormText
                      name={[field.name, "title"]}
                      label="Step title"
                      placeholder="e.g. Introduction to HTML & CSS"
                      rules={[
                        {
                          required: true,
                          message: "Please enter a step title.",
                        },
                      ]}
                    />
                    <ProFormSelect
                      name={[field.name, "type"]}
                      label="Step type"
                      options={stepTypeOptions}
                      rules={[
                        {
                          required: true,
                          message: "Please select a step type.",
                        },
                      ]}
                    />
                    <ProFormTextArea
                      name={[field.name, "objective"]}
                      label="Learning objective"
                      placeholder="What should learners be able to do after this step?"
                      fieldProps={{
                        autoSize: { minRows: 2, maxRows: 4 },
                      }}
                    />
                  </ProCard>
                )}
              </ProFormList>
            </StepsForm.StepForm>

            <StepsForm.StepForm<LearningPathFormValues>
              name="resources"
              title="Resources"
            >
              <ProFormDependency name={["steps"]}>
                {({ steps }) => {
                  const stepList = (steps as LearningPathStepForm[]) ?? [];
                  if (!stepList.length) {
                    return (
                      <Alert
                        type="warning"
                        showIcon
                        message="You need to create at least one step in the previous step before attaching resources."
                      />
                    );
                  }

                  return (
                    <>
                      <Paragraph>
                        Attach one or more library resources to each step. You
                        can still save as a draft without completing all
                        attachments, but every step must have at least one
                        resource before publishing.
                      </Paragraph>

                      <Space direction="vertical" style={{ width: "100%" }}>
                        {stepList.map((step, index) => (
                          <ProCard
                            key={index}
                            bordered
                            title={`Step ${index + 1}: ${
                              step.title || "Untitled"
                            }`}
                            extra={
                              <Button
                                onClick={() => openResourceDrawer(index)}
                                size="small"
                              >
                                Select resources
                              </Button>
                            }
                          >
                            {step.resourceIds && step.resourceIds.length > 0 ? (
                              <Space wrap>
                                {step.resourceIds.map((id) => (
                                  <Tag key={id}>{`Resource #${id}`}</Tag>
                                ))}
                              </Space>
                            ) : (
                              <Paragraph type="secondary">
                                No resources attached yet.
                              </Paragraph>
                            )}
                          </ProCard>
                        ))}
                      </Space>
                    </>
                  );
                }}
              </ProFormDependency>
            </StepsForm.StepForm>

            <StepsForm.StepForm<LearningPathFormValues>
              name="review"
              title="Review & publish"
            >
              <ProFormDependency
                name={["name", "description", "difficulty", "tags", "steps"]}
              >
                {({ name, description, difficulty, tags, steps }) => {
                  const stepList = (steps as LearningPathStepForm[]) ?? [];

                  return (
                    <Space direction="vertical" style={{ width: "100%" }}>
                      <ProDescriptions
                        column={1}
                        title="Path summary"
                        dataSource={{
                          name,
                          description,
                          difficulty,
                          tags,
                        }}
                      >
                        <ProDescriptions.Item label="Name" dataIndex="name" />
                        <ProDescriptions.Item
                          label="Description"
                          dataIndex="description"
                        />
                        <ProDescriptions.Item
                          label="Difficulty"
                          dataIndex="difficulty"
                        />
                        <ProDescriptions.Item
                          label="Tags"
                          dataIndex="tags"
                          render={(_, record) => {
                            const value = (record as {
                              tags?: string[];
                            }).tags;

                            return value && value.length ? (
                              <Space wrap>
                                {value.map((t) => (
                                  <Tag key={t}>{t}</Tag>
                                ))}
                              </Space>
                            ) : (
                              <span>‚Äî</span>
                            );
                          }}
                        />
                      </ProDescriptions>

                      <ProCard title="Steps" bordered>
                        {stepList.length === 0 ? (
                          <Paragraph type="secondary">
                            No steps defined yet.
                          </Paragraph>
                        ) : (
                          <Space direction="vertical" style={{ width: "100%" }}>
                            {stepList.map((step, index) => (
                              <ProCard
                                key={index}
                                bordered
                                title={`Step ${index + 1}: ${
                                  step.title || "Untitled"
                                }`}
                              >
                                <Paragraph>
                                  <strong>Type:</strong> {step.type}
                                </Paragraph>
                                {step.objective && (
                                  <Paragraph>
                                    <strong>Objective:</strong>{" "}
                                    {step.objective}
                                  </Paragraph>
                                )}
                                <Paragraph>
                                  <strong>Resources:</strong>{" "}
                                  {step.resourceIds &&
                                  step.resourceIds.length > 0 ? (
                                    <Space wrap>
                                      {step.resourceIds.map((id) => (
                                        <Tag key={id}>{`Resource #${id}`}</Tag>
                                      ))}
                                    </Space>
                                  ) : (
                                    <span>None</span>
                                  )}
                                </Paragraph>
                              </ProCard>
                            ))}
                          </Space>
                        )}
                      </ProCard>

                      {submitMode === "published" && (
                        <Alert
                          type="warning"
                          showIcon
                          message="Publishing will make this path visible to eligible learners. Make sure steps and resources are complete."
                        />
                      )}
                    </Space>
                  );
                }}
              </ProFormDependency>
            </StepsForm.StepForm>
          </StepsForm>
        </ProCard>
      </PageContainer>

      <Drawer
        title="Select resources"
        width={720}
        open={resourceDrawerOpen}
        onClose={closeResourceDrawer}
        destroyOnClose
        extra={
          <Space>
            <Button onClick={closeResourceDrawer}>Cancel</Button>
            <Button type="primary" onClick={handleResourceDrawerOk}>
              Attach selected
            </Button>
          </Space>
        }
      >
        <Space style={{ marginBottom: 16 }} wrap>
          <Search
            placeholder="Search resources"
            allowClear
            onSearch={(value) => handleResourceSearch(value || undefined)}
            style={{ width: 260 }}
          />
          <Select
            style={{ width: 200 }}
            defaultValue="all"
            options={CONTENT_TYPE_OPTIONS}
            onChange={(value) =>
              handleResourceTypeChange(value as ResourceSearchParams["type"])
            }
          />
        </Space>

        {resourcesLoading ? (
          <Spin />
        ) : resources.length === 0 ? (
          <Empty description="No resources found." />
        ) : (
          <Table<KnowledgeResource>
            rowKey="id"
            dataSource={resources}
            columns={resourceColumns}
            rowSelection={{
              selectedRowKeys: selectedResourceIds,
              onChange: (keys) => setSelectedResourceIds(keys),
            }}
            pagination={{ pageSize: 10 }}
          />
        )}
      </Drawer>
    </KonnectedPageShell>
  );
};

export default CreateLearningPathPage;

===== END app/konnected/learning-paths/create-learning-path/page.tsx =====


===== BEGIN app/konnected/learning-paths/manage-existing-paths/page.tsx =====
Ôªø'use client';

import React, { useRef, useState } from 'react';
import Link from 'next/link';
import type { ActionType, ProColumns } from '@ant-design/pro-components';
import { ProTable } from '@ant-design/pro-components';
import {
  Button,
  Empty,
  Form,
  Input,
  Modal,
  Select,
  Space,
  Tag,
  Typography,
  message,
} from 'antd';
import {
  DeleteOutlined,
  EditOutlined,
  PlusOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Paragraph, Text } = Typography;
const { Option } = Select;

const API_BASE = '/api/konnected/learning-paths'; // Adjust to match your backend

type LearningPathStatus = 'draft' | 'published' | 'archived';

type Difficulty = 'Beginner' | 'Intermediate' | 'Advanced';

export interface LearningPath {
  id: string | number;
  /** Display name of the path (maps to CertificationPath.name / LearningPath.title) */
  name: string;
  /** Optional long description */
  description?: string;
  /** Difficulty band for filtering in UI only (optional in backend) */
  difficulty?: Difficulty;
  /** Subject or topic grouping (STEM, Civics, etc.) */
  subject?: string;
  /** Human-friendly owner label (instructor or admin) */
  owner_name?: string;
  owner_id?: string | number;
  /** Tag labels for search/filter (optional) */
  tags?: string[];
  /** Draft / Published / Archived */
  status: LearningPathStatus;
  /** ISO timestamps (may come from DB or view) */
  created_at?: string;
  updated_at?: string;
  published_at?: string | null;
  /** Learners currently enrolled or who completed this path */
  learners_count?: number;
  /** Count of steps/modules in the path */
  modules_count?: number;
}

type TableQueryParams = {
  current?: number;
  pageSize?: number;
  status?: LearningPathStatus;
  owner?: string;
  subject?: string;
  keyword?: string;
  created_from?: string;
  created_to?: string;
};

type EditFormValues = {
  name: string;
  description?: string;
  difficulty?: Difficulty;
  subject?: string;
  status: LearningPathStatus;
};

type LearningPathListResponse = {
  results?: LearningPath[];
  items?: LearningPath[];
  count?: number;
  total?: number;
};

async function listLearningPaths(params: TableQueryParams) {
  const searchParams = new URLSearchParams();

  if (params.current) searchParams.set('page', String(params.current));
  if (params.pageSize) searchParams.set('page_size', String(params.pageSize));
  if (params.status) searchParams.set('status', params.status);
  if (params.owner) searchParams.set('owner', params.owner);
  if (params.subject) searchParams.set('subject', params.subject);
  if (params.keyword) searchParams.set('search', params.keyword);
  if (params.created_from) searchParams.set('created_from', params.created_from);
  if (params.created_to) searchParams.set('created_to', params.created_to);

  const res = await fetch(
    `${API_BASE}?${searchParams.toString()}`,
    { credentials: 'include' },
  );

  if (!res.ok) {
    throw new Error('Failed to load learning paths.');
  }

  // Support both { results, count } and { items, total } shapes
  const json = (await res.json()) as LearningPathListResponse;
  const data = (json.results ?? json.items ?? []) ?? [];
  const total = json.count ?? json.total ?? data.length;

  return { data, total };
}

async function updateLearningPath(id: string | number, payload: Partial<LearningPath>) {
  const res = await fetch(`${API_BASE}/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify(payload),
  });

  if (!res.ok) {
    throw new Error('Failed to update learning path.');
  }

  return res.json();
}

async function archiveLearningPath(id: string | number) {
  const res = await fetch(`${API_BASE}/${id}/archive`, {
    method: 'POST',
    credentials: 'include',
  });

  if (!res.ok) {
    throw new Error('Failed to archive learning path.');
  }
}

async function deleteLearningPath(id: string | number) {
  const res = await fetch(`${API_BASE}/${id}`, {
    method: 'DELETE',
    credentials: 'include',
  });

  if (!res.ok) {
    throw new Error('Failed to delete learning path.');
  }
}

function renderStatusTag(status: LearningPathStatus): React.ReactNode {
  const label =
    status === 'draft'
      ? 'Draft'
      : status === 'published'
      ? 'Published'
      : 'Archived';

  const color =
    status === 'published' ? 'green' : status === 'draft' ? 'gold' : 'default';

  return <Tag color={color}>{label}</Tag>;
}

function formatDate(iso?: string): string {
  if (!iso) return '‚Äî';
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) return '‚Äî';
  return date.toLocaleDateString();
}

export default function ManageExistingPathsPage(): JSX.Element {
  const actionRef = useRef<ActionType>();
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [editSubmitting, setEditSubmitting] = useState(false);
  const [editingPath, setEditingPath] = useState<LearningPath | null>(null);
  const [editForm] = Form.useForm<EditFormValues>();

  const openEditModal = (record: LearningPath) => {
    setEditingPath(record);
    editForm.setFieldsValue({
      name: record.name,
      description: record.description,
      difficulty: record.difficulty,
      subject: record.subject,
      status: record.status,
    });
    setEditModalOpen(true);
  };

  const handleEditSubmit = async () => {
    try {
      const values = await editForm.validateFields();
      if (!editingPath) return;

      setEditSubmitting(true);
      await updateLearningPath(editingPath.id, values);
      message.success('Learning path updated.');
      setEditModalOpen(false);
      setEditingPath(null);
      editForm.resetFields();
      actionRef.current?.reload();
    } catch (err: any) {
      // Ignore validation errors (they‚Äôre already shown by antd)
      if (err?.errorFields) return;
      message.error(err?.message || 'Failed to update learning path.');
    } finally {
      setEditSubmitting(false);
    }
  };

  const confirmArchive = (record: LearningPath) => {
    Modal.confirm({
      title: 'Archive this learning path?',
      content:
        'Learners will no longer see this path in recommendations, but historical progress may remain visible.',
      okText: 'Archive',
      onOk: async () => {
        try {
          await archiveLearningPath(record.id);
          message.success('Learning path archived.');
          actionRef.current?.reload();
        } catch (err: any) {
          message.error(err?.message || 'Failed to archive learning path.');
        }
      },
    });
  };

  const confirmDelete = (record: LearningPath) => {
    Modal.confirm({
      title: 'Delete this learning path?',
      content:
        'This action cannot be undone. If learners are still attached, prefer archiving instead of deleting.',
      okText: 'Delete',
      okButtonProps: { danger: true },
      onOk: async () => {
        try {
          await deleteLearningPath(record.id);
          message.success('Learning path deleted.');
          actionRef.current?.reload();
        } catch (err: any) {
          message.error(err?.message || 'Failed to delete learning path.');
        }
      },
    });
  };

  const columns: ProColumns<LearningPath>[] = [
    {
      title: 'Path',
      dataIndex: 'name',
      key: 'name',
      ellipsis: true,
      render: (dom, record) => (
        <Link href={`/konnected/learning-paths/manage-existing-paths/${record.id}`}>
          {dom}
        </Link>
      ),
    },
    {
      title: 'Subject',
      dataIndex: 'subject',
      key: 'subject',
      ellipsis: true,
      search: {
        transform: (value: string) => ({ subject: value }),
      },
    },
    {
      title: 'Owner',
      dataIndex: 'owner_name',
      key: 'owner_name',
      ellipsis: true,
      render: (dom) => dom ?? '‚Äî',
      search: {
        transform: (value: string) => ({ owner: value }),
      },
    },
    {
      title: 'Difficulty',
      dataIndex: 'difficulty',
      key: 'difficulty',
      valueType: 'select',
      valueEnum: {
        Beginner: { text: 'Beginner' },
        Intermediate: { text: 'Intermediate' },
        Advanced: { text: 'Advanced' },
      },
      render: (_, record) => record.difficulty || '‚Äî',
    },
    {
      title: 'Modules',
      dataIndex: 'modules_count',
      key: 'modules_count',
      width: 110,
      align: 'right',
      render: (dom) => (dom ?? '‚Äî'),
      search: false,
    },
    {
      title: 'Learners',
      dataIndex: 'learners_count',
      key: 'learners_count',
      width: 120,
      align: 'right',
      render: (dom) => (dom ?? 0),
      search: false,
    },
    {
      title: 'Created',
      dataIndex: 'created_at',
      key: 'created_at',
      valueType: 'date',
      width: 140,
      render: (_, record) => formatDate(record.created_at),
      search: false,
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      valueType: 'select',
      width: 130,
      valueEnum: {
        draft: { text: 'Draft' },
        published: { text: 'Published' },
        archived: { text: 'Archived' },
      },
      render: (_, record) => renderStatusTag(record.status),
    },
    {
      title: 'Created between',
      dataIndex: 'created_at_range',
      hideInTable: true,
      valueType: 'dateRange',
      search: {
        transform: (value: [string, string]) => ({
          created_from: value[0],
          created_to: value[1],
        }),
      },
    },
    {
      title: 'Keyword',
      dataIndex: 'keyword',
      hideInTable: true,
      renderFormItem: () => (
        <Input placeholder="Search by title, description, tags‚Ä¶" allowClear />
      ),
      search: {
        transform: (value: string) => ({ keyword: value }),
      },
    },
    {
      title: 'Actions',
      key: 'actions',
      fixed: 'right',
      width: 220,
      valueType: 'option',
      render: (_, record) => {
        const canEdit = record.status !== 'archived';
        const canArchive = record.status !== 'archived';
        const canDelete = record.status === 'draft';

        return (
          <Space size="small">
            <Button type="link" onClick={() => openEditModal(record)} disabled={!canEdit}>
              <EditOutlined /> Edit
            </Button>
            <Button
              type="link"
              onClick={() => confirmArchive(record)}
              disabled={!canArchive}
            >
              Archive
            </Button>
            <Button
              type="link"
              danger
              onClick={() => confirmDelete(record)}
              disabled={!canDelete}
            >
              <DeleteOutlined /> Delete
            </Button>
          </Space>
        );
      },
    },
  ];

  return (
    <KonnectedPageShell
      title="Manage Learning Paths"
      subtitle={
        <Paragraph style={{ marginBottom: 0 }}>
          Review, edit, archive or delete existing learning paths. Published paths
          are visible to learners and may already have active enrollments.
        </Paragraph>
      }
      primaryAction={
        <Link href="/konnected/learning-paths/create-learning-path">
          <Button type="primary" icon={<PlusOutlined />}>
            Create Path
          </Button>
        </Link>
      }
    >
      <ProTable<LearningPath, TableQueryParams>
        rowKey="id"
        actionRef={actionRef}
        columns={columns}
        pagination={{
          pageSize: 10,
          showSizeChanger: true,
          showTotal: (total) => `${total} learning paths`,
        }}
        search={{
          labelWidth: 120,
        }}
        locale={{
          emptyText: (
            <Empty description="No learning paths found.">
              <Link href="/konnected/learning-paths/create-learning-path">
                <Button type="primary" icon={<PlusOutlined />}>
                  Create New Path
                </Button>
              </Link>
            </Empty>
          ),
        }}
        toolBarRender={() => [
          <Text type="secondary" key="hint">
            Filter by owner, subject, status or date to narrow down large catalogs.
          </Text>,
        ]}
        request={async (params) => {
          try {
            const { data, total } = await listLearningPaths({
              current: params.current,
              pageSize: params.pageSize,
              status: params.status as LearningPathStatus | undefined,
              owner: params.owner as string | undefined,
              subject: params.subject as string | undefined,
              keyword: params.keyword as string | undefined,
              created_from: (params as TableQueryParams).created_from,
              created_to: (params as TableQueryParams).created_to,
            });

            return {
              data,
              total,
              success: true,
            };
          } catch (err: any) {
            message.error(err?.message || 'Failed to load learning paths.');
            return {
              data: [],
              total: 0,
              success: false,
            };
          }
        }}
      />

      <Modal
        title={
          editingPath
            ? `Edit learning path ‚Äì ${editingPath.name}`
            : 'Edit learning path'
        }
        open={editModalOpen}
        onOk={handleEditSubmit}
        confirmLoading={editSubmitting}
        onCancel={() => {
          setEditModalOpen(false);
          setEditingPath(null);
          editForm.resetFields();
        }}
        destroyOnClose
      >
        <Form<EditFormValues> form={editForm} layout="vertical">
          <Form.Item
            label="Path name"
            name="name"
            rules={[{ required: true, message: 'Please enter a path name.' }]}
          >
            <Input placeholder="e.g. Intro to Sustainability for Team Leads" />
          </Form.Item>

          <Form.Item label="Description" name="description">
            <Input.TextArea
              rows={3}
              placeholder="Short summary of who this path is for and what it covers."
            />
          </Form.Item>

          <Form.Item label="Difficulty" name="difficulty">
            <Select allowClear placeholder="Select difficulty">
              <Option value="Beginner">Beginner</Option>
              <Option value="Intermediate">Intermediate</Option>
              <Option value="Advanced">Advanced</Option>
            </Select>
          </Form.Item>

          <Form.Item label="Subject / Domain" name="subject">
            <Input placeholder="e.g. AI Ethics, Public Health, Civic Engagement" />
          </Form.Item>

          <Form.Item
            label="Status"
            name="status"
            rules={[{ required: true, message: 'Please select a status.' }]}
          >
            <Select>
              <Option value="draft">Draft</Option>
              <Option value="published">Published</Option>
              <Option value="archived">Archived</Option>
            </Select>
          </Form.Item>
        </Form>
      </Modal>
    </KonnectedPageShell>
  );
}

===== END app/konnected/learning-paths/manage-existing-paths/page.tsx =====


===== BEGIN app/konnected/learning-paths/my-learning-path/page.tsx =====
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Alert,
  Button,
  Card,
  Col,
  Empty,
  Progress,
  Row,
  Skeleton,
  Space,
  Tabs,
  Tag,
  Typography,
  message as antdMessage,
  Select,
} from 'antd';
import type { TabsProps } from 'antd';
import { ClockCircleOutlined, PlayCircleOutlined } from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text, Paragraph, Title } = Typography;
const { Option } = Select;

type LearningPathStatus = 'active' | 'completed' | 'archived';

type Level = 'Beginner' | 'Intermediate' | 'Advanced';

interface LearningPathProgress {
  completedItems: number;
  totalItems: number;
  percentage: number;
  lastActivityAt?: string;
}

interface LearningPath {
  id: string;
  title: string;
  description: string;
  level?: Level;
  tags?: string[];
  estimatedMinutes?: number;
  status: LearningPathStatus;
  progress: LearningPathProgress;
  startedAt?: string;
  completedAt?: string | null;
  // Optional link to the next resource in the path
  nextResourceHref?: string;
  nextResourceLabel?: string;
}

type TabKey = 'active' | 'completed' | 'all';
type SortKey = 'recent' | 'progress' | 'title';

/**
 * Fallback mock data so the page stays functional even without the backend.
 * Replace this with real API data once endpoints are wired.
 */
const MOCK_LEARNING_PATHS: LearningPath[] = [
  {
    id: 'lp-beginner-web',
    title: 'Beginner Web Development',
    description:
      'A structured path introducing HTML, CSS, and JavaScript fundamentals for first-time learners.',
    level: 'Beginner',
    tags: ['Web', 'Foundations', 'HTML/CSS/JS'],
    estimatedMinutes: 360,
    status: 'active',
    progress: {
      completedItems: 3,
      totalItems: 5,
      percentage: 60,
      lastActivityAt: '2025-01-05T15:30:00Z',
    },
    startedAt: '2025-01-01T09:00:00Z',
    completedAt: null,
    nextResourceHref:
      '/konnected/learning-library/browse-resources?pathId=lp-beginner-web',
    nextResourceLabel: 'Continue with CSS Layouts',
  },
  {
    id: 'lp-ai-ethics',
    title: 'AI & Ethics',
    description:
      'Explore responsible AI design, bias mitigation, and governance frameworks across industries.',
    level: 'Intermediate',
    tags: ['AI', 'Ethics', 'Governance'],
    estimatedMinutes: 420,
    status: 'active',
    progress: {
      completedItems: 1,
      totalItems: 6,
      percentage: 17,
      lastActivityAt: '2025-01-03T10:15:00Z',
    },
    startedAt: '2025-01-02T11:00:00Z',
    completedAt: null,
    nextResourceHref:
      '/konnected/learning-library/browse-resources?pathId=lp-ai-ethics',
    nextResourceLabel: 'Resume: What is Responsible AI?',
  },
  {
    id: 'lp-sustainability',
    title: 'Sustainability & Impact Projects',
    description:
      'A curated sequence of resources to design, measure, and communicate sustainability projects.',
    level: 'Advanced',
    tags: ['Sustainability', 'Impact', 'Measurement'],
    estimatedMinutes: 540,
    status: 'completed',
    progress: {
      completedItems: 8,
      totalItems: 8,
      percentage: 100,
      lastActivityAt: '2024-12-20T16:00:00Z',
    },
    startedAt: '2024-11-15T09:00:00Z',
    completedAt: '2024-12-20T16:00:00Z',
    nextResourceHref:
      '/konnected/learning-library/recommended-resources?fromPath=lp-sustainability',
    nextResourceLabel: 'Go to recommended follow-ups',
  },
];

function normalizeLearningPath(raw: any): LearningPath {
  const totalItems =
    raw?.progress?.totalItems ??
    raw?.totalItems ??
    raw?.modulesCount ??
    raw?.resourcesCount ??
    0;
  const completedItems =
    raw?.progress?.completedItems ??
    raw?.completedItems ??
    raw?.completedModules ??
    0;
  const percentage =
    raw?.progress?.percentage ??
    (totalItems > 0 ? Math.round((completedItems / totalItems) * 100) : 0);

  const status: LearningPathStatus =
    raw?.status && ['active', 'completed', 'archived'].includes(raw.status)
      ? raw.status
      : percentage === 100
      ? 'completed'
      : 'active';

  return {
    id: String(raw.id ?? raw.learning_path_id ?? raw.slug ?? crypto.randomUUID()),
    title: raw.title ?? raw.name ?? 'Untitled learning path',
    description: raw.description ?? raw.summary ?? '',
    level: raw.level as Level | undefined,
    tags: raw.tags ?? raw.tagList ?? [],
    estimatedMinutes:
      raw.estimatedMinutes ?? raw.estimated_duration_minutes ?? undefined,
    status,
    progress: {
      completedItems,
      totalItems,
      percentage,
      lastActivityAt:
        raw.progress?.lastActivityAt ??
        raw.progress?.last_activity_at ??
        raw.lastActivityAt ??
        raw.last_activity_at ??
        raw.updatedAt ??
        raw.updated_at,
    },
    startedAt: raw.startedAt ?? raw.started_at,
    completedAt: raw.completedAt ?? raw.completed_at ?? null,
    nextResourceHref:
      raw.nextResourceHref ??
      raw.next_resource_href ??
      (typeof window !== 'undefined' && raw.id
        ? `/konnected/learning-library/browse-resources?pathId=${raw.id}`
        : undefined),
    nextResourceLabel:
      raw.nextResourceLabel ??
      raw.next_resource_label ??
      undefined,
  };
}

type MyLearningPathsApiResponse = {
  items?: unknown[];
  results?: unknown[];
};

async function fetchMyLearningPaths(): Promise<LearningPath[]> {
  try {
    // Aligns with the OpenAPI "my learning paths" use-case.
    const res = await fetch('/api/konnected/learning-paths/my', {
      method: 'GET',
      cache: 'no-store',
    });

    if (!res.ok) {
      throw new Error(`Failed to load learning paths (${res.status})`);
    }

    const json = (await res.json()) as MyLearningPathsApiResponse | unknown[];

    const rawList: unknown[] = Array.isArray(json)
      ? json
      : (json.items ?? json.results ?? []);

    if (!Array.isArray(rawList) || rawList.length === 0) {
      // Fall back to mocks to keep UX rich
      return MOCK_LEARNING_PATHS;
    }

    return rawList.map((item) => normalizeLearningPath(item));
  } catch (err) {
    // Fallback to mock data; we still surface a warning in the UI.
    // eslint-disable-next-line no-console
    console.error('Error fetching learning paths', err);
    return MOCK_LEARNING_PATHS;
  }
}

export default function MyLearningPathsPage(): JSX.Element {
  const router = useRouter();

  const [paths, setPaths] = useState<LearningPath[] | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<TabKey>('active');
  const [sortKey, setSortKey] = useState<SortKey>('recent');

  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      setLoading(true);
      setError(null);

      try {
        const data = await fetchMyLearningPaths();
        if (!cancelled) {
          setPaths(data);
        }
      } catch (e: any) {
        if (!cancelled) {
          setError(
            e?.message ?? 'Unable to load your learning paths right now.',
          );
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, []);

  const handleTabChange: TabsProps['onChange'] = (key) => {
    setActiveTab(key as TabKey);
  };

  const handleSortChange = (value: SortKey) => {
    setSortKey(value);
  };

  const handleResume = (path: LearningPath) => {
    const href =
      path.nextResourceHref ??
      `/konnected/learning-library/browse-resources?pathId=${path.id}`;
    router.push(href);
  };

  const handleMarkComplete = (pathId: string) => {
    // TODO: POST /api/konnected/learning-paths/{id}/complete (OpenAPI: mark learner path as complete)
    setPaths((prev) =>
      (prev ?? []).map((p) =>
        p.id === pathId
          ? {
              ...p,
              status: 'completed',
              completedAt: new Date().toISOString(),
              progress: {
                ...p.progress,
                completedItems: p.progress.totalItems,
                percentage: 100,
              },
            }
          : p,
      ),
    );
    antdMessage.success('Learning path marked as completed.');
  };

  const handleLeavePath = (pathId: string) => {
    // TODO: POST /api/konnected/learning-paths/{id}/leave (OpenAPI: leave learning path)
    setPaths((prev) => (prev ?? []).filter((p) => p.id !== pathId));
    antdMessage.success('Learning path removed from your list.');
  };

  const handleBrowseCatalog = () => {
    router.push('/konnected/learning-library/browse-resources');
  };

  const stats = useMemo(() => {
    if (!paths || paths.length === 0) {
      return {
        total: 0,
        active: 0,
        completed: 0,
        avgCompletion: 0,
      };
    }

    const total = paths.length;
    const active = paths.filter((p) => p.status === 'active').length;
    const completed = paths.filter((p) => p.status === 'completed').length;
    const avgCompletion = Math.round(
      paths.reduce((sum, p) => sum + (p.progress?.percentage ?? 0), 0) /
        Math.max(total, 1),
    );

    return { total, active, completed, avgCompletion };
  }, [paths]);

  const filteredAndSortedPaths: LearningPath[] = useMemo(() => {
    if (!paths) return [];

    let filtered = paths;

    if (activeTab === 'active') {
      filtered = filtered.filter((p) => p.status === 'active');
    } else if (activeTab === 'completed') {
      filtered = filtered.filter((p) => p.status === 'completed');
    } else if (activeTab === 'all') {
      filtered = filtered.filter((p) => p.status !== 'archived');
    }

    const sorted = [...filtered].sort((a, b) => {
      if (sortKey === 'title') {
        return a.title.localeCompare(b.title);
      }

      if (sortKey === 'progress') {
        return (b.progress?.percentage ?? 0) - (a.progress?.percentage ?? 0);
      }

      // 'recent' (default) ‚Äì use last activity or started date
      const aDate =
        a.progress?.lastActivityAt ??
        a.completedAt ??
        a.startedAt ??
        '1970-01-01';
      const bDate =
        b.progress?.lastActivityAt ??
        b.completedAt ??
        b.startedAt ??
        '1970-01-01';
      return new Date(bDate).getTime() - new Date(aDate).getTime();
    });

    return sorted;
  }, [paths, activeTab, sortKey]);

  const hasAnyPaths = (paths?.length ?? 0) > 0;
  const activeCount =
    paths?.filter((p) => p.status === 'active').length ?? 0;
  const completedCount =
    paths?.filter((p) => p.status === 'completed').length ?? 0;

  const tabsItems: TabsProps['items'] = [
    {
      key: 'active',
      label: `Active (${activeCount})`,
    },
    {
      key: 'completed',
      label: `Completed (${completedCount})`,
    },
    {
      key: 'all',
      label: `All (${paths?.length ?? 0})`,
    },
  ];

  return (
    <KonnectedPageShell
      title="My Learning Paths"
      subtitle="Track your in-progress and completed learning paths across the KonnectED Knowledge Library."
      primaryAction={
        <Button type="primary" onClick={handleBrowseCatalog}>
          Browse new learning paths
        </Button>
      }
      secondaryActions={
        <Space>
          <Text type="secondary">Sort by</Text>
          <Select<SortKey>
            value={sortKey}
            size="small"
            style={{ width: 160 }}
            onChange={handleSortChange}
          >
            <Option value="recent">Most recent activity</Option>
            <Option value="progress">Highest completion</Option>
            <Option value="title">Title (A‚ÄìZ)</Option>
          </Select>
        </Space>
      }
    >
      {/* Top summary cards */}
      <Row gutter={[16, 16]} style={{ marginBottom: 24 }}>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Space direction="vertical" size={4}>
              <Text type="secondary">Active paths</Text>
              <Title level={3} style={{ margin: 0 }}>
                {stats.active}
              </Title>
            </Space>
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Space direction="vertical" size={4}>
              <Text type="secondary">Completed paths</Text>
              <Title level={3} style={{ margin: 0 }}>
                {stats.completed}
              </Title>
            </Space>
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Space direction="vertical" size={4}>
              <Text type="secondary">Total enrolled</Text>
              <Title level={3} style={{ margin: 0 }}>
                {stats.total}
              </Title>
            </Space>
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Space direction="vertical" size={4} style={{ width: '100%' }}>
              <Text type="secondary">Average completion</Text>
              <Progress
                percent={stats.avgCompletion}
                size="small"
                status={stats.avgCompletion === 100 ? 'success' : 'active'}
              />
            </Space>
          </Card>
        </Col>
      </Row>

      {error && (
        <Alert
          type="warning"
          showIcon
          closable
          style={{ marginBottom: 16 }}
          message="Unable to fully sync with the learning backend."
          description={
            <span>
              Showing locally cached / mock data for now. Once the
              KonnectED Learning Paths API is wired, this page will
              refresh automatically.
            </span>
          }
        />
      )}

      {/* Empty state when there is nothing at all */}
      {!loading && !hasAnyPaths && (
        <Card>
          <Empty
            description="You are not enrolled in any learning paths yet."
            image={Empty.PRESENTED_IMAGE_SIMPLE}
          >
            <Space direction="vertical">
              <Button type="primary" onClick={handleBrowseCatalog}>
                Explore the Knowledge Library
              </Button>
              <Text type="secondary">
                Browse curated learning paths or assemble your own from
                KonnectED resources.
              </Text>
            </Space>
          </Empty>
        </Card>
      )}

      {/* Tabs + list */}
      {hasAnyPaths && (
        <>
          <Tabs
            items={tabsItems}
            activeKey={activeTab}
            onChange={handleTabChange}
            style={{ marginBottom: 16 }}
          />

          {loading ? (
            <Row gutter={[16, 16]}>
              {Array.from({ length: 3 }).map((_, idx) => (
                <Col xs={24} md={12} lg={8} key={idx}>
                  <Card>
                    <Skeleton active paragraph={{ rows: 4 }} />
                  </Card>
                </Col>
              ))}
            </Row>
          ) : filteredAndSortedPaths.length === 0 ? (
            <Card>
              <Empty
                description={
                  activeTab === 'active'
                    ? 'No active learning paths in this view.'
                    : activeTab === 'completed'
                    ? 'You have not completed any learning paths yet.'
                    : 'No learning paths match the current filters.'
                }
              >
                {activeTab === 'active' && completedCount > 0 && (
                  <Text type="secondary">
                    You do have completed paths ‚Äì switch to the
                    &quot;Completed&quot; tab to review them.
                  </Text>
                )}
                {activeTab === 'completed' && activeCount > 0 && (
                  <Text type="secondary">
                    You still have active paths in progress ‚Äì check the
                    &quot;Active&quot; tab to resume.
                  </Text>
                )}
                {stats.total === 0 && (
                  <Space direction="vertical" style={{ marginTop: 8 }}>
                    <Button type="primary" onClick={handleBrowseCatalog}>
                      Explore the Knowledge Library
                    </Button>
                  </Space>
                )}
              </Empty>
            </Card>
          ) : (
            <Row gutter={[16, 16]}>
              {filteredAndSortedPaths.map((path) => {
                const minutes = path.estimatedMinutes ?? 0;
                const hours = minutes / 60;
                const isCompleted = path.status === 'completed';
                const progress = path.progress?.percentage ?? 0;

                return (
                  <Col xs={24} md={12} lg={8} key={path.id}>
                    <Card
                      hoverable
                      title={
                        <Space>
                          <span>{path.title}</span>
                          {path.level && (
                            <Tag color="blue">{path.level}</Tag>
                          )}
                          {isCompleted && (
                            <Tag color="green">Completed</Tag>
                          )}
                        </Space>
                      }
                      extra={
                        path.progress?.lastActivityAt ? (
                          <Space size={4}>
                            <ClockCircleOutlined />
                            <Text type="secondary">
                              Last activity{' '}
                              {new Date(
                                path.progress.lastActivityAt,
                              ).toLocaleDateString()}
                            </Text>
                          </Space>
                        ) : null
                      }
                      actions={[
                        <Button
                          key="resume"
                          type="primary"
                          icon={<PlayCircleOutlined />}
                          onClick={() => handleResume(path)}
                        >
                          {isCompleted ? 'Review path' : 'Resume'}
                        </Button>,
                        !isCompleted && (
                          <Button
                            key="complete"
                            type="default"
                            onClick={() => handleMarkComplete(path.id)}
                          >
                            Mark complete
                          </Button>
                        ),
                        <Button
                          key="leave"
                          type="link"
                          danger
                          onClick={() => handleLeavePath(path.id)}
                        >
                          Leave path
                        </Button>,
                      ].filter(Boolean)}
                    >
                      <Space
                        direction="vertical"
                        size="small"
                        style={{ width: '100%' }}
                      >
                        {path.description && (
                          <Paragraph
                            type="secondary"
                            ellipsis={{ rows: 3 }}
                            style={{ marginBottom: 8 }}
                          >
                            {path.description}
                          </Paragraph>
                        )}

                        {path.tags && path.tags.length > 0 && (
                          <Space wrap style={{ marginBottom: 4 }}>
                            {path.tags.map((tag) => (
                              <Tag key={tag}>{tag}</Tag>
                            ))}
                          </Space>
                        )}

                        <Space
                          direction="vertical"
                          style={{ width: '100%', marginTop: 4 }}
                        >
                          <Space
                            align="center"
                            style={{
                              width: '100%',
                              justifyContent: 'space-between',
                            }}
                          >
                            <Text type="secondary">
                              {path.progress?.completedItems ?? 0} of{' '}
                              {path.progress?.totalItems ?? 0} items
                              completed
                            </Text>
                            {minutes > 0 && (
                              <Text type="secondary">
                                ~
                                {hours >= 1
                                  ? `${hours.toFixed(1)} h`
                                  : `${minutes} min`}{' '}
                                total
                              </Text>
                            )}
                          </Space>
                          <Progress
                            percent={progress}
                            status={isCompleted ? 'success' : 'active'}
                            size="small"
                          />
                        </Space>
                      </Space>
                    </Card>
                  </Col>
                );
              })}
            </Row>
          )}
        </>
      )}
    </KonnectedPageShell>
  );
}

===== END app/konnected/learning-paths/my-learning-path/page.tsx =====


===== BEGIN app/konnected/teams-collaboration/activity-planner/page.tsx =====
// app/konnected/teams-collaboration/activity-planner/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import type { CalendarProps } from 'antd';
import {
  Calendar,
  Modal,
  Form,
  DatePicker,
  TimePicker,
  Input,
  Button,
  List,
  Select,
  Typography,
  Row,
  Col,
  Card,
  Tag,
  Divider,
  message,
} from 'antd';
import { PlusOutlined } from '@ant-design/icons';
import dayjs, { Dayjs } from 'dayjs';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Title, Text, Paragraph } = Typography;

/** Domain types */
type ActivityType = 'Workshop' | 'Check-in' | 'Live Session' | 'Async Sprint';

interface ActivityEvent {
  id: string;
  title: string;
  description: string;
  /** Stored as Dayjs (AntD v5 default) */
  dateTime: Dayjs;
  owner: string;
  team: string;
  activityType?: ActivityType;
  /** Optional linkage to other KonnectED sub-modules */
  linkedLearningPathLabel?: string;
  linkedResourceLabel?: string;
}

interface ActivityFormValues {
  eventTitle: string;
  eventDescription?: string;
  eventDate?: Dayjs | null;
  eventTime?: Dayjs | null;
  team?: string;
  owner?: string;
  activityType?: ActivityType;
  linkedLearningPathLabel?: string;
  linkedResourceLabel?: string;
}

/** Team list for filter and form */
const teamOptions = ['All', 'Alpha Innovators', 'Beta Coders', 'Gamma Team'] as const;

/** Activity type options (team learning & collaboration) */
const ACTIVITY_TYPE_OPTIONS: ActivityType[] = [
  'Workshop',
  'Check-in',
  'Live Session',
  'Async Sprint',
];

/** Some sample learning paths / resources labels (UI-only for now) */
const LEARNING_PATH_OPTIONS = [
  'Onboarding to KonnectED',
  'AI Literacy Starter',
  'Leadership Essentials',
];

const RESOURCE_OPTIONS = [
  'Knowledge: ‚ÄúIntro to Robotics‚Äù',
  'Knowledge: ‚ÄúImpact Evaluation Basics‚Äù',
  'Knowledge: ‚ÄúTeam Collaboration Best Practices‚Äù',
];

export default function ActivityPlannerPage(): JSX.Element {
  /** Initial mocked events ‚Äì replace with API data later */
  const [events, setEvents] = useState<ActivityEvent[]>([
    {
      id: 'evt1',
      title: 'Team Onboarding Workshop',
      description:
        'Kick-off session for new members, reviewing our current learning path and workspace norms.',
      dateTime: dayjs().add(2, 'day').hour(10).minute(0),
      owner: 'Alice',
      team: 'Alpha Innovators',
      activityType: 'Workshop',
      linkedLearningPathLabel: 'Onboarding to KonnectED',
    },
    {
      id: 'evt2',
      title: 'Sprint Learning Check-in',
      description:
        'Short sync on what we learned this sprint and which resources to bookmark in Knowledge.',
      dateTime: dayjs().add(4, 'day').hour(9).minute(30),
      owner: 'Bob',
      team: 'Beta Coders',
      activityType: 'Check-in',
      linkedResourceLabel: 'Knowledge: ‚ÄúTeam Collaboration Best Practices‚Äù',
    },
  ]);

  const [selectedTeam, setSelectedTeam] = useState<string>('All');
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [preSelectedDate, setPreSelectedDate] = useState<Dayjs | null>(null);

  const [form] = Form.useForm<ActivityFormValues>();

  /** Filtering by team */
  const filteredEvents = useMemo(
    () =>
      selectedTeam === 'All'
        ? events
        : events.filter((evt) => evt.team === selectedTeam),
    [events, selectedTeam],
  );

  /** Upcoming list, sorted by date/time */
  const upcomingEvents = useMemo(
    () =>
      [...filteredEvents]
        .filter((evt) => evt.dateTime.isAfter(dayjs().subtract(1, 'day')))
        .sort((a, b) => a.dateTime.valueOf() - b.dateTime.valueOf()),
    [filteredEvents],
  );

  /** AntD v5: use `cellRender` for date cells to show small markers */
  const cellRender: CalendarProps<Dayjs>['cellRender'] = (value, info) => {
    if (info.type !== 'date') return info.originNode;
    const listData = events.filter((evt) => evt.dateTime.isSame(value, 'day'));
    if (!listData.length) return info.originNode;

    return (
      <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
        {listData.slice(0, 3).map((item) => (
          <li key={item.id} style={{ marginBottom: 2 }}>
            <Text style={{ fontSize: 10 }} ellipsis>
              {item.title}
            </Text>
          </li>
        ))}
        {listData.length > 3 && (
          <li>
            <Text type="secondary" style={{ fontSize: 10 }}>
              +{listData.length - 3} more
            </Text>
          </li>
        )}
      </ul>
    );
  };

  /** Calendar selection uses Dayjs in AntD v5 */
  const handleDateSelect = (value: Dayjs) => {
    setPreSelectedDate(value);
    // preset only the date; time stays empty until user picks it
    form.setFieldsValue({ eventDate: value });
    setModalVisible(true);
  };

  /** Add new activity (currently client-side only) */
  const handleAddEvent = (values: ActivityFormValues) => {
    if (!values.eventDate || !values.eventTime || !values.team || !values.owner) {
      message.error('Please fill in all required fields.');
      return;
    }

    const mergedDateTime = values.eventDate
      .hour(values.eventTime.hour())
      .minute(values.eventTime.minute());

    const newEvent: ActivityEvent = {
      id: `evt-${Date.now()}`,
      title: values.eventTitle,
      description: values.eventDescription ?? '',
      dateTime: mergedDateTime,
      owner: values.owner,
      team: values.team,
      activityType: values.activityType,
      linkedLearningPathLabel: values.linkedLearningPathLabel,
      linkedResourceLabel: values.linkedResourceLabel,
    };

    setEvents((prev) => [...prev, newEvent]);
    setModalVisible(false);
    form.resetFields();
    setPreSelectedDate(null);
    message.success('Activity added to the team calendar.');
  };

  const handleDeleteEvent = (id: string) => {
    setEvents((prev) => prev.filter((evt) => evt.id !== id));
    message.success('Activity removed.');
  };

  const handleOpenModalEmpty = () => {
    setPreSelectedDate(null);
    form.resetFields();
    setModalVisible(true);
  };

  const modalTitle = preSelectedDate
    ? `Add Activity on ${preSelectedDate.format('YYYY-MM-DD')}`
    : 'Add New Activity';

  return (
    <KonnectedPageShell
      title="Activity Planner"
      subtitle={
        <span>
          Plan team learning sessions, workshops, and collaborative check-ins, and optionally link
          them to Learning Paths or Knowledge resources.
        </span>
      }
      primaryAction={
        <Button type="primary" icon={<PlusOutlined />} onClick={handleOpenModalEmpty}>
          Add Activity
        </Button>
      }
      secondaryActions={
        <Select
          value={selectedTeam}
          style={{ minWidth: 180 }}
          onChange={setSelectedTeam}
          options={teamOptions.map((t) => ({ label: t, value: t }))}
        />
      }
    >
      <Row gutter={[24, 24]}>
        <Col xs={24} lg={16}>
          <Card
            title="Team Activity Calendar"
            extra={
              <Text type="secondary">
                Click a date to schedule a new session for a team.
              </Text>
            }
            bordered
          >
            <Calendar
              fullscreen
              onSelect={handleDateSelect}
              cellRender={cellRender}
            />
          </Card>
        </Col>

        <Col xs={24} lg={8}>
          <Card bordered>
            <Title level={4} style={{ marginBottom: 8 }}>
              Upcoming Activities
            </Title>
            <Paragraph type="secondary" style={{ marginBottom: 16 }}>
              Showing activities for{' '}
              <Text strong>{selectedTeam === 'All' ? 'all teams' : selectedTeam}</Text>.
            </Paragraph>

            <List
              size="small"
              dataSource={upcomingEvents}
              locale={{
                emptyText: 'No planned activities yet. Use ‚ÄúAdd Activity‚Äù to get started.',
              }}
              renderItem={(item) => (
                <List.Item
                  key={item.id}
                  actions={[
                    <Button
                      key="delete"
                      danger
                      size="small"
                      onClick={() => handleDeleteEvent(item.id)}
                    >
                      Delete
                    </Button>,
                  ]}
                >
                  <List.Item.Meta
                    title={
                      <span>
                        {item.title}{' '}
                        {item.activityType && <Tag color="blue">{item.activityType}</Tag>}
                      </span>
                    }
                    description={
                      <div>
                        <div>
                          <Text strong>
                            {item.dateTime.format('YYYY-MM-DD HH:mm')}
                          </Text>
                        </div>
                        <div>
                          <Text type="secondary">
                            Team: {item.team} ‚Ä¢ Owner: {item.owner}
                          </Text>
                        </div>
                        {(item.linkedLearningPathLabel || item.linkedResourceLabel) && (
                          <div style={{ marginTop: 4 }}>
                            {item.linkedLearningPathLabel && (
                              <Tag color="green">
                                Path: {item.linkedLearningPathLabel}
                              </Tag>
                            )}
                            {item.linkedResourceLabel && (
                              <Tag color="purple">
                                Resource: {item.linkedResourceLabel}
                              </Tag>
                            )}
                          </div>
                        )}
                        {item.description && (
                          <div style={{ marginTop: 4 }}>
                            <Text>{item.description}</Text>
                          </div>
                        )}
                      </div>
                    }
                  />
                </List.Item>
              )}
            />

            <Divider />

            <Text type="secondary">
              Tip: You can later wire this planner to real team data, Learning Paths, and Knowledge
              resources so that attendance and completion stats feed into analytics.
            </Text>
          </Card>
        </Col>
      </Row>

      <Modal
        title={modalTitle}
        open={modalVisible}
        onCancel={() => {
          setModalVisible(false);
          form.resetFields();
          setPreSelectedDate(null);
        }}
        footer={null}
        destroyOnClose
      >
        <Form<ActivityFormValues> form={form} layout="vertical" onFinish={handleAddEvent}>
          <Form.Item
            label="Activity Title"
            name="eventTitle"
            rules={[{ required: true, message: 'Please enter the activity title.' }]}
          >
            <Input placeholder="e.g. Sprint Learning Check-in" />
          </Form.Item>

          <Form.Item label="Description" name="eventDescription">
            <Input.TextArea
              rows={3}
              placeholder="What is the team expected to do or learn during this activity?"
            />
          </Form.Item>

          <Row gutter={12}>
            <Col span={12}>
              <Form.Item
                label="Date"
                name="eventDate"
                rules={[{ required: true, message: 'Please select a date.' }]}
              >
                <DatePicker style={{ width: '100%' }} />
              </Form.Item>
            </Col>
            <Col span={12}>
              <Form.Item
                label="Time"
                name="eventTime"
                rules={[{ required: true, message: 'Please select a time.' }]}
              >
                <TimePicker style={{ width: '100%' }} format="HH:mm" />
              </Form.Item>
            </Col>
          </Row>

          <Form.Item
            label="Team"
            name="team"
            rules={[{ required: true, message: 'Please select a team.' }]}
            initialValue={teamOptions[1]}
          >
            <Select
              options={teamOptions
                .filter((t) => t !== 'All')
                .map((t) => ({ value: t, label: t }))}
            />
          </Form.Item>

          <Form.Item label="Activity Type" name="activityType">
            <Select
              placeholder="Select an activity type"
              allowClear
              options={ACTIVITY_TYPE_OPTIONS.map((t) => ({ label: t, value: t }))}
            />
          </Form.Item>

          <Form.Item
            label="Owner"
            name="owner"
            rules={[{ required: true, message: 'Please enter the owner.' }]}
          >
            <Input placeholder="e.g. Team lead or facilitator name" />
          </Form.Item>

          <Form.Item label="Linked Learning Path (optional)" name="linkedLearningPathLabel">
            <Select
              placeholder="Link to a Learning Path"
              allowClear
              options={LEARNING_PATH_OPTIONS.map((label) => ({ label, value: label }))}
            />
          </Form.Item>

          <Form.Item label="Linked Knowledge Resource (optional)" name="linkedResourceLabel">
            <Select
              placeholder="Link to a Knowledge resource"
              allowClear
              options={RESOURCE_OPTIONS.map((label) => ({ label, value: label }))}
            />
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" block icon={<PlusOutlined />}>
              Add Activity
            </Button>
          </Form.Item>
        </Form>
      </Modal>
    </KonnectedPageShell>
  );
}

===== END app/konnected/teams-collaboration/activity-planner/page.tsx =====


===== BEGIN app/konnected/teams-collaboration/my-teams/page.tsx =====
Ôªø// C:\MyCode\Konnaxionv14\frontend\app\konnected\teams-collaboration\my-teams\page.tsx
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Avatar,
  Alert,
  Button,
  Col,
  Dropdown,
  Empty,
  Input,
  List,
  MenuProps,
  Row,
  Select,
  Space,
  Switch,
  Table,
  Tag,
  Typography,
  message as antdMessage,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import type { TableProps } from 'antd';
import {
  DownOutlined,
  TeamOutlined,
  UsergroupAddOutlined,
  PlusOutlined,
  ProjectOutlined,
  CalendarOutlined,
} from '@ant-design/icons';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Text, Paragraph } = Typography;
const { Search } = Input;
const { Option } = Select;

type TeamRole = 'owner' | 'admin' | 'member' | 'observer';
type MembershipStatus = 'active' | 'invited' | 'request_pending';

interface TeamMember {
  id: string;
  name: string;
  role: string;
}

interface MyTeamsApiTeam {
  id: string;
  name: string;
  project_title?: string | null;
  membership_role: TeamRole;
  membership_status?: MembershipStatus;
  members_count?: number;
  is_restricted?: boolean;
  recent_activity?: string[];
  members_preview?: TeamMember[];
}

interface TeamRow {
  key: string;
  teamId: string;
  teamName: string;
  projectName: string;
  userRole: TeamRole;
  membershipStatus: MembershipStatus;
  membersCount: number;
  isRestricted: boolean;
  roster: TeamMember[];
  recentActivity: string[];
}

const MY_TEAMS_ENDPOINT = '/api/konnected/teams/my-teams';
const LEAVE_TEAM_ENDPOINT = (teamId: string) =>
  `/api/konnected/teams/${encodeURIComponent(teamId)}/leave`;

function mapToRows(payload: unknown): TeamRow[] {
  const rawItems: MyTeamsApiTeam[] = Array.isArray(payload)
    ? (payload as MyTeamsApiTeam[])
    : (payload as { items?: MyTeamsApiTeam[] })?.items ?? [];

  return rawItems.map((t) => {
    const roster =
      t.members_preview ??
      ([] as TeamMember[]);

    return {
      key: t.id,
      teamId: t.id,
      teamName: t.name,
      projectName: t.project_title ?? '‚Äî',
      userRole: t.membership_role,
      membershipStatus: t.membership_status ?? 'active',
      membersCount: t.members_count ?? roster.length,
      isRestricted: Boolean(t.is_restricted),
      roster,
      recentActivity: t.recent_activity ?? [],
    };
  });
}

export default function MyTeamsPage(): JSX.Element {
  const router = useRouter();

  const [loading, setLoading] = useState<boolean>(true);
  const [reloadFlag, setReloadFlag] = useState<number>(0);
  const [error, setError] = useState<string | null>(null);

  const [selectedTeamKeys, setSelectedTeamKeys] = useState<React.Key[]>([]);
  const [data, setData] = useState<TeamRow[]>([]);

  const [searchText, setSearchText] = useState('');
  const [roleFilter, setRoleFilter] = useState<'all' | TeamRole>('all');
  const [statusFilter, setStatusFilter] =
    useState<'all' | MembershipStatus>('all');
  const [restrictedOnly, setRestrictedOnly] = useState(false);

  const [leavingTeamId, setLeavingTeamId] = useState<string | null>(null);

  useEffect(() => {
    let cancelled = false;

    async function loadTeams() {
      setLoading(true);
      setError(null);
      try {
        const res = await fetch(MY_TEAMS_ENDPOINT, {
          credentials: 'include',
        });

        if (!res.ok) {
          throw new Error(
            `Failed to load teams (${res.status} ${res.statusText})`,
          );
        }

        const json = await res.json();
        if (!cancelled) {
          const rows = mapToRows(json);
          setData(rows);
        }
      } catch (err) {
        if (!cancelled) {
          setError(
            err instanceof Error ? err.message : 'Unknown error while loading teams.',
          );
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }

    loadTeams();

    return () => {
      cancelled = true;
    };
  }, [reloadFlag]);

  const handleLeaveTeam = async (team: TeamRow) => {
    if (team.userRole === 'owner') {
      antdMessage.warning(
        'You are the owner of this team. Transfer ownership before leaving.',
      );
      return;
    }

    setLeavingTeamId(team.teamId);
    try {
      const res = await fetch(LEAVE_TEAM_ENDPOINT(team.teamId), {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!res.ok) {
        throw new Error(
          `Failed to leave team (${res.status} ${res.statusText})`,
        );
      }

      antdMessage.success(`You left ${team.teamName}.`);
      setData((prev) => prev.filter((row) => row.teamId !== team.teamId));
      setSelectedTeamKeys((prev) =>
        prev.filter((key) => key !== team.key),
      );
    } catch (err) {
      antdMessage.error(
        err instanceof Error
          ? err.message
          : 'Could not leave the team. Please try again.',
      );
    } finally {
      setLeavingTeamId(null);
    }
  };

  const handleViewTeam = (team: TeamRow) => {
    router.push(
      `/konnected/teams-collaboration/my-teams/${encodeURIComponent(team.teamId)}`,
    );
  };

  const handleInviteMembers = (team: TeamRow) => {
    router.push(
      `/konnected/teams-collaboration/team-builder?teamId=${encodeURIComponent(
        team.teamId,
      )}&mode=invite`,
    );
  };

  const filteredData = useMemo(() => {
    return data.filter((row) => {
      if (searchText) {
        const q = searchText.toLowerCase();
        const matchesName =
          row.teamName.toLowerCase().includes(q) ||
          row.projectName.toLowerCase().includes(q);
        if (!matchesName) return false;
      }

      if (roleFilter !== 'all' && row.userRole !== roleFilter) {
        return false;
      }

      if (statusFilter !== 'all' && row.membershipStatus !== statusFilter) {
        return false;
      }

      if (restrictedOnly && !row.isRestricted) {
        return false;
      }

      return true;
    });
  }, [data, searchText, roleFilter, statusFilter, restrictedOnly]);

  const sortedData = useMemo(
    () => [...filteredData].sort((a, b) => a.teamName.localeCompare(b.teamName)),
    [filteredData],
  );

  const totalTeams = data.length;
  const ownerAdminCount = data.filter(
    (t) => t.userRole === 'owner' || t.userRole === 'admin',
  ).length;
  const restrictedCount = data.filter((t) => t.isRestricted).length;

  const rowSelection: TableProps<TeamRow>['rowSelection'] = {
    selectedRowKeys: selectedTeamKeys,
    onChange: (keys) => setSelectedTeamKeys(keys as React.Key[]),
  };

  const columns: ColumnsType<TeamRow> = [
    {
      title: 'Team',
      dataIndex: 'teamName',
      key: 'teamName',
      render: (value: string, record) => (
        <Space direction="vertical" size={0}>
          <Text strong>{value}</Text>
          <Text type="secondary">ID: {record.teamId}</Text>
        </Space>
      ),
    },
    {
      title: 'Project',
      dataIndex: 'projectName',
      key: 'projectName',
      ellipsis: true,
      render: (value: string) => <Text>{value}</Text>,
    },
    {
      title: 'My role',
      dataIndex: 'userRole',
      key: 'userRole',
      width: 140,
      render: (role: TeamRole) => {
        let color: string | undefined;
        switch (role) {
          case 'owner':
            color = 'gold';
            break;
          case 'admin':
            color = 'blue';
            break;
          case 'member':
            color = 'green';
            break;
          case 'observer':
            color = 'default';
            break;
          default:
            color = 'default';
        }
        return <Tag color={color}>{role}</Tag>;
      },
    },
    {
      title: 'Members',
      dataIndex: 'roster',
      key: 'roster',
      width: 260,
      render: (_: TeamMember[], record) => {
        const preview = record.roster.slice(0, 3);
        return preview.length ? (
          <List
            dataSource={preview}
            renderItem={(m: TeamMember) => (
              <List.Item style={{ paddingInline: 0 }} key={m.id}>
                <List.Item.Meta
                  avatar={<Avatar>{m.name.charAt(0)}</Avatar>}
                  title={<Text>{m.name}</Text>}
                  description={<Text type="secondary">{m.role}</Text>}
                />
              </List.Item>
            )}
          />
        ) : (
          <Text type="secondary">Members not loaded</Text>
        );
      },
    },
    {
      title: 'Recent activity',
      dataIndex: 'recentActivity',
      key: 'recentActivity',
      width: 260,
      render: (activities: string[]) =>
        activities.length ? (
          <List
            size="small"
            dataSource={activities.slice(0, 3)}
            renderItem={(msg) => (
              <List.Item style={{ paddingInline: 0 }}>{msg}</List.Item>
            )}
          />
        ) : (
          <Text type="secondary">No recent activity</Text>
        ),
      responsive: ['lg'],
    },
    {
      title: 'Status',
      dataIndex: 'membershipStatus',
      key: 'membershipStatus',
      width: 140,
      render: (status: MembershipStatus) => {
        switch (status) {
          case 'active':
            return <Tag color="green">Active</Tag>;
          case 'invited':
            return <Tag color="blue">Invitation</Tag>;
          case 'request_pending':
            return <Tag color="orange">Request pending</Tag>;
          default:
            return <Tag>Unknown</Tag>;
        }
      },
    },
    {
      title: 'Access',
      dataIndex: 'isRestricted',
      key: 'isRestricted',
      width: 120,
      render: (isRestricted: boolean) =>
        isRestricted ? (
          <Tag color="volcano">Restricted</Tag>
        ) : (
          <Tag color="default">Open</Tag>
        ),
      responsive: ['md'],
    },
    {
      title: 'Actions',
      key: 'actions',
      fixed: 'right',
      width: 160,
      render: (_: unknown, record) => {
        const items: MenuProps['items'] = [
          { key: 'view', label: 'Open team' },
          { key: 'invite', label: 'Invite members' },
          { type: 'divider' },
          {
            key: 'leave',
            danger: true,
            label: 'Leave team',
          },
        ];

        const onMenuClick: MenuProps['onClick'] = ({ key }) => {
          switch (key) {
            case 'view':
              handleViewTeam(record);
              break;
            case 'invite':
              handleInviteMembers(record);
              break;
            case 'leave':
              void handleLeaveTeam(record);
              break;
            default:
              break;
          }
        };

        const isLeaving = leavingTeamId === record.teamId;

        return (
          <Dropdown
            menu={{ items, onClick: onMenuClick }}
            trigger={['click']}
            disabled={isLeaving}
          >
            <Button loading={isLeaving}>
              Actions <DownOutlined />
            </Button>
          </Dropdown>
        );
      },
    },
  ];

  const headerSecondaryActions = (
    <Space>
      <Button
        icon={<ProjectOutlined />}
        onClick={() =>
          router.push('/konnected/teams-collaboration/project-workspaces')
        }
      >
        Project workspaces
      </Button>
      <Button
        icon={<CalendarOutlined />}
        onClick={() =>
          router.push('/konnected/teams-collaboration/activity-planner')
        }
      >
        Activity planner
      </Button>
    </Space>
  );

  const headerPrimaryAction = (
    <Button
      type="primary"
      icon={<PlusOutlined />}
      onClick={() =>
        router.push('/konnected/teams-collaboration/team-builder')
      }
    >
      Create or join a team
    </Button>
  );

  return (
    <KonnectedPageShell
      title="My Teams"
      subtitle={
        <span>
          Manage the collaboration teams you are part of in KonnectED. View
          membership, recent activity, and jump into workspaces.
        </span>
      }
      primaryAction={headerPrimaryAction}
      secondaryActions={headerSecondaryActions}
    >
      <Row gutter={[16, 16]} style={{ marginBottom: 16 }}>
        <Col xs={24} sm={8}>
          <Space direction="vertical" size={0}>
            <Text type="secondary">Total teams</Text>
            <Text strong>
              <TeamOutlined style={{ marginRight: 4 }} />
              {totalTeams}
            </Text>
          </Space>
        </Col>
        <Col xs={24} sm={8}>
          <Space direction="vertical" size={0}>
            <Text type="secondary">Teams you own/admin</Text>
            <Text strong>{ownerAdminCount}</Text>
          </Space>
        </Col>
        <Col xs={24} sm={8}>
          <Space direction="vertical" size={0}>
            <Text type="secondary">Restricted teams</Text>
            <Text strong>{restrictedCount}</Text>
          </Space>
        </Col>
      </Row>

      <Row gutter={[16, 16]} style={{ marginBottom: 16 }}>
        <Col xs={24} md={10}>
          <Search
            placeholder="Search by team or project name"
            allowClear
            value={searchText}
            onChange={(e) => setSearchText(e.target.value)}
            onSearch={(value) => setSearchText(value)}
          />
        </Col>
        <Col xs={12} md={6}>
          <Select<'all' | TeamRole>
            style={{ width: '100%' }}
            value={roleFilter}
            onChange={(val) => setRoleFilter(val)}
          >
            <Option value="all">All roles</Option>
            <Option value="owner">Owner</Option>
            <Option value="admin">Admin</Option>
            <Option value="member">Member</Option>
            <Option value="observer">Observer</Option>
          </Select>
        </Col>
        <Col xs={12} md={6}>
          <Select<'all' | MembershipStatus>
            style={{ width: '100%' }}
            value={statusFilter}
            onChange={(val) => setStatusFilter(val)}
          >
            <Option value="all">All membership states</Option>
            <Option value="active">Active</Option>
            <Option value="invited">Invitations</Option>
            <Option value="request_pending">Requests pending</Option>
          </Select>
        </Col>
        <Col xs={24} md={2}>
          <Space>
            <Switch
              checked={restrictedOnly}
              onChange={(checked) => setRestrictedOnly(checked)}
            />
            <Text type="secondary">Restricted only</Text>
          </Space>
        </Col>
      </Row>

      {error && (
        <Alert
          type="error"
          message="Unable to load your teams"
          description={
            <>
              <Paragraph style={{ marginBottom: 8 }}>{error}</Paragraph>
              <Button size="small" onClick={() => setReloadFlag((n) => n + 1)}>
                Retry
              </Button>
            </>
          }
          showIcon
          style={{ marginBottom: 16 }}
        />
      )}

      {!loading && !error && sortedData.length === 0 ? (
        <Empty
          description="You are not part of any team yet."
          style={{ padding: '40px 0' }}
        >
          <Space>
            <Button
              type="primary"
              icon={<PlusOutlined />}
              onClick={() =>
                router.push('/konnected/teams-collaboration/team-builder')
              }
            >
              Create or join a team
            </Button>
            <Button
              icon={<ProjectOutlined />}
              onClick={() =>
                router.push('/konnected/teams-collaboration/project-workspaces')
              }
            >
              Browse project workspaces
            </Button>
          </Space>
        </Empty>
      ) : (
        <Table<TeamRow>
          rowKey="key"
          size="middle"
          bordered
          loading={loading}
          columns={columns}
          dataSource={sortedData}
          rowSelection={rowSelection}
          pagination={{ pageSize: 8, showSizeChanger: false }}
          scroll={{ x: 1000 }}
        />
      )}
    </KonnectedPageShell>
  );
}

===== END app/konnected/teams-collaboration/my-teams/page.tsx =====


===== BEGIN app/konnected/teams-collaboration/project-workspaces/page.tsx =====
// app/konnected/teams-collaboration/project-workspaces/page.tsx
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Button,
  Card,
  Col,
  Dropdown,
  Empty,
  Input,
  message as antdMessage,
  Row,
  Select,
  Space,
  Spin,
  Statistic,
  Tag,
  Tooltip,
  Typography,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import type { MenuProps } from 'antd';
import {
  ArrowRightOutlined,
  DownOutlined,
  ProjectOutlined,
  TeamOutlined,
} from '@ant-design/icons';
import { Table } from 'antd';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';
import api from '@/api';

const { Text } = Typography;
const { Search } = Input;
const { Option } = Select;

type WorkspaceVisibility = 'open' | 'team-only' | 'restricted';

/**
 * Shape aligned with the KonnectED ¬∑ Teams Collaboration spec:
 * - bridges a KeenKonnect Project + Collaboration Workspace
 * - scoped by team membership and role
 */
export interface ProjectWorkspaceRow {
  id: string;
  projectId: string;
  teamId: string;

  projectTitle: string;
  teamName: string;

  /** e.g. "Active", "Planning", "Completed", "Archived" */
  status: string;

  /** e.g. "Owner", "Facilitator", "Contributor", "Viewer" */
  userRole: string;

  /** true = workspace already launched in KeenKonnect */
  isWorkspaceLaunched: boolean;

  /** last activity timestamp (ISO) */
  lastActivityAt?: string | null;

  /** membership / presence */
  totalMembers?: number | null;
  onlineMembers?: number | null;

  /** linked KonnectED resources */
  linkedKnowledgeCount?: number | null;
  linkedCertificationsCount?: number | null;

  /** access rules as resolved for current user */
  visibility?: WorkspaceVisibility;
  canEnter?: boolean;
  canManage?: boolean;
  canArchive?: boolean;
}

/**
 * API response is expected to follow the common list pattern:
 * {
 *   items: ProjectWorkspaceRow[];
 *   total: number;
 * }
 */
interface WorkspaceListResponse {
  items: ProjectWorkspaceRow[];
  total: number;
}

type StatusFilterValue = 'all' | 'active' | 'planning' | 'completed' | 'archived';
type OwnershipFilterValue = 'all' | 'owner' | 'member';

function getStatusTagColor(status: string): string {
  const normalized = status.toLowerCase();
  if (normalized.includes('active')) return 'green';
  if (normalized.includes('plan')) return 'blue';
  if (normalized.includes('complete')) return 'geekblue';
  if (normalized.includes('hold')) return 'orange';
  if (normalized.includes('archiv')) return 'default';
  return 'default';
}

function formatLastActivity(iso?: string | null): string {
  if (!iso) return 'N/A';
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) return 'N/A';
  return date.toLocaleString();
}

export default function KonnectedProjectWorkspacesPage(): JSX.Element {
  const router = useRouter();

  const [loading, setLoading] = useState<boolean>(false);
  const [rows, setRows] = useState<ProjectWorkspaceRow[]>([]);
  const [total, setTotal] = useState<number>(0);

  const [searchText, setSearchText] = useState<string>('');
  const [statusFilter, setStatusFilter] = useState<StatusFilterValue>('all');
  const [ownershipFilter, setOwnershipFilter] =
    useState<OwnershipFilterValue>('all');
  const [teamFilter, setTeamFilter] = useState<string | 'all'>('all');

  // --- Fetch data from backend ------------------------------------------------

  useEffect(() => {
    let isMounted = true;

    async function fetchWorkspaces() {
      try {
        setLoading(true);

        // Endpoint naming aligned to KonnectED Teams Collaboration aggregation:
        // backend should expose /konnected/teams/project-workspaces for the
        // current user, returning { items, total }.
        const response = await api.get<WorkspaceListResponse>(
          '/konnected/teams/project-workspaces',
        );

        if (!isMounted) return;
        setRows(response.items ?? []);
        setTotal(response.total ?? response.items?.length ?? 0);
      } catch (error) {
        if (!isMounted) return;
        // eslint-disable-next-line no-console
        console.error('Failed to load project workspaces', error);
        antdMessage.error(
          'Unable to load project workspaces. Please try again later.',
        );
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    }

    fetchWorkspaces();

    return () => {
      isMounted = false;
    };
  }, []);

  // --- Derived filters & stats ------------------------------------------------

  const teamOptions = useMemo(() => {
    const uniqueTeams = Array.from(
      new Set(rows.map((r) => r.teamName).filter(Boolean)),
    );
    return uniqueTeams.sort();
  }, [rows]);

  const filteredRows = useMemo(() => {
    return rows.filter((row) => {
      // text search on project + team
      if (searchText.trim()) {
        const needle = searchText.toLowerCase();
        const haystack = `${row.projectTitle} ${row.teamName}`.toLowerCase();
        if (!haystack.includes(needle)) {
          return false;
        }
      }

      // status filter ‚Äì approximate mapping based on label
      if (statusFilter !== 'all') {
        const normalized = row.status.toLowerCase();
        switch (statusFilter) {
          case 'active':
            if (!normalized.includes('active')) return false;
            break;
          case 'planning':
            if (!normalized.includes('plan')) return false;
            break;
          case 'completed':
            if (!normalized.includes('complete')) return false;
            break;
          case 'archived':
            if (!normalized.includes('archiv')) return false;
            break;
          default:
            break;
        }
      }

      // ownership filter ‚Äì relies on semantic role label
      if (ownershipFilter !== 'all') {
        const role = (row.userRole || '').toLowerCase();
        if (ownershipFilter === 'owner') {
          if (!role.includes('owner') && !role.includes('lead')) return false;
        }
        if (ownershipFilter === 'member') {
          if (role.includes('owner') || role.includes('lead')) return false;
        }
      }

      // team filter
      if (teamFilter !== 'all' && row.teamName !== teamFilter) {
        return false;
      }

      return true;
    });
  }, [rows, searchText, statusFilter, ownershipFilter, teamFilter]);

  const totalActive = useMemo(
    () =>
      rows.filter((r) => r.status.toLowerCase().includes('active')).length,
    [rows],
  );

  const totalOwned = useMemo(
    () =>
      rows.filter((r) => {
        const role = (r.userRole || '').toLowerCase();
        return role.includes('owner') || role.includes('lead');
      }).length,
    [rows],
  );

  const totalLinkedKnowledge = useMemo(
    () =>
      rows.reduce(
        (acc, r) => acc + (r.linkedKnowledgeCount ?? 0),
        0,
      ),
    [rows],
  );

  // --- Navigation helpers -----------------------------------------------------

  const goToWorkspace = (row: ProjectWorkspaceRow) => {
    if (row.canEnter === false) {
      antdMessage.warning(
        'You do not have permission to enter this workspace.',
      );
      return;
    }

    // All ‚Äúdeep work‚Äù still occurs inside keenKonnect project workspace.
    // We simply route to the existing workspace surface and let it resolve context.
    router.push(`/keenkonnect/projects/project-workspace?projectId=${row.projectId}`);
  };

  const goToTeam = (row: ProjectWorkspaceRow) => {
    // For now, route back to KonnectED ‚ÄúMy Teams‚Äù with a pre-selected context
    // once that page is aware of query params. For now, just generally go there.
    router.push('/konnected/teams-collaboration/my-teams');
  };

  const handleArchiveWorkspace = (row: ProjectWorkspaceRow) => {
    if (!row.canArchive) {
      antdMessage.warning('You do not have permission to archive this workspace.');
      return;
    }
    // TODO: plug to API when archive endpoint is wired (e.g. PATCH /projects/{id}/archive/)
    antdMessage.info(
      `Archive action would be sent for workspace "${row.projectTitle}".`,
    );
  };

  // --- Table columns ----------------------------------------------------------

  const columns: ColumnsType<ProjectWorkspaceRow> = [
    {
      title: 'Project Workspace',
      dataIndex: 'projectTitle',
      key: 'projectTitle',
      width: 280,
      render: (value: string, row) => (
        <Space direction="vertical" size={0}>
          <Space>
            <ProjectOutlined />
            <Text strong>{value}</Text>
          </Space>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Project ID: {row.projectId}
          </Text>
        </Space>
      ),
    },
    {
      title: 'Team',
      dataIndex: 'teamName',
      key: 'teamName',
      width: 200,
      render: (teamName: string, row) => (
        <Space direction="vertical" size={0}>
          <Space>
            <TeamOutlined />
            <Text>{teamName}</Text>
          </Space>
          <Text type="secondary" style={{ fontSize: 12 }}>
            Team ID: {row.teamId}
          </Text>
        </Space>
      ),
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      width: 120,
      render: (status: string) => (
        <Tag color={getStatusTagColor(status)}>{status}</Tag>
      ),
    },
    {
      title: 'Your role',
      dataIndex: 'userRole',
      key: 'userRole',
      width: 140,
      render: (role: string) => <Tag>{role || 'Member'}</Tag>,
    },
    {
      title: 'Members',
      key: 'members',
      width: 130,
      render: (_: unknown, row) => {
        const total = row.totalMembers ?? 0;
        const online = row.onlineMembers ?? 0;
        return (
          <Tooltip title="Online / total members in this workspace">
            <Text>
              {online}/{total} online
            </Text>
          </Tooltip>
        );
      },
    },
    {
      title: 'Linked learning',
      key: 'linked',
      width: 180,
      render: (_: unknown, row) => (
        <Space direction="vertical" size={2}>
          <Text style={{ fontSize: 12 }}>
            Knowledge items:{' '}
            <Text strong>{row.linkedKnowledgeCount ?? 0}</Text>
          </Text>
          <Text style={{ fontSize: 12 }}>
            Certifications:{' '}
            <Text strong>{row.linkedCertificationsCount ?? 0}</Text>
          </Text>
        </Space>
      ),
    },
    {
      title: 'Last activity',
      dataIndex: 'lastActivityAt',
      key: 'lastActivityAt',
      width: 160,
      render: (value?: string | null) => (
        <Text style={{ fontSize: 12 }}>{formatLastActivity(value)}</Text>
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      fixed: 'right',
      width: 210,
      render: (_: unknown, row) => {
        const primaryDisabled = row.canEnter === false;
        const primaryLabel =
          row.isWorkspaceLaunched && !primaryDisabled
            ? 'Open workspace'
            : row.isWorkspaceLaunched && primaryDisabled
              ? 'View only'
              : 'Launch workspace';

        const items: MenuProps['items'] = [
          {
            key: 'view-team',
            label: 'View team',
            onClick: () => goToTeam(row),
          },
          {
            key: 'archive',
            disabled: !row.canArchive,
            label: row.canArchive ? (
              <span>Archive workspace</span>
            ) : (
              <span style={{ opacity: 0.65 }}>Archive (no permission)</span>
            ),
            onClick: () => handleArchiveWorkspace(row),
          },
        ];

        return (
          <Space>
            <Button
              type="primary"
              size="small"
              disabled={primaryDisabled}
              icon={<ArrowRightOutlined />}
              onClick={() => goToWorkspace(row)}
            >
              {primaryLabel}
            </Button>

            <Dropdown
              menu={{ items }}
              trigger={['click']}
              placement="bottomRight"
            >
              <Button size="small" icon={<DownOutlined />}>
                More
              </Button>
            </Dropdown>
          </Space>
        );
      },
    },
  ];

  // --- Render -----------------------------------------------------------------

  const hasData = filteredRows.length > 0;

  return (
    <KonnectedPageShell
      title="Project Workspaces"
      subtitle={
        <span>
          Bridge your KeenKonnect project workspaces with KonnectED learning
          activities for each team.
        </span>
      }
      primaryAction={
        <Button
          type="primary"
          onClick={() =>
            router.push('/keenkonnect/projects/create-new-project')
          }
        >
          Start a new project
        </Button>
      }
      secondaryActions={
        <Button
          onClick={() =>
            router.push('/konnected/teams-collaboration/my-teams')
          }
        >
          Manage teams
        </Button>
      }
    >
      {/* Top KPIs */}
      <Row gutter={[16, 16]} style={{ marginBottom: 16 }}>
        <Col xs={24} sm={8}>
          <Card>
            <Statistic
              title="Total project workspaces"
              value={total}
              suffix="linked"
            />
          </Card>
        </Col>
        <Col xs={24} sm={8}>
          <Card>
            <Statistic
              title="Active workspaces"
              value={totalActive}
              valueStyle={{ color: '#52c41a' }}
            />
          </Card>
        </Col>
        <Col xs={24} sm={8}>
          <Card>
            <Statistic
              title="Workspaces you own"
              value={totalOwned}
            />
          </Card>
        </Col>
      </Row>

      {/* Filters */}
      <Card style={{ marginBottom: 16 }}>
        <Row gutter={[16, 16]} align="middle">
          <Col xs={24} md={10}>
            <Search
              placeholder="Search by project or team"
              allowClear
              onSearch={(value) => setSearchText(value)}
              onChange={(e) => setSearchText(e.target.value)}
            />
          </Col>

          <Col xs={24} sm={8} md={4}>
            <Text type="secondary" style={{ display: 'block', marginBottom: 4 }}>
              Status
            </Text>
            <Select<StatusFilterValue>
              value={statusFilter}
              onChange={(value) => setStatusFilter(value)}
              style={{ width: '100%' }}
            >
              <Option value="all">All statuses</Option>
              <Option value="active">Active</Option>
              <Option value="planning">Planning</Option>
              <Option value="completed">Completed</Option>
              <Option value="archived">Archived</Option>
            </Select>
          </Col>

          <Col xs={24} sm={8} md={4}>
            <Text type="secondary" style={{ display: 'block', marginBottom: 4 }}>
              Ownership
            </Text>
            <Select<OwnershipFilterValue>
              value={ownershipFilter}
              onChange={(value) => setOwnershipFilter(value)}
              style={{ width: '100%' }}
            >
              <Option value="all">All memberships</Option>
              <Option value="owner">Owned by me</Option>
              <Option value="member">Where I collaborate</Option>
            </Select>
          </Col>

          <Col xs={24} sm={8} md={6}>
            <Text type="secondary" style={{ display: 'block', marginBottom: 4 }}>
              Team
            </Text>
            <Select<string | 'all'>
              value={teamFilter}
              onChange={(value) => setTeamFilter(value)}
              style={{ width: '100%' }}
              allowClear={false}
            >
              <Option value="all">All teams</Option>
              {teamOptions.map((team) => (
                <Option key={team} value={team}>
                  {team}
                </Option>
              ))}
            </Select>
          </Col>
        </Row>
      </Card>

      {/* Table */}
      <Card>
        {loading ? (
          <div style={{ padding: 32, textAlign: 'center' }}>
            <Spin />
          </div>
        ) : (
          <Table<ProjectWorkspaceRow>
            rowKey={(row) => row.id}
            columns={columns}
            dataSource={filteredRows}
            size="middle"
            bordered
            scroll={{ x: 1000 }}
            pagination={{
              pageSize: 10,
              showSizeChanger: false,
            }}
            locale={{
              emptyText: hasData ? (
                <Empty description="No workspaces match the current filters." />
              ) : (
                <Empty description="No project workspaces linked to your teams yet." />
              ),
            }}
          />
        )}
      </Card>
    </KonnectedPageShell>
  );
}

===== END app/konnected/teams-collaboration/project-workspaces/page.tsx =====


===== BEGIN app/konnected/teams-collaboration/team-builder/page.tsx =====
// app/konnected/teams-collaboration/team-builder/page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Card,
  Table,
  Tag,
  Space,
  Button,
  Typography,
  message as antdMessage,
  Form,
  Input,
  Select,
  Switch,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import {
  UserOutlined,
  UserAddOutlined,
  MailOutlined,
  TeamOutlined,
  ExclamationCircleOutlined,
} from '@ant-design/icons';
import {
  StepsForm,
  ProFormText,
  ProFormTextArea,
  ProFormSwitch,
} from '@ant-design/pro-components';
import KonnectedPageShell from '@/app/konnected/KonnectedPageShell';

const { Paragraph, Text } = Typography;
const { Option } = Select;

/**
 * Domain types
 */
type TeamRole = 'leader' | 'coordinator' | 'member';

interface TeamInfo {
  name: string;
  description?: string;
  isOpenJoin?: boolean;
}

interface TeamMember {
  key: string;
  email: string;
  role: TeamRole;
  responsibilityArea?: string;
}

/**
 * API payloads (front-end representation)
 * You will likely need to align these with your real OpenAPI / backend models.
 */
interface CreateTeamPayload {
  name: string;
  description?: string;
  isOpenJoin?: boolean;
  members: {
    email: string;
    role: TeamRole;
    responsibilityArea?: string;
  }[];
}

interface CreateTeamResponse {
  id: string;
  slug?: string;
}

/**
 * Helpers
 */
const normalizeEmail = (value: string): string => value.trim().toLowerCase();

const TEAM_ROLE_LABEL: Record<TeamRole, string> = {
  leader: 'Team leader',
  coordinator: 'Coordinator',
  member: 'Member',
};

/**
 * API call (isolate endpoint here to make it easy to wire to your real backend).
 *
 * TODO: adjust URL & shape to your real OpenAPI (schema-endpoints).
 * For example, this might be:
 *   POST /api/konnected/teams
 *   or POST /api/project-teams
 */
async function createTeamApi(payload: CreateTeamPayload): Promise<CreateTeamResponse> {
  const response = await fetch('/api/konnected/teams', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });

  if (response.status === 403) {
    throw new Error('PERMISSION_DENIED');
  }

  if (!response.ok) {
    // Try to surface backend validation errors if possible
    let details: unknown;
    try {
      details = await response.json();
    } catch {
      // ignore
    }
    const error = new Error('SERVER_ERROR');
    (error as any).details = details;
    throw error;
  }

  return (await response.json()) as CreateTeamResponse;
}

/**
 * Members table columns
 */
const useMemberColumns = (
  onRemove: (key: string) => void,
): ColumnsType<TeamMember> => [
  {
    title: 'Member',
    dataIndex: 'email',
    key: 'email',
    render: (email: string) => (
      <Space>
        <MailOutlined />
        <span>{email}</span>
      </Space>
    ),
  },
  {
    title: 'Role',
    dataIndex: 'role',
    key: 'role',
    render: (role: TeamRole) => {
      const color =
        role === 'leader' ? 'gold' : role === 'coordinator' ? 'processing' : 'default';
      return <Tag color={color}>{TEAM_ROLE_LABEL[role]}</Tag>;
    },
  },
  {
    title: 'Responsibility area',
    dataIndex: 'responsibilityArea',
    key: 'responsibilityArea',
    ellipsis: true,
    render: (value?: string) => value || <Text type="secondary">Not specified</Text>,
  },
  {
    title: 'Actions',
    key: 'actions',
    width: 120,
    render: (_: unknown, record: TeamMember) => (
      <Button danger size="small" onClick={() => onRemove(record.key)}>
        Remove
      </Button>
    ),
  },
];

export default function TeamBuilderPage(): JSX.Element {
  const router = useRouter();

  /**
   * Step 1 ‚Äì team info
   */
  const [teamInfo, setTeamInfo] = useState<TeamInfo | null>(null);

  /**
   * Step 2 ‚Äì members
   */
  const [members, setMembers] = useState<TeamMember[]>([]);

  // Draft row for the ‚Äúadd member‚Äù mini-form
  const [memberForm] = Form.useForm<{
    email: string;
    role: TeamRole;
    responsibilityArea?: string;
  }>();

  /**
   * Submitting / global loading
   */
  const [submitting, setSubmitting] = useState(false);

  /**
   * Derived data
   */
  const isValidForSubmit = useMemo(() => {
    return Boolean(teamInfo && teamInfo.name && members.length > 0);
  }, [teamInfo, members]);

  const handleAddMember = async () => {
    try {
      const values = await memberForm.validateFields();
      const email = normalizeEmail(values.email);

      if (members.some((m) => m.email === email)) {
        antdMessage.warning('This email is already in the team.');
        return;
      }

      const newMember: TeamMember = {
        key: `${Date.now()}-${email}`,
        email,
        role: values.role,
        responsibilityArea: values.responsibilityArea?.trim() || undefined,
      };

      setMembers((prev) => [...prev, newMember]);
      memberForm.resetFields();
    } catch {
      // Validation error, do nothing (ProForm already shows messages)
    }
  };

  const handleRemoveMember = (key: string) => {
    setMembers((prev) => prev.filter((m) => m.key !== key));
  };

  const memberColumns = useMemberColumns(handleRemoveMember);

  /**
   * Global submit ‚Äì called when last step is submitted.
   */
  const handleFinish = async (): Promise<boolean> => {
    if (!teamInfo) {
      antdMessage.error('Please complete team information first.');
      return false;
    }
    if (!members.length) {
      antdMessage.error('Please add at least one member to the team.');
      return false;
    }

    const payload: CreateTeamPayload = {
      name: teamInfo.name.trim(),
      description: teamInfo.description?.trim() || undefined,
      isOpenJoin: teamInfo.isOpenJoin ?? false,
      members: members.map((member) => ({
        email: member.email,
        role: member.role,
        responsibilityArea: member.responsibilityArea,
      })),
    };

    try {
      setSubmitting(true);
      const created = await createTeamApi(payload);
      antdMessage.success('Team created successfully.');
      // Redirect to ‚ÄúMy teams‚Äù or to the created team if you have a slug
      if (created.slug) {
        router.push(`/konnected/teams-collaboration/my-teams/${created.slug}`);
      } else {
        router.push('/konnected/teams-collaboration/my-teams');
      }
      return true;
    } catch (err) {
      const error = err as Error & { details?: any };
      if (error.message === 'PERMISSION_DENIED') {
        antdMessage.error(
          'You do not have permission to create teams. Please contact an administrator.',
        );
      } else if (error.details?.code === 'TEAM_NAME_ALREADY_EXISTS') {
        antdMessage.error('A team with this name already exists. Please pick another name.');
      } else {
        antdMessage.error('Could not create the team. Please try again or contact support.');
      }
      return false;
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <KonnectedPageShell
      title="Team Builder"
      subtitle={
        <span>
          Configure a collaboration-ready team for KonnectED: define the team, assign roles, and
          confirm membership before you start collaborating.
        </span>
      }
      primaryAction={
        <Button
          type="primary"
          icon={<TeamOutlined />}
          disabled={!isValidForSubmit || submitting}
          onClick={handleFinish}
        >
          Create team
        </Button>
      }
      secondaryActions={
        <Text type="secondary">
          <UserOutlined /> You will be automatically added as a member.
        </Text>
      }
    >
      <Card>
        <StepsForm
          onFinish={handleFinish}
          formProps={{ layout: 'vertical' }}
          submitter={{
            submitButtonProps: {
              loading: submitting,
            },
            searchConfig: {
              submitText: 'Create team',
            },
          }}
        >
          {/* Step 1 ‚Äì Team information */}
          <StepsForm.StepForm<TeamInfo>
            name="teamInfo"
            title="Team details"
            onFinish={async (values) => {
              const trimmedName = values.name?.trim();
              if (!trimmedName) {
                antdMessage.error('Team name is required.');
                return false;
              }
              setTeamInfo({
                name: trimmedName,
                description: values.description?.trim() || undefined,
                isOpenJoin: values.isOpenJoin ?? false,
              });
              return true;
            }}
          >
            <Paragraph type="secondary" style={{ marginBottom: 16 }}>
              Give your team a clear identity and choose whether new members can request to join.
            </Paragraph>

            <ProFormText
              name="name"
              label="Team name"
              placeholder="e.g. Robotics Innovation Squad"
              rules={[
                { required: true, message: 'Please enter a team name.' },
                { min: 3, message: 'Name should be at least 3 characters long.' },
              ]}
              fieldProps={{
                maxLength: 120,
                showCount: true,
              }}
            />

            <ProFormTextArea
              name="description"
              label="Team description"
              placeholder="Briefly describe the team‚Äôs purpose, focus areas, and who should join."
              fieldProps={{
                rows: 4,
                maxLength: 500,
                showCount: true,
              }}
            />

            <ProFormSwitch
              name="isOpenJoin"
              label="Allow join requests"
              tooltip="If enabled, learners can send join requests which team leaders can approve."
            />
          </StepsForm.StepForm>

          {/* Step 2 ‚Äì Members & roles */}
          <StepsForm.StepForm
            name="members"
            title="Members & roles"
            onFinish={async () => {
              if (!members.length) {
                antdMessage.error('Add at least one member to continue.');
                return false;
              }
              return true;
            }}
          >
            <Paragraph type="secondary" style={{ marginBottom: 16 }}>
              Add core team members now. You can invite more people later from ‚ÄúMy teams‚Äù.
            </Paragraph>

            {/* Add-member mini-form */}
            <Card
              size="small"
              style={{ marginBottom: 24 }}
              title={
                <Space>
                  <UserAddOutlined />
                  <span>Add member</span>
                </Space>
              }
            >
              <Form
                form={memberForm}
                layout="vertical"
                initialValues={{
                  role: 'member' as TeamRole,
                }}
              >
                <Form.Item
                  label="Email"
                  name="email"
                  rules={[
                    { required: true, message: 'Please enter an email address.' },
                    { type: 'email', message: 'Please enter a valid email address.' },
                  ]}
                >
                  <Input
                    prefix={<MailOutlined />}
                    placeholder="member@example.org"
                    autoComplete="off"
                  />
                </Form.Item>

                <Form.Item label="Role" name="role" rules={[{ required: true }]}>
                  <Select>
                    <Option value="leader">Team leader</Option>
                    <Option value="coordinator">Coordinator</Option>
                    <Option value="member">Member</Option>
                  </Select>
                </Form.Item>

                <Form.Item label="Responsibility area" name="responsibilityArea">
                  <Input placeholder="e.g. Impact tracking, facilitation, content curation" />
                </Form.Item>

                <Form.Item>
                  <Space>
                    <Button type="primary" onClick={handleAddMember}>
                      Add to team
                    </Button>
                    <Text type="secondary">
                      You can adjust roles later from ‚ÄúMy teams‚Äù.
                    </Text>
                  </Space>
                </Form.Item>
              </Form>
            </Card>

            {/* Members table */}
            <Table<TeamMember>
              rowKey="key"
              size="middle"
              bordered
              columns={memberColumns}
              dataSource={members}
              pagination={false}
              locale={{
                emptyText: 'No members added yet.',
              }}
            />
          </StepsForm.StepForm>

          {/* Step 3 ‚Äì Review & confirm */}
          <StepsForm.StepForm name="review" title="Review & confirm">
            <Paragraph style={{ marginBottom: 16 }}>
              Review your team configuration before creating it. You can still adjust details later
              in ‚ÄúMy teams‚Äù.
            </Paragraph>

            <Card size="small" style={{ marginBottom: 24 }} title="Team summary">
              {teamInfo ? (
                <>
                  <Paragraph>
                    <Text strong>Name:</Text> {teamInfo.name}
                  </Paragraph>
                  <Paragraph>
                    <Text strong>Description:</Text>{' '}
                    {teamInfo.description || <Text type="secondary">Not provided</Text>}
                  </Paragraph>
                  <Paragraph>
                    <Text strong>Join policy:</Text>{' '}
                    {teamInfo.isOpenJoin ? (
                      <Tag color="success">Requests allowed</Tag>
                    ) : (
                      <Tag>Invite-only</Tag>
                    )}
                  </Paragraph>
                </>
              ) : (
                <Paragraph type="secondary">
                  Team information is incomplete. Go back to the first step to fill it in.
                </Paragraph>
              )}
            </Card>

            <Card
              size="small"
              style={{ marginBottom: 24 }}
              title={`Members (${members.length})`}
            >
              {members.length ? (
                <Table<TeamMember>
                  rowKey="key"
                  size="small"
                  bordered
                  columns={memberColumns}
                  dataSource={members}
                  pagination={false}
                />
              ) : (
                <Paragraph type="secondary">No members added yet.</Paragraph>
              )}
            </Card>

            <Card
              size="small"
              type="inner"
              title={
                <Space>
                  <ExclamationCircleOutlined />
                  <span>Before you create the team</span>
                </Space>
              }
            >
              <ul className="list-disc pl-5">
                <li>You will be added as a member of the team automatically.</li>
                <li>
                  Team leaders can manage roles, approve join requests (if enabled), and archive
                  the team.
                </li>
                <li>
                  You can always modify membership later from{' '}
                  <Text strong>Teams Collaboration ‚Üí My teams</Text>.
                </li>
              </ul>
            </Card>
          </StepsForm.StepForm>
        </StepsForm>
      </Card>
    </KonnectedPageShell>
  );
}

===== END app/konnected/teams-collaboration/team-builder/page.tsx =====


===== BEGIN app/konsensus/page.tsx =====
import { PollPage } from "@/modules/konsensus/pages";
export default PollPage;

===== END app/konsensus/page.tsx =====


===== BEGIN app/kreative/collaborative-spaces/find-spaces/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import {
  Row,
  Col,
  Card,
  Input,
  Select,
  Button,
  Modal,
  Pagination,
  Space,
  Typography,
  message as antdMessage,
} from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Text } = Typography;
const { Option } = Select;

type Discipline = 'Art' | 'Music' | 'Writing' | 'Technology' | 'Other';
type JoinType = 'open' | 'invite-only';
type DisciplineFilter = Discipline | 'All';
type JoinTypeFilter = JoinType | 'All';

interface CollaborativeSpace {
  id: string;
  name: string;
  description: string;
  discipline: Discipline;
  memberCount: number;
  joinType: JoinType;
  createdAt: string; // ISO date
}

// Demo data
const dummySpaces: CollaborativeSpace[] = [
  {
    id: '1',
    name: 'Urban Art Collective',
    description: 'A community for street artists and mural enthusiasts.',
    discipline: 'Art',
    memberCount: 35,
    joinType: 'open',
    createdAt: '2025-11-15T10:00:00Z',
  },
  {
    id: '2',
    name: 'Indie Music Makers',
    description: 'Join to collaborate on original music projects and recordings.',
    discipline: 'Music',
    memberCount: 50,
    joinType: 'invite-only',
    createdAt: '2025-11-20T14:30:00Z',
  },
  {
    id: '3',
    name: 'Writers‚Äô Lounge',
    description:
      'A space for writers to share ideas, get feedback, and find collaborators.',
    discipline: 'Writing',
    memberCount: 25,
    joinType: 'open',
    createdAt: '2025-11-18T09:15:00Z',
  },
  {
    id: '4',
    name: 'Tech & Art Fusion',
    description:
      'Where creativity meets innovation: join us to build interactive art installations.',
    discipline: 'Technology',
    memberCount: 18,
    joinType: 'invite-only',
    createdAt: '2025-11-22T11:45:00Z',
  },
];

export default function FindSpacesPage(): JSX.Element {
  const router = useRouter();

  // Filters, tri, pagination
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedDiscipline, setSelectedDiscipline] =
    useState<DisciplineFilter>('All');
  const [selectedJoinType, setSelectedJoinType] =
    useState<JoinTypeFilter>('All');
  const [sortOption, setSortOption] =
    useState<'mostActive' | 'newest'>('mostActive');
  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 4;

  // Modal d‚Äôinvitation
  const [joinModalVisible, setJoinModalVisible] = useState(false);
  const [selectedSpace, setSelectedSpace] = useState<CollaborativeSpace | null>(
    null,
  );

  // Filtre + tri
  const filteredSpaces = useMemo(() => {
    let spaces = dummySpaces;

    if (selectedDiscipline !== 'All') {
      spaces = spaces.filter((s) => s.discipline === selectedDiscipline);
    }
    if (selectedJoinType !== 'All') {
      spaces = spaces.filter((s) => s.joinType === selectedJoinType);
    }
    if (searchQuery.trim() !== '') {
      const q = searchQuery.toLowerCase();
      spaces = spaces.filter(
        (s) =>
          s.name.toLowerCase().includes(q) ||
          s.description.toLowerCase().includes(q),
      );
    }

    if (sortOption === 'newest') {
      // copie pour √©viter la mutation
      return [...spaces].sort(
        (a, b) =>
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
      );
    }
    // proxy d‚Äôactivit√© = memberCount
    return [...spaces].sort((a, b) => b.memberCount - a.memberCount);
  }, [searchQuery, selectedDiscipline, selectedJoinType, sortOption]);

  // Pagination
  const paginatedSpaces = useMemo(() => {
    const start = (currentPage - 1) * pageSize;
    return filteredSpaces.slice(start, start + pageSize);
  }, [filteredSpaces, currentPage]);

  // Actions
  function handleJoin(space: CollaborativeSpace) {
    if (space.joinType === 'open') {
      antdMessage.success(`You have joined "${space.name}"!`);
      router.push(`/kreative/collaborative-spaces/${space.id}`);
      return;
    }
    setSelectedSpace(space);
    setJoinModalVisible(true);
  }

  function confirmJoinRequest() {
    if (selectedSpace) {
      antdMessage.success(
        `Your request to join "${selectedSpace.name}" has been sent.`,
      );
    }
    setJoinModalVisible(false);
    setSelectedSpace(null);
  }

  return (
    <PageContainer title="Find Spaces">
      <Space direction="vertical" style={{ width: '100%', marginBottom: 24 }} size="large">
        <Space wrap>
          <Input
            placeholder="Search spaces..."
            prefix={<SearchOutlined />}
            value={searchQuery}
            onChange={(e) => {
              setSearchQuery(e.target.value);
              setCurrentPage(1);
            }}
            style={{ width: 300 }}
          />

          <Select
            value={selectedDiscipline}
            onChange={(v) => {
              setSelectedDiscipline(v as DisciplineFilter);
              setCurrentPage(1);
            }}
            style={{ width: 180 }}
          >
            <Option value="All">All Disciplines</Option>
            <Option value="Art">Art</Option>
            <Option value="Music">Music</Option>
            <Option value="Writing">Writing</Option>
            <Option value="Technology">Technology</Option>
            <Option value="Other">Other</Option>
          </Select>

          <Select
            value={selectedJoinType}
            onChange={(v) => {
              setSelectedJoinType(v as JoinTypeFilter);
              setCurrentPage(1);
            }}
            style={{ width: 180 }}
          >
            <Option value="All">All Join Types</Option>
            <Option value="open">Open</Option>
            <Option value="invite-only">Invite-Only</Option>
          </Select>

          <Select
            value={sortOption}
            onChange={(v) => {
              setSortOption(v as 'mostActive' | 'newest');
              setCurrentPage(1);
            }}
            style={{ width: 180 }}
          >
            <Option value="mostActive">Most Active</Option>
            <Option value="newest">Newest</Option>
          </Select>
        </Space>
      </Space>

      <Row gutter={[24, 24]}>
        {paginatedSpaces.map((space) => (
          <Col key={space.id} xs={24} sm={12} md={8}>
            <Card
              hoverable
              title={space.name}
              extra={<Text type="secondary">{space.memberCount} Members</Text>}
              actions={[
                <Button
                  key="join"
                  type="primary"
                  onClick={(e) => {
                    e.stopPropagation();
                    handleJoin(space);
                  }}
                >
                  {space.joinType === 'open' ? 'Join' : 'Request to Join'}
                </Button>,
              ]}
              onClick={() =>
                router.push(`/kreative/collaborative-spaces/${space.id}`)
              }
            >
              <Card.Meta description={<Text>{space.description}</Text>} />
              <div style={{ marginTop: 12 }}>
                <Text strong>Discipline:</Text> <Text>{space.discipline}</Text>
                <br />
                <Text strong>Status:</Text>{' '}
                <Text>{space.joinType === 'open' ? 'Open' : 'Invite-Only'}</Text>
              </div>
            </Card>
          </Col>
        ))}
      </Row>

      <div style={{ textAlign: 'center', marginTop: 24 }}>
        <Pagination
          current={currentPage}
          pageSize={pageSize}
          total={filteredSpaces.length}
          onChange={(page) => setCurrentPage(page)}
        />
      </div>

      <Modal
        title="Request to Join Space"
        open={joinModalVisible}
        onOk={confirmJoinRequest}
        onCancel={() => setJoinModalVisible(false)}
        okText="Send Request"
        cancelText="Cancel"
      >
        {selectedSpace && (
          <p>
            Do you want to send a join request for the space:{' '}
            <strong>{selectedSpace.name}</strong>?
          </p>
        )}
      </Modal>
    </PageContainer>
  );
}

===== END app/kreative/collaborative-spaces/find-spaces/page.tsx =====


===== BEGIN app/kreative/collaborative-spaces/my-spaces/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\collaborative-spaces\my-spaces\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import {
  List,
  Button,
  Input,
  Select,
  Badge,
  Avatar,
  Space,
  Row,
  Col,
  Typography,
  Empty,
} from 'antd';
import { TeamOutlined, PlusOutlined, SearchOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { Title, Text } = Typography;

// Collaborative space model
interface CollaborativeSpace {
  id: string;
  name: string;
  topic: string;
  membersCount: number;
  category: 'Studio' | 'Club' | 'Community';
  unreadCount: number;
}

// Demo data
const dummySpaces: CollaborativeSpace[] = [
  {
    id: '1',
    name: 'Creative Studio Alpha',
    topic: 'Graphic Design & Illustration',
    membersCount: 12,
    category: 'Studio',
    unreadCount: 3,
  },
  {
    id: '2',
    name: 'Music Club Beta',
    topic: 'Indie & Electronic Music',
    membersCount: 20,
    category: 'Club',
    unreadCount: 0,
  },
  {
    id: '3',
    name: 'Writers Community Gamma',
    topic: 'Creative Writing & Storytelling',
    membersCount: 15,
    category: 'Community',
    unreadCount: 5,
  },
];

export default function MySpacesPage(): JSX.Element {
  const router = useRouter();

  const [selectedCategory, setSelectedCategory] = useState<string>('All');
  const [searchQuery, setSearchQuery] = useState<string>('');

  const filteredSpaces = useMemo<CollaborativeSpace[]>(() => {
    let spaces = dummySpaces;

    if (selectedCategory !== 'All') {
      spaces = spaces.filter((s) => s.category === selectedCategory);
    }

    if (searchQuery.trim() !== '') {
      const q = searchQuery.toLowerCase();
      spaces = spaces.filter(
        (s) =>
          s.name.toLowerCase().includes(q) ||
          s.topic.toLowerCase().includes(q),
      );
    }

    return spaces;
  }, [selectedCategory, searchQuery]);

  const enterSpace = (id: string) => {
    router.push(`/kreative/collaborative-spaces/${id}`);
  };

  const hasSpaces = filteredSpaces.length > 0;

  return (
    <KreativePageShell
      title="My Spaces"
      subtitle="Spaces you‚Äôve joined or created across the Kreative collaborative hub."
      primaryAction={
        <Button
          type="primary"
          icon={<PlusOutlined />}
          onClick={() =>
            router.push('/kreative/collaborative-spaces/start-new-space')
          }
        >
          Start a New Space
        </Button>
      }
    >
      <Row
        justify="space-between"
        align="middle"
        style={{ marginBottom: 24 }}
      >
        <Col>
          <Space wrap>
            <Input
              placeholder="Search spaces..."
              prefix={<SearchOutlined />}
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              style={{ width: 300 }}
              allowClear
            />
            <Select
              value={selectedCategory}
              onChange={(value: string) => setSelectedCategory(value)}
              style={{ width: 200 }}
              options={[
                { value: 'All', label: 'All Categories' },
                { value: 'Studio', label: 'Studio' },
                { value: 'Club', label: 'Club' },
                { value: 'Community', label: 'Community' },
              ]}
            />
          </Space>
        </Col>
      </Row>

      {hasSpaces ? (
        <List<CollaborativeSpace>
          itemLayout="horizontal"
          dataSource={filteredSpaces}
          renderItem={(space) => (
            <List.Item
              key={space.id}
              actions={[
                <Button
                  key="enter"
                  type="primary"
                  onClick={() => enterSpace(space.id)}
                >
                  Enter Space
                </Button>,
              ]}
            >
              <List.Item.Meta
                avatar={
                  space.unreadCount > 0 ? (
                    <Badge count={space.unreadCount} offset={[-5, 5]}>
                      <Avatar size="large" icon={<TeamOutlined />} />
                    </Badge>
                  ) : (
                    <Avatar size="large" icon={<TeamOutlined />} />
                  )
                }
                title={
                  <Title level={4} style={{ margin: 0 }}>
                    {space.name}
                  </Title>
                }
                description={
                  <Space direction="vertical" size={0}>
                    <Text strong>Topic:</Text>
                    <Text>{space.topic}</Text>
                    <Text strong>Members:</Text>
                    <Text>{space.membersCount}</Text>
                  </Space>
                }
              />
            </List.Item>
          )}
        />
      ) : (
        <Empty
          image={Empty.PRESENTED_IMAGE_SIMPLE}
          description="You‚Äôre not part of any spaces yet. Start a new one or explore available spaces."
        />
      )}
    </KreativePageShell>
  );
}

===== END app/kreative/collaborative-spaces/my-spaces/page.tsx =====


===== BEGIN app/kreative/collaborative-spaces/start-new-space/page.tsx =====
// app/kreative/collaborative-spaces/start-new-space/page.tsx
'use client';

import React, { useState } from 'react';
import {
  Form,
  Input,
  Select,
  Radio,
  Button,
  Upload,
  Space,
  Typography,
  message as antdMessage,
} from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import { UploadOutlined, PlusOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { TextArea } = Input;
const { Option } = Select;
const { Paragraph } = Typography;

type PrivacyOption = 'Public' | 'Private';

interface InvitedMemberField {
  email: string;
}

interface StartNewSpaceFormValues {
  name: string;
  description: string;
  category: string;
  privacy: PrivacyOption;
  invitedMembers?: InvitedMemberField[];
  banner?: UploadFile[];
}

// Minimal type for Upload onChange (keeps us away from implicit any)
type UploadChangeParamLite = {
  fileList: UploadFile[];
};

export default function StartNewSpacePage(): JSX.Element {
  const [form] = Form.useForm<StartNewSpaceFormValues>();
  const router = useRouter();
  const [fileList, setFileList] = useState<UploadFile[]>([]);

  const handleFileChange = (info: UploadChangeParamLite) => {
    setFileList(info.fileList);
  };

  const onFinish = (values: StartNewSpaceFormValues) => {
    const spaceData = {
      ...values,
      banner: fileList,
    };

    // TODO: replace with real API call
    // await api.createSpace(spaceData)

    // eslint-disable-next-line no-console
    console.log('New Space Data:', spaceData);
    antdMessage.success('Your new space has been created successfully!');
    router.push('/kreative/collaborative-spaces/my-spaces');
  };

  return (
    <PageContainer title="Start a New Space">
      <Paragraph type="secondary" style={{ marginBottom: 24 }}>
        Define your collaborative space so others can discover and join the right context.
      </Paragraph>

      <Form<StartNewSpaceFormValues>
        form={form}
        layout="vertical"
        onFinish={onFinish}
        initialValues={{ privacy: 'Public', category: 'Art Study Group' }}
      >
        {/* Space Name */}
        <Form.Item
          label="Space Name"
          name="name"
          rules={[{ required: true, message: 'Please enter a space name.' }]}
        >
          <Input placeholder="Enter the name of your space" />
        </Form.Item>

        {/* Description / Purpose */}
        <Form.Item
          label="Description / Purpose"
          name="description"
          rules={[{ required: true, message: 'Please provide a description for your space.' }]}
        >
          <TextArea rows={5} placeholder="Describe the purpose and vision of your space" />
        </Form.Item>

        {/* Category / Type */}
        <Form.Item
          label="Category / Type"
          name="category"
          rules={[{ required: true, message: 'Please select a category.' }]}
        >
          <Select placeholder="Select a category">
            <Option value="Art Study Group">Art Study Group</Option>
            <Option value="Music Jam Session">Music Jam Session</Option>
            <Option value="Creative Writing Circle">Creative Writing Circle</Option>
            <Option value="Digital Innovation Hub">Digital Innovation Hub</Option>
          </Select>
        </Form.Item>

        {/* Privacy Setting */}
        <Form.Item
          label="Privacy Setting"
          name="privacy"
          rules={[{ required: true, message: 'Please choose a privacy setting.' }]}
        >
          <Radio.Group>
            <Radio value="Public">Public (Anyone can join)</Radio>
            <Radio value="Private">Private (Invite Only)</Radio>
          </Radio.Group>
        </Form.Item>

        {/* Invite Initial Members (only when Private) */}
        <Form.Item shouldUpdate={(prev, cur) => prev.privacy !== cur.privacy}>
          {({ getFieldValue }) =>
            getFieldValue('privacy') === 'Private' ? (
              <Form.List name="invitedMembers">
                {(fields, { add, remove }) => (
                  <>
                    <Space direction="vertical" style={{ width: '100%' }}>
                      {fields.map((field) => (
                        <Space key={field.key} align="baseline">
                          <Form.Item
                            {...field}
                            name={[field.name, 'email']}
                            rules={[
                              { required: true, message: 'Please enter an email address.' },
                              { type: 'email', message: 'Please enter a valid email address.' },
                            ]}
                          >
                            <Input placeholder="Enter member email" />
                          </Form.Item>
                          <Button type="link" onClick={() => remove(field.name)}>
                            Remove
                          </Button>
                        </Space>
                      ))}
                      <Form.Item>
                        <Button type="dashed" onClick={() => add()} icon={<PlusOutlined />}>
                          Invite Member
                        </Button>
                      </Form.Item>
                    </Space>
                  </>
                )}
              </Form.List>
            ) : null
          }
        </Form.Item>

        {/* Space Banner or Icon Upload */}
        <Form.Item label="Space Icon / Banner Image" name="banner">
          <Upload
            beforeUpload={() => false} // prevent auto-upload
            fileList={fileList}
            onChange={handleFileChange}
            accept="image/*"
          >
            <Button icon={<UploadOutlined />}>Upload Image</Button>
          </Upload>
        </Form.Item>

        {/* Submit Button */}
        <Form.Item>
          <Button type="primary" htmlType="submit">
            Create Space
          </Button>
        </Form.Item>
      </Form>
    </PageContainer>
  );
}

===== END app/kreative/collaborative-spaces/start-new-space/page.tsx =====


===== BEGIN app/kreative/community-showcases/featured-projects/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\featured-projects\page.tsx
'use client';

import React, { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import {
  Card,
  Row,
  Col,
  Input,
  Select,
  Modal,
  Pagination,
  Typography,
  Badge,
  Space,
  Button,
} from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import PageContainer from '@/components/PageContainer';

const { Title, Text, Paragraph } = Typography;

interface Project {
  id: string;
  title: string;
  description: string;
  creator: string;
  coverImage: string;
  category: string;
}

const dummyProjects: Project[] = [
  {
    id: '1',
    title: 'Project Sunrise',
    description:
      'An inspiring project that captures the beauty of dawn with innovative photo techniques and a vivid color palette.',
    creator: 'Alice Johnson',
    coverImage: 'https://via.placeholder.com/400x300.png?text=Project+Sunrise',
    category: 'Photography',
  },
  {
    id: '2',
    title: 'Digital Dreamscape',
    description:
      'A surreal digital art piece combining abstract concepts with vibrant colors to evoke emotion.',
    creator: 'Bob Smith',
    coverImage: 'https://via.placeholder.com/400x300.png?text=Digital+Dreamscape',
    category: 'Digital Art',
  },
  {
    id: '3',
    title: 'Urban Poetry',
    description:
      'A mixed-media project blending urban photography with spoken word performance, reimagining cityscapes in a poetic light.',
    creator: 'Carol Lee',
    coverImage: 'https://via.placeholder.com/400x300.png?text=Urban+Poetry',
    category: 'Mixed Media',
  },
  {
    id: '4',
    title: 'Vintage Revival',
    description:
      'A creative reinterpretation of vintage art styles merged with modern design sensibilities.',
    creator: 'David Kim',
    coverImage: 'https://via.placeholder.com/400x300.png?text=Vintage+Revival',
    category: 'Painting',
  },
];

export default function FeaturedProjectsPage(): JSX.Element {
  const router = useRouter();

  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedCategory, setSelectedCategory] = useState<string>('All');
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [selectedProject, setSelectedProject] = useState<Project | null>(null);

  // Pagination
  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 4;

  // Filters
  const filteredProjects = useMemo(() => {
    let projects = dummyProjects;
    if (selectedCategory !== 'All') {
      projects = projects.filter((project) => project.category === selectedCategory);
    }
    if (searchQuery.trim() !== '') {
      const q = searchQuery.toLowerCase();
      projects = projects.filter(
        (project) =>
          project.title.toLowerCase().includes(q) ||
          project.description.toLowerCase().includes(q),
      );
    }
    return projects;
  }, [searchQuery, selectedCategory]);

  const paginatedProjects = useMemo(() => {
    const start = (currentPage - 1) * pageSize;
    return filteredProjects.slice(start, start + pageSize);
  }, [filteredProjects, currentPage]);

  const openModal = (project: Project) => {
    setSelectedProject(project);
    setModalVisible(true);
  };

  const closeModal = () => {
    setModalVisible(false);
    setSelectedProject(null);
  };

  return (
    <PageContainer title="Featured Projects">
      {/* Filters */}
      <Space wrap style={{ marginBottom: 24 }}>
        <Input
          placeholder="Search projects."
          prefix={<SearchOutlined />}
          value={searchQuery}
          onChange={(e) => {
            setSearchQuery(e.target.value);
            setCurrentPage(1);
          }}
          style={{ width: 300 }}
        />

        <Select
          value={selectedCategory}
          onChange={(value) => {
            setSelectedCategory(value);
            setCurrentPage(1);
          }}
          style={{ width: 220 }}
          options={[
            { value: 'All', label: 'All Categories' },
            { value: 'Photography', label: 'Photography' },
            { value: 'Digital Art', label: 'Digital Art' },
            { value: 'Mixed Media', label: 'Mixed Media' },
            { value: 'Painting', label: 'Painting' },
          ]}
        />
      </Space>

      {/* Grid */}
      <Row gutter={[24, 24]}>
        {paginatedProjects.map((project) => (
          <Col key={project.id} xs={24} sm={12} md={8} lg={6}>
            <Badge.Ribbon text="Featured" color="red">
              <Card
                hoverable
                cover={
                  <img
                    alt={project.title}
                    src={project.coverImage}
                    style={{ height: 200, objectFit: 'cover' }}
                  />
                }
                onClick={() => openModal(project)}
              >
                <Card.Meta
                  title={project.title}
                  description={
                    <>
                      <Paragraph className="line-clamp-2" style={{ marginBottom: 8 }}>
                        {project.description}
                      </Paragraph>
                      <Text type="secondary">By {project.creator}</Text>
                    </>
                  }
                />
              </Card>
            </Badge.Ribbon>
          </Col>
        ))}
      </Row>

      {/* Pagination */}
      <div style={{ textAlign: 'center', marginTop: 24 }}>
        <Pagination
          current={currentPage}
          pageSize={pageSize}
          total={filteredProjects.length}
          onChange={(page) => setCurrentPage(page)}
        />
      </div>

      {/* Modal */}
      <Modal open={modalVisible} onCancel={closeModal} footer={null} width={800}>
        {selectedProject && (
          <div>
            <img
              alt={selectedProject.title}
              src={selectedProject.coverImage}
              style={{ width: '100%', maxHeight: 400, objectFit: 'cover' }}
            />
            <div style={{ marginTop: 16 }}>
              <Title level={3}>{selectedProject.title}</Title>
              <Text type="secondary">By {selectedProject.creator}</Text>
              <p style={{ marginTop: 12 }}>{selectedProject.description}</p>
              <Button
                type="primary"
                onClick={() =>
                  router.push(
                    `/kreative/community-showcases/featured-projects/${selectedProject.id}`,
                  )
                }
              >
                View Details
              </Button>
            </div>
          </div>
        )}
      </Modal>

      {/* simple 2-line clamp */}
      <style jsx>{`
        .line-clamp-2 {
          display: -webkit-box;
          -webkit-line-clamp: 2;
          -webkit-box-orient: vertical;
          overflow: hidden;
        }
      `}</style>
    </PageContainer>
  );
}

===== END app/kreative/community-showcases/featured-projects/page.tsx =====


===== BEGIN app/kreative/community-showcases/submit-to-showcase/page.tsx =====
// File: app/kreative/community-showcases/submit-to-showcase/page.tsx
'use client';

import React, { useState } from 'react';
import { Form, Input, Select, Button, Modal, message as antdMessage } from 'antd';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { TextArea } = Input;

type FormValues = {
  title: string;
  category: string;
  description: string;
  link?: string;
  tags?: string[];
};

export default function SubmitToShowcasePage(): JSX.Element {
  const [form] = Form.useForm<FormValues>();
  const router = useRouter();
  const [submitting, setSubmitting] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);

  const categories = [
    { label: 'Art', value: 'art' },
    { label: 'Design', value: 'design' },
    { label: 'Photography', value: 'photography' },
    { label: 'Music', value: 'music' },
  ];

  const onFinish = async (values: FormValues) => {
    setSubmitting(true);
    try {
      // TODO: plug into backend API when available (e.g. POST /api/showcases)
      // await fetch('/api/showcases', { method: 'POST', body: JSON.stringify(values) });

      antdMessage.success('Submission received');
      setModalVisible(true);
    } catch (e) {
      antdMessage.error("Une erreur est survenue lors de l'envoi.");
    } finally {
      setSubmitting(false);
    }
  };

  const onCancel = () => router.back();

  return (
    <KreativePageShell
      title="Submit to Showcase"
      subtitle="Share a project you‚Äôre proud of with the Kreative community showcase."
    >
      <Form<FormValues>
        form={form}
        layout="vertical"
        onFinish={onFinish}
        name="submitToShowcaseForm"
      >
        <Form.Item
          label="Project title"
          name="title"
          rules={[{ required: true, message: 'Please enter a title' }]}
        >
          <Input placeholder="e.g. Konnaxion Visualizer" allowClear />
        </Form.Item>

        <Form.Item
          label="Category"
          name="category"
          rules={[{ required: true, message: 'Please choose a category' }]}
        >
          <Select
            placeholder="Select a category"
            options={categories}
            showSearch
            filterOption={(input, option) =>
              (option?.label as string)
                .toLowerCase()
                .includes(input.toLowerCase())
            }
          />
        </Form.Item>

        <Form.Item
          label="Description"
          name="description"
          rules={[{ required: true, message: 'Please add a short description' }]}
        >
          <TextArea
            rows={5}
            placeholder="What is this project about?"
            allowClear
          />
        </Form.Item>

        <Form.Item label="Reference link (optional)" name="link">
          <Input placeholder="https://‚Ä¶" allowClear type="url" />
        </Form.Item>

        <Form.Item label="Tags (optional)" name="tags">
          <Select
            mode="tags"
            placeholder="Add tags"
            tokenSeparators={[',']}
            options={[]}
          />
        </Form.Item>

        <Form.Item style={{ marginTop: 16 }}>
          <Button onClick={onCancel} style={{ marginRight: 8 }}>
            Cancel
          </Button>
          <Button type="primary" htmlType="submit" loading={submitting}>
            Submit
          </Button>
        </Form.Item>
      </Form>

      <Modal
        open={modalVisible}
        onOk={() => {
          setModalVisible(false);
          router.push('/kreative/community-showcases');
        }}
        onCancel={() => setModalVisible(false)}
        okText="Ok"
        cancelButtonProps={{ style: { display: 'none' } }}
      >
        <p>
          Your project has been submitted for review. Moderators will evaluate
          your submission shortly.
        </p>
      </Modal>
    </KreativePageShell>
  );
}

===== END app/kreative/community-showcases/submit-to-showcase/page.tsx =====


===== BEGIN app/kreative/community-showcases/top-creators/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\community-showcases\top-creators\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { Table, Avatar, Select, Typography, Space, Button } from 'antd';
import type { ColumnsType } from 'antd/es/table';
import { TrophyOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { Title, Text } = Typography;

type TimeFrame = 'all-time' | 'this-month';

interface Creator {
  id: string;
  name: string;
  avatar: string;
  contributions: number;
  specialty: string;
}

const creatorsData: Creator[] = [
  {
    id: '1',
    name: 'Alice Johnson',
    avatar: 'https://via.placeholder.com/80.png?text=A',
    contributions: 125,
    specialty: 'Digital Art',
  },
  {
    id: '2',
    name: 'Bob Smith',
    avatar: 'https://via.placeholder.com/80.png?text=B',
    contributions: 110,
    specialty: 'Photography',
  },
  {
    id: '3',
    name: 'Carol Lee',
    avatar: 'https://via.placeholder.com/80.png?text=C',
    contributions: 105,
    specialty: 'Mixed Media',
  },
  {
    id: '4',
    name: 'David Kim',
    avatar: 'https://via.placeholder.com/80.png?text=D',
    contributions: 95,
    specialty: 'Painting',
  },
  {
    id: '5',
    name: 'Eva Martinez',
    avatar: 'https://via.placeholder.com/80.png?text=E',
    contributions: 88,
    specialty: 'Illustration',
  },
];

export default function TopCreatorsPage(): JSX.Element {
  const router = useRouter();
  const [timeFrame, setTimeFrame] = useState<TimeFrame>('all-time');

  const data = useMemo<Creator[]>(() => {
    return timeFrame === 'this-month' ? creatorsData.slice(0, 3) : creatorsData;
  }, [timeFrame]);

  const columns: ColumnsType<Creator> = [
    {
      title: 'Rank',
      key: 'rank',
      width: 80,
      render: (_value, _record, index) =>
        index < 3 ? (
          <TrophyOutlined style={{ fontSize: 20, color: '#faad14' }} />
        ) : (
          <Text>{index + 1}</Text>
        ),
    },
    {
      title: 'Creator',
      key: 'creator',
      width: 250,
      render: (_value, record) => (
        <Space>
          <Avatar src={record.avatar} />
          <Button
            type="link"
            onClick={() => router.push(`/kreative/profile/${record.id}`)}
          >
            {record.name}
          </Button>
        </Space>
      ),
    },
    {
      title: 'Contributions',
      dataIndex: 'contributions',
      key: 'contributions',
      width: 150,
      render: (value: number) => <Text>{value}</Text>,
    },
    {
      title: 'Specialty',
      dataIndex: 'specialty',
      key: 'specialty',
    },
  ];

  const timeframeSelector = (
    <Space>
      <Text strong>Filter by timeframe:</Text>
      <Select
        value={timeFrame}
        onChange={(value: TimeFrame) => setTimeFrame(value)}
        style={{ width: 180 }}
        options={[
          { value: 'all-time', label: 'All Time' },
          { value: 'this-month', label: 'This Month' },
        ]}
      />
    </Space>
  );

  return (
    <KreativePageShell
      title="Top Creators"
      subtitle="Leaderboard of creators with the most contributions across community showcases."
      secondaryActions={timeframeSelector}
    >
      <Space direction="vertical" size="middle" style={{ width: '100%' }}>
        <Title level={4} style={{ margin: 0 }}>
          Leaderboard
        </Title>

        <Table<Creator>
          columns={columns}
          dataSource={data}
          rowKey="id"
          pagination={{ pageSize: 5 }}
        />
      </Space>
    </KreativePageShell>
  );
}

===== END app/kreative/community-showcases/top-creators/page.tsx =====


===== BEGIN app/kreative/creative-hub/explore-ideas/page.tsx =====
'use client';

// File: C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\explore-ideas\page.tsx

import React, { useMemo, useState } from 'react';
import {
  Row,
  Col,
  Card,
  Input,
  Select,
  Typography,
  Space,
  Pagination,
  Button,
} from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { Title, Text, Paragraph } = Typography;

type Domain = 'Art' | 'Music' | 'Writing';
type SortOpt = 'newest' | 'popular';
type CategoryFilter = 'All' | Domain;

interface CreativeIdea {
  id: string;
  title: string;
  excerpt: string;
  author: string;
  domain: Domain;
  thumbnail: string;
  date: string; // ISO date
  popularity: number;
}

const creativeIdeasData: CreativeIdea[] = [
  {
    id: '1',
    title: 'The Beauty of Minimalism',
    excerpt: 'Exploring the art of less is more in design and creative expression.',
    author: 'Alice Martin',
    domain: 'Art',
    thumbnail: 'https://via.placeholder.com/300x200.png?text=Minimalism',
    date: '2025-11-20T10:00:00Z',
    popularity: 87,
  },
  {
    id: '2',
    title: 'Soundscapes: Music and Emotion',
    excerpt: 'How different chord progressions evoke specific emotional responses.',
    author: 'Brian Chen',
    domain: 'Music',
    thumbnail: 'https://via.placeholder.com/300x200.png?text=Soundscapes',
    date: '2025-11-18T14:30:00Z',
    popularity: 73,
  },
  {
    id: '3',
    title: 'Writing with Constraints',
    excerpt: 'Using constraints like lipograms to spark creativity.',
    author: 'Caroline Dupont',
    domain: 'Writing',
    thumbnail: 'https://via.placeholder.com/300x200.png?text=Constraints',
    date: '2025-11-15T09:00:00Z',
    popularity: 55,
  },
  {
    id: '4',
    title: 'Color Theory Basics',
    excerpt: 'Understanding complementary and analogous color schemes.',
    author: 'David Lopez',
    domain: 'Art',
    thumbnail: 'https://via.placeholder.com/300x200.png?text=Color+Theory',
    date: '2025-11-10T11:45:00Z',
    popularity: 61,
  },
];

export default function ExploreIdeasPage(): JSX.Element {
  const router = useRouter();

  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedCategory, setSelectedCategory] =
    useState<CategoryFilter>('All');
  const [sortOption, setSortOption] = useState<SortOpt>('newest');

  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 9;

  const filteredIdeas = useMemo<CreativeIdea[]>(() => {
    let ideas = [...creativeIdeasData];

    if (selectedCategory !== 'All') {
      ideas = ideas.filter((idea) => idea.domain === selectedCategory);
    }

    const q = searchQuery.trim().toLowerCase();
    if (q) {
      ideas = ideas.filter(
        (idea) =>
          idea.title.toLowerCase().includes(q) ||
          idea.excerpt.toLowerCase().includes(q),
      );
    }

    ideas =
      sortOption === 'newest'
        ? ideas.sort(
            (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime(),
          )
        : ideas.sort((a, b) => b.popularity - a.popularity);

    return ideas;
  }, [searchQuery, selectedCategory, sortOption]);

  const paginatedIdeas = useMemo<CreativeIdea[]>(() => {
    const startIndex = (currentPage - 1) * pageSize;
    return filteredIdeas.slice(startIndex, startIndex + pageSize);
  }, [filteredIdeas, currentPage]);

  const handleCardClick = (idea: CreativeIdea) => {
    router.push(`/kreative/creative-hub/idea/${idea.id}`);
  };

  return (
    <KreativePageShell
      title="Explore Ideas"
      subtitle="Browse curated prompts and articles across creative domains."
      primaryAction={
        <Button
          type="primary"
          onClick={() =>
            router.push('/kreative/idea-incubator/create-new-idea')
          }
        >
          Create New Idea
        </Button>
      }
    >
      <Space direction="vertical" size="middle" style={{ width: '100%' }}>
        <Space wrap>
          <Input
            placeholder="Search ideas"
            prefix={<SearchOutlined />}
            value={searchQuery}
            onChange={(e) => {
              setSearchQuery(e.target.value);
              setCurrentPage(1);
            }}
            style={{ width: 300 }}
            allowClear
          />

          <Select<CategoryFilter>
            value={selectedCategory}
            onChange={(value) => {
              setSelectedCategory(value);
              setCurrentPage(1);
            }}
            options={[
              { value: 'All', label: 'All Domains' },
              { value: 'Art', label: 'Art' },
              { value: 'Music', label: 'Music' },
              { value: 'Writing', label: 'Writing' },
            ]}
            style={{ width: 180 }}
          />

          <Select<SortOpt>
            value={sortOption}
            onChange={(value) => {
              setSortOption(value);
              setCurrentPage(1);
            }}
            options={[
              { value: 'newest', label: 'Newest' },
              { value: 'popular', label: 'Most Popular' },
            ]}
            style={{ width: 180 }}
          />
        </Space>

        <Row gutter={[24, 24]}>
          {paginatedIdeas.map((idea) => (
            <Col key={idea.id} xs={24} sm={12} md={8}>
              <Card
                hoverable
                cover={
                  <img
                    alt={idea.title}
                    src={idea.thumbnail}
                    style={{ height: 160, objectFit: 'cover' }}
                  />
                }
                onClick={() => handleCardClick(idea)}
              >
                <Title
                  level={4}
                  className="clamp-1"
                  style={{ marginBottom: 8 }}
                >
                  {idea.title}
                </Title>

                <Paragraph
                  className="clamp-2"
                  type="secondary"
                  style={{ marginBottom: 12 }}
                >
                  {idea.excerpt}
                </Paragraph>

                <Text strong>By: </Text>
                <Text>{idea.author}</Text>
              </Card>
            </Col>
          ))}
        </Row>

        <div style={{ textAlign: 'center', marginTop: 24 }}>
          <Pagination
            current={currentPage}
            pageSize={pageSize}
            total={filteredIdeas.length}
            onChange={(page) => setCurrentPage(page)}
            showSizeChanger={false}
          />
        </div>
      </Space>

      <style jsx>{`
        .clamp-1 {
          overflow: hidden;
          white-space: nowrap;
          text-overflow: ellipsis;
        }
        .clamp-2 {
          display: -webkit-box;
          -webkit-line-clamp: 2;
          -webkit-box-orient: vertical;
          overflow: hidden;
        }
      `}</style>
    </KreativePageShell>
  );
}

===== END app/kreative/creative-hub/explore-ideas/page.tsx =====


===== BEGIN app/kreative/creative-hub/inspiration-gallery/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\inspiration-gallery\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import {
  Row,
  Col,
  Card,
  Modal,
  Pagination,
  Tabs,
  Button,
  Typography,
  Space,
} from 'antd';
import { HeartOutlined, HeartFilled } from '@ant-design/icons';
import PageContainer from '@/components/PageContainer';

const { Title, Text, Paragraph } = Typography;

type Category = 'All' | 'Photography' | 'Painting' | 'Digital Art';

interface CreativeWork {
  id: string;
  title: string;
  description: string;
  creator: string;
  category: Exclude<Category, 'All'>;
  imageUrl: string;
  likes: number;
  liked?: boolean;
}

// Dummy data for the gallery
const dummyWorks: CreativeWork[] = [
  {
    id: '1',
    title: 'Sunset Overdrive',
    description: 'A breathtaking view of the sunset captured in high resolution.',
    creator: 'Alice Johnson',
    category: 'Photography',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Sunset',
    likes: 34,
    liked: false,
  },
  {
    id: '2',
    title: 'Abstract Colors',
    description: 'A vibrant abstract painting exploring the interplay of color.',
    creator: 'Bob Smith',
    category: 'Painting',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Abstract+Painting',
    likes: 58,
    liked: false,
  },
  {
    id: '3',
    title: 'Digital Dreams',
    description: 'A surreal piece of digital art mixing technology and imagination.',
    creator: 'Carla Gomez',
    category: 'Digital Art',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Digital+Art',
    likes: 72,
    liked: false,
  },
  {
    id: '4',
    title: 'City Reflections',
    description: 'A dramatic urban photograph showcasing reflections on wet streets.',
    creator: 'David Lee',
    category: 'Photography',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=City+Reflections',
    likes: 43,
    liked: false,
  },
  {
    id: '5',
    title: 'Impressionist Waves',
    description: 'An impressionist painting capturing the movement of ocean waves.',
    creator: 'Eva Martinez',
    category: 'Painting',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Impressionist+Waves',
    likes: 66,
    liked: false,
  },
  {
    id: '6',
    title: 'Virtual Reality',
    description: 'An innovative digital artwork blending real and virtual elements.',
    creator: 'Felix Zhang',
    category: 'Digital Art',
    imageUrl: 'https://via.placeholder.com/400x300.png?text=Virtual+Reality',
    likes: 51,
    liked: false,
  },
];

export default function InspirationGalleryPage(): JSX.Element {
  // State for category filtering, pagination, Modal, and works.
  const [selectedCategory, setSelectedCategory] = useState<Category>('All');
  const [currentPage, setCurrentPage] = useState<number>(1);
  const pageSize = 6;
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [selectedWork, setSelectedWork] = useState<CreativeWork | null>(null);
  const [works, setWorks] = useState<CreativeWork[]>(dummyWorks);

  // Tabs (AntD v5) items
  const tabItems = useMemo(
    () => [
      { key: 'All', label: 'All' },
      { key: 'Photography', label: 'Photography' },
      { key: 'Painting', label: 'Painting' },
      { key: 'Digital Art', label: 'Digital Art' },
    ],
    [],
  );

  // Filter works based on selected category.
  const filteredWorks = useMemo(() => {
    if (selectedCategory === 'All') return works;
    return works.filter((work) => work.category === selectedCategory);
  }, [selectedCategory, works]);

  // Paginate the filtered works.
  const paginatedWorks = useMemo(() => {
    const startIndex = (currentPage - 1) * pageSize;
    return filteredWorks.slice(startIndex, startIndex + pageSize);
  }, [filteredWorks, currentPage]);

  // Handle like toggle.
  const toggleLike = (id: string): void => {
    setWorks((prev) =>
      prev.map((w) =>
        w.id === id ? { ...w, liked: !w.liked, likes: w.liked ? w.likes - 1 : w.likes + 1 } : w,
      ),
    );
  };

  // Open Modal for work details.
  const openWorkModal = (work: CreativeWork): void => {
    setSelectedWork(work);
    setModalVisible(true);
  };

  // Close the details Modal.
  const closeModal = (): void => {
    setModalVisible(false);
    setSelectedWork(null);
  };

  return (
    <PageContainer title="Inspiration Gallery">
      {/* Category Filter (AntD v5 Tabs API) */}
      <Tabs
        activeKey={selectedCategory}
        onChange={(key) => {
          setSelectedCategory(key as Category);
          setCurrentPage(1);
        }}
        type="card"
        items={tabItems}
        style={{ marginBottom: 24 }}
      />

      {/* Gallery Grid */}
      <Row gutter={[16, 16]}>
        {paginatedWorks.map((work) => (
          <Col key={work.id} xs={24} sm={12} md={8}>
            <Card
              hoverable
              cover={
                <img
                  alt={work.title}
                  src={work.imageUrl}
                  style={{ height: 200, objectFit: 'cover' }}
                />
              }
              actions={[
                <Button
                  key="like"
                  type="text"
                  onClick={(e) => {
                    e.stopPropagation();
                    toggleLike(work.id);
                  }}
                >
                  {work.liked ? (
                    <HeartFilled style={{ color: 'red', fontSize: 18 }} />
                  ) : (
                    <HeartOutlined style={{ fontSize: 18 }} />
                  )}
                  <Text style={{ marginLeft: 4 }}>{work.likes}</Text>
                </Button>,
              ]}
              onClick={() => openWorkModal(work)}
            >
              <Card.Meta
                title={work.title}
                description={
                  <>
                    <Text>{work.creator}</Text>
                    <br />
                    {/* Replace ellipsis={{}} with CSS line clamp */}
                    <Paragraph type="secondary" className="lineClamp2">
                      {work.description}
                    </Paragraph>
                  </>
                }
              />
            </Card>
          </Col>
        ))}
      </Row>

      {/* Pagination */}
      <div style={{ textAlign: 'center', marginTop: 24 }}>
        <Pagination
          current={currentPage}
          pageSize={pageSize}
          total={filteredWorks.length}
          onChange={(page) => setCurrentPage(page)}
        />
      </div>

      {/* Modal for work details */}
      <Modal open={modalVisible} footer={null} onCancel={closeModal} width={800}>
        {selectedWork && (
          <>
            <img
              alt={selectedWork.title}
              src={selectedWork.imageUrl}
              style={{ width: '100%', maxHeight: 400, objectFit: 'contain' }}
            />
            <div style={{ marginTop: 16 }}>
              <Title level={3}>{selectedWork.title}</Title>
              <Text strong>By: </Text>
              <Text>{selectedWork.creator}</Text>
              <p style={{ marginTop: 12 }}>{selectedWork.description}</p>
              <Space>
                <Button type="text" onClick={() => toggleLike(selectedWork.id)}>
                  {selectedWork.liked ? (
                    <HeartFilled style={{ color: 'red', fontSize: 20 }} />
                  ) : (
                    <HeartOutlined style={{ fontSize: 20 }} />
                  )}
                  <Text style={{ marginLeft: 4 }}>{selectedWork.likes} Likes</Text>
                </Button>
              </Space>
            </div>
          </>
        )}
      </Modal>

      <style jsx>{`
        /* Multi-line clamp to replace AntD ellipsis { rows } */
        .lineClamp2 {
          display: -webkit-box;
          -webkit-line-clamp: 2;
          -webkit-box-orient: vertical;
          overflow: hidden;
        }
      `}</style>
    </PageContainer>
  );
}

===== END app/kreative/creative-hub/inspiration-gallery/page.tsx =====


===== BEGIN app/kreative/creative-hub/submit-creative-work/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\creative-hub\submit-creative-work\page.tsx
'use client';

import React, { useState } from 'react';
import {
  Form,
  Input,
  Button,
  Upload,
  Select,
  message as antdMessage,
  Alert,
} from 'antd';
import type { UploadFile } from 'antd/es/upload/interface';
import { UploadOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

type CreativeWorkFormValues = {
  title: string;
  description: string;
  category: string;
  credits?: string;
  creativeFile: UploadFile[];
};

// Type minimal utile pour le onChange d'Upload (√©vite implicit any)
type UploadChangeParamLite = {
  fileList: UploadFile[];
};

export default function SubmitCreativeWorkPage(): JSX.Element {
  const [form] = Form.useForm<CreativeWorkFormValues>();
  const [fileList, setFileList] = useState<UploadFile[]>([]);
  const router = useRouter();

  const handleUploadChange = (info: UploadChangeParamLite) => {
    setFileList(info.fileList);
  };

  // Normalise l'√©v√®nement Upload pour AntD Form
  const normFile = (e: UploadChangeParamLite | UploadFile[]) => {
    if (Array.isArray(e)) return e;
    return e?.fileList ?? [];
  };

  const onFinish = async (values: CreativeWorkFormValues) => {
    if (!fileList.length) {
      antdMessage.error('Veuillez joindre au moins un fichier.');
      return;
    }
    try {
      // TODO: remplacer par l'appel API r√©el d‚Äôenvoi
      // await api.submitCreativeWork(values, fileList)
      antdMessage.success('Cr√©ation envoy√©e avec succ√®s !');
      router.push('/kreative/dashboard');
    } catch {
      antdMessage.error("Erreur lors de l'envoi. R√©essayez.");
    }
  };

  return (
    <KreativePageShell
      title="Submit Creative Work"
      subtitle="Share your creative work with the community."
    >
      <Alert
        type="info"
        showIcon
        style={{ marginBottom: 16 }}
        message="Partagez votre travail cr√©atif avec la communaut√©."
      />

      <Form<CreativeWorkFormValues> layout="vertical" form={form} onFinish={onFinish}>
        <Form.Item
          label="Title"
          name="title"
          rules={[{ required: true, message: 'Please enter a title' }]}
        >
          <Input placeholder="e.g., Generative sculpture series" />
        </Form.Item>

        <Form.Item
          label="Description"
          name="description"
          rules={[{ required: true, message: 'Please add a description' }]}
        >
          <Input.TextArea rows={4} placeholder="What did you make? How? Why?" />
        </Form.Item>

        <Form.Item
          label="Category"
          name="category"
          rules={[{ required: true, message: 'Please pick a category' }]}
        >
          <Select placeholder="Choose one">
            <Select.Option value="art">Art</Select.Option>
            <Select.Option value="design">Design</Select.Option>
            <Select.Option value="music">Music</Select.Option>
            <Select.Option value="other">Other</Select.Option>
          </Select>
        </Form.Item>

        <Form.Item
          label="Upload"
          name="creativeFile"
          valuePropName="fileList"
          getValueFromEvent={normFile}
          rules={[
            {
              validator: (_, value: UploadFile[]) =>
                value && value.length
                  ? Promise.resolve()
                  : Promise.reject(new Error('Please attach at least one file')),
            },
          ]}
        >
          <Upload
            beforeUpload={() => false} // emp√™che l‚Äôupload auto, on laisse le form g√©rer
            multiple
            onChange={handleUploadChange}
            fileList={fileList}
          >
            <Button icon={<UploadOutlined />}>Select file(s)</Button>
          </Upload>
        </Form.Item>

        <Form.Item label="Credits" name="credits">
          <Input placeholder="Collaborators, references, tools‚Ä¶" />
        </Form.Item>

        <Form.Item>
          <Button type="primary" htmlType="submit">
            Submit
          </Button>
        </Form.Item>
      </Form>
    </KreativePageShell>
  );
}

===== END app/kreative/creative-hub/submit-creative-work/page.tsx =====


===== BEGIN app/kreative/dashboard/page.tsx =====
// app/kreative/dashboard/page.tsx
'use client';

import React from 'react';
import {
  Card,
  Avatar,
  Button,
  Carousel,
  List,
  Row,
  Col,
  Typography,
  Space,
} from 'antd';
import {
  PictureOutlined,
  BulbOutlined,
  UploadOutlined,
} from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import KreativePageShell from '@/app/kreative/kreativePageShell';

const { Title, Text } = Typography;

type QuickLink = {
  title: string;
  icon: React.ReactNode;
  href: string;
};

/** Featured Project */
const featuredProject = {
  title: 'Dreamscape: A Visual Journey',
  imageUrl: 'https://via.placeholder.com/600x300.png?text=Featured+Project',
};

/** Inspiration Gallery (carousel) */
const inspirationGallery = [
  { id: '1', imageUrl: 'https://via.placeholder.com/600x300.png?text=Art+1' },
  { id: '2', imageUrl: 'https://via.placeholder.com/600x300.png?text=Art+2' },
  { id: '3', imageUrl: 'https://via.placeholder.com/600x300.png?text=Art+3' },
  { id: '4', imageUrl: 'https://via.placeholder.com/600x300.png?text=Art+4' },
];

/** Top Creator */
const topCreator = {
  name: 'Sophia Rivera',
  avatar: 'https://via.placeholder.com/80.png?text=S',
  stats: '48 Projects ¬∑ 1200 Likes',
};

/** Quick Links (wired to existing Kreative routes) */
const quickLinks: QuickLink[] = [
  {
    title: 'Explore Ideas',
    icon: <BulbOutlined style={{ fontSize: 24 }} />,
    href: '/kreative/creative-hub/explore-ideas',
  },
  {
    title: 'Submit Work',
    icon: <UploadOutlined style={{ fontSize: 24 }} />,
    href: '/kreative/creative-hub/submit-creative-work',
  },
  {
    title: 'View Gallery',
    icon: <PictureOutlined style={{ fontSize: 24 }} />,
    href: '/kreative/creative-hub/inspiration-gallery',
  },
];

/** Recent Activity */
const recentActivities = [
  {
    id: 'a1',
    text: 'User John submitted a new Art piece in Photography',
    time: '2 hours ago',
  },
  {
    id: 'a2',
    text: 'User Emma started a new idea: ‚ÄúUrban Sketching‚Äù',
    time: '5 hours ago',
  },
  {
    id: 'a3',
    text: 'User Liam commented on ‚ÄúDreamscape: A Visual Journey‚Äù',
    time: '1 day ago',
  },
  {
    id: 'a4',
    text: 'User Olivia liked a work in Digital Art',
    time: '2 days ago',
  },
];

export default function KreativeDashboardPage(): JSX.Element {
  const router = useRouter();

  return (
    <KreativePageShell title="Kreative Dashboard">
      <Row gutter={[24, 24]}>
        {/* Featured Project Highlight */}
        <Col xs={24} md={16}>
          <Card
            hoverable
            cover={
              <img
                alt="Featured Project"
                src={featuredProject.imageUrl}
                style={{ objectFit: 'cover' }}
              />
            }
          >
            <Title level={3}>{featuredProject.title}</Title>
          </Card>
        </Col>

        {/* Top Creator Spotlight */}
        <Col xs={24} md={8}>
          <Card>
            <Space direction="vertical" align="center" style={{ width: '100%' }}>
              <Avatar size={80} src={topCreator.avatar} />
              <Title level={4} style={{ margin: 0 }}>
                {topCreator.name}
              </Title>
              <Text type="secondary">{topCreator.stats}</Text>
            </Space>
          </Card>
        </Col>
      </Row>

      <Row gutter={[24, 24]} style={{ marginTop: 24 }}>
        {/* Inspiration Gallery Preview */}
        <Col xs={24} md={16}>
          <Card title="Inspiration Gallery Preview">
            <Carousel autoplay dotPosition="bottom">
              {inspirationGallery.map((item) => (
                <div key={item.id}>
                  <img
                    alt={`Art ${item.id}`}
                    src={item.imageUrl}
                    style={{ width: '100%', height: 300, objectFit: 'cover' }}
                  />
                </div>
              ))}
            </Carousel>
          </Card>
        </Col>

        {/* Quick Links */}
        <Col xs={24} md={8}>
          <Card title="Quick Links">
            <Space direction="vertical" size="middle" style={{ width: '100%' }}>
              {quickLinks.map((link) => (
                <Button
                  key={link.title}
                  type="primary"
                  block
                  icon={link.icon}
                  onClick={() => router.push(link.href)}
                >
                  {link.title}
                </Button>
              ))}
            </Space>
          </Card>
        </Col>
      </Row>

      {/* Recent Activity Feed */}
      <Row gutter={[24, 24]} style={{ marginTop: 24 }}>
        <Col xs={24}>
          <Card title="Recent Activity">
            <List
              itemLayout="horizontal"
              dataSource={recentActivities}
              renderItem={(item) => (
                <List.Item>
                  <List.Item.Meta title={item.text} description={item.time} />
                </List.Item>
              )}
            />
          </Card>
        </Col>
      </Row>
    </KreativePageShell>
  );
}

===== END app/kreative/dashboard/page.tsx =====


===== BEGIN app/kreative/idea-incubator/collaborate-on-ideas/page.tsx =====
'use client';

import React, { useMemo, useState } from 'react';
import { List, Button, Badge, Input, Select, Space, Typography } from 'antd';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Title, Text } = Typography;

interface Idea {
  id: string;
  title: string;
  status: 'Seeking Collaboration' | 'In Progress';
  dateCreated: string; // YYYY-MM-DD
  newActivity: boolean;
}

const dummyIdeas: Idea[] = [
  {
    id: '1',
    title: 'Revolutionary App Concept',
    status: 'Seeking Collaboration',
    dateCreated: '2025-11-20',
    newActivity: true,
  },
  {
    id: '2',
    title: 'Sustainable Energy Initiative',
    status: 'In Progress',
    dateCreated: '2025-10-15',
    newActivity: false,
  },
  {
    id: '3',
    title: 'Urban Gardening Project',
    status: 'Seeking Collaboration',
    dateCreated: '2025-11-01',
    newActivity: true,
  },
];

type StatusFilter = 'All' | Idea['status'];

export default function CollaborateOnIdeasPage(): JSX.Element {
  const router = useRouter();

  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedStatus, setSelectedStatus] = useState<StatusFilter>('All');

  const filteredIdeas = useMemo<Idea[]>(() => {
    let ideas = dummyIdeas;
    if (selectedStatus !== 'All') {
      ideas = ideas.filter((idea) => idea.status === selectedStatus);
    }
    if (searchQuery.trim() !== '') {
      const q = searchQuery.toLowerCase();
      ideas = ideas.filter((idea) => idea.title.toLowerCase().includes(q));
    }
    return ideas;
  }, [searchQuery, selectedStatus]);

  return (
    <PageContainer title="Collaborate on Ideas">
      <Space direction="vertical" size="middle" style={{ width: '100%', marginBottom: 24 }}>
        <Space>
          <Input
            placeholder="Search by title..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            style={{ width: 300 }}
            allowClear
          />
          <Select<StatusFilter>
            value={selectedStatus}
            onChange={(value) => setSelectedStatus(value)}
            style={{ width: 220 }}
            options={[
              { value: 'All', label: 'All Status' },
              { value: 'Seeking Collaboration', label: 'Seeking Collaboration' },
              { value: 'In Progress', label: 'In Progress' },
            ]}
          />
        </Space>
      </Space>

      <List
        itemLayout="vertical"
        dataSource={filteredIdeas}
        renderItem={(idea) => (
          <List.Item
            key={idea.id}
            actions={[
              <Button
                key="edit"
                type="primary"
                onClick={() => router.push(`/kreative/idea-incubator/edit/${idea.id}`)}
              >
                Edit
              </Button>,
              <Button
                key="view"
                onClick={() => router.push(`/kreative/idea-incubator/view/${idea.id}`)}
              >
                View
              </Button>,
            ]}
          >
            <List.Item.Meta
              title={
                <Space>
                  {idea.newActivity && (
                    <Badge count="New" style={{ backgroundColor: '#52c41a' }} />
                  )}
                  <Title level={4} style={{ margin: 0 }}>
                    {idea.title}
                  </Title>
                </Space>
              }
              description={
                <>
                  <Text type="secondary">Status: {idea.status}</Text>
                  <br />
                  <Text type="secondary">Created on: {idea.dateCreated}</Text>
                </>
              }
            />
          </List.Item>
        )}
      />
    </PageContainer>
  );
}

===== END app/kreative/idea-incubator/collaborate-on-ideas/page.tsx =====


===== BEGIN app/kreative/idea-incubator/create-new-idea/page.tsx =====
'use client';

import React from 'react';
import { Form, Input, Select, Button, message as antdMessage } from 'antd';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';
// Note: MainLayout import removed because the /kreative layout handles the layout wrapper.

const { TextArea } = Input;
const { Option } = Select;

const CreateNewIdea: React.FC = () => {
  const [form] = Form.useForm();
  const router = useRouter();

  // Handler for form submission.
  const onFinish = (values: any) => {
    console.log('Submitted Idea:', values);
    antdMessage.success('Votre id√©e a √©t√© soumise avec succ√®s‚ÄØ!');
    // Redirect to the "My Ideas" page after submitting.
    router.push('/kreative/idea-incubator/my-ideas');
  };

  return (
    <PageContainer title="Create New Idea">
      <Form form={form} layout="vertical" onFinish={onFinish}>
        {/* Title Field */}
        <Form.Item
          label="Title of Idea"
          name="title"
          rules={[{ required: true, message: 'Veuillez saisir le titre de votre id√©e.' }]}
        >
          <Input placeholder="Enter title of your idea" />
        </Form.Item>

        {/* Detailed Description Field */}
        <Form.Item
          label="Detailed Description"
          name="description"
          rules={[{ required: true, message: 'Veuillez saisir une description d√©taill√©e de votre id√©e.' }]}
        >
          <TextArea
            rows={6}
            placeholder="Explain your idea, including the problem it solves or your vision"
          />
        </Form.Item>

        {/* Category / Field Selector */}
        <Form.Item
          label="Category / Field"
          name="category"
          rules={[{ required: true, message: 'Veuillez s√©lectionner une cat√©gorie.' }]}
        >
          <Select placeholder="Select a category">
            <Option value="Technology">Technology</Option>
            <Option value="Art">Art</Option>
            <Option value="Education">Education</Option>
            <Option value="Health">Health</Option>
            <Option value="Environment">Environment</Option>
          </Select>
        </Form.Item>

        {/* (Optional) Resources Needed / Skills Required - omitted for now */}

        {/* Submit Button */}
        <Form.Item>
          <Button type="primary" htmlType="submit">
            Submit Idea
          </Button>
        </Form.Item>
      </Form>
    </PageContainer>
  );
};

export default CreateNewIdea;

===== END app/kreative/idea-incubator/create-new-idea/page.tsx =====


===== BEGIN app/kreative/idea-incubator/my-ideas/page.tsx =====
// C:\MyCode\Konnaxionv14\frontend\app\kreative\idea-incubator\my-ideas\page.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { Badge, Button, Input, List, Select, Space, Typography } from 'antd';
import { useRouter } from 'next/navigation';
import PageContainer from '@/components/PageContainer';

const { Title, Text } = Typography;

type IdeaStatus = 'Seeking Collaboration' | 'In Progress';
type StatusFilter = 'All' | IdeaStatus;

interface Idea {
  id: string;
  title: string;
  status: IdeaStatus;
  dateCreated: string; // YYYY-MM-DD
  newActivity: boolean;
}

const dummyIdeas: Idea[] = [
  {
    id: '1',
    title: 'Revolutionary App Concept',
    status: 'Seeking Collaboration',
    dateCreated: '2025-11-20',
    newActivity: true,
  },
  {
    id: '2',
    title: 'Sustainable Energy Initiative',
    status: 'In Progress',
    dateCreated: '2025-10-15',
    newActivity: false,
  },
  {
    id: '3',
    title: 'Urban Gardening Project',
    status: 'Seeking Collaboration',
    dateCreated: '2025-11-01',
    newActivity: true,
  },
];

export default function MyIdeasPage(): JSX.Element {
  const router = useRouter();

  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedStatus, setSelectedStatus] = useState<StatusFilter>('All');

  const filteredIdeas = useMemo<Idea[]>(() => {
    let ideas = dummyIdeas;
    if (selectedStatus !== 'All') {
      ideas = ideas.filter((idea) => idea.status === selectedStatus);
    }
    if (searchQuery.trim()) {
      const q = searchQuery.toLowerCase();
      ideas = ideas.filter((idea) => idea.title.toLowerCase().includes(q));
    }
    return ideas;
  }, [searchQuery, selectedStatus]);

  return (
    <PageContainer title="My Ideas">
      <Space direction="vertical" size="middle" style={{ width: '100%', marginBottom: 24 }}>
        <Space>
          <Input
            placeholder="Search by title."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            style={{ width: 300 }}
            allowClear
          />
          <Select<StatusFilter>
            value={selectedStatus}
            onChange={(value) => setSelectedStatus(value)}
            style={{ width: 220 }}
            options={[
              { value: 'All', label: 'All Status' },
              { value: 'Seeking Collaboration', label: 'Seeking Collaboration' },
              { value: 'In Progress', label: 'In Progress' },
            ]}
          />
        </Space>
      </Space>

      <List<Idea>
        itemLayout="vertical"
        dataSource={filteredIdeas}
        renderItem={(idea) => (
          <List.Item
            key={idea.id}
            actions={[
              <Button
                key="edit"
                type="primary"
                onClick={() => router.push(`/kreative/idea-incubator/edit/${idea.id}`)}
              >
                Edit
              </Button>,
              <Button
                key="view"
                onClick={() => router.push(`/kreative/idea-incubator/view/${idea.id}`)}
              >
                View
              </Button>,
            ]}
          >
            <List.Item.Meta
              title={
                <Space>
                  {idea.newActivity && (
                    <Badge count="New" style={{ backgroundColor: '#52c41a' }} />
                  )}
                  <Title level={4} style={{ margin: 0 }}>
                    {idea.title}
                  </Title>
                </Space>
              }
              description={
                <>
                  <Text type="secondary">Status: {idea.status}</Text>
                  <br />
                  <Text type="secondary">Created on: {idea.dateCreated}</Text>
                </>
              }
            />
          </List.Item>
        )}
      />
    </PageContainer>
  );
}

===== END app/kreative/idea-incubator/my-ideas/page.tsx =====


===== BEGIN app/kreative/kreativePageShell.tsx =====
'use client';

import React, { ReactNode } from 'react';
import { Typography, Space } from 'antd';

const { Title, Paragraph } = Typography;

type KreativePageShellProps = {
  /** Main page title (no extra <h1> in the page) */
  title: string;
  /** Optional subtitle / helper text under the title */
  subtitle?: string;
  /** Primary action on the right (e.g. main CTA button) */
  primaryAction?: ReactNode;
  /** Secondary actions on the right (e.g. ghost buttons, filters) */
  secondaryActions?: ReactNode;
  /** Main page content */
  children: ReactNode;
};

/**
 * Central layout wrapper for Kreative pages.
 *
 * Usage rules:
 * - Pas de gros <h1> / Title suppl√©mentaire dans les pages elles‚Äëm√™mes.
 * - Pas de fil d‚ÄôAriane ici (utiliser celui du layout global si besoin).
 * - Toutes les pages Kreative devraient utiliser ce shell pour garder
 *   le m√™me padding, la m√™me hi√©rarchie de titres, etc.
 */
export default function KreativePageShell({
  title,
  subtitle,
  primaryAction,
  secondaryActions,
  children,
}: KreativePageShellProps): JSX.Element {
  const hasActions = Boolean(primaryAction || secondaryActions);

  return (
    <div className="container mx-auto p-5">
      {/* Header */}
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div>
          <Title level={2} style={{ marginBottom: subtitle ? 4 : 0 }}>
            {title}
          </Title>
          {subtitle && (
            <Paragraph type="secondary" style={{ marginBottom: 0 }}>
              {subtitle}
            </Paragraph>
          )}
        </div>

        {hasActions && (
          <Space wrap>
            {secondaryActions}
            {primaryAction}
          </Space>
        )}
      </div>

      {/* Main content */}
      <div>{children}</div>
    </div>
  );
}

===== END app/kreative/kreativePageShell.tsx =====


===== BEGIN app/kreative/layout.tsx =====
import React, { Suspense } from 'react'
import MainLayout from '@/components/layout-components/MainLayout'

export default function SegmentLayout({ children }: { children: React.ReactNode }) {
  return (
    <Suspense fallback={null}>
      <MainLayout>{children}</MainLayout>
    </Suspense>
  )
}
===== END app/kreative/layout.tsx =====


===== BEGIN app/layout.tsx =====
// app/layout.tsx
import '@/styles/tailwind.css'                // ‚Üê global Tailwind + reset AntD
import { ThemeProvider } from '@/context/ThemeContext'
import QueryProvider from '@/shared/QueryProvider'
import "../src/dayjs-setup"
import AuthProvider from './providers/AuthProvider'

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <ThemeProvider>
          <QueryProvider>
            <AuthProvider>
              {children}
            </AuthProvider>
          </QueryProvider>
        </ThemeProvider>
      </body>
    </html>
  )
}

===== END app/layout.tsx =====


===== BEGIN app/page.tsx =====
// app/page.tsx
import PageContainer from "@/components/PageContainer";

export const metadata = {
  title: "Accueil",
  description: "Point d‚Äôentr√©e",
};

export default function Page() {
  return (
    <PageContainer title="Accueil">
      <p>Bienvenue. Cette page affiche uniquement le PageContainer et son contenu.</p>
    </PageContainer>
  );
}

===== END app/page.tsx =====


===== BEGIN app/providers/AuthProvider.tsx =====
// app/providers/AuthProvider.tsx
'use client';

import React from 'react';

/**
 * Auth provider wrapper for App Router.
 * No SDK import needed ‚Äî Auth0 sessions are handled by middleware.
 */
export default function AuthProvider({ children }: { children: React.ReactNode }) {
  return <>{children}</>;
}

===== END app/providers/AuthProvider.tsx =====

