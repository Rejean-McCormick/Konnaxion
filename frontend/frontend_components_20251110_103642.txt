===== TOC (64 fichiers) =====
1. C:\MyCode\Konnaxionv14\frontend\components\activity-components\index.tsx
2. C:\MyCode\Konnaxionv14\frontend\components\activity-components\RecentComments.tsx
3. C:\MyCode\Konnaxionv14\frontend\components\activity-components\RecentLikes.tsx
4. C:\MyCode\Konnaxionv14\frontend\components\activity-components\RecentVisits.tsx
5. C:\MyCode\Konnaxionv14\frontend\components\activity-components\style.tsx
6. C:\MyCode\Konnaxionv14\frontend\components\auth0-components\index.tsx
7. C:\MyCode\Konnaxionv14\frontend\components\Button\Button.stories.tsx
8. C:\MyCode\Konnaxionv14\frontend\components\Button\Button.tsx
9. C:\MyCode\Konnaxionv14\frontend\components\charts\ChartCard.tsx
10. C:\MyCode\Konnaxionv14\frontend\components\compat\Comment.tsx
11. C:\MyCode\Konnaxionv14\frontend\components\compat\Icon.tsx
12. C:\MyCode\Konnaxionv14\frontend\components\concatv3.py
13. C:\MyCode\Konnaxionv14\frontend\components\CustomComment.tsx
14. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\CommentCard.tsx
15. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\index.tsx
16. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\LikeCard.tsx
17. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\LineChart.tsx
18. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\SculptureTable.tsx
19. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\StatisticCard.tsx
20. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\style.tsx
21. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\UserCard.tsx
22. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\UserPieChart.tsx
23. C:\MyCode\Konnaxionv14\frontend\components\dashboard-components\VisitCard.tsx
24. C:\MyCode\Konnaxionv14\frontend\components\layout-components\Drawer.tsx
25. C:\MyCode\Konnaxionv14\frontend\components\layout-components\Header.tsx
26. C:\MyCode\Konnaxionv14\frontend\components\layout-components\LogoTitle.tsx
27. C:\MyCode\Konnaxionv14\frontend\components\layout-components\Main.tsx
28. C:\MyCode\Konnaxionv14\frontend\components\layout-components\MainLayout.tsx
29. C:\MyCode\Konnaxionv14\frontend\components\layout-components\Menu.tsx
30. C:\MyCode\Konnaxionv14\frontend\components\layout-components\Sider.tsx
31. C:\MyCode\Konnaxionv14\frontend\components\Loading.tsx
32. C:\MyCode\Konnaxionv14\frontend\components\map-components\ControlPanel.tsx
33. C:\MyCode\Konnaxionv14\frontend\components\map-components\index.tsx
34. C:\MyCode\Konnaxionv14\frontend\components\map-components\Map.tsx
35. C:\MyCode\Konnaxionv14\frontend\components\map-components\MapMarker.tsx
36. C:\MyCode\Konnaxionv14\frontend\components\map-components\StaticMap.tsx
37. C:\MyCode\Konnaxionv14\frontend\components\PageContainer.tsx
38. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\CreateForm\CreateFormTextFields.tsx
39. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\CreateForm\index.tsx
40. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\CreateForm\MakerCreate.tsx
41. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\CreateForm\SculptureCreate.tsx
42. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\CreateForm\SculptureUploadImage.tsx
43. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\EditForm\EditFormTextFields.tsx
44. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\EditForm\EditImage.tsx
45. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\EditForm\index.tsx
46. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\EditForm\MakerEdit.tsx
47. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\EditForm\SculptureEdit.tsx
48. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\MakerList.tsx
49. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\SculptureDetail\index.tsx
50. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\SculptureDetail\SculptureComment.tsx
51. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\SculptureDetail\SculptureTrend.tsx
52. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\SculptureGrid.tsx
53. C:\MyCode\Konnaxionv14\frontend\components\sculpture-maker-components\style.tsx
54. C:\MyCode\Konnaxionv14\frontend\components\shared\utils.tsx
55. C:\MyCode\Konnaxionv14\frontend\components\TagsList.tsx
56. C:\MyCode\Konnaxionv14\frontend\components\Tooltip\Tooltip.tsx
57. C:\MyCode\Konnaxionv14\frontend\components\user-components\index.tsx
58. C:\MyCode\Konnaxionv14\frontend\components\user-components\style.tsx
59. C:\MyCode\Konnaxionv14\frontend\components\user-components\UserComments.tsx
60. C:\MyCode\Konnaxionv14\frontend\components\user-components\UserLikes.tsx
61. C:\MyCode\Konnaxionv14\frontend\components\user-components\UserProfile.tsx
62. C:\MyCode\Konnaxionv14\frontend\components\user-components\UserVisit.tsx
63. C:\MyCode\Konnaxionv14\frontend\src\components\CommonWidget\page.tsx
64. C:\MyCode\Konnaxionv14\frontend\src\components\ThemeSwitcher.tsx
===== END TOC =====


===== BEGIN components/activity-components/index.tsx =====
'use client';

import React from 'react';
import { Card, Col, Row, Typography, List } from 'antd';
import { api } from '@/shared/api';

const { Title } = Typography;

interface ActivityItem {
  id: string;
  title: string;
  date: string;
  description?: string;
}

/**
 * Composant d'activité principale
 * - Correction : ne relit plus `.data` d'une réponse déjà déballée
 * - Typage explicite des données et suppression des `any`
 * - Conserve compatibilité avec Axios configuré dans `shared/api.ts`
 */
const ActivityDashboard: React.FC = () => {
  const [recentComments, setRecentComments] = React.useState<ActivityItem[]>([]);
  const [recentLikes, setRecentLikes] = React.useState<ActivityItem[]>([]);
  const [recentVisits, setRecentVisits] = React.useState<ActivityItem[]>([]);

  React.useEffect(() => {
    const fetchAll = async () => {
      try {
        // Le client `api` retourne déjà la payload, pas besoin de `.data`
        const [comments, likes, visits] = await Promise.all([
          api.get<ActivityItem[]>('/activity/recent-comments'),
          api.get<ActivityItem[]>('/activity/recent-likes'),
          api.get<ActivityItem[]>('/activity/recent-visits'),
        ]);

        setRecentComments(comments);
        setRecentLikes(likes);
        setRecentVisits(visits);
      } catch (err) {
        console.error('Error fetching activities:', err);
      }
    };

    fetchAll();
  }, []);

  return (
    <div className="p-6">
      <Title level={2}>Recent Activity</Title>
      <Row gutter={[16, 16]}>
        <Col xs={24} md={8}>
          <Card title="Recent Comments" bordered>
            <List
              dataSource={recentComments}
              renderItem={(item) => (
                <List.Item key={item.id}>
                  <List.Item.Meta
                    title={item.title}
                    description={item.date}
                  />
                </List.Item>
              )}
            />
          </Card>
        </Col>

        <Col xs={24} md={8}>
          <Card title="Recent Likes" bordered>
            <List
              dataSource={recentLikes}
              renderItem={(item) => (
                <List.Item key={item.id}>
                  <List.Item.Meta
                    title={item.title}
                    description={item.date}
                  />
                </List.Item>
              )}
            />
          </Card>
        </Col>

        <Col xs={24} md={8}>
          <Card title="Recent Visits" bordered>
            <List
              dataSource={recentVisits}
              renderItem={(item) => (
                <List.Item key={item.id}>
                  <List.Item.Meta
                    title={item.title}
                    description={item.date}
                  />
                </List.Item>
              )}
            />
          </Card>
        </Col>
      </Row>
    </div>
  );
};

export default ActivityDashboard;

===== END components/activity-components/index.tsx =====


===== BEGIN components/activity-components/RecentComments.tsx =====
'use client';

import React, { useMemo } from 'react';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import Link from 'next/link';
import {
  Card,
  List,
  Avatar,
  Typography,
  Dropdown,
  Modal,
  Tooltip,
  Space,
  Button,
  message as antdMessage,
} from 'antd';
import type { MenuProps } from 'antd';
import {
  ExclamationCircleOutlined,
  EllipsisOutlined,
  DeleteOutlined,
} from '@ant-design/icons';

import api from '@/services/_request';
import { normalizeError } from '../../shared/errors';

dayjs.extend(relativeTime);

const { Text } = Typography;

export interface RecentCommentUser {
  userId: string;
  nickname?: string | null;
  name?: string | null;
  picture?: string | null;
}

export interface RecentCommentSculpture {
  accessionId: string | number;
  name: string;
}

export interface RecentCommentItem {
  commentId: string;
  content: string;
  createdTime: string; // ISO 8601
  user: RecentCommentUser;
  sculpture: RecentCommentSculpture;
}

export interface RecentCommentsProps {
  comments: RecentCommentItem[];
  deleteComment: (commentId: string) => void;
}

const RecentComments: React.FC<RecentCommentsProps> = ({
  comments,
  deleteComment,
}) => {
  // Avoid mutating props. Sort newest first.
  const items = useMemo<RecentCommentItem[]>(
    () =>
      [...comments].sort(
        (a, b) => Date.parse(b.createdTime) - Date.parse(a.createdTime),
      ),
    [comments],
  );

  const onMenuClick: MenuProps['onClick'] = ({ key }) => {
    Modal.confirm({
      title: 'Delete this comment permanently?',
      icon: <ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />,
      style: { top: 110 },
      maskClosable: true,
      okText: 'Confirm',
      okButtonProps: { style: { background: '#ff4d4f', borderColor: '#ff4d4f' } },
      onOk: async () => {
        try {
          await api.delete(`/comment/${String(key)}`);
          antdMessage.success('Deleted comment successfully!', 2);
          deleteComment(String(key));
        } catch (error) {
          const norm = normalizeError(error as unknown) as { message?: string };
          antdMessage.error(norm?.message || 'Failed to delete');
        }
      },
    });
  };

  return (
    <Card title="Recent Comments" bodyStyle={{ padding: '20px 24px 0px' }} bordered={false}>
      <List<RecentCommentItem>
        itemLayout="horizontal"
        dataSource={items}
        className="comment-list"
        pagination={{ pageSize: 15, hideOnSinglePage: true }}
        renderItem={(x) => {
          const name = x.user.userId.includes('auth0')
            ? x.user.nickname ?? x.user.name ?? 'User'
            : x.user.name ?? x.user.nickname ?? 'User';

          return (
            <List.Item
              key={x.commentId}
              actions={[
                <Dropdown
                  key="more"
                  trigger={['click']}
                  menu={{
                    items: [
                      {
                        key: x.commentId,
                        label: 'Delete comment',
                        icon: <DeleteOutlined />,
                      },
                    ],
                    onClick: onMenuClick,
                  }}
                >
                  <Button type="text" aria-label="More actions" icon={<EllipsisOutlined />} />
                </Dropdown>,
              ]}
            >
              <List.Item.Meta
                avatar={
                  <Avatar src={x.user.picture ?? undefined} alt={name}>
                    {!x.user.picture && name.charAt(0).toUpperCase()}
                  </Avatar>
                }
                title={
                  <Space size={8} wrap>
                    <Link href={`/users/id/${x.user.userId}`}>
                      <Text strong>{name}</Text>
                    </Link>
                    <Tooltip title={dayjs(x.createdTime).format('D MMMM YYYY, h:mm:ss a')}>
                      <Text type="secondary">{dayjs(x.createdTime).fromNow()} in</Text>
                    </Tooltip>
                    <Link href={`/sculptures/id/${String(x.sculpture.accessionId)}`}>
                      <Text>{x.sculpture.name}</Text>
                    </Link>
                  </Space>
                }
                description={
                  <div style={{ fontSize: 14, whiteSpace: 'pre-wrap' }}>
                    {x.content?.trim() ?? ''}
                  </div>
                }
              />
            </List.Item>
          );
        }}
      />
    </Card>
  );
};

export default RecentComments;

===== END components/activity-components/RecentComments.tsx =====


===== BEGIN components/activity-components/RecentLikes.tsx =====
// components/activity-components/RecentLikes.tsx
'use client';

import React from 'react';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import { Card, List, Tooltip, Avatar, Typography, Space } from 'antd';
import Link from 'next/link';

dayjs.extend(relativeTime);

const { Text } = Typography;

export interface RecentLike {
  likedTime: string | Date;
  user: {
    userId: string;          // used with .includes('auth0')
    nickname?: string;
    name?: string;
    picture?: string;
  };
  sculpture: {
    accessionId: string | number;
    name: string;
  };
}

export interface RecentLikesProps {
  likes: RecentLike[];
}

const RecentLikes: React.FC<RecentLikesProps> = ({ likes }) => {
  const sortedLikes: RecentLike[] = [...likes].sort(
    (a, b) =>
      new Date(b.likedTime).getTime() - new Date(a.likedTime).getTime()
  );

  return (
    <Card title="Recent Likes" bodyStyle={{ padding: '20px 24px 0px' }} bordered={false}>
      <List
        itemLayout="horizontal"
        dataSource={sortedLikes ?? []}
        renderItem={(x: RecentLike) => {
          const displayName =
            x.user.userId.includes('auth0')
              ? x.user.nickname ?? x.user.name ?? 'User'
              : x.user.name ?? x.user.nickname ?? 'User';

          return (
            <List.Item
              key={`${x.user.userId}-${x.sculpture.accessionId}-${String(x.likedTime)}`}
            >
              <List.Item.Meta
                avatar={
                  <Avatar
                    src={x.user.picture}
                    size={42}
                    style={{ objectFit: 'cover' }}
                  >
                    {!x.user.picture && (displayName[0]?.toUpperCase() ?? '?')}
                  </Avatar>
                }
                title={
                  <Space size={4} wrap>
                    <Link href={`/users/id/${x.user.userId}`}>
                      <Text strong style={{ fontSize: 14, color: 'rgba(0, 0, 0, 0.65)' }}>
                        {displayName}
                      </Text>
                    </Link>
                    <Text style={{ fontSize: 14, color: 'rgba(0, 0, 0, 0.65)' }}>
                      liked
                    </Text>
                    <Link href={`/sculptures/id/${x.sculpture.accessionId}`}>
                      <Text style={{ fontSize: 14 }}>{x.sculpture.name}</Text>
                    </Link>
                  </Space>
                }
                description={
                  <Tooltip title={dayjs(x.likedTime).format('D MMMM YYYY, h:mm:ss a')}>
                    <Text style={{ fontSize: 14, color: 'rgba(0, 0, 0, 0.35)' }}>
                      {dayjs(x.likedTime).fromNow()}
                    </Text>
                  </Tooltip>
                }
              />
            </List.Item>
          );
        }}
        pagination={{ pageSize: 15, hideOnSinglePage: true }}
      />
    </Card>
  );
};

export default RecentLikes;

===== END components/activity-components/RecentLikes.tsx =====


===== BEGIN components/activity-components/RecentVisits.tsx =====
/**
 * Description: Recent visits component
 * Author: Hieu Chu
 */

import dayjs from 'dayjs'
import { Tooltip, List, Card } from 'antd'
import { Comment } from '@ant-design/compatible'
import Link from 'next/link'

type VisitItem = {
  visitTime: string | Date
  user: {
    userId: string
    nickname?: string
    name?: string
    picture: string
  }
  sculpture: {
    accessionId: string
    name: string
  }
}

type RecentVisitsProps = {
  visits: VisitItem[]
}

const RecentVisits = ({ visits }: RecentVisitsProps) => {
  const sorted = [...visits].sort(
    (a, b) => new Date(b.visitTime).getTime() - new Date(a.visitTime).getTime()
  )

  const formattedComments = sorted.map(x => ({
    key: `${x.user.userId}-${x.visitTime}-${x.sculpture.accessionId}`,
    author: (
      <Link
        href={`/users/id/${x.user.userId}`}
        style={{ fontSize: 14, fontWeight: 500, color: 'rgba(0, 0, 0, 0.65)' }}
      >
        {x.user.userId.includes('auth0') ? x.user.nickname : x.user.name}
      </Link>
    ),
    avatar: (
      <img
        src={x.user.picture}
        alt=""
        style={{
          width: 42,
          height: 42,
          borderRadius: '50%',
          objectFit: 'cover'
        }}
      />
    ),
    content: (
      <div style={{ fontSize: 14 }}>
        <Tooltip title={dayjs(x.visitTime).format('D MMMM YYYY, h:mm:ss a')}>
          <span style={{ fontSize: 14, color: 'rgba(0, 0, 0, 0.35)' }}>
            {dayjs(x.visitTime).fromNow()}
          </span>
        </Tooltip>
      </div>
    ),
    datetime: (
      <div>
        <span style={{ fontSize: 14, color: 'rgba(0, 0, 0, 0.35)' }}>
          visited{' '}
        </span>
        <Link
          href={`/sculptures/id/${x.sculpture.accessionId}`}
          style={{ fontSize: 14 }}
        >
          {x.sculpture.name}
        </Link>
      </div>
    )
  }))

  return (
    <Card
      title="Recent Visits"
      bodyStyle={{ padding: '20px 24px 0px' }}
      variant="borderless"
      style={{ marginTop: 12 }}
    >
      <List
        itemLayout="horizontal"
        dataSource={formattedComments ?? []}
        className="comment-list"
        renderItem={item => (
          <li key={item.key}>
            <Comment
              author={item.author}
              avatar={item.avatar}
              content={item.content}
              datetime={item.datetime}
              className="comment"
            />
          </li>
        )}
        pagination={{ pageSize: 15, hideOnSinglePage: true }}
      />
    </Card>
  )
}

export default RecentVisits

===== END components/activity-components/RecentVisits.tsx =====


===== BEGIN components/activity-components/style.tsx =====
/**
 * Description: Stylesheet for recent activity components
 * Author: Hieu Chu
 */

import React, { CSSProperties, ForwardedRef } from 'react';
import styled from 'styled-components';
import { Card, Col, Form, Typography, Empty, Table } from 'antd';
import type { SVGProps } from 'react';
import {
  LikeOutlined,
  LikeFilled,
  LikeTwoTone,
  DislikeOutlined,
  DislikeFilled,
  DislikeTwoTone,
  MessageOutlined,
  MessageFilled,
  StarOutlined,
  StarFilled,
  StarTwoTone,
  HeartOutlined,
  HeartFilled,
  HeartTwoTone,
  ShareAltOutlined,
  EyeOutlined,
  EyeFilled,
  EditOutlined,
  DeleteOutlined,
  PlusOutlined,
  MinusOutlined,
  CheckOutlined,
  CloseOutlined,
  WarningOutlined,
  InfoCircleOutlined,
  QuestionCircleOutlined,
  CalendarOutlined,
  ClockCircleOutlined,
  UserOutlined,
  TeamOutlined,
  BellOutlined,
  SearchOutlined,
  FilterOutlined,
  SettingOutlined,
  LoadingOutlined,
} from '@ant-design/icons';

const { Text } = Typography;

/* --------------------------------------------------------------------------------
   AntD v5 does not export a generic <Icon />.
   Shim to keep usages like <DescriptionIcon type="like" /> working.
-------------------------------------------------------------------------------- */

type LegacyIconName =
  | 'like' | 'like-filled' | 'like-two-tone'
  | 'dislike' | 'dislike-filled' | 'dislike-two-tone'
  | 'message' | 'message-filled'
  | 'star' | 'star-filled' | 'star-two-tone'
  | 'heart' | 'heart-filled' | 'heart-two-tone'
  | 'share' | 'eye' | 'eye-filled'
  | 'edit' | 'delete' | 'plus' | 'minus'
  | 'check' | 'close' | 'warning' | 'info' | 'question'
  | 'calendar' | 'clock' | 'user' | 'team' | 'bell' | 'search' | 'filter' | 'setting'
  | 'loading';

/** All AntD icons share the same component type. */
type AnyAntdIcon = typeof LikeOutlined;

const ICON_MAP: Record<LegacyIconName, AnyAntdIcon> = {
  like: LikeOutlined,
  'like-filled': LikeFilled,
  'like-two-tone': LikeTwoTone,
  dislike: DislikeOutlined,
  'dislike-filled': DislikeFilled,
  'dislike-two-tone': DislikeTwoTone,
  message: MessageOutlined,
  'message-filled': MessageFilled,
  star: StarOutlined,
  'star-filled': StarFilled,
  'star-two-tone': StarTwoTone,
  heart: HeartOutlined,
  'heart-filled': HeartFilled,
  'heart-two-tone': HeartTwoTone,
  share: ShareAltOutlined,
  eye: EyeOutlined,
  'eye-filled': EyeFilled,
  edit: EditOutlined,
  delete: DeleteOutlined,
  plus: PlusOutlined,
  minus: MinusOutlined,
  check: CheckOutlined,
  close: CloseOutlined,
  warning: WarningOutlined,
  info: InfoCircleOutlined,
  question: QuestionCircleOutlined,
  calendar: CalendarOutlined,
  clock: ClockCircleOutlined,
  user: UserOutlined,
  team: TeamOutlined,
  bell: BellOutlined,
  search: SearchOutlined,
  filter: FilterOutlined,
  setting: SettingOutlined,
  loading: LoadingOutlined,
};

export type IconProps = {
  /** Legacy name, e.g. 'like', 'star-filled', 'heart-two-tone', 'loading' */
  type?: LegacyIconName;
  /** Custom SVG React component (legacy `<Icon component={...} />` usage) */
  component?: React.ComponentType<SVGProps<SVGSVGElement>>;
  rotate?: number;
  spin?: boolean;
  /** Matches AntD twoTone type: string or [primary, secondary] */
  twoToneColor?: string | [string, string];
  className?: string;
  style?: CSSProperties;
  title?: string;
  onClick?: React.MouseEventHandler<HTMLSpanElement>;
} & Omit<React.HTMLAttributes<HTMLSpanElement>, 'onClick' | 'title'>;

/** Local Icon shim */
export const Icon = React.forwardRef<HTMLSpanElement, IconProps>(function LegacyIcon(
  { type, component: CustomSvg, rotate, spin, twoToneColor, className, style, title, onClick, ...rest },
  ref
) {
  // Custom SVG support
  if (CustomSvg) {
    const Comp = CustomSvg;
    const wrapperStyle: CSSProperties = {
      display: 'inline-flex',
      lineHeight: 0,
      verticalAlign: 'middle',
      ...(rotate ? { transform: `rotate(${rotate}deg)` } : null),
      ...(spin ? { animation: 'antIconSpin 1s linear infinite' } : null),
      ...style,
    };
    return (
      <span ref={ref} className={className} style={wrapperStyle} onClick={onClick} title={title} {...rest}>
        <Comp width="1em" height="1em" fill="currentColor" focusable="false" aria-hidden={title ? undefined : true} />
      </span>
    );
  }

  const Mapped = type ? ICON_MAP[type] : undefined;
  const RenderIcon = Mapped ?? QuestionCircleOutlined;

  const needsWrap = !!rotate;
  const iconEl = (
    <RenderIcon
      spin={spin}
      rotate={needsWrap ? undefined : rotate}
      twoToneColor={twoToneColor as any}
      style={style}
      className={className}
    />
  );

  if (!needsWrap) {
    return (
      <span ref={ref} onClick={onClick} title={title} {...rest}>
        {iconEl}
      </span>
    );
  }

  return (
    <span
      ref={ref}
      onClick={onClick}
      title={title}
      style={{ display: 'inline-flex', lineHeight: 0, verticalAlign: 'middle', transform: `rotate(${rotate}deg)` }}
      {...rest}
    >
      {iconEl}
    </span>
  );
});

/* --------------------------------------------------------------------------------
   Styled exports (API preserved)
-------------------------------------------------------------------------------- */

export const CardStyled: React.FC<React.ComponentProps<typeof Card>> = (props) => (
  <Card bordered={false} bodyStyle={{ padding: '20px 24px 20px' }} {...props} />
);

export const ColStyled = styled(Col)`
  padding-bottom: 12px;
`;

/** Previously: styled(Icon) from 'antd' — now styled local shim */
export const DescriptionIcon = styled(Icon)`
  font-size: 20px;
`;

export const ShadowCard = styled(CardStyled)`
  box-shadow: rgba(0, 0, 0, 0.06) 0px 9px 24px;
  border-width: 1px;
  border-style: solid;
  border-color: rgb(242, 242, 242);
  border-radius: 3px;
  transition: all 150ms ease-in-out 0s;

  &:hover {
    box-shadow: rgba(0, 0, 0, 0.1) 0px 9px 24px;
    cursor: pointer;
    transition: all 150ms ease-in-out 0s;
  }
`;

export const CustomFormItem = styled(Form.Item)`
  margin-bottom: 8px;

  &.ant-form-item-with-help {
    margin-bottom: 5px;
  }
`;

export const FormCol = styled(Col)`
  padding-left: 0px !important;
  padding-right: 0px !important;
`;

export const Subtitle = styled(Text)`
  display: block;
  margin-bottom: 12px;
`;

export const EmptyImage = styled(Empty)`
  height: 230px;
  margin: 0;
  border-bottom: 0.3px solid rgba(0, 0, 0, 0.25);

  & .ant-empty-image {
    margin-top: 220px;
  }
`;

export const StyledTable = styled(Table)`
  .ant-table table {
    border-left: 1px solid #e8e8e8;
    border-top: 1px solid #e8e8e8;
    border-right: 1px solid #e8e8e8;
  }
`;

===== END components/activity-components/style.tsx =====


===== BEGIN components/auth0-components/index.tsx =====
'use client';

/**
 * Description: Auth0 component which manages authentication and admin authorization
 * Author: Hieu Chu
 */

import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
  type ReactNode,
} from 'react';
import createAuth0Client, {
  Auth0Client,
  type Auth0ClientOptions,
  type RedirectLoginOptions,
  type PopupLoginOptions,
  type GetTokenSilentlyOptions,
  type GetTokenWithPopupOptions,
  type GetIdTokenClaimsOptions,
  type LogoutOptions,
  type User,
  type IdToken,
} from '@auth0/auth0-spa-js';
import { normalizeError } from '../../shared/errors';

const DEFAULT_REDIRECT_CALLBACK = () =>
  window.history.replaceState({}, document.title, window.location.pathname);

type Nullable<T> = T | null;

interface Auth0ContextValue {
  isAuthenticated: boolean;
  user: Nullable<User>;
  loading: boolean;
  popupOpen: boolean;
  loginWithPopup: (params?: PopupLoginOptions) => Promise<void>;
  handleRedirectCallback: () => Promise<void>;
  getIdTokenClaims: (p?: GetIdTokenClaimsOptions) => Promise<IdToken>;
  loginWithRedirect: (p?: RedirectLoginOptions) => Promise<void>;
  getTokenSilently: (p?: GetTokenSilentlyOptions) => Promise<string>;
  getTokenWithPopup: (p?: GetTokenWithPopupOptions) => Promise<string>;
  logout: (p?: LogoutOptions) => void;
}

const Auth0Context = createContext<Auth0ContextValue | undefined>(undefined);
export const useAuth0 = (): Auth0ContextValue => {
  const ctx = useContext(Auth0Context);
  if (!ctx) throw new Error('useAuth0 must be used within <Auth0Provider>');
  return ctx;
};

type Auth0ProviderProps = {
  children: ReactNode;
  onRedirectCallback?: (appState?: unknown) => void;
} & Auth0ClientOptions;

export const Auth0Provider: React.FC<Auth0ProviderProps> = ({
  children,
  onRedirectCallback = DEFAULT_REDIRECT_CALLBACK,
  ...initOptions
}) => {
  const [auth0Client, setAuth0Client] = useState<Auth0Client | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [popupOpen, setPopupOpen] = useState<boolean>(false);

  useEffect(() => {
    let mounted = true;

    const initAuth0 = async () => {
      try {
        const client = await createAuth0Client({
          ...initOptions,
          // Ensure redirect_uri exists unless explicitly provided
          authorizationParams: {
            redirect_uri: window.location.origin,
            ...(initOptions.authorizationParams ?? {}),
          },
        });
        if (!mounted) return;
        setAuth0Client(client);

        // Handle redirect callback if returning from Auth0
        if (
          typeof window !== 'undefined' &&
          window.location.search.includes('code=') &&
          window.location.search.includes('state=')
        ) {
          const { appState } = await client.handleRedirectCallback();
          onRedirectCallback?.(appState);
        }

        const authenticated = await client.isAuthenticated();
        setIsAuthenticated(authenticated);

        if (authenticated) {
          const u = await client.getUser();
          setUser(u ?? null);
        }
      } catch (e: unknown) {
        const { message } = normalizeError(e);
        // Keep surface minimal; log for diagnostics
        // eslint-disable-next-line no-console
        console.error('[Auth0] init failed:', message);
      } finally {
        if (mounted) setLoading(false);
      }
    };

    void initAuth0();
    return () => {
      mounted = false;
    };
    // initOptions is stable in practice; if it changes, re-init intentionally
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const loginWithPopup = useCallback(
    async (params?: PopupLoginOptions) => {
      if (!auth0Client) return;
      setPopupOpen(true);
      try {
        await auth0Client.loginWithPopup(params);
        const u = await auth0Client.getUser();
        setUser(u ?? null);
        setIsAuthenticated(true);
      } catch (error: unknown) {
        const { message, statusCode } = normalizeError(error);
        // eslint-disable-next-line no-console
        console.error('[Auth0] loginWithPopup failed:', statusCode, message);
      } finally {
        setPopupOpen(false);
      }
    },
    [auth0Client]
  );

  const handleRedirectCallback = useCallback(async () => {
    if (!auth0Client) return;
    setLoading(true);
    try {
      await auth0Client.handleRedirectCallback();
      const u = await auth0Client.getUser();
      setIsAuthenticated(true);
      setUser(u ?? null);
    } finally {
      setLoading(false);
    }
  }, [auth0Client]);

  const getIdTokenClaims = useCallback(
    async (p?: GetIdTokenClaimsOptions) => {
      if (!auth0Client) throw new Error('Auth0 client not initialized');
      return auth0Client.getIdTokenClaims(p);
    },
    [auth0Client]
  );

  const loginWithRedirect = useCallback(
    async (p?: RedirectLoginOptions) => {
      if (!auth0Client) throw new Error('Auth0 client not initialized');
      await auth0Client.loginWithRedirect(p);
    },
    [auth0Client]
  );

  const getTokenSilently = useCallback(
    async (p?: GetTokenSilentlyOptions) => {
      if (!auth0Client) throw new Error('Auth0 client not initialized');
      return auth0Client.getTokenSilently(p);
    },
    [auth0Client]
  );

  const getTokenWithPopup = useCallback(
    async (p?: GetTokenWithPopupOptions) => {
      if (!auth0Client) throw new Error('Auth0 client not initialized');
      return auth0Client.getTokenWithPopup(p);
    },
    [auth0Client]
  );

  const logout = useCallback(
    (p?: LogoutOptions) => {
      if (!auth0Client) return;
      auth0Client.logout({
        logoutParams: {
          returnTo: window.location.origin,
          ...(p?.logoutParams ?? {}),
        },
        ...p,
      });
    },
    [auth0Client]
  );

  const value: Auth0ContextValue = {
    isAuthenticated,
    user,
    loading,
    popupOpen,
    loginWithPopup,
    handleRedirectCallback,
    getIdTokenClaims,
    loginWithRedirect,
    getTokenSilently,
    getTokenWithPopup,
    logout,
  };

  return <Auth0Context.Provider value={value}>{children}</Auth0Context.Provider>;
};

===== END components/auth0-components/index.tsx =====


===== BEGIN components/Button/Button.stories.tsx =====
import type { Meta, StoryObj } from "@storybook/react"
import { Button } from "./Button"

const meta: Meta<typeof Button> = {
  title: "Button",
  component: Button,
  args: {
    intent: "primary",
    underline: false,
    children: "Button",
    size: "lg",
  },
  argTypes: {
    intent: {
      options: ["primary", "secondary"],
      control: { type: "select" },
    },
    size: {
      options: ["sm", "lg"],
      control: { type: "select" },
    },
  },
}

type Story = StoryObj<typeof Button>

export const Default: Story = {
  render: (args, row) => <Button {...args} />,
}

export default meta

===== END components/Button/Button.stories.tsx =====


===== BEGIN components/Button/Button.tsx =====
import { cva, type VariantProps } from "class-variance-authority"

import { twMerge } from "tailwind-merge"

const button = cva(
  [
    "justify-center",
    "inline-flex",
    "items-center",
    "rounded-xl",
    "text-center",
    "border",
    "border-blue-400",
    "transition-colors",
    "delay-50",
  ],
  {
    variants: {
      intent: {
        primary: ["bg-blue-400", "text-white", "hover:enabled:bg-blue-700"],
        secondary: ["bg-transparent", "text-blue-400", "hover:enabled:bg-blue-400", "hover:enabled:text-white"],
      },
      size: {
        sm: ["min-w-20", "h-full", "min-h-10", "text-sm", "py-1.5", "px-4"],
        lg: ["min-w-32", "h-full", "min-h-12", "text-lg", "py-2.5", "px-6"],
      },
      underline: { true: ["underline"], false: [] },
    },
    defaultVariants: {
      intent: "primary",
      size: "lg",
    },
  }
)

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLAnchorElement>, VariantProps<typeof button> {
  underline?: boolean
  href: string
}

export function Button({ className, intent, size, underline, ...props }: ButtonProps) {
  return (
    <a className={twMerge(button({ intent, size, className, underline }))} {...props}>
      {props.children}
    </a>
  )
}

===== END components/Button/Button.tsx =====


===== BEGIN components/charts/ChartCard.tsx =====
// components/charts/ChartCard.tsx
'use client';
import React from 'react';
import { Line, Area } from '@ant-design/plots';

interface ChartCardProps {
  /** choose a compact chart variant */
  type: 'line' | 'area';
  /** [{ x: …, y: … }] or any fields you map with xField / yField */
  data: { x?: string | number; y: number }[];
  height?: number;
  /* forward any extra Ant Design Plot options */
  [key: string]: any;
}

export default function ChartCard({
  type,
  data,
  height = 60,
  ...rest
}: ChartCardProps) {
  const commonCfg = {
    data,
    height,
    autoFit: true,
    smooth: true,
    xField: 'x',
    yField: 'y',
    ...rest,               // allow overrides
  };

  return type === 'area'
    ? <Area {...commonCfg} />
    : <Line {...commonCfg} />;
}

===== END components/charts/ChartCard.tsx =====


===== BEGIN components/compat/Comment.tsx =====
// components/compat/Comment.tsx
import React from 'react'
import { Avatar, List, Typography } from 'antd'

type Props = {
  author?: React.ReactNode
  avatar?: React.ReactNode
  content?: React.ReactNode
  datetime?: React.ReactNode
  className?: string
  actions?: React.ReactNode[]
}

export default function Comment({ author, avatar, content, datetime, className, actions }: Props) {
  return (
    <List.Item className={className} actions={actions}>
      <List.Item.Meta
        avatar={avatar}
        title={
          <div style={{ display: 'flex', justifyContent: 'space-between' }}>
            <span>{author}</span>
            {datetime ? <Typography.Text type="secondary">{datetime}</Typography.Text> : null}
          </div>
        }
        description={content}
      />
    </List.Item>
  )
}

===== END components/compat/Comment.tsx =====


===== BEGIN components/compat/Icon.tsx =====
// components/compat/Icon.tsx
import React from 'react'
import {
  DeleteOutlined,
  EditOutlined,
  LikeOutlined,
  MessageOutlined,
  LoadingOutlined,
  PlusOutlined,
  InfoCircleOutlined,
  WarningOutlined,
  ArrowRightOutlined,
  ArrowLeftOutlined,
} from '@ant-design/icons'

const MAP: Record<string, React.ComponentType<any>> = {
  delete: DeleteOutlined,
  edit: EditOutlined,
  like: LikeOutlined,
  message: MessageOutlined,
  loading: LoadingOutlined,
  plus: PlusOutlined,
  'info-circle': InfoCircleOutlined,
  warning: WarningOutlined,
  'arrow-right': ArrowRightOutlined,
  'arrow-left': ArrowLeftOutlined,
}

type Props = { type: string } & React.HTMLAttributes<HTMLSpanElement>

export default function Icon({ type, ...rest }: Props) {
  const C = MAP[type] ?? InfoCircleOutlined
  return <C {...rest} />
}

===== END components/compat/Icon.tsx =====


===== BEGIN components/concatv3.py =====
#!/usr/bin/env python3
"""
Concatène tous les fichiers texte du dossier du script et de ses sous-dossiers.
Par défaut, écrit le résultat dans "Code_<nom_dossier>_<YYYYMMDD_HHMMSS>.txt" à la racine du script.
"""

from __future__ import annotations
import argparse
import fnmatch
import os
from pathlib import Path
from typing import Set, List, Optional
from datetime import datetime

DEFAULT_EXTS: Set[str] = {
    ".tx", ".md", ".markdown",
    ".json", ".yaml", ".yml", ".xml", ".toml", ".ini", ".cfg", ".conf", ".properties",
    ".html", ".htm", ".css", ".scss", ".less",
    ".js", ".jsx", ".ts", ".tsx", ".mjs", ".cjs",
    ".py", ".pyi", ".ipynb",
    ".java", ".kt", ".swift", ".rb", ".php", ".go", ".rs",
    ".c", ".h", ".cpp", ".cc", ".hpp", ".cs",
    ".sql",
    ".sh", ".bash", ".zsh", ".fish", ".ps1", ".bat",
    ".tex", ".bib",
    ".graphql", ".gql",
    ".gradle",
    ".pl", ".lua", ".r",
    ".env",
}

NAMES_WITHOUT_EXT: Set[str] = {
    "Dockerfile", "Makefile", "CMakeLists.txt",
    ".gitignore", ".gitattributes", ".editorconfig",
    "Procfile", "Gemfile", "requirements.txt", "Pipfile", "poetry.lock",
    "package.json", "package-lock.json", "yarn.lock", "pnpm-lock.yaml",
    "tsconfig.json", "eslint.config.js", ".eslintrc", ".prettierrc",
}

DEFAULT_EXCLUDE_DIRS: Set[str] = {
    ".git", ".hg", ".svn",
    "node_modules", ".next", ".nuxt",
    "dist", "build", "out", "coverage", ".cache",
    ".venv", "venv", "__pycache__",
    "target", "bin", "obj",
}


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Concatène les fichiers texte du projet dans un seul fichier.")
    p.add_argument("-o", "--out", default=None, help="Fichier de sortie (facultatif)")
    p.add_argument("--ext", help="Extensions additionnelles ou personnalisées, séparées par des virgules")
    p.add_argument("--include", action="append", default=[], help="Glob d'inclusion relatif à la racine (répétable)")
    p.add_argument("--exclude", action="append", default=[], help="Glob d'exclusion relatif à la racine (répétable)")
    p.add_argument("--max-size", type=int, default=2_000_000, help="Taille max par fichier en octets")
    p.add_argument("--no-headers", action="store_true", help="Ne pas imprimer d'entêtes par fichier")
    return p.parse_args()


def normalize_exts(exts_csv: Optional[str]) -> Set[str]:
    if not exts_csv:
        return set(DEFAULT_EXTS)
    parts = [e.strip().lower() for e in exts_csv.split(",") if e.strip()]
    normed = set()
    for e in parts:
        if not e.startswith("."):
            e = "." + e
        normed.add(e)
    return normed


def is_probably_text(sample: bytes) -> bool:
    if not sample:
        return True
    if b"\x00" in sample:
        return False
    try:
        sample.decode("utf-8")
        return True
    except UnicodeDecodeError:
        pass
    ctrl_hits = 0
    for b in sample:
        if b < 32 and b not in (9, 10, 13):
            ctrl_hits += 1
    return (ctrl_hits / max(1, len(sample))) < 0.01


def pick_encoding(path: Path) -> Optional[str]:
    try:
        with path.open("rb") as f:
            sample = f.read(32768)
    except Exception:
        return None
    if not is_probably_text(sample):
        return None
    for enc in ("utf-8", "utf-8-sig", "utf-16", "cp1252", "latin-1"):
        try:
            sample.decode(enc)
            return enc
        except UnicodeDecodeError:
            continue
    return "latin-1"


def relpath(base: Path, p: Path) -> str:
    try:
        return str(p.relative_to(base))
    except Exception:
        return str(p)


def should_include_file(base: Path, file_path: Path, allowed_exts: Set[str],
                        include_globs: List[str], exclude_globs: List[str],
                        max_size: int, out_path: Path) -> bool:
    if not file_path.is_file():
        return False
    if file_path == out_path:
        return False
    if file_path.suffix.lower() == ".txt":
        return False
    try:
        if file_path.stat().st_size > max_size:
            return False
    except Exception:
        return False
    rel = relpath(base, file_path)
    for pat in exclude_globs:
        if fnmatch.fnmatch(rel, pat):
            return False
    if include_globs:
        ok = any(fnmatch.fnmatch(rel, pat) for pat in include_globs)
        if not ok:
            return False
    if file_path.suffix.lower() in allowed_exts or file_path.name in NAMES_WITHOUT_EXT:
        return True
    enc = pick_encoding(file_path)
    return enc is not None


def main() -> None:
    args = parse_args()
    base_dir = Path(__file__).resolve().parent
    self_path = Path(__file__).resolve()

    if args.out:
        out_path = (base_dir / args.out).resolve()
    else:
        stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        out_name = f"Code_{base_dir.name}_{stamp}.txt"
        out_path = (base_dir / out_name).resolve()

    allowed_exts = normalize_exts(args.ext)
    include_globs = list(args.include or [])
    exclude_globs = list(args.exclude or [])

    selected: List[Path] = []
    for root, dirs, files in os.walk(base_dir, followlinks=False):
        dirs[:] = [d for d in dirs if d not in DEFAULT_EXCLUDE_DIRS]
        root_path = Path(root)
        for name in files:
            fp = root_path / name
            # exclure le script exécuté lui-même
            try:
                if fp.resolve() == self_path:
                    continue
            except Exception:
                pass
            if should_include_file(base_dir, fp, allowed_exts, include_globs, exclude_globs, args.max_size, out_path):
                selected.append(fp)

    selected.sort(key=lambda p: relpath(base_dir, p).lower())
    out_path.parent.mkdir(parents=True, exist_ok=True)

    with out_path.open("w", encoding="utf-8", newline="\n") as out:
        for p in selected:
            enc = pick_encoding(p) or "utf-8"
            if not args.no_headers:
                out.write(f"\n===== BEGIN {relpath(base_dir, p)} =====\n")
            try:
                with p.open("r", encoding=enc, errors="strict") as f:
                    for line in f:
                        out.write(line)
            except UnicodeDecodeError:
                with p.open("r", encoding="latin-1", errors="replace") as f:
                    for line in f:
                        out.write(line)
            if not args.no_headers:
                out.write(f"\n===== END {relpath(base_dir, p)} =====\n")
            out.write("\n")

    print(f"{len(selected)} fichier(s) concaténé(s) -> {relpath(base_dir, out_path)}")


if __name__ == "__main__":
    main()

===== END components/concatv3.py =====


===== BEGIN components/CustomComment.tsx =====
'use client'

import { Typography } from 'antd'

export default function CustomComment({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <Typography.Text
      type="secondary"
      style={{ fontSize: 'var(--ant-font-size-sm)' }}
    >
      {children}
    </Typography.Text>
  )
}

===== END components/CustomComment.tsx =====


===== BEGIN components/dashboard-components/CommentCard.tsx =====
'use client'

/**
 * Description: Comment statistics card, including total comments and trend graph
 * Author: Hieu Chu
 */

import React from 'react'
import dynamic from 'next/dynamic'
import type { AreaConfig } from '@ant-design/plots'
import {
  MainIcon,
  CardDivider,
  NumberInfoStyled,
  CardFooter,
  BarContainer,
} from './style'

type Point = { x: string | number; y: number }

interface Props {
  TOTAL_COMMENTS: number
  DAILY_COMMENTS: number
  DAILY_COMMENTS_CHANGE: number
  COMMENT_DATA: Point[]
}

// SSR-safe dynamic import of the Area chart
const Area = dynamic(() => import('@ant-design/plots').then(m => m.Area), {
  ssr: false,
})

export default function CommentCard({
  TOTAL_COMMENTS,
  DAILY_COMMENTS,
  DAILY_COMMENTS_CHANGE,
  COMMENT_DATA,
}: Props) {
  const areaConfig: AreaConfig = {
    data: COMMENT_DATA,
    xField: 'x',
    yField: 'y',
    smooth: true,
    height: 90,
    autoFit: true,
    padding: 0,
    xAxis: false,
    yAxis: false,
    tooltip: {},
    areaStyle: { fillOpacity: 0.2 },
  }

  return (
    <>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <MainIcon type="message" twoToneColor="rgb(205, 34, 255)" />
        <NumberInfoStyled subTitle="Comments" total={TOTAL_COMMENTS} />
      </div>

      <BarContainer>
        <Area {...areaConfig} />
      </BarContainer>

      <CardDivider />

      <CardFooter
        title="Daily comments"
        value={DAILY_COMMENTS}
        change={DAILY_COMMENTS_CHANGE}
      />
    </>
  )
}

===== END components/dashboard-components/CommentCard.tsx =====


===== BEGIN components/dashboard-components/index.tsx =====
import UserCard from './UserCard'
import VisitCard from './VisitCard'
import LikeCard from './LikeCard'
import CommentCard from './CommentCard'
import SculptureTable from './SculptureTable'
import UserPieChart from './UserPieChart'
import { ColStyled } from './style'

export {
  UserCard,
  VisitCard,
  LikeCard,
  CommentCard,
  SculptureTable,
  UserPieChart,
  ColStyled
}

===== END components/dashboard-components/index.tsx =====


===== BEGIN components/dashboard-components/LikeCard.tsx =====
'use client';

import React from 'react';
import dynamic from 'next/dynamic';
import { Card, Statistic, Skeleton } from 'antd';
import type { TinyLineConfig } from '@ant-design/plots';

// SSR-safe dynamic import of TinyLine
const TinyLine = dynamic(
  () => import('@ant-design/plots').then((m) => m.TinyLine),
  { ssr: false }
);

export interface LikeCardProps {
  title?: string;            // Default: 'Likes'
  total: number;             // Total likes
  trend?: number[];          // Sparkline series
  loading?: boolean;
}

const LikeCard: React.FC<LikeCardProps> = ({
  title = 'Likes',
  total,
  trend = [],
  loading = false,
}) => {
  const data: number[] = Array.isArray(trend) ? trend : [];

  const config: TinyLineConfig = {
    data,
    autoFit: true,
    smooth: true,
    height: 56,
    padding: 0,
    tooltip: {},
  };

  return (
    <Card bordered={false} bodyStyle={{ padding: 16 }}>
      <Statistic title={title} value={total} />
      {loading ? (
        <Skeleton active paragraph={false} style={{ marginTop: 8 }} />
      ) : (
        <div style={{ marginTop: 8 }}>
          <TinyLine {...config} />
        </div>
      )}
    </Card>
  );
};

export default LikeCard;

===== END components/dashboard-components/LikeCard.tsx =====


===== BEGIN components/dashboard-components/LineChart.tsx =====
'use client'
import React from 'react';
import {
  LineChart as ReLineChart,
  Line,
  CartesianGrid,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
} from 'recharts';

type DataPoint = {
  time: string;
  value: number;
};

type LineChartProps = {
  data: DataPoint[];
};

const LineChart: React.FC<LineChartProps> = ({ data }) => {
  return (
    <ResponsiveContainer width="100%" height={300}>
      <ReLineChart data={data}>
        <CartesianGrid stroke="#ccc" />
        <XAxis dataKey="time" />
        <YAxis />
        <Tooltip />
        <Line type="monotone" dataKey="value" stroke="#8884d8" />
      </ReLineChart>
    </ResponsiveContainer>
  );
};

export default LineChart;

===== END components/dashboard-components/LineChart.tsx =====


===== BEGIN components/dashboard-components/SculptureTable.tsx =====
"use client";
/**
 * Description: Sculpture table with support for sorting according to likes, comments and visits
 * Author: Hieu Chu
 */

import { Table } from 'antd'
import { CardStyled } from './style'
import styled from 'styled-components'
import { useRouter } from 'next/navigation';

const StyledTable = styled(Table)`
  .ant-table table {
    border-left: 1px solid #e8e8e8;
    border-top: 1px solid #e8e8e8;
    border-right: 1px solid #e8e8e8;
  }
`

export default ({ sculptures }) => {
  const columns = [
    {
      title: 'Sculpture Name',
      dataIndex: 'name'
    },
    {
      title: 'Author',
      key: 'author',
      render: (_, { primaryMaker: { firstName, lastName } }) => (
        <span>{`${firstName} ${lastName}`}</span>
      )
    },
    {
      title: 'Likes',
      dataIndex: 'totalLikes',
      sorter: (a, b) => a.totalLikes - b.totalLikes,
      sortDirections: ['descend', 'ascend']
    },
    {
      title: 'Comments',
      dataIndex: 'totalComments',
      sorter: (a, b) => a.totalComments - b.totalComments,
      sortDirections: ['descend', 'ascend']
    },
    {
      title: 'Visits',
      dataIndex: 'totalVisits',
      sorter: (a, b) => a.totalVisits - b.totalVisits,
      sortDirections: ['descend', 'ascend']
    }
  ]

  return (
    <CardStyled title="Sculpture Rankings">
      <StyledTable
        dataSource={sculptures}
        columns={columns}
        pagination={{ pageSize: 10 }}
        className="sculpture-table"
        onRow={(record, _) => {
          return {
            onClick: () => {
              const router = useRouter();
              router.push(`/sculptures/id/${record.key}`)
            }
          };
        }}
      />
    </CardStyled>
  );
}

===== END components/dashboard-components/SculptureTable.tsx =====


===== BEGIN components/dashboard-components/StatisticCard.tsx =====
import React from 'react';
import { Card, Statistic } from 'antd';

type StatisticCardProps = {
  title: string;
  value: number;
};

const StatisticCard: React.FC<StatisticCardProps> = ({ title, value }) => {
  return (
    <Card>
      <Statistic title={title} value={value} />
    </Card>
  );
};

export default StatisticCard;

===== END components/dashboard-components/StatisticCard.tsx =====


===== BEGIN components/dashboard-components/style.tsx =====
/**
 * Description: Stylesheet for dashboard components
 * Author: Hieu Chu
 */

import React from 'react'
import { Card, Tooltip, Divider, Col } from 'antd'
import { NumberInfo } from 'ant-design-pro'
import styled from 'styled-components'
import {
  InfoCircleOutlined,
  CaretDownOutlined,
  CaretUpOutlined,
} from '@ant-design/icons'
import * as AntIcons from '@ant-design/icons'

/** helper: map legacy Icon `type` strings (e.g. "shopping-cart") to v4 components */
const legacyTypeToIcon = (type?: string) => {
  if (!type) return null
  const pascal =
    type
      .split('-')
      .map(s => s.charAt(0).toUpperCase() + s.slice(1))
      .join('') + 'Outlined'
  // @ts-ignore dynamic lookup
  return (AntIcons as any)[pascal] || null
}

export const CardStyled = (props: any) => {
  const bodyStyle: React.CSSProperties = {
    padding: '20px 24px 8px',
  }
  if (props.type === 'stats') {
    bodyStyle.padding = '20px 16px 16px'
  }
  return <Card bodyStyle={bodyStyle} variant="borderless" {...props} />
}

export const NumberInfoStyled = (props: any) => (
  <NumberInfo
    {...props}
    total={<span style={{ fontSize: 30 }}>{props.total.toLocaleString()}</span>}
    style={{ display: 'inline-block' }}
  />
)

export const HelperIcon = (props: any) => (
  <div style={{ marginLeft: 'auto', alignSelf: 'flex-start' }}>
    <Tooltip {...props} placement="topLeft" arrowPointAtCenter={true}>
      <InfoCircleOutlined style={{ verticalAlign: -3, cursor: 'pointer' }} />
    </Tooltip>
  </div>
)

/**
 * Backward compatible MainIcon.
 * Preferred: <MainIcon icon={<YourIcon />} />
 * Legacy support: <MainIcon type="shopping-cart" />
 */
export const MainIcon = (props: any) => {
  const { icon, type, style, ...rest } = props
  const Resolved = icon
    ? icon
    : (() => {
        const Comp = legacyTypeToIcon(type)
        return Comp ? <Comp /> : null
      })()

  return (
    <div style={{ marginRight: 16 }} {...rest}>
      {React.isValidElement(Resolved)
        ? React.cloneElement(Resolved as React.ReactElement, {
            style: { ...(Resolved.props?.style || {}), ...(style || {}), fontSize: 54 },
          })
        : null}
    </div>
  )
}

export const CardFooter = (props: any) => {
  return (
    <div style={{ position: 'relative', zIndex: 99 }}>
      <span>{props.title}:</span>
      <span style={{ marginLeft: 8, color: 'rgba(0,0,0,.85)' }}>
        {props.value.toLocaleString()}
      </span>
      <Tooltip title="Change compared to yesterday">
        <span style={{ marginLeft: 16 }}>
          <span style={{ color: 'rgba(0,0,0,.55)', marginRight: 2 }}>
            {props.change.toLocaleString()}
          </span>

          {/* Up/down icon */}
          {props.change < 0 ? (
            <CaretDownOutlined style={{ color: '#f5222d', verticalAlign: 'text-bottom' }} />
          ) : (
            <CaretUpOutlined style={{ color: '#52c41a', verticalAlign: 'middle' }} />
          )}
        </span>
      </Tooltip>
    </div>
  )
}

export const ColStyled = styled(Col)`
  padding-bottom: 12px;
`

export const CardDivider = styled(Divider)`
  margin-top: 12px;
  margin-bottom: 9px;
`

export const BarContainer = styled.div`
  height: 90px;
  margin-top: 10px;
  margin-bottom: -10px;
`

export const ShadowCard = styled(CardStyled)`
  box-shadow: rgba(0, 0, 0, 0.06) 0px 9px 24px;
  border-width: 1px;
  border-style: solid;
  border-color: rgb(242, 242, 242);
  border-radius: 3px;
  transition: all 150ms ease-in-out 0s;

  &:hover {
    box-shadow: rgba(0, 0, 0, 0.1) 0px 9px 24px;
    cursor: pointer;
    transition: all 150ms ease-in-out 0s;
  }
`

===== END components/dashboard-components/style.tsx =====


===== BEGIN components/dashboard-components/UserCard.tsx =====
'use client';

import React from 'react';
import dynamic from 'next/dynamic';
import { Card, Statistic, Skeleton } from 'antd';
import type { TinyColumnConfig } from '@ant-design/plots';

// SSR-safe dynamic import of TinyColumn
const TinyColumn = dynamic(
  () => import('@ant-design/plots').then((m) => m.TinyColumn),
  { ssr: false }
);

export interface UserCardProps {
  title?: string;                       // Default: 'New Users'
  total: number;                        // Total users (or new users)
  trend?: number[];                     // Tiny column series (e.g., daily counts)
  loading?: boolean;
}

const UserCard: React.FC<UserCardProps> = ({
  title = 'New Users',
  total,
  trend = [],
  loading = false,
}) => {
  const data: number[] = Array.isArray(trend) ? trend : [];

  const config: TinyColumnConfig = {
    data,
    autoFit: true,
    height: 56,
    padding: 0,
    tooltip: {},
  };

  return (
    <Card bordered={false} bodyStyle={{ padding: 16 }}>
      <Statistic title={title} value={total} />
      {loading ? (
        <Skeleton active paragraph={false} style={{ marginTop: 8 }} />
      ) : (
        <div style={{ marginTop: 8 }}>
          <TinyColumn {...config} />
        </div>
      )}
    </Card>
  );
};

export default UserCard;

===== END components/dashboard-components/UserCard.tsx =====


===== BEGIN components/dashboard-components/UserPieChart.tsx =====
'use client'
import React from 'react'
import {
  PieChart, Pie, Cell, Tooltip, ResponsiveContainer, Legend,
} from 'recharts'
import { CardStyled } from './style'

type User = { userId: string }
export default function UserPieChart({ users }: { users: User[] }) {
  const data = [
    { name: 'Email', value: 0 },
    { name: 'Google', value: 0 },
    { name: 'Facebook', value: 0 },
  ]
  for (const u of users) {
    if (u.userId.includes('auth0')) data[0].value++
    else if (u.userId.includes('google')) data[1].value++
    else data[2].value++
  }

  const COLORS = ['#A97BE9', '#EA4335', '#1890FF']

  return (
    <CardStyled title="Proportion of Users">
      <div style={{ width: '100%', height: 294 }}>
        <ResponsiveContainer>
          <PieChart>
            <Pie data={data} dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={90} label>
              {data.map((entry, i) => <Cell key={entry.name} fill={COLORS[i % COLORS.length]} />)}
            </Pie>
            <Tooltip />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
      </div>
    </CardStyled>
  )
}

===== END components/dashboard-components/UserPieChart.tsx =====


===== BEGIN components/dashboard-components/VisitCard.tsx =====
'use client'

/**
 * Description: Visit statistics card, including total visits and trend graph
 * Author: Hieu Chu
 */

import React from 'react'
import ChartCard from '@/components/charts/ChartCard'
import {
  MainIcon,
  CardDivider,
  NumberInfoStyled,
  CardFooter,
  HelperIcon,
  BarContainer,
} from './style'

type Point = { x: string | number; y: number }

interface Props {
  TOTAL_VISITS: number
  DAILY_VISITS: number
  DAILY_VISITS_CHANGE: number
  VISIT_DATA: Point[]
  SINGLE_SCULPTURE?: boolean
}

export default function VisitCard({
  TOTAL_VISITS,
  DAILY_VISITS,
  DAILY_VISITS_CHANGE,
  VISIT_DATA,
  SINGLE_SCULPTURE,
}: Props) {
  return (
    <>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <MainIcon type="environment" style={{ color: '#F73F3F' }} />
        <NumberInfoStyled subTitle="Total visits" total={TOTAL_VISITS} />
        {!SINGLE_SCULPTURE && (
          <HelperIcon title="Total number of times sculptures have been visited" />
        )}
      </div>

      <BarContainer>
        <ChartCard type="area" data={VISIT_DATA} height={90} />
      </BarContainer>

      <CardDivider />

      <CardFooter
        title="Daily visits"
        value={DAILY_VISITS}
        change={DAILY_VISITS_CHANGE}
      />
    </>
  )
}

===== END components/dashboard-components/VisitCard.tsx =====


===== BEGIN components/layout-components/Drawer.tsx =====
'use client'

import React from 'react'
import { Drawer } from 'antd'
import styled from 'styled-components'

/* ------------------------------------------------------------------ */
/*  Drawer stylé : suit les variables CSS du thème et bloque le scroll */
/* ------------------------------------------------------------------ */
const StyledDrawer = styled(Drawer)`
  .ant-drawer-wrapper-body {
    overflow: hidden !important;
  }

  .ant-drawer-content {
    background: var(--ant-color-bg-container) !important;
    color: var(--ant-color-text);
  }
`

interface Props {
  drawerVisible: boolean
  closeDrawer : () => void
  children    : React.ReactNode
}

export default function LayoutDrawer({
  drawerVisible,
  closeDrawer,
  children,
}: Props) {
  return (
    <StyledDrawer
      placement="left"
      closable={false}
      onClose={closeDrawer}
      open={drawerVisible}
        styles={{
			body: {
			margin: 0,
			padding: 0,
			background: 'var(--ant-color-bg-container)',
		},
      }}
    >
      {children}
    </StyledDrawer>
  )
}

===== END components/layout-components/Drawer.tsx =====


===== BEGIN components/layout-components/Header.tsx =====
'use client'

import { Layout, Dropdown, Breadcrumb } from 'antd'
import {
  UserOutlined,
  LogoutOutlined,
  MenuUnfoldOutlined,
  MenuFoldOutlined,
} from '@ant-design/icons'
import styled from 'styled-components'
import Link from 'next/link'
import nookies from 'nookies'
import { useRouter, usePathname } from 'next/navigation'
import { useMemo } from 'react'
import ThemeSwitcher from '@/components/ThemeSwitcher'

const { Header } = Layout

/* -------- styled -------- */
const NavBar = styled.div`
  display: flex;
  align-items: center;
  height: 64px;
  padding: 0 16px;
`

const Crumb = styled(Breadcrumb)`
  margin-left: 20px; /* espace après le toggle */
  color: var(--ant-color-text);
  .ant-breadcrumb-separator {
    color: var(--ant-color-text-secondary);
  }
`

const HeaderBlock = styled.div`
  padding: 0 12px;
  cursor: pointer;
  transition: all 0.3s;
  &:hover {
    background: var(--ant-color-fill-secondary);
  }
`

/* -------- helpers -------- */
const accountItems = [
  { key: 'profile', icon: <UserOutlined />, label: 'Profile' },
  { type: 'divider' as const },
  { key: 'logout', icon: <LogoutOutlined />, label: 'Logout' },
]

interface Route {
  path?: string
  name: string
  views?: Route[]
}

const trail = (rs: Route[], cur: string): Route[] => {
  for (const r of rs) {
    if (r.views?.length) {
      const sub = trail(r.views, cur)
      if (sub.length) return [r, ...sub]
    }
    if (r.path && (cur === r.path || cur.startsWith(r.path))) return [r]
  }
  return []
}

/* -------- component -------- */
interface Props {
  collapsed: boolean
  handleToggle: () => void
  routes?: Route[]
  selectedSidebar?: string
}

export default function HeaderBar({
  collapsed,
  handleToggle,
  routes = [],
  selectedSidebar = '',
}: Props) {
  const router = useRouter()
  const pathname = usePathname() ?? '/'
  const cur = pathname

  const breadcrumbItems = useMemo(() => {
    const br = trail(routes, cur)
    const root = {
      name: selectedSidebar
        ? selectedSidebar[0].toUpperCase() + selectedSidebar.slice(1)
        : '',
      path: `/${selectedSidebar}`,
    }
    const crumbs = br.length ? [root, ...br] : [root]
    return crumbs.map(c => ({
      key: c.path ?? c.name,
      title: c.path ? (
        <Link
          href={{ pathname: c.path, query: { sidebar: selectedSidebar } }}
          style={{ color: 'var(--ant-color-text)' }}
        >
          {c.name}
        </Link>
      ) : (
        <span style={{ color: 'var(--ant-color-text)' }}>{c.name}</span>
      ),
    }))
  }, [routes, cur, selectedSidebar])

  return (
    <Header
      style={{
        position: 'sticky',
        top: 0,
        zIndex: 100,
        background: 'var(--ant-color-bg-container)',
        padding: 0,
        boxShadow: 'var(--ant-box-shadow-secondary)',
      }}
    >
      <NavBar>
        {/* Toggle sidebar */}
        <div
          onClick={handleToggle}
          style={{ cursor: 'pointer', marginRight: 20 }}
        >
          {collapsed ? (
            <MenuUnfoldOutlined style={{ fontSize: 20, color: 'var(--ant-color-text)' }} />
          ) : (
            <MenuFoldOutlined style={{ fontSize: 20, color: 'var(--ant-color-text)' }} />
          )}
        </div>

        {/* Fil d’Ariane */}
        <Crumb items={breadcrumbItems} />

        {/* Zone droite : thème + compte */}
        <div style={{ marginLeft: 'auto', display: 'flex', gap: 8, alignItems: 'center' }}>
          <ThemeSwitcher />

          <Dropdown
            placement="bottomRight"
            menu={{
              items: accountItems,
              onClick: ({ key }) => {
                if (key === 'logout') {
                  nookies.destroy({}, 'auth0.is.authenticated')
                  nookies.destroy({}, 'accessToken')
                  router.push('/')
                } else if (key === 'profile') {
                  router.push('/users/id/123')
                }
              },
            }}
          >
            <HeaderBlock>
              <UserOutlined style={{ marginRight: 8, color: 'var(--ant-color-text)' }} /> Admin
            </HeaderBlock>
          </Dropdown>
        </div>
      </NavBar>
    </Header>
  )
}

===== END components/layout-components/Header.tsx =====


===== BEGIN components/layout-components/LogoTitle.tsx =====
// File: /components/layout-components/LogoTitle.tsx
'use client'

import styled from 'styled-components'
import { Dropdown } from 'antd'

/* ------------ styled ------------ */
export const Logo = styled.img`
  display: block;
  height: 32px;
  vertical-align: middle;
`

const Title = styled.span`
  display: inline-block;
  color: var(--ant-color-text);
  font-weight: 600;
  font-size: 20px;
  margin-left: 12px;
  font-family: 'Arial';
  vertical-align: middle;
`

const TitleWrapper = styled.div`
  position: relative;
  height: 64px;
  padding-left: 24px;
  overflow: hidden;
  line-height: 64px;
  transition: background 0.3s ease;
  background: var(--ant-color-bg-container);
`

const LogoContainer = styled.div`
  display: flex;
  align-items: center;
  cursor: pointer;
`

/* ------------ mapping du label par sidebar ------------ */
const titleMapping = {
  ekoh        : 'EkoH',
  ethikos     : 'EthiKos',
  keenkonnect : 'keenKonnect',
  konnected   : 'KonnectED',
  kreative    : 'Kreative',
} as const

interface Props {
  onSidebarChange : (key: string) => void
  selectedSidebar?: string
}

/* ------------ composant ------------ */
export default function LogoTitle({
  onSidebarChange,
  selectedSidebar,
}: Props) {
  const sidebar = selectedSidebar?.toLowerCase() ?? 'ekoh'

  const menuItems = Object.entries(titleMapping).map(([key, label]) => ({
    key, label,
  }))

  return (
    <TitleWrapper>
      <Dropdown
        trigger={['click']}
        menu={{
          items: menuItems,
          onClick: ({ key }) => onSidebarChange(key),
          // **ici on force un fond opaque + ombre**
          style: {
            background: 'var(--ant-color-bg-container)',
            boxShadow: 'var(--ant-box-shadow-secondary)',
          },
        }}
      >
        <LogoContainer>
          <Logo src="/LogoK.svg" alt="Konnaxion logo" />
          <Title>
            {titleMapping[sidebar as keyof typeof titleMapping] ?? 'UOW Sculptures'}
          </Title>
        </LogoContainer>
      </Dropdown>
    </TitleWrapper>
  )
}

===== END components/layout-components/LogoTitle.tsx =====


===== BEGIN components/layout-components/Main.tsx =====
'use client'

import { Layout } from 'antd'
import styled, { css } from 'styled-components'

const StyledMain = styled(
  ({ collapsed: _c, ...rest }) => <Layout {...rest} />,
)<{ collapsed: boolean }>`
  transition: 0.2s all;

  /* décalage = largeur réelle du sider (ouvert) */
  margin-left: 256px;

  background: var(--ant-color-bg-layout);

  /* décalage quand le sider est réduit */
  ${({ collapsed }) =>
    collapsed &&
    css`
      margin-left: 80px;
    `}

  @media (max-width: 575.98px) {
    margin-left: 0;
  }
`

export default function Main({
  children,
  collapsed,
}: {
  children: React.ReactNode
  collapsed: boolean
}) {
  return <StyledMain collapsed={collapsed}>{children}</StyledMain>
}

===== END components/layout-components/Main.tsx =====


===== BEGIN components/layout-components/MainLayout.tsx =====
'use client'

import React, { useState, useEffect } from 'react'
import { Layout } from 'antd'
import { useRouter, usePathname, useSearchParams } from 'next/navigation'

import FixedSider      from '@/components/layout-components/Sider'
import Main            from '@/components/layout-components/Main'
import HeaderComponent from '@/components/layout-components/Header'
import LogoTitle       from '@/components/layout-components/LogoTitle'
import DrawerComponent from '@/components/layout-components/Drawer'
import MenuComponent   from '@/components/layout-components/Menu'
import type { Route }  from '@/components/layout-components/Menu'

interface RoutesConfig {
  ekoh: Route[]
  ethikos: Route[]
  keenkonnect: Route[]
  konnected: Route[]
  kreative: Route[]
}

const { Content } = Layout

export default function MainLayout({
  collapsed: initialCollapsed = false,
  children,
}: React.PropsWithChildren<{ collapsed?: boolean }>) {
  const router   = useRouter()
  const pathname = usePathname()
  const q        = useSearchParams()

  /* états */
  const [collapsed, setCollapsed] = useState(initialCollapsed)
  const [drawerVisible, setDrawer] = useState(false)

  const [routes, setRoutes] = useState<RoutesConfig>({
    ekoh: [], ethikos: [], keenkonnect: [], konnected: [], kreative: [],
  })

  /* suite depuis ?sidebar= */
  const [suite, setSuite] = useState(q.get('sidebar') ?? 'ekoh')

  /* charger dynamiquement les routes */
  useEffect(() => {
    Promise.all([
      import('@/routes/routesEkoh'),
      import('@/routes/routesEthikos'),
      import('@/routes/routesKeenkonnect'),
      import('@/routes/routesKonnected'),
      import('@/routes/routesKreative'),
    ])
      .then(([
        { default: ekoh },
        { default: ethikos },
        { default: keen },
        { default: konnected },
        { default: kreative },
      ]) => setRoutes({ ekoh, ethikos, keenkonnect: keen, konnected, kreative }))
      .catch(err => console.error('Erreur chargement routes :', err))
  }, [])

  /* sync si ?sidebar change */
  useEffect(() => {
    const v = q.get('sidebar')
    if (v && v !== suite) setSuite(v)
  }, [q])

  const changeSuite = (key: string) => {
    setSuite(key)
    const params = new URLSearchParams(Array.from(q.entries()))
    params.set('sidebar', key)
    router.push(`${pathname}?${params.toString()}`)
  }

  const toggle = () => {
    if (window.innerWidth >= 576) setCollapsed(!collapsed)
    else setDrawer(v => !v)
  }

  const suiteRoutes = routes[suite as keyof RoutesConfig] ?? []

  return (
    <Layout style={{ minHeight: '100vh', background: 'var(--ant-layout-color-bg-layout)' }}>
      {/* SIDEBAR desktop */}
      <FixedSider collapsed={collapsed} setCollapsed={setCollapsed}>
        <LogoTitle onSidebarChange={changeSuite} selectedSidebar={suite} />
        <MenuComponent
          routes={suiteRoutes}
          closeDrawer={() => setDrawer(false)}
          selectedSidebar={suite}
        />
      </FixedSider>

      {/* MAIN + HEADER */}
      <Main collapsed={collapsed}>
        <HeaderComponent
          collapsed={collapsed}
          handleToggle={toggle}
          routes={suiteRoutes}
          selectedSidebar={suite}
        />
        <Content
          style={{
            margin      : '20px 16px 15px 16px',
            background  : 'var(--ant-color-bg-container)',
            borderRadius: 8,
          }}
        >
          {children}
        </Content>
      </Main>

      {/* DRAWER mobile */}
      <DrawerComponent
        drawerVisible={drawerVisible}
        closeDrawer={() => setDrawer(false)}
      >
        <LogoTitle onSidebarChange={changeSuite} selectedSidebar={suite} />
        <MenuComponent
          routes={suiteRoutes}
          style={{ minHeight: '100vh' }}
          closeDrawer={() => setDrawer(false)}
          selectedSidebar={suite}
        />
      </DrawerComponent>
    </Layout>
  )
}

===== END components/layout-components/MainLayout.tsx =====


===== BEGIN components/layout-components/Menu.tsx =====
'use client'

import React from 'react'
import { Menu } from 'antd'
import { usePathname } from 'next/navigation'
import Link from 'next/link'

export interface Route {
  path?: string
  name: string
  icon?: React.ReactNode
  views?: Route[]
}

interface Props {
  routes: Route[]
  style?: React.CSSProperties
  closeDrawer: () => void
  selectedSidebar: string
}

const MenuComponent: React.FC<Props> = ({
  routes,
  style,
  closeDrawer,
  selectedSidebar,
}) => {
  const pathname = usePathname()

  /* helpers */
  const toItems = (rs: Route[]): any[] =>
    rs
      .map(r =>
        r.views?.length
          ? {
              key: r.name,
              icon: r.icon,
              label: r.name,
              children: toItems(r.views),
            }
          : r.path
          ? {
              key: r.path,
              icon: r.icon,
              label: (
                <Link
                  href={{ pathname: r.path, query: { sidebar: selectedSidebar } }}
                  onClick={closeDrawer}
                >
                  {r.name}
                </Link>
              ),
            }
          : null,
      )
      .filter(Boolean)

  const flatten = (rs: Route[]): Route[] =>
    rs.flatMap(r => (r.views?.length ? flatten(r.views) : [r]))

  const selectedKeys = flatten(routes)
    .filter(r => r.path && pathname.startsWith(r.path!))
    .map(r => r.path!)

  return (
    <Menu
      mode="inline"
      selectedKeys={selectedKeys}
      items={toItems(routes)}
      style={{
        background: 'var(--ant-color-bg-container)',
        color     : 'var(--ant-color-text)',
        padding   : '16px 0',
        ...style,
      }}
    />
  )
}

export default MenuComponent

===== END components/layout-components/Menu.tsx =====


===== BEGIN components/layout-components/Sider.tsx =====
'use client'

import { Layout } from 'antd'
import styled     from 'styled-components'

const { Sider } = Layout

/* Sider fixe alimenté par les variables Ant Design */
const FixedSider = styled(Sider)`
  background : var(--ant-color-bg-container) !important;
  overflow   : auto;
  height     : 100vh;
  position   : fixed;
  left       : 0;
  box-shadow : var(--ant-box-shadow-secondary, 2px 0 6px rgba(0, 21, 41, .35));
  transition : background 0.3s ease;

  @media (max-width: 575.98px) {
    display: none;
  }
`

interface Props {
  collapsed    : boolean
  setCollapsed : (c: boolean) => void
  children     : React.ReactNode
}

export default function SiderWrapper({
  collapsed,
  setCollapsed,
  children,
}: Props) {
  return (
    <FixedSider
      trigger={null}
      width={256}
      collapsible
      collapsed={collapsed}
      breakpoint="lg"
      onBreakpoint={setCollapsed}
    >
      {children}
    </FixedSider>
  )
}

===== END components/layout-components/Sider.tsx =====


===== BEGIN components/Loading.tsx =====
// components/Loading.tsx
import { Spin } from 'antd'
export default function Loading() {
  return (
    <div style={{ padding: 24, textAlign: 'center' }}>
      <Spin />
    </div>
  )
}

===== END components/Loading.tsx =====


===== BEGIN components/map-components/ControlPanel.tsx =====
/**
 * Description: Helper control panel in Map view to show current co-ordinates of marker
 * Author: Hieu Chu
 */

import React, { PureComponent } from 'react'

type ControlPanelProps = {
  lat: number
  lng: number
}

export default class ControlPanel extends PureComponent<ControlPanelProps> {
  render() {
    const { lat, lng } = this.props
    return (
      <div className="control-panel">
        <div>Latitude: {lat}</div>
        <div>Longitude: {lng}</div>
      </div>
    )
  }
}

===== END components/map-components/ControlPanel.tsx =====


===== BEGIN components/map-components/index.tsx =====
import Map from './Map'

export default Map

===== END components/map-components/index.tsx =====


===== BEGIN components/map-components/Map.tsx =====
'use client';
/**
 * Description: Dynamic map view with support for geolocation control and draggable marker
 * Author: Hieu Chu
 */

import type { CSSProperties } from 'react';
import {
  Map as ReactMapGL,
  Marker,
  NavigationControl,
  FullscreenControl,
  GeolocateControl,
} from 'react-map-gl';

import 'mapbox-gl/dist/mapbox-gl.css';
import MapMarker from './MapMarker';
import ControlPanel from './ControlPanel';

const fullscreenControlStyle: CSSProperties = {
  position: 'absolute',
  top: 0,
  left: 0,
  padding: '10px',
};

const navStyle: CSSProperties = {
  position: 'absolute',
  top: 36,
  left: 0,
  padding: '10px',
};

const geolocateStyle: CSSProperties = {
  position: 'absolute',
  bottom: 30,
  right: 0,
  margin: 10,
};

type ViewState = {
  latitude: number;
  longitude: number;
  zoom: number;
  pitch?: number;
  bearing?: number;
};

type MarkerState = { markerLat: number; markerLng: number };

type Props = {
  view: ViewState;
  setView: (v: ViewState) => void;
  marker: MarkerState;
  setMarker: (m: MarkerState) => void;
};

const Map = ({ view, setView, marker, setMarker }: Props) => {
  const token = process.env.NEXT_PUBLIC_MAPBOX_ACCESS_TOKEN || process.env.NEXT_PUBLIC_MAPBOX_ACCESS_TOKEN || process.env.MAPBOX_ACCESS_TOKEN as string | undefined;
  const { markerLat, markerLng } = marker;

  return (
    <ReactMapGL
      initialViewState={view}
      viewState={view}
      onMove={(evt) => {
        const vs = evt.viewState;
        setView({
          ...view,
          latitude: vs.latitude,
          longitude: vs.longitude,
          zoom: vs.zoom,
          pitch: vs.pitch,
          bearing: vs.bearing,
        });
      }}
      mapboxAccessToken={token}
      mapStyle="mapbox://styles/mapbox/streets-v11"
      style={{ width: '100%', height: '100%' }}
    >
      <Marker
        longitude={markerLng}
        latitude={markerLat}
        draggable
        onDragEnd={(e) => {
          const { lng, lat } = e.lngLat;
          setMarker({ markerLat: lat, markerLng: lng });
        }}
      >
        {/* Removed undeclared `size` prop */}
        <MapMarker />
      </Marker>

      <div className="fullscreen" style={fullscreenControlStyle}>
        <FullscreenControl />
      </div>

      <div className="nav" style={navStyle}>
        <NavigationControl />
      </div>

      <GeolocateControl
        style={geolocateStyle}
        positionOptions={{ enableHighAccuracy: true }}
        trackUserLocation
        showUserLocation
        // Zoom d’accompagnement après géolocalisation
        onGeolocate={() => setView({ ...view, zoom: 13 })}
      />

      {/* Removed undeclared lat/lng props */}
      <ControlPanel lat={markerLat} lng={markerLng} />
    </ReactMapGL>
  );
};

export default Map;

===== END components/map-components/Map.tsx =====


===== BEGIN components/map-components/MapMarker.tsx =====
/**
 * Description: Marker custom icon
 * Author: Hieu Chu
 */

import React, { PureComponent } from 'react'

type MapMarkerProps = {
  size?: number
}

const ICON = `M20.2,15.7L20.2,15.7c1.1-1.6,1.8-3.6,1.8-5.7c0-5.6-4.5-10-10-10S2,4.5,2,10c0,2,0.6,3.9,1.6,5.4c0,0.1,0.1,0.2,0.2,0.3
  c0,0,0.1,0.1,0.1,0.2c0.2,0.3,0.4,0.6,0.7,0.9c2.6,3.1,7.4,7.6,7.4,7.6s4.8-4.5,7.4-7.5c0.2-0.3,0.5-0.6,0.7-0.9
  C20.1,15.8,20.2,15.8,20.2,15.7z`

const pinStyle: React.CSSProperties = {
  fill: '#FF0000',
  stroke: 'none',
  transform: 'translate(-50%,-100%)'
}

export default class MapMarker extends PureComponent<MapMarkerProps> {
  render() {
    const { size = 20 } = this.props
    return (
      <svg height={size} viewBox="0 0 24 24" style={pinStyle}>
        <path d={ICON} />
      </svg>
    )
  }
}

===== END components/map-components/MapMarker.tsx =====


===== BEGIN components/map-components/StaticMap.tsx =====
'use client'

/**
 * Description: Static map view
 * Author: Hieu Chu
 */

import type { CSSProperties } from 'react'
import {
  Map as ReactMapGL,
  Marker,
  FullscreenControl,
  Popup,
  GeolocateControl
} from 'react-map-gl'

import { useState } from 'react'
import 'mapbox-gl/dist/mapbox-gl.css'
import MapMarker from './MapMarker'

const fullscreenControlStyle: CSSProperties = {
  position: 'absolute',
  top: 0,
  left: 0,
  padding: '10px'
}

const geolocateStyle: CSSProperties = {
  position: 'absolute',
  bottom: 30,
  right: 0,
  margin: 10
}

const defaultLocation = {
  latitude: -34.40581053569814,
  longitude: 150.87842788963476
}

type StaticMapProps = {
  markerLat?: number
  markerLng?: number
}

const MyStaticMap = ({ markerLat, markerLng }: StaticMapProps) => {
  const token = process.env.MAPBOX_ACCESS_TOKEN as string | undefined

  const [vp, setVp] = useState({
    latitude: markerLat ?? defaultLocation.latitude,
    longitude: markerLng ?? defaultLocation.longitude,
    zoom: 15,
    pitch: 50
  })

  return (
    <ReactMapGL
      initialViewState={vp}
      viewState={vp}
      onMove={evt => {
        const vs = evt.viewState
        setVp(v => ({
          ...v,
          latitude: vs.latitude,
          longitude: vs.longitude,
          zoom: vs.zoom,
          pitch: vs.pitch,
          bearing: vs.bearing
        }))
      }}
      mapboxAccessToken={token}
      mapStyle="mapbox://styles/mapbox/streets-v11"
      style={{ width: '100%', height: '640px' }}
    >
      <div>
        {markerLat != null && markerLng != null && (
          <>
            <Marker longitude={markerLng} latitude={markerLat}>
              <MapMarker size={22} />
            </Marker>

            <Popup
              anchor="bottom"
              latitude={markerLat}
              longitude={markerLng}
              closeOnClick={false}
              closeButton={false}
              offset={[0, -20]}
            >
              <div style={{ marginLeft: 5, marginRight: 5 }}>
                <div>Latitude: {markerLat}</div>
                <div>Longitude: {markerLng}</div>
              </div>
            </Popup>
          </>
        )}

        <div className="fullscreen" style={fullscreenControlStyle}>
          <FullscreenControl />
        </div>

        <GeolocateControl
          style={geolocateStyle}
          positionOptions={{ enableHighAccuracy: true }}
          trackUserLocation
          showUserLocation
          onGeolocate={() =>
            setVp(v => ({ ...v, zoom: 14 }))
          }
        />
      </div>
    </ReactMapGL>
  )
}

export default MyStaticMap

===== END components/map-components/StaticMap.tsx =====


===== BEGIN components/PageContainer.tsx =====
'use client'

import React, { ReactNode } from 'react'
import styled from 'styled-components'

interface PageContainerProps {
  title: string
  children: ReactNode
}

const Container = styled.div`
  padding: var(--ant-space-lg);
  background: var(--ant-color-bg-container);
  color: var(--ant-color-text);
`

const Header = styled.header`
  border-bottom: 1px solid var(--ant-color-split);
  margin-bottom: var(--ant-space-lg);
`

const Title = styled.h1`
  margin: 0;
  color: var(--ant-color-text);
`

export default function PageContainer({
  title,
  children,
}: PageContainerProps) {
  return (
    <Container>
      <Header>
        <Title>{title}</Title>
      </Header>
      <main>{children}</main>
    </Container>
  )
}

===== END components/PageContainer.tsx =====


===== BEGIN components/sculpture-maker-components/CreateForm/CreateFormTextFields.tsx =====
'use client'

/**
 * Description: Sculpture create text fields component
 * Author: Hieu Chu
 */

import { useState } from 'react'
import { Input, Select, Divider } from 'antd';
import Icon from '@/components/compat/Icon';
const { TextArea } = Input
import { FormCol, CustomFormItem } from '../style'
import { validateLatitude, validateLongitude } from '../../shared/utils'
import MakerCreate from './MakerCreate'

const { Option } = Select

export default ({
  getFieldDecorator,
  initialData: { markerLat, markerLng },
  makerList,
  addMaker
}) => {
  const [showModal, setShowModal] = useState(false)

  const openModal = () => setShowModal(true)
  const handleCancel = () => setShowModal(false)

  return (
    <>
      <FormCol>
        <CustomFormItem label="Sculpture name" hasFeedback>
          {getFieldDecorator('name', {
            rules: [
              {
                required: true,
                whitespace: true,
                message: 'Please fill in the sculpture name!'
              }
            ]
          })(
            <Input
              prefix={
                <Icon type="trophy" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Sculpture name"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Accession ID" hasFeedback>
          {getFieldDecorator('accessionId', {
            rules: [
              {
                required: true,
                whitespace: true,
                message: 'Please fill in the unique accession ID!'
              }
            ]
          })(
            <Input
              prefix={
                <Icon type="number" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Accession ID"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Primary maker" hasFeedback>
          {getFieldDecorator('primaryMakerId', {
            rules: [
              {
                required: true,
                whitespace: true,
                message: 'Please fill in the primary maker!'
              }
            ]
          })(
            <Select
              placeholder="Primary maker"
              dropdownRender={menu => (
                <div>
                  {menu}
                  <Divider style={{ margin: '4px 0' }} />
                  <div
                    style={{ padding: '8px', cursor: 'pointer' }}
                    onMouseDown={e => e.preventDefault()} // fix
                    onClick={openModal}
                  >
                    <Icon type="plus" /> Add new maker
                  </div>
                </div>
              )}
            >
              {makerList.map(maker => (
                <Option key={maker.id} value={maker.id}>
                  {maker.firstName + ' ' + maker.lastName}
                </Option>
              ))}
            </Select>
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Production date" hasFeedback>
          {getFieldDecorator('productionDate')(
            <Input
              prefix={
                <Icon type="calendar" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Production date"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Material" hasFeedback>
          {getFieldDecorator('material')(
            <Input
              prefix={
                <Icon
                  type="code-sandbox"
                  style={{ color: 'rgba(0,0,0,.25)' }}
                />
              }
              type="text"
              placeholder="Material"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Credit line" hasFeedback>
          {getFieldDecorator('creditLine')(
            <TextArea
              placeholder="Credit line"
              autoSize={{ minRows: 3, maxRows: 5 }}
              style={{ marginTop: 5 }}
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Location details" hasFeedback>
          {getFieldDecorator('locationNotes')(
            <TextArea
              placeholder="Location details"
              autoSize={{ minRows: 3, maxRows: 5 }}
              style={{ marginTop: 5 }}
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol xs={24} sm={12}>
        <CustomFormItem label="Latitude" hasFeedback className="latitude-input">
          {getFieldDecorator('latitude', {
            rules: [
              {
                validator: validateLatitude
              }
            ],
            initialValue: String(markerLat)
          })(
            <Input
              prefix={
                <Icon type="compass" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Latitude"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol xs={24} sm={12}>
        <CustomFormItem
          label="Longitude"
          hasFeedback
          className="longitude-input"
        >
          {getFieldDecorator('longitude', {
            rules: [
              {
                validator: validateLongitude
              }
            ],
            initialValue: String(markerLng)
          })(
            <Input
              prefix={
                <Icon type="compass" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Longitude"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <MakerCreate
        visible={showModal}
        handleCancel={handleCancel}
        addMaker={addMaker}
      />
    </>
  )
}

===== END components/sculpture-maker-components/CreateForm/CreateFormTextFields.tsx =====


===== BEGIN components/sculpture-maker-components/CreateForm/index.tsx =====
'use client'

/**
 * Description: Sculpture create page component
 * Author: Hieu Chu
 */

import { useState } from 'react'
import SculptureCreate from './SculptureCreate'
import SculptureUploadImage from './SculptureUploadImage'
const CreateForm = () => {
  const [step, setStep] = useState(1)
  const [sculpture, setSculpture] = useState({})

  if (step === 1) {
    return <SculptureCreate setStep={setStep} setSculpture={setSculpture} />
  } else if (step === 2) {
    return <SculptureUploadImage sculpture={sculpture} />
  }
}

export default CreateForm

===== END components/sculpture-maker-components/CreateForm/index.tsx =====


===== BEGIN components/sculpture-maker-components/CreateForm/MakerCreate.tsx =====
'use client'

/**
 * Description: Component for primary maker create page
 * Author: Hieu Chu
 */

import { useState } from 'react'
import { Form, Input, Button, Modal, message as antdMessage } from 'antd'
import { CustomFormItem } from '../style'
import api from '../../../api'
import { normalizeError } from '../../../shared/errors'

type Maker = {
  id: string | number
  firstName: string
  lastName: string
  nationality?: string
  birthYear?: number | null
  deathYear?: number | null
  wikiUrl?: string
}

type MakerCreateProps = {
  visible: boolean
  handleCancel: () => void
  addMaker: (m: Maker) => void
}

export default function MakerCreate({
  visible,
  handleCancel,
  addMaker,
}: MakerCreateProps) {
  const [form] = Form.useForm()
  const [submitting, setSubmitting] = useState(false)

  const handleOk = async () => {
    try {
      const raw = await form.validateFields()

      // prune empty values
      const values: Record<string, any> = {}
      Object.keys(raw).forEach((k) => {
        const v = raw[k]
        if (v !== undefined && v !== null && String(v).trim() !== '') values[k] = v
      })
      if (values.birthYear) values.birthYear = Number(values.birthYear)
      if (values.deathYear) values.deathYear = Number(values.deathYear)

      setSubmitting(true)
      // axios instance already returns raw data (no `.data`)
      const result = await api.post<Maker>('/maker', values)
      addMaker(result)
      antdMessage.success('Created new maker successfully!', 2)
      form.resetFields()
      handleCancel()
    } catch (e) {
      const { message } = normalizeError(e)
      if (message) antdMessage.error(message)
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <Modal
      open={visible}
      title="Add new maker"
      onOk={handleOk}
      onCancel={handleCancel}
      maskClosable={false}
      footer={[
        <Button key="back" onClick={handleCancel}>
          Cancel
        </Button>,
        <Button key="submit" type="primary" loading={submitting} onClick={handleOk}>
          Submit
        </Button>,
      ]}
    >
      <Form form={form} autoComplete="off" layout="vertical">
        <CustomFormItem
          label="First name"
          name="firstName"
          hasFeedback
          rules={[{ required: true, whitespace: true, message: 'Please fill in the first name!' }]}
        >
          <Input type="text" placeholder="First name" />
        </CustomFormItem>

        <CustomFormItem
          label="Last name"
          name="lastName"
          hasFeedback
          rules={[{ required: true, whitespace: true, message: 'Please fill in the last name!' }]}
        >
          <Input type="text" placeholder="Last name" />
        </CustomFormItem>

        <CustomFormItem label="Nationality" name="nationality" hasFeedback>
          <Input type="text" placeholder="Nationality" />
        </CustomFormItem>

        <CustomFormItem
          label="Born"
          name="birthYear"
          hasFeedback
          rules={[{ pattern: /^\d{4}$/, message: 'Please fill in a valid year!' }]}
        >
          <Input type="text" placeholder="Born" inputMode="numeric" />
        </CustomFormItem>

        <CustomFormItem
          label="Passed away"
          name="deathYear"
          hasFeedback
          rules={[{ pattern: /^\d{4}$/, message: 'Please fill in a valid year!' }]}
        >
          <Input type="text" placeholder="Passed away" inputMode="numeric" />
        </CustomFormItem>

        <CustomFormItem
          label="Website"
          name="wikiUrl"
          hasFeedback
          rules={[{ type: 'url', message: 'Please fill in a valid URL!' }]}
        >
          <Input type="text" placeholder="Website" />
        </CustomFormItem>
      </Form>
    </Modal>
  )
}

===== END components/sculpture-maker-components/CreateForm/MakerCreate.tsx =====


===== BEGIN components/sculpture-maker-components/CreateForm/SculptureCreate.tsx =====
'use client';

import React, { useCallback, useEffect, useState } from 'react';
import { Alert, Button, Col, Form, Row, message as antdMessage } from 'antd';
import type { FormInstance } from 'antd/es/form';
import { Map } from '../../map-components'; // wrapper local; on ne dépend plus de FlyToInterpolator ici
import Loading from '../../Loading';
import api from '../../../shared/api';
import { normalizeError } from '../../../shared/errors';
import {
  ColStyled,
  Container,
  FormCol,
  MapCol,
  MapWrapper,
  Title,
  Wrapper,
} from '../style';
import TextFields from './CreateFormTextFields';

type ErrState = { message: string; statusCode?: number } | null;

type ViewState = {
  longitude: number;
  latitude: number;
  zoom: number;
  pitch: number;
};

type MarkerState = {
  longitude?: number;
  latitude?: number;
};

type SculptureCreateProps = {
  setStep: (updater: number | ((n: number) => number)) => void;
  setSculpture: (data: any) => void;
  initialData?: Record<string, unknown>;
};

const DEFAULT_VIEW: ViewState = {
  longitude: -73.5673,
  latitude: 45.5017,
  zoom: 1,
  pitch: 0,
};

const SculptureCreate: React.FC<SculptureCreateProps> = ({
  setStep,
  setSculpture,
  initialData,
}) => {
  const [form] = Form.useForm();
  const [view, setView] = useState<ViewState>(DEFAULT_VIEW);
  const [marker, setMarker] = useState<MarkerState>({});
  const [makerList, setMakerList] = useState<any[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [error, setError] = useState<ErrState>(null);

  // Exemple de chargement (si présent dans l’original)
  useEffect(() => {
    let mounted = true;
    const run = async () => {
      try {
        setLoading(true);
        // ... éventuels chargements (makers, catégories, etc.)
        // const { data } = await api.get('/makers');
        // if (mounted) setMakerList(data);
      } catch (e: any) {
        const { message, statusCode } = normalizeError(e);
        if (mounted) setError({ message, statusCode });
      } finally {
        if (mounted) setLoading(false);
      }
    };
    run();
    return () => {
      mounted = false;
    };
  }, []);

  const addMaker = useCallback((m: any) => {
    setMakerList((prev) => [...prev, m]);
  }, []);

  const updateMapTo = useCallback(
    (lng: number, lat: number, zoom = 14) => {
      // Remplace l’ancien FlyToInterpolator : on se contente de mettre à jour l’état
      setMarker({ longitude: lng, latitude: lat });
      setView((v) => ({
        ...v,
        longitude: lng,
        latitude: lat,
        zoom: Math.max(v.zoom, zoom),
      }));
      form.setFieldsValue({ longitude: lng, latitude: lat });
    },
    [form]
  );

  const handleMapClick = useCallback(
    (lng: number, lat: number) => updateMapTo(lng, lat),
    [updateMapTo]
  );

  const handleShowOnMap = useCallback(() => {
    const { longitude, latitude } = form.getFieldsValue([
      'longitude',
      'latitude',
    ]) as { longitude?: number; latitude?: number };

    if (
      typeof longitude === 'number' &&
      !Number.isNaN(longitude) &&
      typeof latitude === 'number' &&
      !Number.isNaN(latitude)
    ) {
      updateMapTo(longitude, latitude);
    } else {
      antdMessage.info('Veuillez saisir une longitude et une latitude valides.');
    }
  }, [form, updateMapTo]);

  const coerceNumbersIn = (vals: Record<string, any>) => {
    // Aligne avec l’intention de l’original (conversion lat/lng notamment)
    ['longitude', 'latitude', 'height', 'width', 'depth'].forEach((k) => {
      if (vals[k] !== undefined && vals[k] !== null && vals[k] !== '') {
        const n = Number(vals[k]);
        if (!Number.isNaN(n)) vals[k] = n;
      }
    });
  };

  const handleFinish = async (values: any) => {
    coerceNumbersIn(values);

    setSubmitting(true);
    setError(null);

    try {
      // L’original postait sur /sculpture avec les valeurs du formulaire
      const { data } = await api.post('/sculpture', values);
      setSculpture(data);
      setStep((n) => n + 1);
      antdMessage.success('Sculpture enregistrée.');
    } catch (e: any) {
      const { message, statusCode } = normalizeError(e);
      setError({ message, statusCode });
      antdMessage.error(message || "Échec de l'enregistrement.");
    } finally {
      setSubmitting(false);
    }
  };

  if (loading) return <Loading />;

  return (
    <Wrapper>
      <Title>Créer une sculpture</Title>

      {error && (
        <Alert
          type="error"
          showIcon
          message={error.message}
          style={{ marginBottom: 16 }}
        />
      )}

      <Container>
        <Form
          form={form}
          layout="vertical"
          autoComplete="off"
          initialValues={initialData}
          onFinish={handleFinish}
        >
          <Row gutter={24}>
            <ColStyled xs={24} md={12}>
              {/* ⚠️ TextFields doit être migré pour utiliser <Form.Item name="...">.
                  On lui passe désormais "form" au lieu de getFieldDecorator. */}
              <TextFields
                form={form as FormInstance}
                initialData={initialData}
                makerList={makerList}
                addMaker={addMaker}
              />

              <FormCol xs={24}>
                <Button onClick={handleShowOnMap}>Afficher sur la carte</Button>
              </FormCol>
            </ColStyled>

            <MapCol xs={24} md={12}>
              <MapWrapper>
                <Map
                  view={view}
                  marker={marker}
                  onViewChange={setView}
                  onClick={(lng: number, lat: number) => handleMapClick(lng, lat)}
                />
              </MapWrapper>
            </MapCol>
          </Row>

          <Row>
            <Col xs={24}>
              <Button type="primary" htmlType="submit" loading={submitting}>
                Enregistrer et continuer
              </Button>
            </Col>
          </Row>
        </Form>
      </Container>
    </Wrapper>
  );
};

export default SculptureCreate;

===== END components/sculpture-maker-components/CreateForm/SculptureCreate.tsx =====


===== BEGIN components/sculpture-maker-components/CreateForm/SculptureUploadImage.tsx =====
'use client';

/**
 * Description: Upload image component when creating new sculpture
 * Author: Hieu Chu
 */

import { Upload, Button, message as antdMessage, Row, Modal  } from 'antd';
import { useState } from 'react'
import { CardStyled, ColStyled } from '../style'
import api from '../../../api'
import { useRouter } from 'next/navigation';
import Head from 'next/head'
import { normalizeError } from "../../../shared/errors";
import Icon from '@/components/compat/Icon';

const { confirm } = Modal

const defaultFileList = []

const SculptureUploadImage = ({ sculpture }) => {
  const [fileList, setFileList] = useState([...defaultFileList])
  const { accessionId, name } = sculpture

  const handleRemove = file => {
    return new Promise((resolve, _reject) => {
      confirm({
        title: 'Do you want to remove this image?',
        icon: <Icon type="exclamation-circle" style={{ color: '#ff4d4f' }} />,
        style: { top: 110 },
        maskClosable: true,
        okText: 'Confirm',
        okButtonProps: {
          style: {
            background: '#ff4d4f',
            borderColor: '#ff4d4f'
          }
        },
        onOk: async () => {
          try {
            const _result = await api.delete(`/sculpture-images/${file.uid}`)
            resolve(true)
            setFileList(fileList => fileList.filter(x => x.uid !== file.uid))
            antdMessage.success('Deleted image successfully!', 2)
          } catch (error: unknown) {
            const { message, statusCode } = normalizeError(error);
            antdMessage.error(error.response.data.message)
            resolve(false)
          }
        },
        onCancel: () => {
          resolve(false)
        }
      })
    })
  }

  const customRequest = async e => {
    const config = {
      headers: {
        'content-type':
          'multipart/form-data; boundary=----WebKitFormBoundaryqTqJIxvkWFYqvP5s'
      },
      onUploadProgress: function(progressEvent) {
        var percentCompleted = Math.round(
          (progressEvent.loaded * 100) / progressEvent.total
        )
        e.onProgress(percentCompleted)
      }
    }

    let data = new FormData()
    data.append('images', e.file)
    data.set('accessionId', accessionId)
    const hide = antdMessage.loading('Uploading image...', 0)

    try {
      const _result = await api.post('/sculpture-images', data, config)
      const file = { ...e.file }
      const { id, url } = _result.data[0]
      file.uid = id
      file.url = url
      file.thumbUrl = url
      file.preview = url
      setFileList(fileList => [...fileList, file])

      e.onSuccess(_result.data[0], e.file)
      hide()
      antdMessage.success('Uploaded image successfully!', 2)
    } catch (error: unknown) {
      const { message, statusCode } = normalizeError(error);
      antdMessage.error(error.response.data.message)
      e.onError(error.response.data.message)
    }
  }

  const uploadButton = (
    <div>
      <Icon type="plus" />
      <div className="ant-upload-text">Upload</div>
    </div>
  )

  return (
    <>
      <Head>
        <title>Upload images - UOW Sculptures</title>
      </Head>
      <Row gutter={16}>
        <ColStyled xs={24}>
          <CardStyled title={`Upload sculpture image for ${name}`}>
            <Upload
              defaultFileList={[...defaultFileList]}
              accept="image/*"
              listType="picture-card"
              customRequest={customRequest}
              onRemove={handleRemove}
              fileList={fileList}
            >
              {uploadButton}
            </Upload>

            <Button
              type="primary"
              onClick={() =>
                router.push(`/sculptures/id/${accessionId}`)
              }
            >
              Finish
            </Button>
          </CardStyled>
        </ColStyled>
      </Row>
    </>
  );
}

export default SculptureUploadImage

===== END components/sculpture-maker-components/CreateForm/SculptureUploadImage.tsx =====


===== BEGIN components/sculpture-maker-components/EditForm/EditFormTextFields.tsx =====
'use client'

/**
 * Description: Text details edit component for sculpture
 * Author: Hieu Chu
 */

import { useState } from 'react'
import { Input, Select, Divider } from 'antd';
import Icon from '@/components/compat/Icon';
const { TextArea } = Input
import { FormCol, CustomFormItem } from '../style'
import { validateLatitude, validateLongitude } from '../../shared/utils'
import MakerEdit from './MakerEdit'
import MakerCreate from '../CreateForm/MakerCreate'

const { Option } = Select

export default ({
  getFieldDecorator,
  setFieldsValue,
  getFieldValue,
  initialData: {
    latitude,
    longitude,
    accessionId,
    creditLine,
    locationNotes,
    material,
    name,
    productionDate,
    primaryMakerId
  },
  makerList,
  setMakerList
}) => {
  const [showModal, setShowModal] = useState(false)
  const [showModalCreate, setShowModalCreate] = useState(false)

  const openModal = () => setShowModal(true)
  const handleCancel = () => setShowModal(false)

  const openModalCreate = () => setShowModalCreate(true)
  const handleCancelCreate = () => setShowModalCreate(false)

  const getCurrentMaker = () => {
    return makerList.find(x => x.id === getFieldValue('primaryMakerId'))
  }

  const addMaker = maker => {
    setMakerList(c => [...c, maker])
    setFieldsValue({
      primaryMakerId: maker.id
    })
  }

  const editMaker = maker => {
    setMakerList(c =>
      c.map(m => {
        if (m.id !== maker.id) {
          return m
        }

        return { ...maker }
      })
    )
    setFieldsValue({
      primaryMakerId: maker.id
    })
  }

  return (
    <>
      <FormCol>
        <CustomFormItem label="Sculpture name" hasFeedback>
          {getFieldDecorator('name', {
            rules: [
              {
                required: true,
                whitespace: true,
                message: 'Please fill in the sculpture name!'
              }
            ],
            initialValue: name
          })(
            <Input
              prefix={
                <Icon type="trophy" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Sculpture name"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Accession ID" hasFeedback>
          {getFieldDecorator('accessionId', {
            rules: [
              {
                required: true,
                whitespace: true,
                message: 'Please fill in the unique accession ID!'
              }
            ],
            initialValue: accessionId
          })(
            <Input
              prefix={
                <Icon type="number" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Accession ID"
              // disabled
              readOnly
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Primary maker" hasFeedback>
          {getFieldDecorator('primaryMakerId', {
            rules: [
              {
                required: true,
                whitespace: true,
                message: 'Please fill in the primary maker!'
              }
            ],
            initialValue: primaryMakerId
          })(
            <Select
              placeholder="Primary maker"
              dropdownRender={menu => (
                <div>
                  {menu}
                  <Divider style={{ margin: '4px 0' }} />
                  <div
                    style={{ padding: '8px', cursor: 'pointer' }}
                    onMouseDown={e => e.preventDefault()} // fix
                    onClick={openModal}
                  >
                    <Icon type="edit" /> Edit current maker
                  </div>
                  <div
                    style={{ padding: '8px', cursor: 'pointer' }}
                    onMouseDown={e => e.preventDefault()} // fix
                    onClick={openModalCreate}
                  >
                    <Icon type="plus" /> Add new maker
                  </div>
                </div>
              )}
            >
              {makerList.map(maker => (
                <Option key={maker.id} value={maker.id}>
                  {maker.firstName + ' ' + maker.lastName}
                </Option>
              ))}
            </Select>
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Production date" hasFeedback>
          {getFieldDecorator('productionDate', {
            initialValue: productionDate
          })(
            <Input
              prefix={
                <Icon type="calendar" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Production date"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Material" hasFeedback>
          {getFieldDecorator('material', {
            initialValue: material
          })(
            <Input
              prefix={
                <Icon
                  type="code-sandbox"
                  style={{ color: 'rgba(0,0,0,.25)' }}
                />
              }
              type="text"
              placeholder="Material"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Credit line" hasFeedback>
          {getFieldDecorator('creditLine', {
            initialValue: creditLine
          })(
            <TextArea
              placeholder="Credit line"
              autoSize={{ minRows: 3, maxRows: 5 }}
              style={{ marginTop: 5 }}
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol>
        <CustomFormItem label="Location details" hasFeedback>
          {getFieldDecorator('locationNotes', {
            initialValue: locationNotes
          })(
            <TextArea
              placeholder="Location details"
              autoSize={{ minRows: 3, maxRows: 5 }}
              style={{ marginTop: 5 }}
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol xs={24} sm={12}>
        <CustomFormItem label="Latitude" hasFeedback className="latitude-input">
          {getFieldDecorator('latitude', {
            rules: [
              {
                validator: validateLatitude
              }
            ],
            initialValue: latitude ? String(latitude) : ''
          })(
            <Input
              prefix={
                <Icon type="compass" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Latitude"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <FormCol xs={24} sm={12}>
        <CustomFormItem
          label="Longitude"
          hasFeedback
          className="longitude-input"
        >
          {getFieldDecorator('longitude', {
            rules: [
              {
                validator: validateLongitude
              }
            ],
            initialValue: longitude ? String(longitude) : ''
          })(
            <Input
              prefix={
                <Icon type="compass" style={{ color: 'rgba(0,0,0,.25)' }} />
              }
              type="text"
              placeholder="Longitude"
            />
          )}
        </CustomFormItem>
      </FormCol>

      <MakerEdit
        visible={showModal}
        handleCancel={handleCancel}
        getCurrentMaker={getCurrentMaker}
        editMaker={editMaker}
      />

      <MakerCreate
        visible={showModalCreate}
        handleCancel={handleCancelCreate}
        addMaker={addMaker}
      />
    </>
  )
}

===== END components/sculpture-maker-components/EditForm/EditFormTextFields.tsx =====


===== BEGIN components/sculpture-maker-components/EditForm/EditImage.tsx =====
'use client';

/**
 * Description: Image edit component for sculpture
 * Author: Hieu Chu
 */

import { Upload, Button, message as antdMessage, Row, Modal  } from 'antd';
import { useState } from 'react'
import { ColStyled } from '../style'
import api from '../../../api'
import { useRouter } from 'next/navigation';
import { normalizeError } from "../../../shared/errors";
import Icon from '@/components/compat/Icon';

const { confirm } = Modal

const EditImage = ({ accessionId, _name, images }) => {
  const [fileList, setFileList] = useState([...images])
  const [isSubmitting, setIsSubmitting] = useState(false)

  const handleRemove = file => {
    return new Promise((resolve, _reject) => {
      confirm({
        title: 'Do you want to remove this image?',
        icon: <Icon type="exclamation-circle" style={{ color: '#ff4d4f' }} />,
        style: { top: 110 },
        maskClosable: true,
        okText: 'Confirm',
        okButtonProps: {
          style: {
            background: '#ff4d4f',
            borderColor: '#ff4d4f'
          }
        },
        onOk: async () => {
          setIsSubmitting(true)
          try {
            const _result = await api.delete(`/sculpture-images/${file.uid}`)
            resolve(true)
            setFileList(fileList => fileList.filter(x => x.uid !== file.uid))
            antdMessage.success('Deleted image successfully!', 2)
          } catch (error: unknown) {
            const { message, statusCode } = normalizeError(error);
            antdMessage.error(error.response.data.message)
            resolve(false)
          }
          setIsSubmitting(false)
        },
        onCancel: () => {
          resolve(false)
        }
      })
    })
  }

  const customRequest = async e => {
    const config = {
      headers: {
        'content-type':
          'multipart/form-data; boundary=----WebKitFormBoundaryqTqJIxvkWFYqvP5s'
      },
      onUploadProgress: function(progressEvent) {
        var percentCompleted = Math.round(
          (progressEvent.loaded * 100) / progressEvent.total
        )
        e.onProgress(percentCompleted)
      }
    }

    let data = new FormData()
    data.append('images', e.file)
    data.set('accessionId', accessionId)
    const hide = antdMessage.loading('Uploading image...', 0)
    setIsSubmitting(true)

    try {
      const _result = await api.post('/sculpture-images', data, config)
      const file = { ...e.file }
      const { id, url } = _result.data[0]
      file.uid = id
      file.url = url
      file.thumbUrl = url
      file.preview = url
      setFileList(fileList => [...fileList, file])

      e.onSuccess(_result.data[0], e.file)
      hide()
      antdMessage.success('Uploaded image successfully!', 2)
    } catch (error: unknown) {
      const { message, statusCode } = normalizeError(error);
      antdMessage.error(error.response.data.message)
      e.onError(error.response.data.message)
    }
    setIsSubmitting(false)
  }

  const uploadButton = (
    <div>
      <Icon type="plus" />
      <div className="ant-upload-text">Upload</div>
    </div>
  )

  return (
    <Row gutter={16}>
      <ColStyled xs={24}>
        <Upload
          accept="image/*"
          listType="picture-card"
          customRequest={customRequest}
          onRemove={handleRemove}
          fileList={fileList}
        >
          {uploadButton}
        </Upload>

        <Button
          type="primary"
          loading={isSubmitting}
          onClick={() =>
            router.push(`/sculptures/id/${accessionId}`)
          }
        >
          Finish
        </Button>
      </ColStyled>
    </Row>
  );
}

export default EditImage

===== END components/sculpture-maker-components/EditForm/EditImage.tsx =====


===== BEGIN components/sculpture-maker-components/EditForm/index.tsx =====
'use client';

/**
 * Description: Sculpture Edit Page component
 * Author: Hieu Chu
 */

import { useEffect, useMemo, useState } from 'react';
import { useRouter, useParams, useSearchParams } from 'next/navigation';
import { Row, Modal, Button, message as antdMessage, notification, Result  } from 'antd';
import { ExclamationCircleOutlined, DeleteOutlined } from '@ant-design/icons';

import { CardStyled, ColStyled } from '../style';
import SculptureEdit from './SculptureEdit';
import EditImage from './EditImage';

// NOTE: API legacy import conservé tel que dans la base
import api from '../../../api';
import { normalizeError } from '../../../shared/errors';

const defaultPosition: [number, number] = [-34.40581053569814, 150.87842788963476];
const { confirm } = Modal;

const tabList = [
  { key: 'tab1', tab: 'Edit text details' },
  { key: 'tab2', tab: 'Edit images' },
] as const;

type TabKey = (typeof tabList)[number]['key'];

type Maker = {
  firstName?: string;
  lastName?: string;
  wikiUrl?: string;
  birthYear?: number | null;
  deathYear?: number | null;
  nationality?: string | null;
};

type ImageItem = {
  id: string | number;
  url: string;
  created: string;
};

type InitialData = {
  accessionId: string;
  name: string;
  images: ImageItem[];
  latitude?: number | null;
  longitude?: number | null;
  primaryMaker?: Maker;
};

type HttpError = { statusCode: number; message: string };

const SculptureEditForm = () => {
  const router = useRouter();
  const params = useParams<{ id?: string; sculptureId?: string }>();
  const searchParams = useSearchParams();

  // Prefer dynamic segment names, then fallback to query ?id=
  const sculptureId = useMemo(
    () => params?.sculptureId ?? params?.id ?? searchParams.get('id') ?? undefined,
    [params, searchParams]
  );

  const [initialData, setInitialData] = useState<InitialData | null>(null);
  const [makerList, setMakerList] = useState<Maker[]>([]);
  const [tabKey, setTabKey] = useState<TabKey>('tab1');
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<HttpError | null>(null);

  const handleTabChange = (key: TabKey) => setTabKey(key);

  const handleDelete = () => {
    confirm({
      title: 'Do you want to remove this sculpture?',
      icon: <ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />,
      style: { top: 110 },
      maskClosable: true,
      okText: 'Confirm',
      okButtonProps: { style: { background: '#ff4d4f', borderColor: '#ff4d4f' } },
      onOk: async () => {
        try {
          if (!sculptureId) return;
          await api.delete(`/sculpture/${sculptureId}`);
          antdMessage.success('Deleted sculpture successfully!', 2);
          router.push('/sculptures');
        } catch (e: unknown) {
          const { message: errMsg } = normalizeError(e);
          notification.error({
            message: 'Delete failed',
            description: errMsg || 'Unexpected error while deleting the sculpture.',
          });
        }
      },
    });
  };

  useEffect(() => {
    const fetchInitialForm = async () => {
      if (!sculptureId) {
        setLoading(false);
        return;
      }
      try {
        const { data } = await api.get<InitialData>(`/sculpture/${sculptureId}`);
        const next: InitialData = {
          ...data,
          latitude: data.latitude != null ? Number(data.latitude) : data.latitude ?? null,
          longitude: data.longitude != null ? Number(data.longitude) : data.longitude ?? null,
          images: Array.isArray(data.images) ? data.images : [],
        };
        setInitialData(next);

        const makersRes = await api.get<Maker[]>('/maker/');
        setMakerList(Array.isArray(makersRes.data) ? makersRes.data : []);
      } catch (e: unknown) {
        const { statusCode = 500, message: errMsg = 'Unknown error' } = normalizeError(e);
        setError({ statusCode, message: errMsg });
      } finally {
        setLoading(false);
      }
    };
    fetchInitialForm();
  }, [sculptureId]);

  if (loading) return null;

  if (error) {
    const status = (['404', '403', '500'] as const).includes(String(error.statusCode) as any)
      ? (String(error.statusCode) as '404' | '403' | '500')
      : 'error';
    return (
      <Result
        status={status}
        title={error.message}
        subTitle={`Error ${error.statusCode}`}
        extra={
          <Button type="primary" onClick={() => router.back()}>
            Go Back
          </Button>
        }
      />
    );
  }

  if (!initialData) return null;

  const sortedImages: ImageItem[] = [...(initialData.images ?? [])].sort(
    (a, b) => new Date(a.created).getTime() - new Date(b.created).getTime()
  );

  return (
    <Row gutter={16}>
      <ColStyled xs={24}>
        <CardStyled
          title={`Edit details for ${initialData.name}`}
          tabList={tabList as unknown as { key: string; tab: string }[]}
          activeTabKey={tabKey}
          onTabChange={handleTabChange as (key: string) => void}
          extra={
            <Button danger icon={<DeleteOutlined />} onClick={handleDelete}>
              Delete
            </Button>
          }
        >
          <div style={{ display: tabKey === 'tab1' ? 'block' : 'none' }}>
            <SculptureEdit
              defaultPosition={defaultPosition}
              initialData={{ ...initialData, images: sortedImages }}
              makerList={makerList}
              setMakerList={setMakerList}
            />
          </div>

          <div style={{ display: tabKey === 'tab2' ? 'block' : 'none' }}>
            <EditImage
              accessionId={initialData.accessionId}
              _name={initialData.name} // NOTE: the component expects `_name`
              images={sortedImages.map((img) => ({
                ...img,
                uid: img.id,
                thumbUrl: img.url,
                preview: img.url,
                status: 'done',
              }))}
            />
          </div>
        </CardStyled>
      </ColStyled>
    </Row>
  );
};

export { SculptureEditForm };

===== END components/sculpture-maker-components/EditForm/index.tsx =====


===== BEGIN components/sculpture-maker-components/EditForm/MakerEdit.tsx =====
'use client'

/**
 * Description: Primary maker edit page component (migrated to AntD v4/v5)
 * Notes:
 *  - Replaces Form.create/getFieldDecorator with Form.useForm + Form.Item
 *  - Replaces validateFields(cb) with await form.validateFields()
 *  - Keeps props API: visible, handleCancel, getCurrentMaker, editMaker
 */

import { useEffect, useState } from 'react'
import { Form, Input, Button, Modal, message as antdMessage } from 'antd'
import { CustomFormItem } from '../style'
import api from '../../../api'
import { normalizeError } from '../../../shared/errors'

type Maker = {
  id: string | number
  firstName: string
  lastName: string
  nationality?: string | null
  birthYear?: number | null
  deathYear?: number | null
  wikiUrl?: string | null
}

type MakerEditProps = {
  /** Modal state controlled by parent */
  visible: boolean
  /** Close handler (parent hides the modal) */
  handleCancel: () => void
  /** Returns the currently selected maker from the parent list */
  getCurrentMaker: () => Maker
  /** Parent updater after a successful save */
  editMaker: (m: Maker) => void
}

export default function MakerEdit({
  visible,
  handleCancel,
  getCurrentMaker,
  editMaker,
}: MakerEditProps) {
  const [form] = Form.useForm()
  const [submitting, setSubmitting] = useState(false)

  // Pre-fill form when modal opens or selection changes
  useEffect(() => {
    if (!visible) {
      form.resetFields()
      return
    }
    const m = getCurrentMaker?.()
    if (m) {
      form.setFieldsValue({
        firstName: m.firstName ?? '',
        lastName: m.lastName ?? '',
        nationality: m.nationality ?? '',
        birthYear: m.birthYear != null ? String(m.birthYear) : '',
        deathYear: m.deathYear != null ? String(m.deathYear) : '',
        wikiUrl: m.wikiUrl ?? '',
      })
    }
  }, [visible, getCurrentMaker, form])

  const handleOk = async () => {
    try {
      const raw = await form.validateFields()

      // prune + convert
      const values: Record<string, any> = {}
      Object.keys(raw).forEach((k) => {
        const v = raw[k]
        if (v !== undefined && v !== null && String(v).trim() !== '') values[k] = v
        else values[k] = null
      })
      if (values.birthYear) values.birthYear = Number(values.birthYear)
      if (values.deathYear) values.deathYear = Number(values.deathYear)

      const current = getCurrentMaker?.()
      if (!current?.id) {
        antdMessage.error('Maker introuvable pour la mise à jour.')
        return
      }
      values.id = current.id

      setSubmitting(true)
      // NB: dans le code récent de MakerCreate vous consommez directement la data (pas .data)
      await api.patch('/maker', values)

      // Sync liste côté parent
      editMaker({ ...current, ...values })
      antdMessage.success('Updated maker details successfully!', 2)

      form.resetFields()
      handleCancel()
    } catch (e: any) {
      // validateFields peut lever une exception de validation -> ne pas traiter comme erreur API
      if (e?.errorFields) return
      const { message: msg } = normalizeError(e)
      antdMessage.error(msg || 'Update failed')
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <Modal
      open={visible}                // AntD v5: prop "open" (remplace "visible")
      title="Edit maker details"
      onOk={handleOk}
      onCancel={handleCancel}
      maskClosable={false}
      footer={[
        <Button key="back" onClick={() => form.resetFields()}>
          Reset
        </Button>,
        <Button key="submit" type="primary" loading={submitting} onClick={handleOk}>
          Submit
        </Button>,
      ]}
    >
      <Form form={form} autoComplete="off" layout="vertical">
        <CustomFormItem
          label="First name"
          name="firstName"
          hasFeedback
          rules={[{ required: true, whitespace: true, message: 'Please fill in the first name!' }]}
        >
          <Input type="text" placeholder="First name" />
        </CustomFormItem>

        <CustomFormItem
          label="Last name"
          name="lastName"
          hasFeedback
          rules={[{ required: true, whitespace: true, message: 'Please fill in the last name!' }]}
        >
          <Input type="text" placeholder="Last name" />
        </CustomFormItem>

        <CustomFormItem label="Nationality" name="nationality" hasFeedback>
          <Input type="text" placeholder="Nationality" />
        </CustomFormItem>

        <CustomFormItem
          label="Born"
          name="birthYear"
          hasFeedback
          rules={[{ pattern: /^\d{4}$/, message: 'Please fill in a valid year!' }]}
        >
          <Input type="text" placeholder="Born" />
        </CustomFormItem>

        <CustomFormItem
          label="Passed away"
          name="deathYear"
          hasFeedback
          rules={[{ pattern: /^\d{4}$/, message: 'Please fill in a valid year!' }]}
        >
          <Input type="text" placeholder="Passed away" />
        </CustomFormItem>

        <CustomFormItem
          label="Website"
          name="wikiUrl"
          hasFeedback
          rules={[{ type: 'url' as const, message: 'Please fill in a valid URL!' }]}
        >
          <Input type="text" placeholder="Website" />
        </CustomFormItem>
      </Form>
    </Modal>
  )
}

===== END components/sculpture-maker-components/EditForm/MakerEdit.tsx =====


===== BEGIN components/sculpture-maker-components/EditForm/SculptureEdit.tsx =====
'use client';

import React, { useCallback, useMemo, useRef, useState } from 'react';
import { Form, Input, Button, Upload, message } from 'antd';
import type { UploadChangeParam, UploadFile } from 'antd/es/upload/interface';
import type { RcFile } from 'antd/es/upload';
import Map, { Marker, MapRef, ViewState, MapLayerMouseEvent } from 'react-map-gl';

const { TextArea } = Input;

export interface Sculpture {
  id: string;
  title: string;
  description: string;
  location: { lat: number; lng: number };
  imageUrl?: string;
}

export interface SculptureEditProps {
  sculpture: Sculpture;
  /** Soumission des données modifiées. Branche ici ta persistance. */
  onSubmit: (updated: Sculpture) => Promise<void>;
}

/** Normalise l’événement Upload → fileList (AntD v4). */
function normFile(e: UploadChangeParam<UploadFile>): UploadFile[] {
  return e?.fileList ?? [];
}

/** Transforme un UploadFile → File (si présent). */
function toFile(uploadFile?: UploadFile): File | undefined {
  const f = uploadFile?.originFileObj as RcFile | undefined;
  return f as unknown as File | undefined;
}

export default function SculptureEdit({ sculpture, onSubmit }: SculptureEditProps) {
  const [form] = Form.useForm();
  const mapRef = useRef<MapRef | null>(null);

  const initialViewState = useMemo<ViewState>(() => ({
    longitude: sculpture.location?.lng ?? 0,
    latitude: sculpture.location?.lat ?? 0,
    zoom: 12,
  }), [sculpture.location?.lat, sculpture.location?.lng]);

  const [viewState, setViewState] = useState<ViewState>(initialViewState);

  const flyTo = useCallback((lat: number, lng: number) => {
    mapRef.current?.flyTo({ center: [lng, lat], zoom: 12, duration: 1200 });
  }, []);

  const onMapClick = useCallback((e: MapLayerMouseEvent) => {
    const { lat, lng } = e.lngLat;
    form.setFieldsValue({ location: { lat, lng } });
    setViewState((vs) => ({ ...vs, latitude: lat, longitude: lng }));
  }, [form]);

  const onFinish = useCallback(async (values: any) => {
    try {
      // NOTE: values a la forme { title, description, location: {lat,lng}, image?: UploadFile[] }
      const file = toFile(values.image?.[0]);
      let imageUrl = sculpture.imageUrl;

      // TODO: uploader le fichier si présent et récupérer un URL
      // if (file) {
      //   const uploadedUrl = await uploadImageToYourAPI(file);
      //   imageUrl = uploadedUrl;
      // }

      const updated: Sculpture = {
        ...sculpture,
        title: values.title,
        description: values.description,
        location: { lat: values.location?.lat, lng: values.location?.lng },
        imageUrl,
      };

      await onSubmit(updated);
      message.success('Sculpture mise à jour');
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error(err);
      message.error("Échec de l'enregistrement");
    }
  }, [onSubmit, sculpture]);

  const onFinishFailed = useCallback(() => {
    message.warning('Merci de corriger les champs requis.');
  }, []);

  return (
    <div style={{ display: 'grid', gap: 16, gridTemplateColumns: '1fr', maxWidth: 900 }}>
      <Form
        form={form}
        layout="vertical"
        initialValues={{
          title: sculpture.title,
          description: sculpture.description,
          location: {
            lat: sculpture.location?.lat,
            lng: sculpture.location?.lng,
          },
          image: [] as UploadFile[],
        }}
        onFinish={onFinish}
        onFinishFailed={onFinishFailed}
      >
        <Form.Item
          label="Titre"
          name="title"
          rules={[{ required: true, message: 'Veuillez saisir un titre.' }]}
        >
          <Input placeholder="Titre de la sculpture" />
        </Form.Item>

        <Form.Item
          label="Description"
          name="description"
          rules={[{ required: true, message: 'Veuillez saisir une description.' }]}
        >
          <TextArea rows={4} placeholder="Décrivez la sculpture…" />
        </Form.Item>

        {/* Coordonnées (lat/lng) synchronisées avec la carte */}
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 12 }}>
          <Form.Item
            label="Latitude"
            name={['location', 'lat']}
            rules={[{ required: true, message: 'Latitude requise.' }]}
          >
            <Input type="number" step="0.000001" onBlur={() => {
              const { location } = form.getFieldsValue();
              if (location?.lat != null && location?.lng != null) {
                flyTo(Number(location.lat), Number(location.lng));
              }
            }} />
          </Form.Item>
          <Form.Item
            label="Longitude"
            name={['location', 'lng']}
            rules={[{ required: true, message: 'Longitude requise.' }]}
          >
            <Input type="number" step="0.000001" onBlur={() => {
              const { location } = form.getFieldsValue();
              if (location?.lat != null && location?.lng != null) {
                flyTo(Number(location.lat), Number(location.lng));
              }
            }} />
          </Form.Item>
        </div>

        {/* Upload de l’image (optionnel). Laisse la TODO pour brancher ton backend. */}
        <Form.Item label="Image" name="image" valuePropName="fileList" getValueFromEvent={normFile}>
          <Upload beforeUpload={() => false} listType="picture-card" maxCount={1}>
            <div>Choisir une image</div>
          </Upload>
        </Form.Item>

        <div style={{ display: 'flex', gap: 8 }}>
          <Button type="primary" htmlType="submit">Enregistrer</Button>
          <Button
            onClick={() => flyTo(
              form.getFieldValue(['location', 'lat']),
              form.getFieldValue(['location', 'lng']),
            )}
          >
            Recentrer la carte
          </Button>
        </div>
      </Form>

      {/* Carte : React Map GL (v7/8). Si tu es sur MapLibre, change l’import à `react-map-gl/maplibre`. */}
      <div style={{ height: 360 }}>
        <Map
          ref={mapRef}
          mapboxAccessToken={process.env.NEXT_PUBLIC_MAPBOX_TOKEN}
          mapStyle="mapbox://styles/mapbox/streets-v11"
          initialViewState={initialViewState}
          {...viewState}
          onMove={(evt) => setViewState(evt.viewState)}
          onClick={onMapClick}
          style={{ width: '100%', height: '100%' }}
        >
          <Marker latitude={viewState.latitude} longitude={viewState.longitude} />
        </Map>
      </div>
    </div>
  );
}

===== END components/sculpture-maker-components/EditForm/SculptureEdit.tsx =====


===== BEGIN components/sculpture-maker-components/MakerList.tsx =====
'use client'

/**
 * Description: Primary maker list component
 * Author: Hieu Chu
 */

import { useState, useEffect } from 'react'
import { Row, Divider, Modal, message as antdMessage, notification, Button  } from 'antd';import { ExclamationCircleOutlined, PlusOutlined } from '@ant-design/icons'
import { ColStyled, CardStyled, StyledTable } from './style'
import MakerEdit from './EditForm/MakerEdit'
import api from '@/services/_request'
import Loading from '../Loading'
import Error from 'next/error'
import MakerCreate from './CreateForm/MakerCreate'
import { normalizeError } from "../../shared/errors";

const { confirm } = Modal

const MakerList = () => {
  useEffect(() => {
    const fetchMakerList = async () => {
      try {
        const data = (await api.get('/maker/')).data

        let formattedData = data.map((maker: any) => {
          let formattedMaker = { ...maker }
          formattedMaker.key = maker.id
          return formattedMaker
        })

        formattedData.sort((a: any, b: any) => a.firstName.localeCompare(b.firstName))

        console.log(formattedData)
        setMakerList(formattedData)
      } catch (e: any) {
        const { message, statusCode } = normalizeError(e);
        const { statusCode, message } = e.response.data
        setError({
          statusCode,
          message
        })
      }
      setLoading(false)
    }
    fetchMakerList()
  }, [])

  const [makerList, setMakerList] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<any>(null)

  const [showModal, setShowModal] = useState(false)
  const [showModalCreate, setShowModalCreate] = useState(false)

  const [currentMakerId, setCurrentMakerId] = useState('')
  const openModal = (makerId: string) => {
    setCurrentMakerId(makerId)
    setShowModal(true)
  }

  const openModalCreate = () => {
    setShowModalCreate(true)
  }

  const handleCancel = () => setShowModal(false)
  const handleCancelCreate = () => setShowModalCreate(false)

  const getCurrentMaker = () =>
    makerList.find(x => x.id === currentMakerId) || {}

  const editMaker = (maker: any) => {
    setMakerList(list =>
      list.map(x => {
        if (x.id === maker.id) {
          return { ...maker, key: maker.id }
        }
        return x
      })
    )
  }

  const deleteMaker = (makerId: string) => {
    setMakerList(list => list.filter(x => x.id !== makerId))
  }

  const addMaker = (maker: any) => {
    maker.key = maker.id
    setMakerList(list => [...list, maker])
  }

  const handleDelete = (makerId: string) => {
    confirm({
      title: 'Do you want to remove this maker?',
      icon: <ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />,
      style: { top: 110 },
      maskClosable: true,
      okText: 'Confirm',
      okButtonProps: {
        style: {
          background: '#ff4d4f',
          borderColor: '#ff4d4f'
        }
      },
      onOk: async () => {
        try {
          await api.delete(`/maker/${makerId}`)
          deleteMaker(makerId)
          antdMessage.success('Deleted maker successfully!', 2)
        } catch (error: unknown) {
          const { message, statusCode } = normalizeError(error);
          notification.error({
            message: 'Error',
            description:
              "There has been internal server error or the maker you're trying to delete is currently associated with a sculpture."
          })
        }
      }
    })
  }

  const columns = [
    {
      title: 'Maker name',
      key: 'makerName',
      width: '22%',
      render: (_: any, record: any) => {
        const { firstName, lastName, wikiUrl } = record
        const makerName = firstName + ' ' + lastName
        if (!wikiUrl) {
          return <span>{makerName}</span>
        }
        return <a href={wikiUrl}>{makerName}</a>
      }
    },

    {
      title: 'Nationality',
      dataIndex: 'nationality',
      width: '22%'
    },
    {
      title: 'Born - Passed away',
      key: 'year',
      width: '28%',
      render: (_: any, record: any) => {
        let { birthYear, deathYear } = record
        if (!birthYear) birthYear = 'N/A'
        if (!deathYear) deathYear = 'N/A'
        return <span>{birthYear + ' - ' + deathYear}</span>
      }
    },
    {
      title: 'Action',
      key: 'action',
      render: (record, row) => (
        <span>
          <a onClick={() => openModal(record.key)}>Edit</a>
          <Divider type="vertical" />
          <a onClick={() => handleDelete(record.key)}>Delete</a>
        </span>
      )
    }
  ]

  if (loading) return <Loading />
  if (error)
    return <Error statusCode={error.statusCode} title={error.message} />

  return (
    <Row gutter={16}>
      <ColStyled xs={24}>
        <CardStyled
          title="Maker List"
          extra={
            <Button type="primary" icon={<PlusOutlined />} onClick={openModalCreate}>
              Add new maker
            </Button>
          }
        >
          <StyledTable
            dataSource={makerList}
            columns={columns}
            pagination={{ pageSize: 25, hideOnSinglePage: true }}
            style={{ maxWidth: 750 }}
          />
        </CardStyled>
      </ColStyled>

      <MakerEdit
        visible={showModal}
        handleCancel={handleCancel}
        getCurrentMaker={getCurrentMaker}
        editMaker={editMaker}
      />

      <MakerCreate
        visible={showModalCreate}
        handleCancel={handleCancelCreate}
        addMaker={addMaker}
      />
    </Row>
  )
}

export default MakerList

===== END components/sculpture-maker-components/MakerList.tsx =====


===== BEGIN components/sculpture-maker-components/SculptureDetail/index.tsx =====
'use client'

/**
 * Description: Sculpture Detail page component
 * Author: Hieu Chu
 */

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Row, Carousel, Typography, List, Empty, Button } from 'antd'
import { ColStyled, CardStyled } from '../style'
import { SculptureCardDescription } from '../SculptureGrid'
import api from '../../../api'
import Loading from '../../Loading'
import Error from 'next/error'
import MyStaticMap from '../../map-components/StaticMap'
import Link from 'next/link'
import Head from 'next/head'
import SculptureComment from './SculptureComment'
import SculptureTrend from './SculptureTrend'
import { normalizeError } from "../../../shared/errors";

const { Title } = Typography

const SculptureDetail = () => {
  const [sculpture, setSculpture] = useState({})
  const [comments, setComments] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    const fetchData = async () => {
      try {
        const sculpturePromise = api.get(`/sculpture/${id}`)
        const commentPromise = api.get(`/comment/sculpture-id/${id}`)

        const [rawSculpture, rawComments] = await Promise.all([
          sculpturePromise,
          commentPromise
        ])

        setComments(rawComments.data)
        console.log('hhhh', rawComments.data)
        setSculpture(rawSculpture.data)
      } catch (e: unknown) {
        const { message, statusCode } = normalizeError(e);
        const { statusCode, message } = e.response.data
        setError({
          statusCode,
          message
        })
      }
      setLoading(false)
    }

    fetchData()
  }, [id])

  const deleteComment = commentId => {
    setComments(c => c.filter(x => x.commentId !== commentId))
    setSculpture(x => ({
      ...x,
      totalComments: +x.totalComments - 1
    }))
  }

  const addComment = comment => {
    setComments(c => [comment, ...c])
    setSculpture(x => ({
      ...x,
      totalComments: +x.totalComments + 1
    }))
  }

  const router = useRouter()
  const id = router.query.id

  if (loading) return <Loading />
  if (error)
    return <Error statusCode={error.statusCode} title={error.message} />

  const {
    images,
    name,
    primaryMaker,
    accessionId,
    longitude,
    latitude,
    productionDate,
    material,
    creditLine,
    locationNotes,
    totalLikes,
    totalComments,
    totalVisits
  } = sculpture

  const { birthYear, deathYear, nationality, wikiUrl } = primaryMaker

  const markerLat = Number(latitude)
  const markerLng = Number(longitude)

  images.sort(
    (a, b) => new Date(a.created).getTime() - new Date(b.created).getTime()
  )
  const imageList = images.map((image, idx) => (
    <div key={idx}>
      <img src={image.url} />
    </div>
  ))

  return (
    <>
      <Head>
        <title>{name} - UOW Sculptures</title>
      </Head>
      <Row gutter={16}>
        <ColStyled xs={24} lg={15}>
          <CardStyled
            title="Sculpture Details"
            extra={
              <Link href={`/sculptures/id/${id}/edit`}>
                <a>
                  <Button icon="edit">Edit details</Button>
                </a>
              </Link>
            }
          >
            <Carousel
              draggable
              style={{
                width: '100%'
              }}
            >
              {images.length ? (
                imageList
              ) : (
                <div>
                  <Empty
                    image={Empty.PRESENTED_IMAGE_SIMPLE}
                    style={{ height: 100, marginTop: 100 }}
                  />
                </div>
              )}
            </Carousel>
            <div
              style={{
                marginTop: 15
              }}
            >
              <Title level={4} style={{ marginBottom: 0 }}>
                {name}
              </Title>
              <SculptureCardDescription
                totalLikes={totalLikes}
                totalComments={totalComments}
                totalVisits={totalVisits}
                makerName={primaryMaker.firstName + ' ' + primaryMaker.lastName}
              />

              <List itemLayout="horizontal">
                <List.Item>
                  <List.Item.Meta
                    title="Accession ID"
                    description={
                      !accessionId.includes('unknown') ? accessionId : 'N/A'
                    }
                  />
                </List.Item>
                <List.Item>
                  <List.Item.Meta
                    title="Production Date"
                    description={productionDate ? productionDate : 'N/A'}
                  />
                </List.Item>
                <List.Item>
                  <List.Item.Meta
                    title="Material"
                    description={material ? material : 'N/A'}
                  />
                </List.Item>
                <List.Item>
                  <List.Item.Meta
                    title="Credit Line"
                    description={
                      creditLine
                        ? creditLine
                            .trim()
                            .split('\n')
                            .map((line, idx) => <div key={idx}>{line}</div>)
                        : 'N/A'
                    }
                  />
                </List.Item>
                <List.Item>
                  <List.Item.Meta
                    title="Location Details"
                    description={
                      locationNotes
                        ? locationNotes
                            .trim()
                            .split('\n')
                            .map((line, idx) => <div key={idx}>{line}</div>)
                        : 'N/A'
                    }
                  />
                </List.Item>
              </List>
            </div>
          </CardStyled>

          <SculptureTrend
            totalLikes={totalLikes}
            totalComments={totalComments}
            totalVisits={totalVisits}
            sculptureId={id}
          />
        </ColStyled>
        {/* Maker detail */}
        <ColStyled xs={24} lg={9}>
          <MyStaticMap markerLat={markerLat} markerLng={markerLng} />
          <CardStyled title="Primary maker details" style={{ marginTop: 10 }}>
            <List
              itemLayout="horizontal"
              style={{
                marginTop: -20
              }}
            >
              <List.Item>
                <List.Item.Meta
                  title="Full Name"
                  description={
                    primaryMaker.firstName + ' ' + primaryMaker.lastName
                  }
                />
              </List.Item>
              <List.Item>
                <List.Item.Meta
                  title="Nationality"
                  description={nationality ? nationality : 'N/A'}
                />
              </List.Item>
              <List.Item>
                <List.Item.Meta
                  title="Born"
                  description={birthYear ? birthYear : 'N/A'}
                />
              </List.Item>
              <List.Item>
                <List.Item.Meta
                  title="Passed away"
                  description={deathYear ? deathYear : 'N/A'}
                />
              </List.Item>
              <List.Item>
                <List.Item.Meta
                  title="Website"
                  description={
                    wikiUrl ? <a href={`${wikiUrl}`}>{wikiUrl}</a> : 'N/A'
                  }
                />
              </List.Item>
            </List>
          </CardStyled>

          <SculptureComment
            comments={comments}
            deleteComment={deleteComment}
            addComment={addComment}
            sculptureId={id}
          />
        </ColStyled>
      </Row>
    </>
  );
}

export default SculptureDetail

===== END components/sculpture-maker-components/SculptureDetail/index.tsx =====


===== BEGIN components/sculpture-maker-components/SculptureDetail/SculptureComment.tsx =====
'use client'

/**
 * Description: Sculpture's comment list component
 * Author: Hieu Chu
 */

import dayjs from 'dayjs'
import { Tooltip,
  List,
  Comment,
  Card,
  Dropdown,
  Modal,
  message as antdMessage,
  Button,
  Empty,
  Input
 } from 'antd';import type { MenuProps } from 'antd'
import { MoreOutlined, ExclamationCircleOutlined } from '@ant-design/icons'
import Link from 'next/link'
import api from '../../../api'
import { useState } from 'react'
import { normalizeError } from "../../../shared/errors";

const { confirm } = Modal
const { TextArea } = Input

const SculptureComment = ({
  comments,
  deleteComment,
  addComment,
  sculptureId
}) => {
  comments.sort(
    (a, b) =>
      new Date(b.createdTime).getTime() - new Date(a.createdTime).getTime()
  )

  const handleDelete: MenuProps['onClick'] = e => {
    confirm({
      title: 'Delete this comment permanently?',
      icon: <ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />,
      style: { top: 110 },
      maskClosable: true,
      okText: 'Confirm',
      okButtonProps: {
        style: {
          background: '#ff4d4f',
          borderColor: '#ff4d4f'
        }
      },
      onOk: async () => {
        try {
          await api.delete(`/comment/${e.key}`)
          antdMessage.success('Deleted comment successfully!', 2)
          deleteComment(e.key as string)
        } catch (error: unknown) {
          const { message, statusCode } = normalizeError(error);
          // @ts-ignore
          antdMessage.error(error.response.data.message)
        }
      }
    })
  }

  const [submitting, setSubmitting] = useState(false)
  const [value, setValue] = useState('')

  const getMenuItems = (commentId: string): MenuProps['items'] => [
    { key: commentId, label: 'Delete comment' }
  ]

  const formattedComments = comments.map(x => ({
    commentId: x.commentId,
    author: (
      <Link href={`/users/id/${x.user.userId}`}>
        <a
          style={{
            fontSize: 14,
            fontWeight: 500,
            color: 'rgba(0, 0, 0, 0.65)'
          }}
        >
          {x.user.userId.includes('auth0') ? x.user.nickname : x.user.name}
        </a>
      </Link>
    ),
    avatar: (
      <img
        src={x.user.picture}
        style={{
          width: 42,
          height: 42,
          borderRadius: '50%',
          objectFit: 'cover'
        }}
      />
    ),
    content: (
      <div style={{ fontSize: 14 }}>
        {x.content
          .trim()
          .split('\n')
          .map((line, idx) => (
            <div key={idx}>{line}</div>
          ))}
      </div>
    ),
    datetime: (
      <div style={{ display: 'flex' }}>
        <Tooltip title={dayjs(x.createdTime).format('D MMMM YYYY, h:mm:ss a')}>
          <div style={{ fontSize: 14, color: 'rgba(0, 0, 0, 0.35)' }}>
            {dayjs(x.createdTime).fromNow()}
          </div>
        </Tooltip>
        <div
          style={{
            fontSize: 14,
            color: 'rgba(0, 0, 0, 0.45)',
            marginLeft: 'auto'
          }}
        >
          <Dropdown
            menu={{ items: getMenuItems(x.commentId), onClick: handleDelete }}
            trigger={['click']}
          >
            <MoreOutlined />
          </Dropdown>
        </div>
      </div>
    )
  }))

  return (
    <Card
      title="Comments"
      bodyStyle={{ padding: '20px 24px 0px' }}
      variant="borderless"
      style={{ marginTop: 12 }}
    >
      <List
        itemLayout="horizontal"
        dataSource={formattedComments ?? []}
        className="comment-list"
        locale={{
          emptyText: (
            <Empty image={Empty.PRESENTED_IMAGE_SIMPLE} description="No Comments" />
          )
        }}
        renderItem={item => (
          <li>
            <Comment
              author={item.author}
              avatar={item.avatar}
              content={item.content}
              datetime={item.datetime}
              className="comment"
            />
          </li>
        )}
        pagination={{ pageSize: 15, hideOnSinglePage: true }}
      />
      <Comment
        className="admin-comment"
        avatar={
          <img
            src={'../../../static/avatar.png'}
            style={{
              width: 42,
              height: 42,
              borderRadius: '50%',
              objectFit: 'cover'
            }}
          />
        }
        content={
          <Editor
            value={value}
            setValue={setValue}
            submitting={submitting}
            setSubmitting={setSubmitting}
            sculptureId={sculptureId}
            addComment={addComment}
          />
        }
      />
    </Card>
  )
}

const Editor = ({
  value,
  setValue,
  setSubmitting,
  submitting,
  sculptureId,
  addComment
}) => (
  <>
    <div style={{ marginBottom: 12 }}>
      <TextArea
        autoSize={{ minRows: 2 }}
        onChange={e => setValue(e.target.value)}
        value={value}
      />
    </div>
    <div style={{ marginBottom: 16 }}>
      <Button
        htmlType="submit"
        disabled={value.trim() === ''}
        loading={submitting}
        onClick={async () => {
          setSubmitting(true)
          try {
            const result = (
              await api.post('/comment', {
                sculptureId,
                content: value
              })
            ).data
            setSubmitting(false)
            setValue('')
            addComment(result)
          } catch (e: unknown) {
            const { message, statusCode } = normalizeError(e);
            setSubmitting(false)
            // @ts-ignore
            antdMessage.error(e.response.data.message)
          }
        }}
        type="primary"
      >
        Post
      </Button>
    </div>
  </>
)

export default SculptureComment

===== END components/sculpture-maker-components/SculptureDetail/SculptureComment.tsx =====


===== BEGIN components/sculpture-maker-components/SculptureDetail/SculptureTrend.tsx =====
'use client'

/**
 * Description: Sculpture's trends graph component
 * Author: Hieu Chu
 */

import 'ant-design-pro/lib/Charts/style/index.less'
import {
  ColStyled,
  VisitCard,
  LikeCard,
  CommentCard
} from '../../dashboard-components/'
import { Popover, DatePicker, Button } from 'antd'
import { MoreOutlined } from '@ant-design/icons'

const { RangePicker } = DatePicker

import dayjs, { Dayjs } from 'dayjs'
import React, { useState, useEffect, useRef } from 'react'
import Loading from '../../Loading'
import Error from 'next/error'
import type { AxiosError } from 'axios'
import api from '../../../api'
import { CardStyled, ShadowCard } from '../../dashboard-components/style'
import { normalizeError } from '../../../shared/errors'

type DailyPoint = { x: string; y: number }

interface TrendState {
  TOTAL_VISITS: number
  DAILY_VISITS: number
  DAILY_VISITS_CHANGE: number
  TOTAL_LIKES: number
  DAILY_LIKES: number
  DAILY_LIKES_CHANGE: number
  TOTAL_COMMENTS: number
  DAILY_COMMENTS: number
  DAILY_COMMENTS_CHANGE: number
  VISIT_DATA: DailyPoint[]
  LIKE_DATA: DailyPoint[]
  COMMENT_DATA: DailyPoint[]
}

interface SculptureTrendProps {
  totalLikes: number
  totalComments: number
  totalVisits: number
  sculptureId: string
}

interface RequestError {
  statusCode: number
  message: string
}

const formatDailyData = (rawData: Record<string, number>): DailyPoint[] => {
  const result: DailyPoint[] = []
  for (const date of Object.keys(rawData)) {
    result.push({
      x: dayjs(date).format('MMM D YYYY'),
      y: rawData[date]
    })
  }
  // sort in correct order
  result.sort((a, b) => dayjs(a.x).valueOf() - dayjs(b.x).valueOf())
  return result
}

const SculptureTrend: React.FC<SculptureTrendProps> = ({
  totalLikes,
  totalComments,
  totalVisits,
  sculptureId
}) => {
  const [state, setState] = useState<TrendState>({
    TOTAL_VISITS: 0,
    DAILY_VISITS: 0,
    DAILY_VISITS_CHANGE: 0,
    TOTAL_LIKES: 0,
    DAILY_LIKES: 0,
    DAILY_LIKES_CHANGE: 0,
    TOTAL_COMMENTS: 0,
    DAILY_COMMENTS: 0,
    DAILY_COMMENTS_CHANGE: 0,
    VISIT_DATA: [],
    LIKE_DATA: [],
    COMMENT_DATA: []
  })
  const [loading, setLoading] = useState<boolean>(true)
  const [error, setError] = useState<RequestError | null>(null)

  const defaultEndDate = useRef<Dayjs>(dayjs(new Date())).current
  const defaultStartDate = useRef<Dayjs>(dayjs(defaultEndDate).subtract(7, 'days')).current

  const [startDate, setStartDate] = useState<Dayjs>(defaultStartDate)
  const [endDate, setEndDate] = useState<Dayjs>(defaultEndDate)

  useEffect(() => {
    const fetchData = async () => {
      try {
        const past = startDate.format('YYYY-MM-DD')
        const today = endDate.format('YYYY-MM-DD')
        const defaultToday = defaultEndDate.format('YYYY-MM-DD')

        const likesPromise = api.get<Record<string, number>>(
          `/stats/likes/sculpture-id/${sculptureId}?fromDate=${past}&toDate=${today}`
        )
        const commentsPromise = api.get<Record<string, number>>(
          `/stats/comments/sculpture-id/${sculptureId}?fromDate=${past}&toDate=${today}`
        )
        const visitPromise = api.get<Record<string, number>>(
          `/stats/visits/sculpture-id/${sculptureId}?fromDate=${past}&toDate=${today}`
        )

        const defaultLikesPromise = api.get<Record<string, number>>(
          `/stats/likes/sculpture-id/${sculptureId}?fromDate=${past}&toDate=${defaultToday}`
        )
        const defaultCommentsPromise = api.get<Record<string, number>>(
          `/stats/comments/sculpture-id/${sculptureId}?fromDate=${past}&toDate=${defaultToday}`
        )
        const defaultVisitsPromise = api.get<Record<string, number>>(
          `/stats/visits/sculpture-id/${sculptureId}?fromDate=${past}&toDate=${defaultToday}`
        )

        const [
          { data: rawLikes },
          { data: rawComments },
          { data: rawVisits },
          { data: rawDefaultLikes },
          { data: rawDefaultComments },
          { data: rawDefaultVisits }
        ] = await Promise.all([
          likesPromise,
          commentsPromise,
          visitPromise,
          defaultLikesPromise,
          defaultCommentsPromise,
          defaultVisitsPromise
        ])

        // format daily data statistics
        const LIKE_DATA = formatDailyData(rawLikes)
        const COMMENT_DATA = formatDailyData(rawComments)
        const VISIT_DATA = formatDailyData(rawVisits)

        const DEFAULT_LIKE_DATA = formatDailyData(rawDefaultLikes)
        const DEFAULT_COMMENT_DATA = formatDailyData(rawDefaultComments)
        const DEFAULT_VISIT_DATA = formatDailyData(rawDefaultVisits)

        const lastVisit = DEFAULT_VISIT_DATA.at(-1)?.y ?? 0
        const prevVisit = DEFAULT_VISIT_DATA.at(-2)?.y ?? 0
        const DAILY_VISITS = lastVisit
        const DAILY_VISITS_CHANGE = lastVisit - prevVisit

        const lastLike = DEFAULT_LIKE_DATA.at(-1)?.y ?? 0
        const prevLike = DEFAULT_LIKE_DATA.at(-2)?.y ?? 0
        const DAILY_LIKES = lastLike
        const DAILY_LIKES_CHANGE = lastLike - prevLike

        const lastComment = DEFAULT_COMMENT_DATA.at(-1)?.y ?? 0
        const prevComment = DEFAULT_COMMENT_DATA.at(-2)?.y ?? 0
        const DAILY_COMMENTS = lastComment
        const DAILY_COMMENTS_CHANGE = lastComment - prevComment

        setState(s => ({
          ...s,
          TOTAL_VISITS: totalVisits,
          DAILY_VISITS,
          DAILY_VISITS_CHANGE,
          TOTAL_LIKES: totalLikes,
          DAILY_LIKES,
          DAILY_LIKES_CHANGE,
          TOTAL_COMMENTS: totalComments,
          DAILY_COMMENTS,
          DAILY_COMMENTS_CHANGE,
          VISIT_DATA,
          LIKE_DATA,
          COMMENT_DATA
        }))
      } catch (e: unknown) {
        const n = normalizeError(e as AxiosError<any>)
        setError({ statusCode: n.statusCode, message: n.message })
      } finally {
        setLoading(false)
      }
    }
    fetchData()
  }, [
    defaultEndDate,
    endDate,
    sculptureId,
    startDate,
    totalComments,
    totalLikes,
    totalVisits
  ])

  const dateFormat = 'MMM D YYYY'
  const staticToday = dayjs(new Date())

  const renderPicker = (start: Dayjs, end: Dayjs) => {
    const disabledDate = (current: Dayjs) => current.valueOf() > staticToday.valueOf()
    return (
      <RangePicker
        defaultValue={[start, end]}
        value={[start, end]}
        format={dateFormat}
        size="large"
        allowClear={false}
        separator="-"
        disabledDate={disabledDate}
        ranges={{
          'Past week': [dayjs(staticToday).subtract(7, 'days'), dayjs(staticToday)],
          'Past 2 weeks': [dayjs(staticToday).subtract(14, 'days'), dayjs(staticToday)],
          'Past month': [dayjs(staticToday).subtract(30, 'days'), dayjs(staticToday)]
        }}
        onChange={(dates) => {
          if (!dates || !dates[0] || !dates[1]) return
          if (dates[0].valueOf() !== dates[1].valueOf()) {
            setStartDate(dates[0])
            setEndDate(dates[1])
          }
        }}
      />
    )
  }

  const {
    TOTAL_VISITS,
    DAILY_VISITS,
    DAILY_VISITS_CHANGE,
    TOTAL_LIKES,
    DAILY_LIKES,
    DAILY_LIKES_CHANGE,
    TOTAL_COMMENTS,
    DAILY_COMMENTS,
    DAILY_COMMENTS_CHANGE,
    VISIT_DATA,
    LIKE_DATA,
    COMMENT_DATA
  } = state

  if (loading) return <Loading />
  if (error) return <Error statusCode={error.statusCode} title={error.message} />

  return (
    <CardStyled
      title="Trends"
      extra={
        <Popover content={renderPicker(startDate, endDate)} trigger="click" placement="bottomRight">
          <Button type="text" icon={<MoreOutlined />} />
        </Popover>
      }
      type="stats"
      style={{ marginTop: 12 }}
    >
      <ColStyled xs={24}>
        <ShadowCard>
          <LikeCard
            TOTAL_LIKES={TOTAL_LIKES}
            DAILY_LIKES={DAILY_LIKES}
            DAILY_LIKES_CHANGE={DAILY_LIKES_CHANGE}
            LIKE_DATA={LIKE_DATA}
            startDate={startDate}
            endDate={endDate}
          />
        </ShadowCard>
      </ColStyled>

      <ColStyled xs={24}>
        <ShadowCard>
          <CommentCard
            TOTAL_COMMENTS={TOTAL_COMMENTS}
            DAILY_COMMENTS={DAILY_COMMENTS}
            DAILY_COMMENTS_CHANGE={DAILY_COMMENTS_CHANGE}
            COMMENT_DATA={COMMENT_DATA}
            startDate={startDate}
            endDate={endDate}
          />
        </ShadowCard>
      </ColStyled>

      <ColStyled xs={24}>
        <ShadowCard>
          <VisitCard
            TOTAL_VISITS={TOTAL_VISITS}
            DAILY_VISITS={DAILY_VISITS}
            DAILY_VISITS_CHANGE={DAILY_VISITS_CHANGE}
            VISIT_DATA={VISIT_DATA}
            startDate={startDate}
            endDate={endDate}
            SINGLE_SCULPTURE
          />
        </ShadowCard>
      </ColStyled>
    </CardStyled>
  )
}

export default SculptureTrend

===== END components/sculpture-maker-components/SculptureDetail/SculptureTrend.tsx =====


===== BEGIN components/sculpture-maker-components/SculptureGrid.tsx =====
'use client'

/**
 * Description: Sculpture list component
 * Author: Hieu Chu
 */

import { useState, useEffect } from 'react'
import {
  Row,
  Card,
  Typography,
  Tooltip,
  Input,
  Empty,
  Button,
  Dropdown
} from 'antd'
import type { MenuProps } from 'antd'
import {
  PlusOutlined,
  SortAscendingOutlined,
  DownOutlined,
  HeartTwoTone,
  MessageTwoTone,
  EnvironmentOutlined
} from '@ant-design/icons'
const { Text } = Typography
const { Meta } = Card
const { Search } = Input
import Link from 'next/link'
import { ColStyled, CardStyled, ShadowCard, Subtitle, EmptyImage } from './style'
import Loading from '../Loading'
import Error from 'next/error'
import api from '@/services/_request'
import { normalizeError } from "../../shared/errors";

const SculptureCard = ({
  info: {
    accessionId,
    name,
    totalVisits,
    totalLikes,
    totalComments,
    primaryMaker,
    images
  }
}) => {
  const makerName = primaryMaker.firstName + ' ' + primaryMaker.lastName
  images.sort(
    (a, b) => new Date(a.created).getTime() - new Date(b.created).getTime()
  )
  return (
    <Link href={`/sculptures/id/${accessionId}`}>
      <a style={{ display: 'inline-block', width: '100%' }}>
        <ShadowCard
          cover={
            images.length ? (
              <div style={{ height: 450 }}>
                <img
                  src={images[0].url}
                  style={{
                    height: '100%',
                    width: '100%',
                    objectFit: 'cover'
                  }}
                />
              </div>
            ) : (
              <EmptyImage
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description="No Images"
              />
            )
          }
          bordered
        >
          <Meta
            title={name}
            description={
              <SculptureCardDescription
                totalLikes={totalLikes}
                totalComments={totalComments}
                totalVisits={totalVisits}
                makerName={makerName}
              />
            }
          />
        </ShadowCard>
      </a>
    </Link>
  )
}

export const SculptureCardDescription = ({
  totalLikes,
  totalComments,
  totalVisits,
  makerName
}) => {
  return (
    <>
      <Subtitle type="secondary">{makerName}</Subtitle>

      <Tooltip placement="top" title="Likes">
        <HeartTwoTone twoToneColor="#eb2f96" style={{ marginRight: 4 }} />
        <Text type="secondary" style={{ marginRight: 8 }}>
          {totalLikes}
        </Text>
      </Tooltip>

      <Tooltip placement="top" title="Comments">
        <MessageTwoTone
          twoToneColor="rgb(205, 34, 255)"
          style={{ marginRight: 4 }}
        />
        <Text type="secondary" style={{ marginRight: 5 }}>
          {totalComments}
        </Text>
      </Tooltip>

      <Tooltip placement="top" title="Visits">
        <EnvironmentOutlined style={{ color: '#F73F3F', marginRight: 3 }} />
        <Text type="secondary" style={{ marginRight: 4 }}>
          {totalVisits}
        </Text>
      </Tooltip>
    </>
  )
}

// custom sort function
const sortBy = (list, criterion) => {
  switch (criterion) {
    case 'Likes':
      return list.slice().sort((a, b) => +b.totalLikes - +a.totalLikes)
    case 'Comments':
      return list.slice().sort((a, b) => +b.totalComments - +a.totalComments)
    case 'Visits':
      return list.slice().sort((a, b) => +b.totalVisits - +a.totalVisits)
    case 'Default':
      return list.slice().sort((a, b) => a.name.localeCompare(b.name))
  }
}

const SculptureGrid = () => {
  const [originalList, setOriginalList] = useState([])
  const [filteredList, setFilteredList] = useState(originalList.slice())
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  const [currentSort, setSort] = useState('Default')

  useEffect(() => {
    const fetchSculpture = async () => {
      try {
        const { data } = await api.get('/sculpture')
        data.sort((a, b) => a.name.localeCompare(b.name))
        setOriginalList(data)
        setFilteredList(data)
      } catch (e: unknown) {
        const { message, statusCode } = normalizeError(e);
        const { statusCode, message } = e.response.data
        setError({ statusCode, message })
      }
      setLoading(false)
    }

    fetchSculpture()
  }, [])

  const handleMenuClick: MenuProps['onClick'] = e => {
    setSort(e.key)
    setFilteredList(filtered => sortBy(filtered, e.key))
  }

  const menuItems: MenuProps['items'] = [
    { key: 'Default', label: 'Default' },
    { key: 'Likes', label: 'Likes' },
    { key: 'Comments', label: 'Comments' },
    { key: 'Visits', label: 'Visits' }
  ]

  const handleChange = e => {
    const input = e.target.value
    if (input.length >= 3) {
      const newList = originalList.filter(sculpture => {
        const makerName =
          sculpture.primaryMaker.firstName +
          ' ' +
          sculpture.primaryMaker.lastName

        return (
          sculpture.name.toLowerCase().includes(input.toLowerCase()) ||
          makerName.toLowerCase().includes(input.toLowerCase())
        )
      })
      setFilteredList(sortBy(newList, currentSort))
    } else {
      if (filteredList.length !== originalList.length) {
        setFilteredList(sortBy(originalList.slice(), currentSort))
      }
    }
  }

  if (loading) return <Loading />
  if (error) return <Error statusCode={error.statusCode} title={error.message} />

  return (
    <Row gutter={16}>
      <ColStyled xs={24}>
        <CardStyled
          title="Sculpture Collection"
          extra={
            <Link href="/sculptures/create">
              <a>
                <Button type="primary" icon={<PlusOutlined />}>
                  Add new sculpture
                </Button>
              </a>
            </Link>
          }
        >
          <div
            style={{
              marginLeft: 8,
              marginRight: 8,
              marginBottom: 16,
              display: 'flex'
            }}
          >
            <Search
              allowClear
              placeholder="Enter search term"
              onChange={handleChange}
              size="large"
              style={{ marginRight: 8 }}
            />

            <Dropdown
              menu={{ items: menuItems, onClick: handleMenuClick }}
              trigger={['click']}
            >
              <Button size="large">
                <SortAscendingOutlined /> {currentSort} <DownOutlined />
              </Button>
            </Dropdown>
          </div>

          <>
            {!filteredList.length ? (
              <Empty
                image={Empty.PRESENTED_IMAGE_SIMPLE}
                description="No Data :("
                style={{ marginTop: 60 }}
              />
            ) : (
              filteredList.map(sculpture => {
                return (
                  <ColStyled xs={24} sm={12} md={8} key={sculpture.accessionId}>
                    <SculptureCard info={sculpture} />
                  </ColStyled>
                )
              })
            )}
          </>
        </CardStyled>
      </ColStyled>
    </Row>
  )
}

export default SculptureGrid

===== END components/sculpture-maker-components/SculptureGrid.tsx =====


===== BEGIN components/sculpture-maker-components/style.tsx =====
/**
 * Description: Stylesheet for sculpture-maker components
 * Author: Hieu Chu
 */

import styled from 'styled-components'
import { Card, Col, Form, Typography, Empty, Table } from 'antd';
import Icon from '@/components/compat/Icon';

const { Text } = Typography

export const CardStyled = props => (
  <Card bodyStyle={{ padding: '20px 24px 20px' }} variant="borderless" {...props} />
)

export const ColStyled = styled(Col)`
  padding-bottom: 12px;
`

export const DescriptionIcon = styled(Icon)`
  font-size: 20px;
`

export const ShadowCard = styled(CardStyled)`
  box-shadow: rgba(0, 0, 0, 0.06) 0px 9px 24px;
  border-width: 1px;
  border-style: solid;
  border-color: rgb(242, 242, 242);
  border-radius: 3px;
  transition: all 150ms ease-in-out 0s;

  &:hover {
    box-shadow: rgba(0, 0, 0, 0.1) 0px 9px 24px;
    cursor: pointer;
    transition: all 150ms ease-in-out 0s;
  }
`

export const CustomFormItem = styled(Form.Item)`
  margin-bottom: 8px;

  &.ant-form-item-with-help {
    margin-bottom: 5px;
  }
`

export const FormCol = styled(Col)`
  padding-left: 0px !important;
  padding-right: 0px !important;
`

export const Subtitle = styled(Text)`
  display: block;
  margin-bottom: 12px;
`

export const EmptyImage = styled(Empty)`
  height: 230px;
  margin: 0;
  border-bottom: 0.3px solid rgba(0, 0, 0, 0.25);

  & .ant-empty-image {
    margin-top: 220px;
  }
`

export const StyledTable = styled(Table)`
  .ant-table table {
    border-left: 1px solid #e8e8e8;
    border-top: 1px solid #e8e8e8;
    border-right: 1px solid #e8e8e8;
  }
`

===== END components/sculpture-maker-components/style.tsx =====


===== BEGIN components/shared/utils.tsx =====
/**
 * Shared utility functions
 * - AntD v5 validators: return Promise<void>, no callback
 * - No implicit any
 */

type FieldValidator = (_rule: unknown, value: unknown) => Promise<void>;

/** Latitude valide strictement dans l'intervalle (-90, 90). */
export const validateLatitude: FieldValidator = async (_rule, value) => {
  // Champ non requis: ne pas invalider si vide
  if (value === undefined || value === null || String(value).trim() === '') {
    return;
  }

  const num = typeof value === 'number' ? value : Number(String(value).trim());
  if (Number.isNaN(num)) {
    throw new Error('Please fill in a valid latitude value!');
  }
  // Reproduit la logique d’origine: bornes -90 et 90 sont considérées invalides
  if (num <= -90 || num >= 90) {
    throw new Error('Please fill in a valid latitude value!');
  }
};

/** Longitude valide strictement dans l'intervalle (-180, 180). */
export const validateLongitude: FieldValidator = async (_rule, value) => {
  if (value === undefined || value === null || String(value).trim() === '') {
    return;
  }

  const num = typeof value === 'number' ? value : Number(String(value).trim());
  if (Number.isNaN(num)) {
    throw new Error('Please fill in a valid longitude value!');
  }
  // Reproduit la logique d’origine: bornes -180 et 180 sont considérées invalides
  if (num <= -180 || num >= 180) {
    throw new Error('Please fill in a valid longitude value!');
  }
};

/**
 * Supprime les accents pour faciliter les recherches "accent-insensitive".
 * Conserve le comportement original (mise en minuscule).
 */
export const convertNonAccent = (str: string): string => {
  if (str == null) return '';
  // Normalisation unicode + suppression des diacritiques
  let s = String(str).toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  // Spécifiques vietnamien (compat avec ancien code)
  s = s.replace(/đ/g, 'd').replace(/Đ/g, 'd');
  return s;
};

===== END components/shared/utils.tsx =====


===== BEGIN components/TagsList.tsx =====
'use client';

import React from 'react';
import { Card, List, Tag as AntdTag, Empty, Typography } from 'antd';

const { Text } = Typography;

export interface TagItem {
  id: string;
  name: string;
  count?: number;
}

type TagsInput = TagItem[] | { data?: TagItem[] } | null | undefined;

interface TagsListProps {
  /** Peut être un tableau direct ou un objet de type AxiosResponse avec `.data` */
  data?: TagsInput;
  onSelectTag?: (tag: TagItem) => void;
}

/** Type guard pour un objet de forme { data: TagItem[] } */
function hasDataArray(x: unknown): x is { data: TagItem[] } {
  return !!x && typeof x === 'object' && Array.isArray((x as any).data);
}

/** Normalise l’entrée en tableau de tags */
function toTagsArray(input: TagsInput): TagItem[] {
  if (Array.isArray(input)) return input;
  if (hasDataArray(input)) return input.data;
  return [];
}

const TagsList: React.FC<TagsListProps> = ({ data, onSelectTag }) => {
  const tags = React.useMemo<TagItem[]>(() => toTagsArray(data), [data]);

  return (
    <Card title="Tags">
      {tags.length === 0 ? (
        <Empty description="No tags" />
      ) : (
        <List<TagItem>
          dataSource={tags}
          renderItem={(item) => (
            <List.Item key={item.id}>
              <div className="flex items-center gap-8">
                <div className="flex items-center gap-8">
                  <AntdTag
                    onClick={onSelectTag ? () => onSelectTag(item) : undefined}
                    style={{ cursor: onSelectTag ? 'pointer' : 'default' }}
                  >
                    {item.name}
                  </AntdTag>
                  {typeof item.count === 'number' && (
                    <Text type="secondary">{item.count}</Text>
                  )}
                </div>
              </div>
            </List.Item>
          )}
        />
      )}
    </Card>
  );
};

export default TagsList;

===== END components/TagsList.tsx =====


===== BEGIN components/Tooltip/Tooltip.tsx =====
"use client"

import * as RadixTooltip from "@radix-ui/react-tooltip"
import { cva, type VariantProps } from "class-variance-authority"
import React from "react"
import { twMerge } from "tailwind-merge"

const tooltipContent = cva([], {
  variants: {
    intent: {
      primary: ["rounded-md", "bg-zinc-700", "font-sans", "text-white"],
    },
    size: {
      md: ["px-4", "py-2.5", "text-xs"],
    },
  },
  defaultVariants: {
    intent: "primary",
    size: "md",
  },
})

const tooltipArrow = cva([], {
  variants: {
    intent: {
      primary: ["fill-zinc-700"],
    },
    size: {
      md: ["w-4", "h-2"],
    },
  },
  defaultVariants: {
    intent: "primary",
    size: "md",
  },
})

export interface TooltipProps extends VariantProps<typeof tooltipContent>, RadixTooltip.TooltipProps {
  explainer: React.ReactElement | string
  children: React.ReactElement
  className?: string
  withArrow?: boolean
  side?: "top" | "right" | "bottom" | "left"
}

export function Tooltip({
  children,
  explainer,
  open,
  defaultOpen,
  onOpenChange,
  intent,
  size,
  side = "top",
  className,
  withArrow,
}: TooltipProps) {
  return (
    <RadixTooltip.Provider>
      <RadixTooltip.Root open={open} defaultOpen={defaultOpen} onOpenChange={onOpenChange} delayDuration={200}>
        <RadixTooltip.Trigger asChild>{children}</RadixTooltip.Trigger>
        <RadixTooltip.Portal>
          <RadixTooltip.Content
            side={side}
            sideOffset={5}
            className={twMerge(tooltipContent({ intent, size, className }))}
          >
            {explainer}
            {withArrow ? <RadixTooltip.Arrow className={twMerge(tooltipArrow({ intent, size, className }))} /> : null}
          </RadixTooltip.Content>
        </RadixTooltip.Portal>
      </RadixTooltip.Root>
    </RadixTooltip.Provider>
  )
}

===== END components/Tooltip/Tooltip.tsx =====


===== BEGIN components/user-components/index.tsx =====
'use client'

/**
 * Description: User management components
 * Author: Hieu Chu
 */

import { useEffect, useRef, useState } from 'react'
import { useRouter } from 'next/navigation'
import dayjs from 'dayjs'

import { Row, Input, Button } from 'antd'
import { SearchOutlined } from '@ant-design/icons'
import { Comment } from '@ant-design/compatible'

import { ColStyled, CardStyled, StyledTable } from './style'
import api from '@/services/_request'
import Loading from '../Loading'
import NextError from 'next/error'
import { convertNonAccent } from '../shared/utils'
import { normalizeError } from "../../shared/errors";

const UserList = () => {
  const router = useRouter()

  const [userList, setUserList] = useState<any[]>([])
  const searchInput = useRef<Input | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<{ statusCode: number; message: string } | null>(null)

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        let users = (await api.get('/user')).data
        users = users
          .filter((x: any) => !x.role)
          .map((x: any) => ({
            ...x,
            key: x.userId,
            totalLikes: +x.totalLikes,
            totalComments: +x.totalComments,
            totalVisits: +x.totalVisits,
          }))

        users.sort(
          (a: any, b: any) => new Date(b.joinDate).getTime() - new Date(a.joinDate).getTime(),
        )

        setUserList(users)
      } catch (e: any) {
        const { message, statusCode } = normalizeError(e);
        const statusCode = e?.response?.data?.statusCode ?? 500
        const message = e?.response?.data?.message ?? 'Failed to load users'
        setError({ statusCode, message })
      } finally {
        setLoading(false)
      }
    }
    fetchUsers()
  }, [])

  const getUserSearchProps = () => ({
    filterDropdown: ({
      setSelectedKeys,
      selectedKeys,
      confirm,
      clearFilters,
    }: {
      setSelectedKeys: (keys: React.Key[]) => void
      selectedKeys: React.Key[]
      confirm: () => void
      clearFilters: () => void
    }) => (
      <div style={{ padding: 8 }}>
        <Input
          ref={searchInput as any}
          placeholder="Search user"
          value={(selectedKeys[0] as string) ?? ''}
          onChange={(e) => setSelectedKeys(e.target.value ? [e.target.value] : [])}
          onPressEnter={() => handleSearch(selectedKeys, confirm)}
          style={{ width: 188, marginBottom: 8, display: 'block' }}
        />
        <Button type="primary" onClick={() => handleSearch(selectedKeys, confirm)} style={{ width: 90, marginRight: 8 }}>
          Search
        </Button>
        <Button onClick={() => handleReset(clearFilters)} style={{ width: 90 }}>
          Reset
        </Button>
      </div>
    ),
    filterIcon: (filtered: boolean) => (
      <SearchOutlined style={{ color: filtered ? '#1890ff' : '#7E7E7E' }} />
    ),
    onFilter: (value: string, record: any) => {
      const { email, name, nickname, userId } = record
      let author = name
      if (userId.includes('auth0')) author = nickname

      return (
        convertNonAccent(author.toLowerCase()).includes(value.toLowerCase()) ||
        convertNonAccent(email.toLowerCase()).includes(value.toLowerCase())
      )
    },
    // AntD v5: "open" naming
    onFilterDropdownOpenChange: (open: boolean) => {
      if (open) {
        setTimeout(() => searchInput.current?.select?.(), 0)
      }
    },
  })

  const handleSearch = (_selectedKeys: React.Key[], confirm: () => void) => {
    confirm()
  }

  const handleReset = (clearFilters: () => void) => {
    clearFilters()
  }

  const columns: any[] = [
    {
      title: 'User',
      key: 'user',
      render: (_: any, record: any) => {
        const { email, name, nickname, picture, userId } = record
        let author = name
        if (userId.includes('auth0')) author = nickname

        return (
          <Comment
            author={
              <span style={{ fontSize: 14, fontWeight: 500, color: 'rgba(0, 0, 0, 0.65)' }}>
                {author}
              </span>
            }
            avatar={
              <img
                src={picture}
                style={{ width: 42, height: 42, borderRadius: '50%', objectFit: 'cover' }}
                alt={author}
              />
            }
            content={<div style={{ fontSize: 14 }}>{email}</div>}
          />
        )
      },
      width: '30%',
      ...getUserSearchProps(),
    },
    {
      title: 'Connection type',
      key: 'connection',
      render: (_: any, record: any) => {
        let connection = ''
        if (record.userId.includes('google')) connection = 'Google'
        else if (record.userId.includes('facebook')) connection = 'Facebook'
        else connection = 'Email'
        return <span>{connection}</span>
      },
      filters: [
        { text: 'Email', value: 'auth0' },
        { text: 'Google', value: 'google' },
        { text: 'Facebook', value: 'facebook' },
      ],
      onFilter: (value: string, record: any) => record.userId.includes(value),
      width: '15%',
    },
    {
      title: 'Join date',
      key: 'joinDate',
      render: (_: any, record: any) => <span>{dayjs(record.joinDate).format('D MMMM YYYY')}</span>,
      sorter: (a: any, b: any) => new Date(a.joinDate).getTime() - new Date(b.joinDate).getTime(),
      sortDirections: ['ascend', 'descend'],
      width: '15%',
    },
    {
      title: 'Likes',
      dataIndex: 'totalLikes',
      sorter: (a: any, b: any) => a.totalLikes - b.totalLikes,
      sortDirections: ['descend', 'ascend'],
      width: '13.33%',
    },
    {
      title: 'Comments',
      dataIndex: 'totalComments',
      sorter: (a: any, b: any) => a.totalComments - b.totalComments,
      sortDirections: ['descend', 'ascend'],
      width: '13.33%',
    },
    {
      title: 'Visits',
      dataIndex: 'totalVisits',
      sorter: (a: any, b: any) => a.totalVisits - b.totalVisits,
      sortDirections: ['descend', 'ascend'],
      width: '13.33%',
    },
  ]

  if (loading) return <Loading />
  if (error) return <NextError statusCode={error.statusCode} title={error.message} />

  return (
    <Row gutter={16}>
      <ColStyled xs={24}>
        <CardStyled title="User Management">
          <StyledTable
            dataSource={userList}
            columns={columns}
            pagination={{ pageSize: 25, hideOnSinglePage: true }}
            className="user-table"
            onRow={(record: any) => ({
              onClick: () => router.push(`/users/id/${record.key}`),
            })}
            style={{ maxWidth: 1100 }}
          />
        </CardStyled>
      </ColStyled>
    </Row>
  )
}

export default UserList

===== END components/user-components/index.tsx =====


===== BEGIN components/user-components/style.tsx =====
/**
 * Description: Stylesheet for user components
 * Author: Hieu Chu
 */

import styled from 'styled-components'
import { Card, Col, Form, Typography, Empty, Table } from 'antd'
import Icon from '../compat/Icon' // wrapper compat

const { Text } = Typography

export const CardStyled = props => (
  <Card bodyStyle={{ padding: '20px 24px 20px' }} variant="borderless" {...props} />
)

export const ColStyled = styled(Col)`
  padding-bottom: 12px;
`

export const DescriptionIcon = styled(Icon)`
  font-size: 20px;
`

export const ShadowCard = styled(CardStyled)`
  box-shadow: rgba(0, 0, 0, 0.06) 0px 9px 24px;
  border-width: 1px;
  border-style: solid;
  border-color: rgb(242, 242, 242);
  border-radius: 3px;
  transition: all 150ms ease-in-out 0s;

  &:hover {
    box-shadow: rgba(0, 0, 0, 0.1) 0px 9px 24px;
    cursor: pointer;
    transition: all 150ms ease-in-out 0s;
  }
`

export const CustomFormItem = styled(Form.Item)`
  margin-bottom: 8px;

  &.ant-form-item-with-help {
    margin-bottom: 5px;
  }
`

export const FormCol = styled(Col)`
  padding-left: 0px !important;
  padding-right: 0px !important;
`

export const Subtitle = styled(Text)`
  display: block;
  margin-bottom: 12px;
`

export const EmptyImage = styled(Empty)`
  height: 230px;
  margin: 0;
  border-bottom: 0.3px solid rgba(0, 0, 0, 0.25);

  & .ant-empty-image {
    margin-top: 220px;
  }
`

export const StyledTable = styled(Table)`
  .ant-table table {
    border-left: 1px solid #e8e8e8;
    border-top: 1px solid #e8e8e8;
    border-right: 1px solid #e8e8e8;
  }
`

===== END components/user-components/style.tsx =====


===== BEGIN components/user-components/UserComments.tsx =====
'use client';

/**
 * Description: User comments list component
 * Author: Hieu Chu
 */

import React, { useMemo } from 'react';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import Link from 'next/link';
import {
  Card,
  List,
  Avatar,
  Typography,
  Dropdown,
  Modal,
  Tooltip,
  Space,
  Button,
  Empty,
  Input,
  message as antdMessage,
} from 'antd';
import type { MenuProps } from 'antd';
import {
  ExclamationCircleOutlined,
  EllipsisOutlined,
  DeleteOutlined,
} from '@ant-design/icons';

import api from '@/services/_request';
import { normalizeError } from '../../shared/errors';

dayjs.extend(relativeTime);

const { Text } = Typography;
const { TextArea } = Input;

interface CommentUser {
  userId: string;
  nickname?: string | null;
  name?: string | null;
  picture?: string | null;
}

interface CommentSculpture {
  accessionId: string | number;
  name: string;
}

export interface UserComment {
  commentId: string;
  content: string;
  createdTime: string; // ISO 8601
  user: CommentUser;
  sculpture: CommentSculpture;
}

interface Props {
  comments: UserComment[];
  deleteComment: (id: string) => void;
}

const UserComments: React.FC<Props> = ({ comments, deleteComment }) => {
  // Tri sans muter les props
  const items = useMemo<UserComment[]>(
    () =>
      [...comments].sort(
        (a, b) => Date.parse(b.createdTime) - Date.parse(a.createdTime),
      ),
    [comments],
  );

  const onMenuClick: MenuProps['onClick'] = ({ key }) => {
    Modal.confirm({
      title: 'Delete this comment permanently?',
      icon: <ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />,
      style: { top: 110 },
      maskClosable: true,
      okText: 'Confirm',
      okButtonProps: {
        style: { background: '#ff4d4f', borderColor: '#ff4d4f' },
      },
      onOk: async () => {
        try {
          await api.delete(`/comment/${String(key)}`);
          antdMessage.success('Deleted comment successfully!', 2);
          deleteComment(String(key));
        } catch (e) {
          const { message } = normalizeError(e);
          antdMessage.error(message || 'Failed to delete');
        }
      },
    });
  };

  return (
    <Card title="Comments" bodyStyle={{ padding: '20px 24px 0px' }} bordered={false}>
      <List<UserComment>
        itemLayout="horizontal"
        dataSource={items}
        className="comment-list"
        locale={{
          emptyText: (
            <Empty image={Empty.PRESENTED_IMAGE_SIMPLE} description="No Comments" />
          ),
        }}
        pagination={{ pageSize: 15, hideOnSinglePage: true }}
        renderItem={(x) => {
          const displayName = x.user.userId.includes('auth0')
            ? x.user.nickname ?? x.user.name ?? 'User'
            : x.user.name ?? x.user.nickname ?? 'User';

          return (
            <List.Item
              key={x.commentId}
              actions={[
                <Dropdown
                  key="more"
                  trigger={['click']}
                  menu={{
                    items: [
                      { key: x.commentId, label: 'Delete comment', icon: <DeleteOutlined /> },
                    ],
                    onClick: onMenuClick,
                  }}
                >
                  <Button type="text" aria-label="More actions" icon={<EllipsisOutlined />} />
                </Dropdown>,
              ]}
            >
              <List.Item.Meta
                avatar={
                  <Avatar src={x.user.picture ?? undefined} alt={displayName}>
                    {!x.user.picture && displayName.charAt(0).toUpperCase()}
                  </Avatar>
                }
                title={
                  <Space size={8} wrap>
                    <Text strong style={{ fontSize: 14, color: 'rgba(0,0,0,0.65)' }}>
                      {displayName}
                    </Text>
                    <Tooltip title={dayjs(x.createdTime).format('D MMMM YYYY, h:mm:ss a')}>
                      <Text type="secondary" style={{ fontSize: 14 }}>
                        {dayjs(x.createdTime).fromNow()} in
                      </Text>
                    </Tooltip>
                    <Link href={`/sculptures/id/${String(x.sculpture.accessionId)}`}>
                      <Text style={{ fontSize: 14 }}>{x.sculpture.name}</Text>
                    </Link>
                  </Space>
                }
                description={
                  <div style={{ fontSize: 14, whiteSpace: 'pre-wrap' }}>
                    {x.content?.trim() ?? ''}
                  </div>
                }
              />
            </List.Item>
          );
        }}
      />

      {/* quick reply editor */}
      <div style={{ padding: '16px 24px' }}>
        <TextArea disabled placeholder="Use admin screen to reply" />
      </div>
    </Card>
  );
};

export default UserComments;

===== END components/user-components/UserComments.tsx =====


===== BEGIN components/user-components/UserLikes.tsx =====
'use client';

/**
 * Description: User likes list component
 * Author: Hieu Chu
 */

import React, { useMemo } from 'react';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import { Card, List, Tooltip, Empty, Avatar, Typography } from 'antd';
import Link from 'next/link';

dayjs.extend(relativeTime);

type LikeImage = { url: string; created?: string | Date };
type Sculpture = {
  name: string;
  images?: LikeImage[];
  accessionId?: string | number;
};

type UserLikeItem = {
  likedTime: string | Date;
  sculptureId?: string | number;
  sculpture: Sculpture;
};

interface UserLikesProps {
  likes: UserLikeItem[];
}

const UserLikes: React.FC<UserLikesProps> = ({ likes }) => {
  // ne pas muter les props; tri sur des copies
  const items = useMemo<UserLikeItem[]>(
    () =>
      [...(likes ?? [])]
        .sort(
          (a, b) =>
            new Date(b.likedTime).getTime() -
            new Date(a.likedTime).getTime(),
        )
        .map((x) => {
          const sortedImages = [...(x.sculpture.images ?? [])].sort(
            (a, b) =>
              new Date(a.created ?? 0).getTime() -
              new Date(b.created ?? 0).getTime(),
          );
          return {
            ...x,
            sculpture: { ...x.sculpture, images: sortedImages },
          };
        }),
    [likes],
  );

  return (
    <Card
      title="Likes"
      bodyStyle={{ padding: '20px 24px 0px' }}
      variant="borderless"
      style={{ marginTop: 12 }}
    >
      <List<UserLikeItem>
        itemLayout="horizontal"
        dataSource={items}
        className="comment-list"
        locale={{
          emptyText: (
            <Empty
              image={Empty.PRESENTED_IMAGE_SIMPLE}
              description="No Likes"
            />
          ),
        }}
        renderItem={(x) => {
          const firstImageUrl =
            x.sculpture.images && x.sculpture.images.length > 0
              ? x.sculpture.images[0].url
              : '/static/no-image.png';
          const targetId = x.sculptureId ?? x.sculpture.accessionId;
          const when = dayjs(x.likedTime);

          return (
            <List.Item key={`${String(targetId)}-${String(x.likedTime)}`}>
              <List.Item.Meta
                avatar={
                  <Avatar
                    shape="square"
                    size={42}
                    src={firstImageUrl}
                    alt={x.sculpture.name}
                    style={{ objectFit: 'cover', borderRadius: 4 }}
                  />
                }
                title={
                  <Link href={`/sculptures/id/${String(targetId)}`}>
                    <Typography.Text
                      style={{
                        fontSize: 14,
                        fontWeight: 500,
                        color: 'rgba(0, 0, 0, 0.65)',
                      }}
                    >
                      {x.sculpture.name}
                    </Typography.Text>
                  </Link>
                }
                description={
                  <Tooltip
                    title={when.format('D MMMM YYYY, h:mm:ss a')}
                  >
                    <Typography.Text
                      style={{
                        fontSize: 14,
                        color: 'rgba(0, 0, 0, 0.35)',
                      }}
                    >
                      {when.fromNow()}
                    </Typography.Text>
                  </Tooltip>
                }
              />
            </List.Item>
          );
        }}
        pagination={{ pageSize: 15, hideOnSinglePage: true }}
      />
    </Card>
  );
};

export default UserLikes;

===== END components/user-components/UserLikes.tsx =====


===== BEGIN components/user-components/UserProfile.tsx =====
'use client';

import React from 'react';
import { useSearchParams } from 'next/navigation';
import type { AxiosError } from 'axios';
import { Card, Typography, List, Empty, Alert } from 'antd';
import { api } from '@/shared/api';

const { Title, Text } = Typography;

/** Types sûrs et minimaux pour ce composant */
interface ProfileSummary {
  id: string;
  name: string;
  avatarUrl?: string;
  bio?: string;
}

interface CommentItem {
  commentId: string;
  author: string;
  content: string;
  createdAt: string; // ISO string
}

interface RequestError {
  statusCode: number;
  message: string;
}

const UserProfile: React.FC = () => {
  const searchParams = useSearchParams();
  const userId = searchParams.get('id') ?? '';

  const [profile, setProfile] = React.useState<ProfileSummary | null>(null);
  const [comments, setComments] = React.useState<CommentItem[]>([]);
  const [loading, setLoading] = React.useState<boolean>(false);
  const [error, setError] = React.useState<RequestError | null>(null);

  /** Supprime un commentaire localement avec typage strict */
  const deleteComment = (commentId: string) => {
    setComments((prev) => prev.filter((x) => x.commentId !== commentId));
  };

  React.useEffect(() => {
    // Si pas d'id dans l'URL, on ne déclenche pas de requête
    if (!userId) return;

    let cancelled = false;
    const run = async () => {
      setLoading(true);
      setError(null);
      try {
        // NOTE: le client `api` retourne la payload (pas besoin de `.data`)
        const [p, c] = await Promise.all([
          api.get<ProfileSummary>(`/users/${userId}`),
          api.get<CommentItem[]>(`/users/${userId}/comments`),
        ]);

        if (cancelled) return;
        setProfile(p);
        setComments(c);
      } catch (e: unknown) {
        // Typage défensif d'une erreur axios
        const ax = e as AxiosError<{ statusCode?: number; message?: string }>;
        const statusCode = ax.response?.data?.statusCode ?? ax.status ?? 500;
        const message =
          ax.response?.data?.message ??
          ax.message ??
          'Request failed';
        if (!cancelled) setError({ statusCode: Number(statusCode), message: String(message) });
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    run();
    return () => {
      cancelled = true;
    };
  }, [userId]);

  return (
    <div className="p-6">
      <Title level={2}>User Profile</Title>

      {!userId && (
        <Alert
          type="warning"
          message="Missing user id"
          description="Ajoutez ?id=<USER_ID> à l’URL pour charger le profil."
          className="mb-4"
        />
      )}

      {error && (
        <Alert
          type="error"
          showIcon
          className="mb-4"
          message={`Erreur ${error.statusCode}`}
          description={error.message}
        />
      )}

      <Card loading={loading} className="mb-6">
        {profile ? (
          <>
            <Title level={4} className="mb-1">
              {profile.name}
            </Title>
            {profile.bio ? <Text type="secondary">{profile.bio}</Text> : <Text type="secondary">No bio</Text>}
          </>
        ) : (
          <Empty description="No profile loaded" />
        )}
      </Card>

      <Card title="Recent comments" loading={loading}>
        {comments.length === 0 ? (
          <Empty description="No comments" />
        ) : (
          <List
            dataSource={comments}
            renderItem={(item) => (
              <List.Item
                key={item.commentId}
                actions={[
                  <button
                    key="delete"
                    onClick={() => deleteComment(item.commentId)}
                    className="text-red-600"
                    aria-label={`Delete comment ${item.commentId}`}
                  >
                    Delete
                  </button>,
                ]}
              >
                <List.Item.Meta
                  title={
                    <div className="flex items-center gap-2">
                      <Text strong>{item.author}</Text>
                      <Text type="secondary">{new Date(item.createdAt).toLocaleString()}</Text>
                    </div>
                  }
                  description={item.content}
                />
              </List.Item>
            )}
          />
        )}
      </Card>
    </div>
  );
};

export default UserProfile;

===== END components/user-components/UserProfile.tsx =====


===== BEGIN components/user-components/UserVisit.tsx =====
/**
 * Description: User visit list component
 * Author: Hieu Chu
 */

import dayjs from 'dayjs'
import { Tooltip, List, Card, Empty } from 'antd'
import { Comment } from '@ant-design/compatible'
import Link from 'next/link'

const UserVisit = ({ visits }) => {
  visits.sort(
    (a, b) => new Date(b.visitTime).getTime() - new Date(a.visitTime).getTime()
  )
  visits.forEach(x => {
    x.sculpture.images.sort(
      (a, b) => new Date(a.created).getTime() - new Date(b.created).getTime()
    )
  })

  const formattedComments = visits.map(x => ({
    author: (
      <span>
        <Link href={`/sculptures/id/${x.sculptureId}`}>
          <a
            style={{
              fontSize: 14,
              fontWeight: 500,
              color: 'rgba(0, 0, 0, 0.65)'
            }}
          >
            {x.sculpture.name}
          </a>
        </Link>
      </span>
    ),
    avatar: (
      <div>
        <img
          src={
            x.sculpture.images.length
              ? x.sculpture.images[0].url
              : '../../static/no-image.png'
          }
          style={{
            width: 42,
            height: 42,
            objectFit: 'cover',
            borderRadius: 4
          }}
        />
      </div>
    ),
    content: (
      <div style={{ fontSize: 14 }}>
        <Tooltip title={dayjs(x.visitTime).format('D MMMM YYYY, h:mm:ss a')}>
          <span style={{ fontSize: 14, color: 'rgba(0, 0, 0, 0.35)' }}>
            {dayjs(x.visitTime).fromNow()}
          </span>
        </Tooltip>
      </div>
    )
  }))

  return (
    <Card
      title="Visits"
      bodyStyle={{ padding: '20px 24px 0px' }}
      variant="borderless"
      style={{ marginTop: 12 }}
    >
      <List
        itemLayout="horizontal"
        dataSource={formattedComments ?? []}
        className="comment-list"
        locale={{
          emptyText: (
            <Empty image={Empty.PRESENTED_IMAGE_SIMPLE} description="No Visits" />
          )
        }}
        renderItem={item => (
          <li>
            <Comment author={item.author} avatar={item.avatar} content={item.content} className="comment" />
          </li>
        )}
        pagination={{ pageSize: 15, hideOnSinglePage: true }}
      />
    </Card>
  )
}

export default UserVisit

===== END components/user-components/UserVisit.tsx =====


===== BEGIN src/components/CommonWidget/page.tsx =====
// pages/pageTemplate/components/CommonWidget.tsx
import React from 'react';
import styles from './CommonWidget.module.css';

interface CommonWidgetProps {
  title: string;
  description: string;
}

const CommonWidget: React.FC<CommonWidgetProps> = ({ title, description }) => {
  return (
    <div className={styles.widget}>
      <h2 className={styles.widgetTitle}>{title}</h2>
      <p className={styles.widgetDescription}>{description}</p>
    </div>
  );
};

export default CommonWidget;

===== END src/components/CommonWidget/page.tsx =====


===== BEGIN src/components/ThemeSwitcher.tsx =====
import React from 'react';
import { Button } from 'antd';
import { useTheme } from '@/context/ThemeContext';

const ThemeSwitcher: React.FC = () => {
  const { token, cycleTheme } = useTheme();   // token contient label + icon

  return (
    <Button onClick={cycleTheme}>
      {token.icon ? `${token.icon} ` : ''}{token.label ?? 'Theme'}
    </Button>
  );
};

export default ThemeSwitcher;

===== END src/components/ThemeSwitcher.tsx =====

