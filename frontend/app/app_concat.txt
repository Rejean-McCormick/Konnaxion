
===== BEGIN admin\page.tsx =====
﻿// File: app/admin/page.tsx
'use client'

import { Col, Row } from 'antd'
import React from 'react'
import { ModerationQueue, UserStats } from '@/admin/components'

export default function AdminPage() {
  return (
    <Row gutter={16}>
      <Col span={12}><UserStats /></Col>
      <Col span={12}><ModerationQueue /></Col>
    </Row>
  )
}

===== END admin\page.tsx =====


===== BEGIN api\admin\moderation\route.ts =====
import { NextResponse } from 'next/server'

interface ModerationItem {
  id: string
  type: string
  content: string
  reason: string
  userId: string
  createdAt: string
}

export async function GET() {
  // TODO: fetch your real moderation queue here
  const queue: ModerationItem[] = [
    {
      id: '1',
      type: 'comment',
      content: 'Offensive comment text here',
      reason: 'profanity',
      userId: 'user_123',
      createdAt: new Date().toISOString(),
    },
  ]

  return NextResponse.json<ModerationItem[]>(queue, {
    status: 200,
    headers: { 'Cache-Control': 'no-store' },
  })
}

===== END api\admin\moderation\route.ts =====


===== BEGIN api\admin\stats\route.ts =====
import { NextResponse } from 'next/server'

interface AdminStats {
  totalUsers: number
  activeUsers: number
  newUsers: number
}

export async function GET() {
  // TODO: hook up your real DB call here
  const stats: AdminStats = {
    totalUsers: 1234,
    activeUsers: 567,
    newUsers: 89,
  }

  return NextResponse.json<AdminStats>(stats, {
    status: 200,
    headers: { 'Cache-Control': 'no-store' },
  })
}

===== END api\admin\stats\route.ts =====


===== BEGIN api\health\route.ts =====
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.json(
    { status: 'ok', timestamp: new Date().toISOString() },
    {
      status: 200,
      headers: { 'Cache-Control': 'no-store' },
    }
  )
}

===== END api\health\route.ts =====


===== BEGIN api\search\route.ts =====
import { NextRequest, NextResponse } from 'next/server'

interface SearchResult {
  id: string
  title: string
  snippet: string
  path: string
}

export async function GET(request: NextRequest) {
  const url = new URL(request.url)
  const q = url.searchParams.get('q')?.trim() || ''
  if (!q) {
    return NextResponse.json({ error: 'Missing query parameter `q`' }, { status: 400 })
  }

  // TODO: replace with real search logic
  const results: SearchResult[] = [
    {
      id: 'item-1',
      title: `Result for "${q}" #1`,
      snippet: 'A brief snippet of matching content…',
      path: `/some/path/1`,
    },
  ]

  return NextResponse.json<{ results: SearchResult[] }>({ results }, {
    status: 200,
    headers: { 'Cache-Control': 'no-store' },
  })
}

===== END api\search\route.ts =====


===== BEGIN archive\page.tsx =====
﻿import { KonservationArchive } from "@/kreative/pages";
export default KonservationArchive;

===== END archive\page.tsx =====


===== BEGIN art\[id]\page.tsx =====
﻿import { ArtworkSheet } from "@/kreative/pages";
export default ArtworkSheet;

===== END art\[id]\page.tsx =====


===== BEGIN certs\page.tsx =====
import MainLayout from "@/shared/layout/MainLayout";

export default function Page() {
  return (
    <MainLayout>
      <div className="text-gray-400">??  certs  (coming soon)</div>
    </MainLayout>
  );
}

===== END certs\page.tsx =====


===== BEGIN chat\page.tsx =====
﻿import { Messenger } from "@/konnected/pages";
export default Messenger;

===== END chat\page.tsx =====


===== BEGIN concatv1.py =====
#!/usr/bin/env python3
"""
Concatène tous les fichiers texte du dossier du script et de ses sous-dossiers.
Par défaut, écrit le résultat dans "concat.txt" à la racine du script.

Usage simple :
    python concat_text.py

Options :
    -o, --out         Fichier de sortie (par défaut: concat.txt)
    --ext             Extensions personnalisées (csv) ex: "tsx,tx,ts,js,md"
    --include         Glob d'inclusion relatif (répétable)
    --exclude         Glob d'exclusion relatif (répétable)
    --max-size        Taille max par fichier en octets (défaut: 2000000)
    --no-headers      Désactive les entêtes BEGIN/END par fichier
"""
from __future__ import annotations

import argparse
import fnmatch
import os
from pathlib import Path
from typing import Set, List, Optional

DEFAULT_EXTS: Set[str] = {
    ".txt", ".tx", ".md", ".markdown",
    ".json", ".yaml", ".yml", ".xml", ".toml", ".ini", ".cfg", ".conf", ".properties",
    ".html", ".htm", ".css", ".scss", ".less",
    ".js", ".jsx", ".ts", ".tsx", ".mjs", ".cjs",
    ".py", ".pyi", ".ipynb",
    ".java", ".kt", ".swift", ".rb", ".php", ".go", ".rs",
    ".c", ".h", ".cpp", ".cc", ".hpp", ".cs",
    ".sql",
    ".sh", ".bash", ".zsh", ".fish", ".ps1", ".bat",
    ".tex", ".bib",
    ".graphql", ".gql",
    ".gradle",
    ".pl", ".lua", ".r",
    ".env",
}

NAMES_WITHOUT_EXT: Set[str] = {
    "Dockerfile", "Makefile", "CMakeLists.txt",
    ".gitignore", ".gitattributes", ".editorconfig",
    "Procfile", "Gemfile", "requirements.txt", "Pipfile", "poetry.lock",
    "package.json", "package-lock.json", "yarn.lock", "pnpm-lock.yaml",
    "tsconfig.json", "eslint.config.js", ".eslintrc", ".prettierrc",
}

DEFAULT_EXCLUDE_DIRS: Set[str] = {
    ".git", ".hg", ".svn",
    "node_modules", ".next", ".nuxt",
    "dist", "build", "out", "coverage", ".cache",
    ".venv", "venv", "__pycache__",
    "target", "bin", "obj",
}

def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Concatène les fichiers texte du projet dans un seul fichier.")
    p.add_argument("-o", "--out", default="concat.txt", help="Fichier de sortie")
    p.add_argument("--ext", help="Extensions additionnelles ou personnalisées, séparées par des virgules")
    p.add_argument("--include", action="append", default=[], help="Glob d'inclusion relatif à la racine (répétable)")
    p.add_argument("--exclude", action="append", default=[], help="Glob d'exclusion relatif à la racine (répétable)")
    p.add_argument("--max-size", type=int, default=2_000_000, help="Taille max par fichier en octets")
    p.add_argument("--no-headers", action="store_true", help="Ne pas imprimer d'entêtes par fichier")
    return p.parse_args()

def normalize_exts(exts_csv: Optional[str]) -> Set[str]:
    if not exts_csv:
        return set(DEFAULT_EXTS)
    parts = [e.strip().lower() for e in exts_csv.split(",") if e.strip()]
    normed = set()
    for e in parts:
        if not e.startswith("."):
            e = "." + e
        normed.add(e)
    return normed

def is_probably_text(sample: bytes) -> bool:
    if not sample:
        return True
    if b"\x00" in sample:
        return False
    try:
        sample.decode("utf-8")
        return True
    except UnicodeDecodeError:
        pass
    ctrl_hits = 0
    for b in sample:
        if b < 32 and b not in (9, 10, 13):  # \t \n \r
            ctrl_hits += 1
    return (ctrl_hits / max(1, len(sample))) < 0.01  # 1% de contrôle toléré

def pick_encoding(path: Path) -> Optional[str]:
    try:
        with path.open("rb") as f:
            sample = f.read(32768)
    except Exception:
        return None
    if not is_probably_text(sample):
        return None
    for enc in ("utf-8", "utf-8-sig", "utf-16", "cp1252", "latin-1"):
        try:
            sample.decode(enc)
            return enc
        except UnicodeDecodeError:
            continue
    return "latin-1"

def relpath(base: Path, p: Path) -> str:
    try:
        return str(p.relative_to(base))
    except Exception:
        return str(p)

def should_include_file(base: Path, file_path: Path, allowed_exts: Set[str], include_globs: List[str], exclude_globs: List[str], max_size: int, out_path: Path) -> bool:
    if not file_path.is_file():
        return False
    if file_path == out_path:
        return False
    try:
        if file_path.stat().st_size > max_size:
            return False
    except Exception:
        return False
    rel = relpath(base, file_path)
    for pat in exclude_globs:
        if fnmatch.fnmatch(rel, pat):
            return False
    if include_globs:
        ok = any(fnmatch.fnmatch(rel, pat) for pat in include_globs)
        if not ok:
            return False
    if file_path.suffix.lower() in allowed_exts or file_path.name in NAMES_WITHOUT_EXT:
        return True
    enc = pick_encoding(file_path)
    return enc is not None

def main() -> None:
    args = parse_args()
    base_dir = Path(__file__).resolve().parent
    out_path = (base_dir / args.out).resolve()
    allowed_exts = normalize_exts(args.ext)
    include_globs = list(args.include or [])
    exclude_globs = list(args.exclude or [])
    selected: List[Path] = []
    for root, dirs, files in os.walk(base_dir, followlinks=False):
        dirs[:] = [d for d in dirs if d not in DEFAULT_EXCLUDE_DIRS]
        root_path = Path(root)
        for name in files:
            fp = root_path / name
            if should_include_file(base_dir, fp, allowed_exts, include_globs, exclude_globs, args.max_size, out_path):
                selected.append(fp)
    selected.sort(key=lambda p: relpath(base_dir, p).lower())
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with out_path.open("w", encoding="utf-8", newline="\n") as out:
        for p in selected:
            enc = pick_encoding(p) or "utf-8"
            if not args.no_headers:
                out.write(f"\n===== BEGIN {relpath(base_dir, p)} =====\n")
            try:
                with p.open("r", encoding=enc, errors="strict") as f:
                    for line in f:
                        out.write(line)
            except UnicodeDecodeError:
                with p.open("r", encoding="latin-1", errors="replace") as f:
                    for line in f:
                        out.write(line)
            if not args.no_headers:
                out.write(f"\n===== END {relpath(base_dir, p)} =====\n")
            out.write("\n")
    print(f"{len(selected)} fichier(s) concaténé(s) -> {relpath(base_dir, out_path)}")

if __name__ == "__main__":
    main()

===== END concatv1.py =====


===== BEGIN connect\page.tsx =====
﻿import { ConnectCenter } from "@/kontact/pages";
export default ConnectCenter;

===== END connect\page.tsx =====


===== BEGIN consult\page.tsx =====
﻿import { ConsultationHub } from "@/ethikos/pages";
export default ConsultationHub;

===== END consult\page.tsx =====


===== BEGIN course\[slug]\page.tsx =====
﻿import MainLayout from '@/shared/layout/MainLayout';

export default function Page() {
  return (
    <MainLayout>
      <p className='text-gray-500'>Placeholder for /course/[slug]</p>
    </MainLayout>
  );
}

===== END course\[slug]\page.tsx =====


===== BEGIN debate\page.tsx =====
﻿import { DebateHub } from "@/ethikos/pages";
export default DebateHub;

===== END debate\page.tsx =====


===== BEGIN ekoh\page.tsx =====
﻿import { ThreadsPage } from "@/ekoh/pages";
export default ThreadsPage;

===== END ekoh\page.tsx =====


===== BEGIN ethikos\insights\page.tsx =====
﻿import { EthikosInsightsDashboard } from "@/ethikos/pages";
export default EthikosInsightsDashboard;

===== END ethikos\insights\page.tsx =====


===== BEGIN impact\page.tsx =====
﻿import { ImpactDashboard } from "@/keenkonnect/pages";
export default ImpactDashboard;

===== END impact\page.tsx =====


===== BEGIN insights\page.tsx =====
import MainLayout from "@/shared/layout/MainLayout";

export default function Page() {
  return (
    <MainLayout>
      <div className="text-gray-400">??  insights  (coming soon)</div>
    </MainLayout>
  );
}

===== END insights\page.tsx =====


===== BEGIN konsensus\page.tsx =====
﻿import { PollPage } from "@/konsensus/pages";
export default PollPage;

===== END konsensus\page.tsx =====


===== BEGIN kreative\page.tsx =====
﻿import { CreativityHub } from "@/kreative/pages";
export default CreativityHub;

===== END kreative\page.tsx =====


===== BEGIN layout.tsx =====
import QueryProvider from "@/shared/QueryProvider";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        {/* Client-side provider lives inside its own client component */}
        <QueryProvider>{children}</QueryProvider>
      </body>
    </html>
  );
}

===== END layout.tsx =====


===== BEGIN learn\page.tsx =====
import MainLayout from "@/shared/layout/MainLayout";

export default function Page() {
  return (
    <MainLayout>
      <div className="text-gray-400">??  learn  (coming soon)</div>
    </MainLayout>
  );
}

===== END learn\page.tsx =====


===== BEGIN my-work\page.tsx =====
﻿import MyWorkPage from '../../modules/global/pages/MyWork';
export default MyWorkPage;

===== END my-work\page.tsx =====


===== BEGIN page.tsx =====
import MainLayout from "@/shared/layout/MainLayout";

export default function Home() {
  return (
    <MainLayout>
      <div className="text-gray-500">Konnaxion frontend ready.</div>
    </MainLayout>
  );
}

===== END page.tsx =====


===== BEGIN profile\[user]\page.tsx =====
﻿import { PublicProfile } from "@/kontact/pages";
export default PublicProfile;

===== END profile\[user]\page.tsx =====


===== BEGIN projects\[slug]\page.tsx =====
﻿import { Workspace } from "@/keenkonnect/pages";
export default Workspace;

===== END projects\[slug]\page.tsx =====


===== BEGIN projects\page.tsx =====
﻿import { ProjectStudio } from "@/keenkonnect/pages";
export default ProjectStudio;

===== END projects\page.tsx =====


===== BEGIN reports\custom\page.tsx =====
﻿import { CustomBuilderPage } from "@/insights/pages";
export default CustomBuilderPage;

===== END reports\custom\page.tsx =====


===== BEGIN reports\page.tsx =====
﻿import { InsightsHomePage } from "@/insights/pages";
export default InsightsHomePage;

===== END reports\page.tsx =====


===== BEGIN reports\perf\page.tsx =====
﻿import { PerfDashboard } from "@/insights/pages";
export default PerfDashboard;

===== END reports\perf\page.tsx =====


===== BEGIN reports\smart-vote\page.tsx =====
﻿import { SmartVoteDashboard } from "@/insights/pages";
export default SmartVoteDashboard;

===== END reports\smart-vote\page.tsx =====


===== BEGIN reports\usage\page.tsx =====
﻿import { UsageDashboard } from "@/insights/pages";
export default UsageDashboard;

===== END reports\usage\page.tsx =====


===== BEGIN reputation\page.tsx =====
﻿import { ReputationPage } from "@/ethikos/pages";
export default ReputationPage;

===== END reputation\page.tsx =====


===== BEGIN scanpathv1.py =====
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
from pathlib import Path
from datetime import datetime


def iter_paths(root: Path):
    """Génère tous les chemins (dossiers puis fichiers) sous root, ordre stable."""
    for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=False):
        dirnames.sort()
        filenames.sort()
        current_dir = Path(dirpath)
        yield current_dir.resolve()  # le dossier lui‑même
        for name in filenames:
            yield (current_dir / name).resolve()


def main():
    # Dossier cible: là où se trouve ce script.
    # Pour utiliser le dossier courant à la place: remplacez par Path.cwd().
    root = Path(__file__).resolve().parent

    # Nom du fichier: <NomDuDossierParent>_<YYYYMMDD_HHMMSS>.txt
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    out_path = root / f"{root.name}_{ts}.txt"

    # Écrit en flux pour éviter la charge mémoire et s’auto‑exclure.
    with out_path.open("w", encoding="utf-8", newline="\n") as f:
        for p in iter_paths(root):
            if p == out_path:
                continue  # ne pas s’inclure
            f.write(str(p) + "\n")

    print(f"Fichier généré: {out_path}")


if __name__ == "__main__":
    main()

===== END scanpathv1.py =====


===== BEGIN search\page.tsx =====
﻿"use client";

import { Alert, List, Spin } from "antd";
import { useSearchParams } from "next/navigation";
import React from "react";
import AppShell from "@/global/components/AppShell";
import useGlobalSearch, { GlobalSearchResult } from "@/global/hooks/useGlobalSearch";

export default function SearchPage() {
  const q = useSearchParams().get("q") ?? "";
  const { data, isLoading, isError, error } = useGlobalSearch(q);

  return (
    <AppShell>
      {isLoading && <Spin />}
      {isError && <Alert message={error.message} type="error" />}
      {data && (
        <List<GlobalSearchResult>
          itemLayout="vertical"
          dataSource={data}
          renderItem={(item) => (
            <List.Item key={item.id}>
              <List.Item.Meta
                title={<a href={item.path}>{item.title}</a>}
                description={item.snippet}
              />
            </List.Item>
          )}
        />
      )}
    </AppShell>
  );
}

===== END search\page.tsx =====


===== BEGIN team\page.tsx =====
﻿import { TeamManager } from "@/konnected/pages";
export default TeamManager;

===== END team\page.tsx =====

