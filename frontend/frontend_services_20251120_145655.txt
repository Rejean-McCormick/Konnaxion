===== TOC (13 fichiers) =====
1. C:\MyCode\Konnaxionv14\frontend\services\_request.ts
2. C:\MyCode\Konnaxionv14\frontend\services\admin.ts
3. C:\MyCode\Konnaxionv14\frontend\services\audit.ts
4. C:\MyCode\Konnaxionv14\frontend\services\decide.mock.ts
5. C:\MyCode\Konnaxionv14\frontend\services\decide.ts
6. C:\MyCode\Konnaxionv14\frontend\services\deliberate.ts
7. C:\MyCode\Konnaxionv14\frontend\services\impact.ts
8. C:\MyCode\Konnaxionv14\frontend\services\index.ts
9. C:\MyCode\Konnaxionv14\frontend\services\learn.ts
10. C:\MyCode\Konnaxionv14\frontend\services\projects.ts
11. C:\MyCode\Konnaxionv14\frontend\services\pulse.ts
12. C:\MyCode\Konnaxionv14\frontend\services\trust.ts
13. C:\MyCode\Konnaxionv14\frontend\services\user.ts
===== END TOC =====


===== BEGIN services/_request.ts =====
'use client'

import axios, {
  AxiosInstance,
  AxiosRequestConfig,
  InternalAxiosRequestConfig,
} from 'axios'

/**
 * One axios instance.
 * Do NOT unwrap in interceptors; wrappers below return `data` as T.
 */
const client: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE ?? '/api',
  withCredentials: true,
  xsrfCookieName: 'csrftoken',
  xsrfHeaderName: 'X-CSRFToken',
  timeout: 15000,
})

client.interceptors.request.use((cfg: InternalAxiosRequestConfig) => {
  // Example:
  // const t = typeof window !== 'undefined' ? localStorage.getItem('token') : null
  // if (t) cfg.headers.Authorization = `Bearer ${t}`
  return cfg
})

client.interceptors.response.use(
  (res) => res,
  (err) => Promise.reject(err),
)

type Cfg<D = any> = AxiosRequestConfig<D>

/** Typed helpers: always return raw data `T` */
export async function get<T, D = any>(url: string, config?: Cfg<D>): Promise<T> {
  const res = await client.get<T>(url, config)
  return res.data as T
}

export async function post<T, D = any>(
  url: string,
  body?: D,
  config?: Cfg<D>,
): Promise<T> {
  const res = await client.post<T>(url, body, config)
  return res.data as T
}

export async function put<T, D = any>(
  url: string,
  body?: D,
  config?: Cfg<D>,
): Promise<T> {
  const res = await client.put<T>(url, body, config)
  return res.data as T
}

export async function patch<T, D = any>(
  url: string,
  body?: D,
  config?: Cfg<D>,
): Promise<T> {
  const res = await client.patch<T>(url, body, config)
  return res.data as T
}

export async function del<T, D = any>(url: string, config?: Cfg<D>): Promise<T> {
  const res = await client.delete<T>(url, config)
  return res.data as T
}

/**
 * Default export: axios instance augmented with data-returning methods.
 * Allows `api.post<T>(...)` to yield `T` (not AxiosResponse<T>).
 */
type DataMethods = {
  get<T, D = any>(url: string, config?: Cfg<D>): Promise<T>
  post<T, D = any>(url: string, body?: D, config?: Cfg<D>): Promise<T>
  put<T, D = any>(url: string, body?: D, config?: Cfg<D>): Promise<T>
  patch<T, D = any>(url: string, body?: D, config?: Cfg<D>): Promise<T>
  delete<T, D = any>(url: string, config?: Cfg<D>): Promise<T>
  del<T, D = any>(url: string, config?: Cfg<D>): Promise<T>
}

type API = Omit<AxiosInstance, 'get' | 'post' | 'put' | 'patch' | 'delete'> & DataMethods

const api = Object.assign(client, {
  async get<T, D = any>(url: string, config?: Cfg<D>) {
    const res = await client.get<T>(url, config)
    return res.data as T
  },
  async post<T, D = any>(url: string, body?: D, config?: Cfg<D>) {
    const res = await client.post<T>(url, body, config)
    return res.data as T
  },
  async put<T, D = any>(url: string, body?: D, config?: Cfg<D>) {
    const res = await client.put<T>(url, body, config)
    return res.data as T
  },
  async patch<T, D = any>(url: string, body?: D, config?: Cfg<D>) {
    const res = await client.patch<T>(url, body, config)
    return res.data as T
  },
  async delete<T, D = any>(url: string, config?: Cfg<D>) {
    const res = await client.delete<T>(url, config)
    return res.data as T
  },
  async del<T, D = any>(url: string, config?: Cfg<D>) {
    const res = await client.delete<T>(url, config)
    return res.data as T
  },
}) as API

export default api

===== END services/_request.ts =====


===== BEGIN services/admin.ts =====
// services/admin.ts
import { get, post, patch } from './_request'
import type { AuditPayload as AuditPayloadBase, LogRow as AuditLogRow } from './audit'
import { fetchAuditLogs as fetchAuditLogsRaw } from './audit'

// ----- Shared Admin types -----
export type RoleRow = {
  id: string
  name: string
  userCount: number
  enabled: boolean
}

export type RolePayload = { items: RoleRow[] }

export type Report = {
  id: string
  content: string
  reporter: string
  type: 'Spam' | 'Harassment' | 'Misinformation'
  status: 'Pending' | 'Resolved'
}

export type ModerationPayload = { items: Report[] }

// Re‑export canonical audit types from services/audit
export type LogRow = AuditLogRow
export type AuditPayload = AuditPayloadBase

// ----- API calls with explicit return types -----
export async function fetchModerationQueue(): Promise<ModerationPayload> {
  return get<ModerationPayload>('admin/moderation')
}

export async function actOnReport(id: string, remove: boolean): Promise<void> {
  return post<void>(`admin/moderation/${id}`, { remove })
}

export async function fetchRoles(): Promise<RolePayload> {
  return get<RolePayload>('admin/roles')
}

export async function toggleRole(id: string, enabled: boolean): Promise<void> {
  return patch<void>(`admin/roles/${id}`, { enabled })
}

/**
 * Convenience wrapper for audit logs used by the Admin UI.
 * It delegates to the canonical implementation in services/audit
 * and intentionally exposes a no‑arg signature so that
 * `useRequest<AuditPayload, []>(fetchAuditLogs)` keeps working.
 */
export async function fetchAuditLogs(): Promise<AuditPayload> {
  return fetchAuditLogsRaw()
}

===== END services/admin.ts =====


===== BEGIN services/audit.ts =====
// services/audit.ts
import { get } from './_request'

/**
 * Canonical audit-log row shape.
 * Includes both the simple Admin UI fields and richer backend metadata.
 */
export interface LogRow {
  /** Unique identifier of the log entry */
  id: string

  /** ISO timestamp when the event occurred */
  ts: string

  /** User or service that triggered the action */
  actor: string

  /** Logical action identifier, e.g. "UPDATE_TOPIC" */
  action: string

  /** Human‑readable target used in the admin UI (topic title, user name, etc.) */
  target?: string

  /** Severity used by the admin UI to color the tag */
  severity?: 'info' | 'warn' | 'critical'

  /** Machine‑oriented entity type, e.g. "topic", "argument", "user" */
  entity?: string

  /** Primary key of the entity in the source system */
  entityId?: string

  /** Source IP address, if tracked */
  ip?: string

  /** Outcome of the operation from the backend point of view */
  status?: 'ok' | 'warn' | 'error'

  /** Free‑form JSON payload with extra context */
  meta?: Record<string, unknown>
}

export interface AuditPayload {
  items: LogRow[]
  page: number
  pageSize: number
  total: number
}

export interface AuditQueryParams {
  page?: number
  pageSize?: number
  q?: string
  sort?: string
  /** Optional server‑side filter by severity */
  severity?: LogRow['severity']
}

/**
 * GET /admin/audit/logs
 * Paginated, filterable audit log stream.
 * Aligned with backend path "admin/audit/logs" and the global services/_request baseURL.
 */
export async function fetchAuditLogs(
  params?: AuditQueryParams,
): Promise<AuditPayload> {
  return get<AuditPayload>('admin/audit/logs', { params })
}

===== END services/audit.ts =====


===== BEGIN services/decide.mock.ts =====
// src/services/decide.mock.ts
import dayjs from 'dayjs';

export type VotingFormat = 'binary' | 'multiple' | 'scale';

export interface PublicTopic {
  id: string;
  categoryId: string;
  question: string;
  format: VotingFormat;
  /** For binary/multiple; ignored for scale */
  options?: string[];
  /** Optional labels for scale (e.g. ['None', 'A little', …]) */
  scaleLabels?: string[];
  turnout: number;      // %
  closesAt: string;     // ISO date-time
}

export interface Category {
  id: string;
  name: string;
}

/* ------------------------------------------------------------------ */
/*  Simulated network helpers                                         */
/* ------------------------------------------------------------------ */

const sleep = (ms = 350) => new Promise(r => setTimeout(r, ms));

/** Pretend “database” — extends easily */
const CATEGORIES: Category[] = [
  { id: 'gov',  name: 'Governance & Democracy' },
  { id: 'econ', name: 'Economy & Taxation' },
  { id: 'env',  name: 'Environment & Climate' },
];

const TOPICS: PublicTopic[] = [
  {
    id: 't1',
    categoryId: 'gov',
    question: 'Should Canada replace its first-past-the-post system with proportional representation?',
    format: 'binary',
    options: ['Yes', 'No'],
    turnout: 43,
    closesAt: dayjs().add(5, 'day').toISOString(),
  },
  {
    id: 't2',
    categoryId: 'econ',
    question: 'At what level should the national minimum wage be set?',
    format: 'multiple',
    options: ['<$18', '$18', '$20', '$22', 'No federal minimum'],
    turnout: 37,
    closesAt: dayjs().add(10, 'day').toISOString(),
  },
  {
    id: 't3',
    categoryId: 'env',
    question: 'How much should Canada raise the carbon tax beyond the current 2030 schedule?',
    format: 'scale',
    scaleLabels: ['None', 'A little', 'Average', 'Much', 'Very much'],
    turnout: 51,
    closesAt: dayjs().add(7, 'day').toISOString(),
  },
];

/* ------------------------------------------------------------------ */
/*  Public API                                                         */
/* ------------------------------------------------------------------ */

/** Fetch all public-ballot topics grouped by category */
export async function fetchPublicTopics(): Promise<{
  categories: Category[];
  topics: PublicTopic[];
}> {
  await sleep();               // simulate latency
  return { categories: CATEGORIES, topics: TOPICS };
}

/** Simulate persisting a vote */
export async function submitPublicVote(topicId: string, value: string | number) {
  console.info('vote saved', { topicId, value });
  await sleep(600);
  // In real life: POST /vote {topicId, value}
}


===== END services/decide.mock.ts =====


===== BEGIN services/decide.ts =====
// frontend/services/decide.ts
import dayjs from 'dayjs'
import { get, post } from './_request'
import type { Ballot } from '@/types'

export type DecisionScope = 'Elite' | 'Public'

export type EliteBallot = Ballot & {
  scope: 'Elite'
  turnout: number
}

export type PublicBallot = Ballot & {
  scope: 'Public'
  options: string[]
  turnout: number
}

export interface EliteBallotResponse {
  ballots: EliteBallot[]
}

export interface PublicBallotResponse {
  ballots: PublicBallot[]
}

export interface DecisionResult {
  id: string
  title: string
  scope: DecisionScope
  passed: boolean
  closesAt: string
  region?: string
}

export interface DecisionResultsResponse {
  items: DecisionResult[]
}

// ──────────────────────────────────────────────────────────
// Backend DTOs (Ethikos)
// ──────────────────────────────────────────────────────────

type TopicStatus = 'open' | 'closed' | 'archived'

interface EthikosCategoryApi {
  id: number
  name: string
  description?: string
}

interface EthikosTopicApi {
  id: number
  title: string
  description: string
  status: TopicStatus
  total_votes?: number | null
  last_activity: string
  created_at: string
  category: EthikosCategoryApi
  expertise_category?: number | null
}

interface EthikosStanceApi {
  id: number
  topic: number
  value: number
  timestamp: string
  user: string
}

// ──────────────────────────────────────────────────────────
// Helpers
// ──────────────────────────────────────────────────────────

const PUBLIC_SCALE_OPTIONS = [
  'Strongly disagree',
  'Disagree',
  'Neutral',
  'Agree',
  'Strongly agree',
]

function computeClosesAt(topic: EthikosTopicApi): string {
  const created = dayjs(topic.created_at)
  if (topic.status === 'open') {
    // Simple heuristic: debates stay open 7 days after creation
    return created.add(7, 'day').toISOString()
  }
  // For closed / archived debates, treat last activity as closing time
  return dayjs(topic.last_activity).toISOString()
}

function normalizeTurnout(totalVotes?: number | null): number {
  const n = typeof totalVotes === 'number' ? totalVotes : 0
  // Clamp to [0, 100]; 1 vote = 1% is enough for initial UX
  return Math.max(0, Math.min(100, n))
}

function topicScope(topic: EthikosTopicApi): DecisionScope {
  return topic.expertise_category ? 'Elite' : 'Public'
}

function toEliteBallot(topic: EthikosTopicApi): EliteBallot {
  return {
    id: String(topic.id),
    title: topic.title,
    closesAt: computeClosesAt(topic),
    scope: 'Elite',
    turnout: normalizeTurnout(topic.total_votes),
  }
}

function toPublicBallot(topic: EthikosTopicApi): PublicBallot {
  return {
    id: String(topic.id),
    title: topic.title,
    closesAt: computeClosesAt(topic),
    scope: 'Public',
    options: PUBLIC_SCALE_OPTIONS,
    turnout: normalizeTurnout(topic.total_votes),
  }
}

function mapOptionToValue(option: string): number {
  const normalized = option.toLowerCase()
  if (normalized.startsWith('strongly disagree')) return -3
  if (normalized.startsWith('disagree')) return -1
  if (normalized.startsWith('neutral')) return 0
  if (normalized.startsWith('strongly agree')) return 3
  if (normalized.startsWith('agree')) return 1
  // Fallback when custom labels are used
  return 0
}

// ──────────────────────────────────────────────────────────
/** Elite ballots = Ethikos topics with an expertise_category (status=open). */
// ──────────────────────────────────────────────────────────
export async function fetchEliteBallots(): Promise<EliteBallotResponse> {
  const topics = await get<EthikosTopicApi[]>('ethikos/topics/', {
    params: { status: 'open' },
  })

  const elite = topics.filter((t) => t.expertise_category != null)

  return {
    ballots: elite.map(toEliteBallot),
  }
}

// ──────────────────────────────────────────────────────────
/** Public ballots = topics without expertise_category (status=open). */
// ──────────────────────────────────────────────────────────
export async function fetchPublicBallots(): Promise<PublicBallotResponse> {
  const topics = await get<EthikosTopicApi[]>('ethikos/topics/', {
    params: { status: 'open' },
  })

  const publicTopics = topics.filter((t) => !t.expertise_category)

  return {
    ballots: publicTopics.map(toPublicBallot),
  }
}

// ──────────────────────────────────────────────────────────
/** Records a stance for the current user via /api/ethikos/stances/. */
// ──────────────────────────────────────────────────────────
export async function submitPublicVote(
  id: string,
  option: string,
): Promise<{ ok: true }> {
  const topicId = Number(id)
  if (!Number.isFinite(topicId)) {
    throw new Error(`Invalid topic id: ${id}`)
  }

  const value = mapOptionToValue(option)

  await post('ethikos/stances/', {
    topic: topicId,
    value,
  })

  return { ok: true }
}

// ──────────────────────────────────────────────────────────
/** Decision results = closed topics + stance direction from /ethikos/stances/. */
// ──────────────────────────────────────────────────────────
export async function fetchDecisionResults(): Promise<DecisionResultsResponse> {
  const [topics, stances] = await Promise.all([
    get<EthikosTopicApi[]>('ethikos/topics/', {
      params: { status: 'closed' },
    }),
    get<EthikosStanceApi[]>('ethikos/stances/'),
  ])

  const byTopic = new Map<number, { sum: number; count: number }>()
  for (const stance of stances) {
    const bucket = byTopic.get(stance.topic) ?? { sum: 0, count: 0 }
    bucket.sum += stance.value
    bucket.count += 1
    byTopic.set(stance.topic, bucket)
  }

  const items: DecisionResult[] = topics.map((topic) => {
    const stats = byTopic.get(topic.id)
    const avg = stats && stats.count > 0 ? stats.sum / stats.count : 0
    const passed = avg >= 0

    return {
      id: String(topic.id),
      title: topic.title,
      scope: topicScope(topic),
      passed,
      closesAt: computeClosesAt(topic),
      region: topic.category?.name,
    }
  })

  return { items }
}

===== END services/decide.ts =====


===== BEGIN services/deliberate.ts =====
// services/deliberate.ts
import { get, post } from './_request'
import type { Topic } from '@/types'

/* ------------------------------------------------------------------ */
/*  Exported types (reused by pages/modules)                           */
/* ------------------------------------------------------------------ */

export type EliteTopic = Topic & {
  createdAt: string
  lastActivity: string
  hot: boolean
  /** May or may not be present in the payload; normalized in the UI */
  stanceCount?: number
}

export type EliteTopicsResponse = {
  list: EliteTopic[]
}

export type TopicPreviewResponse = {
  id: string
  title: string
  category: string
  createdAt: string
  latest: { id: string; author: string; body: string }[]
}

export type TopicDetailResponse = {
  id: string
  title: string
  statements: { id: string; author: string; body: string; createdAt: string }[]
}

/* ------------------------------------------------------------------ */
/*  API calls                                                          */
/* ------------------------------------------------------------------ */

/** GET /deliberate/elite/topics */
export async function fetchEliteTopics(): Promise<EliteTopicsResponse> {
  return get<EliteTopicsResponse>('deliberate/elite/topics')
}

/** GET /deliberate/topics/:id/preview */
export async function fetchTopicPreview(id: string): Promise<TopicPreviewResponse> {
  return get<TopicPreviewResponse>(`deliberate/topics/${id}/preview`)
}

/** POST /deliberate/elite/topics */
export async function createEliteTopic(payload: {
  title: string
  category: string
}): Promise<{ id: string }> {
  return post<{ id: string }>('deliberate/elite/topics', payload)
}

/** GET /deliberate/topics/:id */
export async function fetchTopicDetail(id: string): Promise<TopicDetailResponse> {
  return get<TopicDetailResponse>(`deliberate/topics/${id}`)
}

===== END services/deliberate.ts =====


===== BEGIN services/impact.ts =====
// frontend/services/impact.ts
import dayjs from 'dayjs'
import { get, patch, post } from './_request'

export type ImpactStatus = 'Planned' | 'In-Progress' | 'Completed' | 'Blocked'

export interface TrackerItem {
  id: string
  title: string
  owner: string
  status: ImpactStatus
  updatedAt: string
}

export interface OutcomeKPI {
  key: string
  label: string
  value: number
  delta?: number
}

export interface ChartConfig {
  data: any[]
  xField: string
  yField: string
  seriesField?: string
  [key: string]: any
}

export interface OutcomeChart {
  key: string
  title: string
  type: 'line' | 'bar'
  config: ChartConfig
}

export interface FeedbackItem {
  id: string
  author: string
  body: string
  rating?: number
  createdAt: string
}

// ──────────────────────────────────────────────────────────
// Backend DTOs (Ethikos)
// ──────────────────────────────────────────────────────────

type TopicStatus = 'open' | 'closed' | 'archived'

interface EthikosTopicApi {
  id: number
  title: string
  status: TopicStatus
  created_by: string
  last_activity: string
  created_at: string
  category: { id: number; name: string; description?: string }
  total_votes?: number | null
}

interface EthikosStanceApi {
  id: number
  topic: number
  value: number
  timestamp: string
}

interface EthikosArgumentApi {
  id: number
  topic: number
  user: string
  content: string
  created_at: string
}

// ──────────────────────────────────────────────────────────
// Helpers
// ──────────────────────────────────────────────────────────

function topicStatusToImpactStatus(status: TopicStatus): ImpactStatus {
  switch (status) {
    case 'closed':
      return 'Completed'
    case 'archived':
      return 'Blocked'
    case 'open':
    default:
      return 'In-Progress'
  }
}

function impactStatusToTopicStatus(status: ImpactStatus): TopicStatus {
  switch (status) {
    case 'Completed':
      return 'closed'
    case 'Blocked':
      return 'archived'
    case 'Planned':
    case 'In-Progress':
    default:
      return 'open'
  }
}

interface DailyPoint {
  date: string
  value: number
}

function buildDailySeries<T>(
  items: T[],
  getDate: (item: T) => string,
  days = 30,
): DailyPoint[] {
  const now = dayjs()
  const start = now.startOf('day').subtract(days - 1, 'day')
  const counts: number[] = new Array<number>(days).fill(0)

  for (const item of items) {
    const d = dayjs(getDate(item))
    if (d.isBefore(start) || d.isAfter(now)) continue
    const offset = d.startOf('day').diff(start, 'day')
    if (offset >= 0 && offset < days) {
      const current = counts[offset] ?? 0
      counts[offset] = current + 1
    }
  }

  const series: DailyPoint[] = []
  for (let i = 0; i < days; i += 1) {
    series.push({
      date: start.add(i, 'day').toISOString(),
      value: counts[i] ?? 0,
    })
  }
  return series
}

function percentDelta(series: DailyPoint[]): number | undefined {
  if (series.length < 2) return undefined

  const latest = series[series.length - 1]?.value
  const previous = series[series.length - 2]?.value

  if (latest === undefined || previous === undefined || previous === 0) {
    return undefined
  }

  return Math.round(((latest - previous) / previous) * 100)
}

// ──────────────────────────────────────────────────────────
// Tracker: maps Ethikos topics → impact items
// ──────────────────────────────────────────────────────────

export async function fetchImpactTracker(): Promise<{ items: TrackerItem[] }> {
  const topics = await get<EthikosTopicApi[]>('ethikos/topics/')

  const items: TrackerItem[] = topics.map((topic) => ({
    id: String(topic.id),
    title: topic.title,
    owner: topic.created_by,
    status: topicStatusToImpactStatus(topic.status),
    updatedAt: topic.last_activity,
  }))

  return { items }
}

export async function patchImpactStatus(
  id: string,
  status: ImpactStatus,
): Promise<void> {
  const topicStatus = impactStatusToTopicStatus(status)
  await patch(`ethikos/topics/${id}/`, { status: topicStatus })
}

// ──────────────────────────────────────────────────────────
// Outcomes: KPIs + charts from Ethikos topics + stances
// ──────────────────────────────────────────────────────────

export async function fetchImpactOutcomes(): Promise<{
  kpis: OutcomeKPI[]
  charts: OutcomeChart[]
}> {
  const [topics, stances] = await Promise.all([
    get<EthikosTopicApi[]>('ethikos/topics/'),
    get<EthikosStanceApi[]>('ethikos/stances/'),
  ])

  const closedTopics = topics.filter((t) => t.status === 'closed')
  const openTopics = topics.filter((t) => t.status === 'open')

  const votesByTopic = new Map<number, { sum: number; count: number }>()
  for (const stance of stances) {
    const bucket = votesByTopic.get(stance.topic) ?? { sum: 0, count: 0 }
    bucket.sum += stance.value
    bucket.count += 1
    votesByTopic.set(stance.topic, bucket)
  }

  const closedWithStats = closedTopics.map((t) => votesByTopic.get(t.id))
  const avgAgreement =
    closedWithStats.length > 0
      ? closedWithStats.reduce((acc, s) => {
          if (!s || s.count === 0) return acc
          return acc + s.sum / (s.count * 3)
        }, 0) / closedWithStats.length
      : 0

  const topicsSeries = buildDailySeries(topics, (t) => t.created_at)
  const stancesSeries = buildDailySeries(stances, (s) => s.timestamp)

  const kpis: OutcomeKPI[] = [
    {
      key: 'resolved',
      label: 'Decisions resolved',
      value: closedTopics.length,
      delta: percentDelta(topicsSeries),
    },
    {
      key: 'participation',
      label: 'Total stances',
      value: stances.length,
      delta: percentDelta(stancesSeries),
    },
    {
      key: 'agreement',
      label: 'Average agreement',
      // avgAgreement ∈ [-1, 1] → [0, 100]
      value: Math.round((avgAgreement + 1) * 50),
    },
    {
      key: 'open',
      label: 'Open debates',
      value: openTopics.length,
    },
  ]

  const topicStatusByCategory: { category: string; value: number }[] = []
  const bucketByCategory = new Map<string, number>()
  for (const topic of topics) {
    const name = topic.category?.name ?? 'Uncategorised'
    const current = bucketByCategory.get(name) ?? 0
    bucketByCategory.set(name, current + 1)
  }
  bucketByCategory.forEach((value, category) => {
    topicStatusByCategory.push({ category, value })
  })

  const charts: OutcomeChart[] = [
    {
      key: 'participation-timeline',
      title: 'Participation over time',
      type: 'line',
      config: {
        data: stancesSeries,
        xField: 'date',
        yField: 'value',
        smooth: true,
      },
    },
    {
      key: 'topics-by-category',
      title: 'Topics by category',
      type: 'bar',
      config: {
        data: topicStatusByCategory,
        xField: 'category',
        yField: 'value',
        seriesField: 'category',
      },
    },
  ]

  return { kpis, charts }
}

// ──────────────────────────────────────────────────────────
// Feedback loop = arguments on a dedicated Ethikos topic
// ──────────────────────────────────────────────────────────

const FEEDBACK_TOPIC_ID = process.env.NEXT_PUBLIC_ETHIKOS_FEEDBACK_TOPIC_ID

export async function fetchFeedback(): Promise<{ items: FeedbackItem[] }> {
  if (!FEEDBACK_TOPIC_ID) {
    // No dedicated topic configured yet – return an empty list.
    return { items: [] }
  }

  const argumentsForTopic = await get<EthikosArgumentApi[]>('ethikos/arguments/', {
    params: { topic: FEEDBACK_TOPIC_ID },
  })

  const items: FeedbackItem[] = argumentsForTopic.map((arg) => ({
    id: String(arg.id),
    author: arg.user,
    body: arg.content,
    createdAt: arg.created_at,
  }))

  return { items }
}

export async function submitFeedback(payload: {
  body: string
  rating?: number
}): Promise<void> {
  if (!FEEDBACK_TOPIC_ID) {
    throw new Error(
      'NEXT_PUBLIC_ETHIKOS_FEEDBACK_TOPIC_ID is not set; cannot store feedback.',
    )
  }

  await post('ethikos/arguments/', {
    topic: Number(FEEDBACK_TOPIC_ID),
    content: payload.body,
  })
}

===== END services/impact.ts =====


===== BEGIN services/index.ts =====
// services/index.ts
export * from './audit'
export * from './decide'
export * from './deliberate'
export * from './pulse'

===== END services/index.ts =====


===== BEGIN services/learn.ts =====
// frontend/services/learn.ts
import { get } from './_request'

export interface ChangelogEntry {
  version: string
  date: string
  tags: string[]
  notes: string[]
}

export interface GuideSection {
  id: string
  title: string
  content: string
}

export interface GlossaryItem {
  id: string
  term: string
  definition: string
}

interface EthikosCategoryApi {
  id: number
  name: string
  description?: string
}

// Static content you can adjust directly in this file
const CHANGELOG: ChangelogEntry[] = [
  {
    version: 'v0.1',
    date: '2025-01-01',
    tags: ['initial'],
    notes: [
      'First deploy of Ethikos kernel (topics, stances, arguments).',
      'Elite / public debates wired on top of the Ethikos models.',
    ],
  },
]

const GUIDES: GuideSection[] = [
  {
    id: 'getting-started',
    title: 'Getting started with Ethikos',
    content:
      'Create a debate topic, invite participants to express a stance, then use DECIDE for outcomes and DELIBERATE for argument threads.',
  },
  {
    id: 'elite-vs-public',
    title: 'Elite vs public consultations',
    content:
      'Elite debates are linked to an expertise category; public debates are open to all. This is defined on the Ethikos topic (expertise_category).',
  },
]

export async function fetchChangelog(): Promise<{ entries: ChangelogEntry[] }> {
  return { entries: CHANGELOG }
}

export async function fetchGuides(): Promise<{ sections: GuideSection[] }> {
  return { sections: GUIDES }
}

export async function fetchGlossary(): Promise<{ items: GlossaryItem[] }> {
  const categories = await get<EthikosCategoryApi[]>('ethikos/categories/')

  const items: GlossaryItem[] = categories.map((c) => ({
    id: String(c.id),
    term: c.name,
    definition: c.description ?? '',
  }))

  return { items }
}

===== END services/learn.ts =====


===== BEGIN services/projects.ts =====
// services/projects.ts
// Thin service layer around the backend /api/projects/ endpoints.

import { get, post, put, del } from './_request';

export type ProjectStatusApi = 'idea' | 'progress' | 'completed' | 'validated';

export interface ApiProject {
  id: number;
  creator: string;
  title: string;
  description: string;
  category: string;
  status: ProjectStatusApi;
  created_at: string;
  updated_at: string;
  tags: number[];
}

/**
 * Fetch list of collaborative projects.
 * Backend: GET /api/projects/
 */
export async function fetchProjects(): Promise<ApiProject[]> {
  // baseURL is provided by NEXT_PUBLIC_API_BASE (e.g. http://localhost:8000/api)
  return get<ApiProject[]>('projects/');
}

/**
 * Fetch a single project by id.
 * Backend: GET /api/projects/:id/
 */
export async function fetchProject(id: number | string): Promise<ApiProject> {
  return get<ApiProject>(`projects/${id}/`);
}

export interface CreateProjectPayload {
  title: string;
  description?: string;
  category?: string;
  status?: ProjectStatusApi;
  tags?: number[];
}

/**
 * Create a new project.
 * Backend: POST /api/projects/
 * The authenticated user is taken from the session/cookie.
 */
export async function createProject(
  payload: CreateProjectPayload,
): Promise<ApiProject> {
  return post<ApiProject>('projects/', payload);
}

/**
 * Update an existing project.
 * Backend: PUT /api/projects/:id/
 */
export async function updateProject(
  id: number | string,
  payload: Partial<CreateProjectPayload>,
): Promise<ApiProject> {
  return put<ApiProject>(`projects/${id}/`, payload);
}

/**
 * Delete an existing project.
 * Backend: DELETE /api/projects/:id/
 */
export async function deleteProject(id: number | string): Promise<void> {
  await del<void>(`projects/${id}/`);
}

===== END services/projects.ts =====


===== BEGIN services/pulse.ts =====
// frontend/services/pulse.ts
import dayjs from 'dayjs'
import { get } from './_request'
import type { KPI } from '@/types'

export interface KPIWithHistory extends KPI {
  history: { date: string; value: number }[]
}

export interface LiveCounter {
  label: string
  value: number
  trend?: number
  history: { ts: number; value: number }[]
}

export interface TrendChart {
  key: string
  title: string
  type: 'line' | 'area' | 'heatmap'
  config: any
}

export interface HealthSummary {
  refreshedAt: string
  radarConfig: any
  pieConfig: any
}

// ──────────────────────────────────────────────────────────
// Backend DTOs
// ──────────────────────────────────────────────────────────

type TopicStatus = 'open' | 'closed' | 'archived'

interface EthikosTopicApi {
  id: number
  title: string
  status: TopicStatus
  total_votes?: number | null
  created_at: string
  last_activity: string
}

interface EthikosStanceApi {
  id: number
  topic: number
  value: number
  timestamp: string
}

interface EthikosArgumentApi {
  id: number
  topic: number
  user: string
  content: string
  created_at: string
}

interface VoteApi {
  id: number
  user: string
  target_type: string
  target_id: number
  raw_value: string | number
  weighted_value: string | number
  voted_at: string
}

// ──────────────────────────────────────────────────────────
// Helpers
// ──────────────────────────────────────────────────────────

interface DailyPoint {
  date: string
  value: number
}

function buildDailySeries<T>(
  items: T[],
  getDate: (item: T) => string,
  days = 30,
): DailyPoint[] {
  const now = dayjs()
  const start = now.startOf('day').subtract(days - 1, 'day')
  const counts: number[] = new Array<number>(days).fill(0)

  for (const item of items) {
    const d = dayjs(getDate(item))
    if (d.isBefore(start) || d.isAfter(now)) continue
    const offset = d.startOf('day').diff(start, 'day')
    if (offset >= 0 && offset < days) {
      const current = counts[offset] ?? 0
      counts[offset] = current + 1
    }
  }

  const series: DailyPoint[] = []
  for (let i = 0; i < days; i += 1) {
    series.push({
      date: start.add(i, 'day').toISOString(),
      value: counts[i] ?? 0,
    })
  }
  return series
}

function percentDelta(series: DailyPoint[]): number | undefined {
  if (series.length < 2) return undefined

  const latestPoint = series[series.length - 1]
  const previousPoint = series[series.length - 2]
  if (!latestPoint || !previousPoint) return undefined

  const latest = latestPoint.value
  const previous = previousPoint.value
  if (previous === 0) return undefined

  return Math.round(((latest - previous) / previous) * 100)
}

function buildStanceHeatmap(stances: EthikosStanceApi[]) {
  const bucket = new Map<string, number>()
  for (const stance of stances) {
    const d = dayjs(stance.timestamp)
    const key = `${d.format('ddd')}-${d.hour()}`
    bucket.set(key, (bucket.get(key) ?? 0) + 1)
  }
  const result: { day: string; hour: number; value: number }[] = []
  bucket.forEach((value, key) => {
    const [day, hourStr] = key.split('-')
    if (!day || !hourStr) return
    result.push({ day, hour: Number(hourStr), value })
  })
  return result
}

// ──────────────────────────────────────────────────────────
// Overview
// ──────────────────────────────────────────────────────────

export async function fetchPulseOverview(): Promise<{
  refreshedAt: string
  kpis: KPIWithHistory[]
}> {
  const [topics, stances, args, votes] = await Promise.all([
    get<EthikosTopicApi[]>('ethikos/topics/'),
    get<EthikosStanceApi[]>('ethikos/stances/'),
    get<EthikosArgumentApi[]>('ethikos/arguments/'),
    get<VoteApi[]>('kollective/votes/'),
  ])

  const topicsSeries = buildDailySeries(topics, (t) => t.created_at)
  const stancesSeries = buildDailySeries(stances, (s) => s.timestamp)
  const argsSeries = buildDailySeries(args, (a) => a.created_at)
  const votesSeries = buildDailySeries(votes, (v) => v.voted_at)

  const sum = (series: DailyPoint[]) =>
    series.reduce((acc, p) => acc + p.value, 0)

  const kpis: KPIWithHistory[] = [
    {
      key: 'topics',
      label: 'Debates created (30d)',
      value: sum(topicsSeries),
      delta: percentDelta(topicsSeries),
      history: topicsSeries,
    },
    {
      key: 'stances',
      label: 'Stances recorded (30d)',
      value: sum(stancesSeries),
      delta: percentDelta(stancesSeries),
      history: stancesSeries,
    },
    {
      key: 'arguments',
      label: 'Arguments posted (30d)',
      value: sum(argsSeries),
      delta: percentDelta(argsSeries),
      history: argsSeries,
    },
    {
      key: 'votes',
      label: 'Weighted votes (30d)',
      value: sum(votesSeries),
      delta: percentDelta(votesSeries),
      history: votesSeries,
    },
  ]

  return {
    refreshedAt: new Date().toISOString(),
    kpis,
  }
}

// ──────────────────────────────────────────────────────────
// Live view (polled periodically)
// ──────────────────────────────────────────────────────────

export async function fetchPulseLiveData(): Promise<{
  counters: LiveCounter[]
}> {
  const [topics, stances] = await Promise.all([
    get<EthikosTopicApi[]>('ethikos/topics/'),
    get<EthikosStanceApi[]>('ethikos/stances/'),
  ])

  const topicsSeries = buildDailySeries(topics, (t) => t.created_at, 7)
  const stancesSeries = buildDailySeries(stances, (s) => s.timestamp, 7)

  const toHistory = (series: DailyPoint[]) =>
    series.map((p) => ({
      ts: new Date(p.date).getTime(),
      value: p.value,
    }))

  const counters: LiveCounter[] = [
    {
      label: 'Open debates',
      value: topics.filter((t) => t.status === 'open').length,
      trend: percentDelta(topicsSeries),
      history: toHistory(topicsSeries),
    },
    {
      label: 'New stances (7d)',
      value: stancesSeries.reduce((acc, p) => acc + p.value, 0),
      trend: percentDelta(stancesSeries),
      history: toHistory(stancesSeries),
    },
  ]

  return { counters }
}

// ──────────────────────────────────────────────────────────
// Trends
// ──────────────────────────────────────────────────────────

export async function fetchPulseTrends(): Promise<{
  charts: TrendChart[]
}> {
  const [topics, stances, args] = await Promise.all([
    get<EthikosTopicApi[]>('ethikos/topics/'),
    get<EthikosStanceApi[]>('ethikos/stances/'),
    get<EthikosArgumentApi[]>('ethikos/arguments/'),
  ])

  const topicsSeries = buildDailySeries(topics, (t) => t.created_at, 60)
  const stancesSeries = buildDailySeries(stances, (s) => s.timestamp, 60)
  const argsSeries = buildDailySeries(args, (a) => a.created_at, 60)

  const heatmapData = buildStanceHeatmap(stances)

  const charts: TrendChart[] = [
    {
      key: 'topics-timeline',
      title: 'Debates over time',
      type: 'line',
      config: {
        data: topicsSeries,
        xField: 'date',
        yField: 'value',
        smooth: true,
      },
    },
    {
      key: 'stances-timeline',
      title: 'Stances over time',
      type: 'area',
      config: {
        data: stancesSeries,
        xField: 'date',
        yField: 'value',
      },
    },
    {
      key: 'activity-heatmap',
      title: 'Deliberation activity heatmap',
      type: 'heatmap',
      config: {
        data: heatmapData,
        xField: 'hour',
        yField: 'day',
        colorField: 'value',
      },
    },
  ]

  return { charts }
}

// ──────────────────────────────────────────────────────────
// Health (radar + pie)
// ──────────────────────────────────────────────────────────

export async function fetchPulseHealth(): Promise<HealthSummary> {
  const [stances, votes] = await Promise.all([
    get<EthikosStanceApi[]>('ethikos/stances/'),
    get<VoteApi[]>('kollective/votes/'),
  ])

  let positive = 0
  let neutral = 0
  let negative = 0

  for (const s of stances) {
    if (s.value > 0) positive += 1
    else if (s.value < 0) negative += 1
    else neutral += 1
  }

  const participation = Math.min(100, stances.length)
  const engagement = Math.min(100, votes.length)
  const balance =
    stances.length > 0
      ? Math.round(
          (1 - Math.abs(positive - negative) / stances.length) * 100,
        )
      : 100
  const constructiveness = Math.round((participation + balance) / 2)

  const radarData = [
    { metric: 'Participation', score: participation },
    { metric: 'Engagement', score: engagement },
    { metric: 'Balance', score: balance },
    { metric: 'Constructiveness', score: constructiveness },
  ]

  const pieData = [
    { type: 'Positive', value: positive },
    { type: 'Neutral', value: neutral },
    { type: 'Negative', value: negative },
  ]

  return {
    refreshedAt: new Date().toISOString(),
    radarConfig: {
      data: radarData,
      xField: 'metric',
      yField: 'score',
      meta: {
        score: { min: 0, max: 100 },
      },
    },
    pieConfig: {
      data: pieData,
      angleField: 'value',
      colorField: 'type',
    },
  }
}

===== END services/pulse.ts =====


===== BEGIN services/trust.ts =====
// frontend/services/trust.ts
import dayjs from 'dayjs'
import { get } from './_request'

export interface ReputationDimension {
  key: string
  label: string
  score: number
  weight: number
}

export interface ReputationProfile {
  level: 'Visitor' | 'Contributor' | 'Steward'
  score: number
  dimensions: ReputationDimension[]
  recent: { label: string; change: number }[]

  /** Identity info derived from /users/me/ so UIs can show name + avatar */
  username?: string
  displayName?: string
  avatarUrl?: string | null
}

export interface Badge {
  id: string
  label: string
  description: string
  earnedAt: string
}

export interface Credential {
  id: string
  title: string
  issuer: string
  issuedAt: string
  url?: string
}

/**
 * Shape of /users/me/ coming from the backend.
 * avatar_url / picture are optional and can be wired later on the server.
 */
interface UserMeApi {
  username: string
  name: string | null
  email: string
  url: string
  avatar_url?: string | null
  picture?: string | null
}

interface EthikosStanceApi {
  id: number
  user: string
  value: number
  timestamp: string
}

interface EthikosArgumentApi {
  id: number
  user: string
  content: string
  created_at: string
}

interface VoteApi {
  id: number
  user: string
  target_type: string
  target_id: number
  raw_value: string | number
  weighted_value: string | number
  voted_at: string
}

// ──────────────────────────────────────────────────────────
// Helpers
// ──────────────────────────────────────────────────────────

function countLastDays(dates: string[], days: number): number {
  const now = dayjs()
  const cut = now.subtract(days, 'day')
  return dates.filter((d) => dayjs(d).isAfter(cut)).length
}

// ──────────────────────────────────────────────────────────
// Reputation profile (derived from real contributions)
// ──────────────────────────────────────────────────────────

export async function fetchUserProfile(): Promise<ReputationProfile> {
  const [me, stances, args, votes] = await Promise.all([
    get<UserMeApi>('users/me/'),
    get<EthikosStanceApi[]>('ethikos/stances/'),
    get<EthikosArgumentApi[]>('ethikos/arguments/'),
    get<VoteApi[]>('kollective/votes/'),
  ])

  const username = me.username
  const displayName = me.name ?? me.username
  const avatarUrl = me.avatar_url ?? me.picture ?? null

  const myStances = stances.filter((s) => s.user === username)
  const myArguments = args.filter((a) => a.user === username)
  const myVotes = votes.filter((v) => v.user === username)

  const contributionScore =
    myStances.length * 3 + myArguments.length * 2 + myVotes.length * 4
  const score = Math.max(10, Math.min(100, contributionScore))

  let level: ReputationProfile['level']
  if (score >= 75) level = 'Steward'
  else if (score >= 40) level = 'Contributor'
  else level = 'Visitor'

  const stanceDates = myStances.map((s) => s.timestamp)
  const recentStances = countLastDays(stanceDates, 30)
  const previousStances = countLastDays(stanceDates, 60) - recentStances

  const recent: { label: string; change: number }[] = [
    {
      label: 'Stances last 30 days',
      change: recentStances - previousStances,
    },
  ]

  const influenceScore = myVotes.reduce((acc, v) => {
    const w =
      typeof v.weighted_value === 'string'
        ? parseFloat(v.weighted_value)
        : v.weighted_value
    return acc + (Number.isFinite(w) ? Number(w) : 0)
  }, 0)

  const dimensions: ReputationDimension[] = [
    {
      key: 'deliberation',
      label: 'Deliberation quality',
      score: Math.min(100, myArguments.length * 5),
      weight: 0.35,
    },
    {
      key: 'participation',
      label: 'Participation',
      score: Math.min(100, myStances.length * 4),
      weight: 0.35,
    },
    {
      key: 'influence',
      label: 'Influence (weighted votes)',
      score: Math.min(100, influenceScore),
      weight: 0.3,
    },
  ]

  return {
    level,
    score,
    dimensions,
    recent,
    username,
    displayName,
    avatarUrl,
  }
}

// ──────────────────────────────────────────────────────────
// Credentials (no real backend endpoint yet)
// ──────────────────────────────────────────────────────────

/**
 * There is currently no dedicated credential storage API.
 * This helper resolves immediately so the UI flow can be wired.
 * When a backend exists, the upload call should be wired here.
 */
export async function uploadCredential(_file: File): Promise<void> {
  return
}

// ──────────────────────────────────────────────────────────
// Badges derived from real activity
// ──────────────────────────────────────────────────────────

export async function fetchUserBadges(): Promise<Badge[]> {
  const [me, stances, args, votes] = await Promise.all([
    get<UserMeApi>('users/me/'),
    get<EthikosStanceApi[]>('ethikos/stances/'),
    get<EthikosArgumentApi[]>('ethikos/arguments/'),
    get<VoteApi[]>('kollective/votes/'),
  ])

  const username = me.username

  const myStances = stances.filter((s) => s.user === username)
  const myArguments = args.filter((a) => a.user === username)
  const myVotes = votes.filter((v) => v.user === username)

  const badges: Badge[] = []

  if (myStances.length > 0) {
    const first = myStances.reduce((min, s) =>
      dayjs(s.timestamp).isBefore(min.timestamp) ? s : min,
    )
    badges.push({
      id: 'first-stance',
      label: 'First stance',
      description: 'Recorded your first stance in a debate.',
      earnedAt: first.timestamp,
    })
  }

  if (myArguments.length >= 5) {
    const first = myArguments.reduce((min, a) =>
      dayjs(a.created_at).isBefore(min.created_at) ? a : min,
    )
    badges.push({
      id: 'argument-builder',
      label: 'Argument builder',
      description: 'Contributed at least 5 arguments to debates.',
      earnedAt: first.created_at,
    })
  }

  if (myVotes.length >= 10) {
    const first = myVotes.reduce((min, v) =>
      dayjs(v.voted_at).isBefore(min.voted_at) ? v : min,
    )
    badges.push({
      id: 'active-voter',
      label: 'Active voter',
      description: 'Cast at least 10 weighted votes across the platform.',
      earnedAt: first.voted_at,
    })
  }

  return badges
}

===== END services/trust.ts =====


===== BEGIN services/user.ts =====
// frontend/services/user.ts
// Wrapper around /api/users/me/ + helpers for avatar_url

import { get } from './_request'

/**
 * Shape returned by /api/users/me/.
 * Backend will be extended to include avatar_url.
 */
export interface CurrentUser {
  username: string
  name: string | null
  /** Optional, depending on how the backend serializer is configured */
  email?: string | null
  url: string
  /** Absolute or relative URL to the user’s avatar image */
  avatar_url?: string | null
}

/**
 * Default avatar used when no avatar_url is provided by the backend.
 * This must match the file you placed under:
 *   backend/konnaxion/media/kreative/artworks/default_profile.png
 */
export const DEFAULT_AVATAR_URL = '/media/kreative/artworks/default_profile.png'

/**
 * Fetch the authenticated user via /api/users/me/.
 * This uses the global NEXT_PUBLIC_API_BASE from services/_request.
 */
export async function fetchCurrentUser(): Promise<CurrentUser> {
  return get<CurrentUser>('users/me/')
}

/**
 * Helper that always returns a usable avatar URL.
 * If the user has no avatar_url yet, we fall back to DEFAULT_AVATAR_URL.
 */
export function resolveAvatarUrl(
  user: Pick<CurrentUser, 'avatar_url'> | null | undefined,
): string {
  const src = user?.avatar_url
  if (typeof src === 'string' && src.trim().length > 0) {
    return src
  }
  return DEFAULT_AVATAR_URL
}


/*
import { Avatar } from 'antd'
import { useEffect, useState } from 'react'
import { fetchCurrentUser, resolveAvatarUrl, type CurrentUser } from '@/services/user'

export default function HeaderUserAvatar() {
  const [user, setUser] = useState<CurrentUser | null>(null)

  useEffect(() => {
    void (async () => {
      try {
        const me = await fetchCurrentUser()
        setUser(me)
      } catch {
        setUser(null)
      }
    })()
  }, [])

  const src = resolveAvatarUrl(user)

  return <Avatar size={40} src={src} />
}
*/
===== END services/user.ts =====

