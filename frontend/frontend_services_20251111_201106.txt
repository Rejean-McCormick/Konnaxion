===== TOC (11 fichiers) =====
1. C:\MyCode\Konnaxionv14\frontend\services\_request.ts
2. C:\MyCode\Konnaxionv14\frontend\services\admin.ts
3. C:\MyCode\Konnaxionv14\frontend\services\audit.ts
4. C:\MyCode\Konnaxionv14\frontend\services\decide.mock.ts
5. C:\MyCode\Konnaxionv14\frontend\services\decide.ts
6. C:\MyCode\Konnaxionv14\frontend\services\deliberate.ts
7. C:\MyCode\Konnaxionv14\frontend\services\impact.ts
8. C:\MyCode\Konnaxionv14\frontend\services\index.ts
9. C:\MyCode\Konnaxionv14\frontend\services\learn.ts
10. C:\MyCode\Konnaxionv14\frontend\services\pulse.ts
11. C:\MyCode\Konnaxionv14\frontend\services\trust.ts
===== END TOC =====


===== BEGIN services/_request.ts =====
'use client'

import axios, {
  AxiosInstance,
  AxiosRequestConfig,
  InternalAxiosRequestConfig,
} from 'axios'

/**
 * One axios instance.
 * Do NOT unwrap in interceptors; wrappers below return `data` as T.
 */
const client: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE ?? '/api',
  withCredentials: true,
  xsrfCookieName: 'csrftoken',
  xsrfHeaderName: 'X-CSRFToken',
  timeout: 15000,
})

client.interceptors.request.use((cfg: InternalAxiosRequestConfig) => {
  // Example:
  // const t = typeof window !== 'undefined' ? localStorage.getItem('token') : null
  // if (t) cfg.headers.Authorization = `Bearer ${t}`
  return cfg
})

client.interceptors.response.use(
  (res) => res,
  (err) => Promise.reject(err),
)

type Cfg<D = any> = AxiosRequestConfig<D>

/** Typed helpers: always return raw data `T` */
export async function get<T, D = any>(url: string, config?: Cfg<D>): Promise<T> {
  const res = await client.get<T>(url, config)
  return res.data as T
}

export async function post<T, D = any>(
  url: string,
  body?: D,
  config?: Cfg<D>,
): Promise<T> {
  const res = await client.post<T>(url, body, config)
  return res.data as T
}

export async function put<T, D = any>(
  url: string,
  body?: D,
  config?: Cfg<D>,
): Promise<T> {
  const res = await client.put<T>(url, body, config)
  return res.data as T
}

export async function patch<T, D = any>(
  url: string,
  body?: D,
  config?: Cfg<D>,
): Promise<T> {
  const res = await client.patch<T>(url, body, config)
  return res.data as T
}

export async function del<T, D = any>(url: string, config?: Cfg<D>): Promise<T> {
  const res = await client.delete<T>(url, config)
  return res.data as T
}

/**
 * Default export: axios instance augmented with data-returning methods.
 * Allows `api.post<T>(...)` to yield `T` (not AxiosResponse<T>).
 */
type DataMethods = {
  get<T, D = any>(url: string, config?: Cfg<D>): Promise<T>
  post<T, D = any>(url: string, body?: D, config?: Cfg<D>): Promise<T>
  put<T, D = any>(url: string, body?: D, config?: Cfg<D>): Promise<T>
  patch<T, D = any>(url: string, body?: D, config?: Cfg<D>): Promise<T>
  delete<T, D = any>(url: string, config?: Cfg<D>): Promise<T>
  del<T, D = any>(url: string, config?: Cfg<D>): Promise<T>
}

type API = Omit<AxiosInstance, 'get' | 'post' | 'put' | 'patch' | 'delete'> & DataMethods

const api = Object.assign(client, {
  async get<T, D = any>(url: string, config?: Cfg<D>) {
    const res = await client.get<T>(url, config)
    return res.data as T
  },
  async post<T, D = any>(url: string, body?: D, config?: Cfg<D>) {
    const res = await client.post<T>(url, body, config)
    return res.data as T
  },
  async put<T, D = any>(url: string, body?: D, config?: Cfg<D>) {
    const res = await client.put<T>(url, body, config)
    return res.data as T
  },
  async patch<T, D = any>(url: string, body?: D, config?: Cfg<D>) {
    const res = await client.patch<T>(url, body, config)
    return res.data as T
  },
  async delete<T, D = any>(url: string, config?: Cfg<D>) {
    const res = await client.delete<T>(url, config)
    return res.data as T
  },
  async del<T, D = any>(url: string, config?: Cfg<D>) {
    const res = await client.delete<T>(url, config)
    return res.data as T
  },
}) as API

export default api

===== END services/_request.ts =====


===== BEGIN services/admin.ts =====
// services/admin.ts
import { get, post, patch } from './_request'

// ----- Shared Admin types -----
export type RoleRow = { id: string; name: string; userCount: number; enabled: boolean }
export type RolePayload = { items: RoleRow[] }

export type Report = {
  id: string
  content: string
  reporter: string
  type: 'Spam' | 'Harassment' | 'Misinformation'
  status: 'Pending' | 'Resolved'
}
export type ModerationPayload = { items: Report[] }

// Narrow log shape used by admin pages
export type LogRow = {
  id: string
  actor: string
  action: string
  target: string
  severity: 'info' | 'warn' | 'critical'
  ts: string
}
export type AuditPayload = { items: LogRow[] }

// ----- API calls with explicit return types -----
export async function fetchModerationQueue(): Promise<ModerationPayload> {
  return get<ModerationPayload>('admin/moderation')
}

export async function actOnReport(id: string, remove: boolean): Promise<void> {
  return post<void>(`admin/moderation/${id}`, { remove })
}

export async function fetchRoles(): Promise<RolePayload> {
  return get<RolePayload>('admin/roles')
}

export async function toggleRole(id: string, enabled: boolean): Promise<void> {
  return patch<void>(`admin/roles/${id}`, { enabled })
}

export async function fetchAuditLogs(): Promise<AuditPayload> {
  return get<AuditPayload>('admin/audit')
}

===== END services/admin.ts =====


===== BEGIN services/audit.ts =====
import { get, post, put, patch, del } from './_request'

export interface LogRow {
  id: string
  ts: string                  // ISO timestamp
  actor: string               // utilisateur / service
  action: string              // ex: "UPDATE_TOPIC"
  entity?: string             // ex: "topic"
  entityId?: string
  ip?: string
  status?: 'ok' | 'warn' | 'error'
  meta?: Record<string, any>  // détails JSON
}

export interface AuditPayload {
  items: LogRow[]
  page: number
  pageSize: number
  total: number
}

/** GET /admin/audit/logs */
export async function fetchAuditLogs(params?: {
  page?: number
  pageSize?: number
  q?: string
  sort?: string
}): Promise<AuditPayload> {
  return get('admin/audit/logs', { params })
}

===== END services/audit.ts =====


===== BEGIN services/decide.mock.ts =====
// src/services/decide.mock.ts
import dayjs from 'dayjs';

export type VotingFormat = 'binary' | 'multiple' | 'scale';

export interface PublicTopic {
  id: string;
  categoryId: string;
  question: string;
  format: VotingFormat;
  /** For binary/multiple; ignored for scale */
  options?: string[];
  /** Optional labels for scale (e.g. ['None', 'A little', …]) */
  scaleLabels?: string[];
  turnout: number;      // %
  closesAt: string;     // ISO date-time
}

export interface Category {
  id: string;
  name: string;
}

/* ------------------------------------------------------------------ */
/*  Simulated network helpers                                         */
/* ------------------------------------------------------------------ */

const sleep = (ms = 350) => new Promise(r => setTimeout(r, ms));

/** Pretend “database” — extends easily */
const CATEGORIES: Category[] = [
  { id: 'gov',  name: 'Governance & Democracy' },
  { id: 'econ', name: 'Economy & Taxation' },
  { id: 'env',  name: 'Environment & Climate' },
];

const TOPICS: PublicTopic[] = [
  {
    id: 't1',
    categoryId: 'gov',
    question: 'Should Canada replace its first-past-the-post system with proportional representation?',
    format: 'binary',
    options: ['Yes', 'No'],
    turnout: 43,
    closesAt: dayjs().add(5, 'day').toISOString(),
  },
  {
    id: 't2',
    categoryId: 'econ',
    question: 'At what level should the national minimum wage be set?',
    format: 'multiple',
    options: ['<$18', '$18', '$20', '$22', 'No federal minimum'],
    turnout: 37,
    closesAt: dayjs().add(10, 'day').toISOString(),
  },
  {
    id: 't3',
    categoryId: 'env',
    question: 'How much should Canada raise the carbon tax beyond the current 2030 schedule?',
    format: 'scale',
    scaleLabels: ['None', 'A little', 'Average', 'Much', 'Very much'],
    turnout: 51,
    closesAt: dayjs().add(7, 'day').toISOString(),
  },
];

/* ------------------------------------------------------------------ */
/*  Public API                                                         */
/* ------------------------------------------------------------------ */

/** Fetch all public-ballot topics grouped by category */
export async function fetchPublicTopics(): Promise<{
  categories: Category[];
  topics: PublicTopic[];
}> {
  await sleep();               // simulate latency
  return { categories: CATEGORIES, topics: TOPICS };
}

/** Simulate persisting a vote */
export async function submitPublicVote(topicId: string, value: string | number) {
  console.info('vote saved', { topicId, value });
  await sleep(600);
  // In real life: POST /vote {topicId, value}
}


===== END services/decide.mock.ts =====


===== BEGIN services/decide.ts =====
import { get, post, put, patch, del } from './_request'
import type { Ballot } from '@/types'

/** GET /decide/elite/ballots */
export async function fetchEliteBallots(): Promise<{
  ballots: (Ballot & { turnout: number })[]
}> {
  return get('decide/elite/ballots')
}

/** GET /decide/public/ballots */
export async function fetchPublicBallots(): Promise<{
  ballots: (Ballot & { options: string[]; turnout: number })[]
}> {
  return get('decide/public/ballots')
}

/** POST /decide/public/ballots/:id/vote */
export async function submitPublicVote(
  id: string,
  option: string,
): Promise<{ ok: true }> {
  return post(`decide/public/ballots/${id}/vote`, { option })
}

/** GET /decide/results */
export async function fetchDecisionResults(): Promise<{
  items: {
    id: string
    title: string
    scope: 'Elite' | 'Public'
    passed: boolean
    closesAt: string
    region: string
  }[]
}> {
  return get('decide/results')
}

===== END services/decide.ts =====


===== BEGIN services/deliberate.ts =====
import { get, post, put, patch, del } from './_request'
import type { Topic } from '@/types'

/** GET /deliberate/elite/topics */
export async function fetchEliteTopics(): Promise<{
  list: (Topic & {
    createdAt: string
    lastActivity: string
    hot: boolean
  })[]
}> {
  return get('deliberate/elite/topics')
}

/** GET /deliberate/topics/:id/preview */
export async function fetchTopicPreview(id: string): Promise<{
  id: string
  title: string
  category: string
  createdAt: string
  latest: { id: string; author: string; body: string }[]
}> {
  return get(`deliberate/topics/${id}/preview`)
}

/** POST /deliberate/elite/topics */
export async function createEliteTopic(payload: {
  title: string
  category: string
}): Promise<{ id: string }> {
  return post('deliberate/elite/topics', payload)
}

/** GET /deliberate/topics/:id */
export async function fetchTopicDetail(id: string): Promise<{
  id: string
  title: string
  statements: { id: string; author: string; body: string; createdAt: string }[]
}> {
  return get(`deliberate/topics/${id}`)
}

===== END services/deliberate.ts =====


===== BEGIN services/impact.ts =====
// services/impact.ts
import { get, post, put, patch, del } from './_request';

/* ------------------------------------------------------------------ *
 *  Tracker (Kanban / table)                                           *
 * ------------------------------------------------------------------ */

export type ImpactStatus = 'Planned' | 'In-Progress' | 'Completed' | 'Blocked';

export interface TrackerItem {
  id: string;
  title: string;
  owner: string;
  status: ImpactStatus;
  updatedAt: string;                    // ISO-8601 timestamp
}

/** GET /impact/tracker */
export async function fetchImpactTracker(): Promise<{
  items: TrackerItem[];
}> {
  return get('impact/tracker');
}

/** PATCH /impact/tracker/:id  (update status only) */
export async function patchImpactStatus(
  id: string,
  status: ImpactStatus,
): Promise<void> {
  await patch(`impact/tracker/${id}`, { status });
}

/* ------------------------------------------------------------------ *
 *  Outcomes dashboard                                                 *
 * ------------------------------------------------------------------ */

export interface OutcomeKPI {
  label: string;
  value: number;
  delta?: number;                       // % change vs previous period
}

export interface OutcomeChart {
  title: string;
  type: 'line' | 'bar';
  config: Record<string, any>;          // Ant Design Plots config
}

/** GET /impact/outcomes */
export async function fetchImpactOutcomes(): Promise<{
  kpis: OutcomeKPI[];
  charts: OutcomeChart[];
}> {
  return get('impact/outcomes');
}

/* ------------------------------------------------------------------ *
 *  Feedback loops                                                     *
 * ------------------------------------------------------------------ */

export interface FeedbackItem {
  id: string;
  author: string;
  body: string;
  rating?: number;                      // 1-5 stars, optional
  createdAt: string;                    // ISO-8601 timestamp
}

/** GET /impact/feedback */
export async function fetchFeedback(): Promise<{
  items: FeedbackItem[];
}> {
  return get('impact/feedback');
}

/** POST /impact/feedback */
export async function submitFeedback(payload: {
  body: string;
  rating?: number;
}): Promise<void> {
  await post('impact/feedback', payload);
}

===== END services/impact.ts =====


===== BEGIN services/index.ts =====
// services/index.ts
export * from './audit'
export * from './decide'
export * from './deliberate'
export * from './pulse'

===== END services/index.ts =====


===== BEGIN services/learn.ts =====
// services/learn.ts
import { get, post, put, patch, del } from './_request';

/* ---------- Changelog ---------- */

export interface ChangelogEntry {
  version: string;
  date: string;                      // ISO-8601 string (e.g. "2025-04-25")
  tags: ('NEW' | 'FIX' | 'IMPROVE')[];
  notes: string[];
}

export async function fetchChangelog(): Promise<{
  entries: ChangelogEntry[];
}> {
  return get('learn/changelog');
}

/* ---------- Guides ---------- */

export interface GuideSection {
  id: string;
  title: string;
  content: string;                  // Markdown / HTML-ready text
}

export async function fetchGuides(): Promise<{
  sections: GuideSection[];
}> {
  return get('learn/guides');
}

/* ---------- Glossary ---------- */

export interface GlossaryItem {
  id: string;
  term: string;
  definition: string;
}

export async function fetchGlossary(): Promise<{
  items: GlossaryItem[];
}> {
  return get('learn/glossary');
}

===== END services/learn.ts =====


===== BEGIN services/pulse.ts =====
import { get, post, put, patch, del } from './_request'
import type { KPI } from '@/types'

export interface KPIWithHistory extends KPI {
  history: { date: string; value: number }[]
}

/** GET /pulse/overview */
export async function fetchPulseOverview(): Promise<{
  refreshedAt: string
  kpis: KPIWithHistory[]
}> {
  return get('pulse/overview')
}

export interface LiveCounter {
  label: string
  value: number
  trend: number
  history: { ts: number; value: number }[]
}

/** GET /pulse/live */
export async function fetchPulseLiveData(): Promise<{
  counters: LiveCounter[]
}> {
  return get('pulse/live')
}

export type TrendChartType = 'line' | 'area' | 'heatmap'

export interface TrendChart {
  title: string
  type: TrendChartType
  config: Record<string, any>
}

/** GET /pulse/trends */
export async function fetchPulseTrends(): Promise<{
  charts: TrendChart[]
}> {
  return get('pulse/trends')
}

export interface HealthResponse {
  radarConfig: Record<string, any>
  pieConfig: Record<string, any>
}

/** GET /pulse/health */
export async function fetchPulseHealth(): Promise<HealthResponse> {
  return get('pulse/health')
}

===== END services/pulse.ts =====


===== BEGIN services/trust.ts =====
// services/trust.ts
import { get, post, put, patch, del } from './_request'

export interface ActivityItem {
  id: string
  when: string
  text: string
}

export interface UserProfile {
  avatar: string | null
  name: string
  joined: string
  score: number
  activity: ActivityItem[]
}

export interface EarnedBadge {
  id: string
  name: string
  desc?: string
}

export interface BadgeProgress {
  id: string
  name: string
  current: number
  required: number
}

export interface UserBadges {
  earned: EarnedBadge[]
  progress: BadgeProgress[]
}

export async function fetchUserProfile(): Promise<UserProfile> {
  return get<UserProfile>('trust/profile')
}

export async function uploadCredential(file: File): Promise<void> {
  const form = new FormData()
  form.append('file', file)
  await post<void>('trust/credentials', form)
}

export async function fetchUserBadges(): Promise<UserBadges> {
  return get<UserBadges>('trust/badges')
}

===== END services/trust.ts =====

