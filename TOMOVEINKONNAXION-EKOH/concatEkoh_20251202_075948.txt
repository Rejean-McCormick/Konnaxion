

===== BEGIN ConcatEkoh.py =====

#!/usr/bin/env python
"""
Concatenate relevant Ekoh code into a single timestamped text file.

Output file name example:
    concatEkoh_20251202_143015.txt
created at the project root.
"""

from pathlib import Path
from datetime import datetime
import os

# Root of the project
ROOT = Path(r"C:\MyCode\Konnaxionv14\TOMOVEINKONNAXION-EKOH")

# Directories to skip completely (by name, anywhere in the tree)
EXCLUDE_DIR_NAMES = {
    ".git",
    ".github",
    "__pycache__",
    ".idea",
    ".vscode",
    "docs",
    "infra",
    "charts",
    "fixtures",
    "migrations",
    "tests",
}

# Files to skip (by file name, anywhere)
EXCLUDE_FILE_NAMES = {
    ".pre-commit-config.yaml",
    "docker-compose.dev.yml",
    "Dockerfile.dev",
    "Makefile",
    "paths.txt",
    "pyproject.toml",
    "README.md",
    "ruff.toml",
    "ToDo (instructions).txt",
}

# Common binary / non-text file extensions to avoid
BINARY_EXTS = {
    ".pyc", ".pyo", ".pyd",
    ".exe", ".dll", ".so",
    ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".ico",
    ".pdf", ".zip", ".tar", ".gz", ".7z",
}


def is_binary_path(path: Path) -> bool:
    return path.suffix.lower() in BINARY_EXTS


def main() -> None:
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    out_file = ROOT / f"concatEkoh_{timestamp}.txt"

    with out_file.open("w", encoding="utf-8") as out:
        for dirpath, dirnames, filenames in os.walk(ROOT):
            dirpath = Path(dirpath)

            # Prune excluded directories in-place so os.walk won't descend into them
            dirnames[:] = [
                d for d in dirnames
                if d not in EXCLUDE_DIR_NAMES
            ]

            for fname in filenames:
                if fname in EXCLUDE_FILE_NAMES:
                    continue

                file_path = dirpath / fname

                # Skip the output file itself if script is re-run
                if file_path == out_file:
                    continue

                if is_binary_path(file_path):
                    continue

                try:
                    text = file_path.read_text(encoding="utf-8", errors="ignore")
                except Exception:
                    # If anything goes wrong reading the file, skip it
                    continue

                rel = file_path.relative_to(ROOT).as_posix()

                out.write(f"\n\n===== BEGIN {rel} =====\n\n")
                out.write(text)
                out.write(f"\n\n===== END {rel} =====\n")


if __name__ == "__main__":
    main()


===== END ConcatEkoh.py =====


===== BEGIN config/celery.py =====

import os
from celery import Celery

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")

app = Celery("konnaxion-ekoh-smartvote")

# Load Celery config from Django settings, using the `CELERY_` prefix.
app.config_from_object("django.conf:settings", namespace="CELERY")

# Auto-discover tasks in all installed Django apps.
app.autodiscover_tasks()

@app.task(bind=True)
def debug_task(self):
    print(f"Celery debug: {self.request!r}")


===== END config/celery.py =====


===== BEGIN config/settings_addons.py =====

import os
from datetime import timedelta
from pathlib import Path

# ── Secret key fallback (local only) ────────────────────────────────
SECRET_KEY = os.getenv("DJANGO_SECRET_KEY", "dev-secret-change-me")

# ── Register EkoH & Smart-Vote apps ────────────────────────────────
INSTALLED_APPS += ["konnaxion.ekoh", "konnaxion.smart_vote"]

# ── Shared-schema search_path ──────────────────────────────────────
DATABASES["default"].setdefault("OPTIONS", {})
DATABASES["default"]["OPTIONS"]["options"] = "-c search_path=ekoh_smartvote,public"

# ── Celery settings ────────────────────────────────────────────────
CELERY_BROKER_URL = os.getenv("CELERY_BROKER_URL", "redis://localhost:6379/0")
CELERY_RESULT_BACKEND = CELERY_BROKER_URL
CELERY_TIMEZONE = "UTC"

from celery.schedules import crontab  # noqa: E402

CELERY_BEAT_SCHEDULE = {
    "ekoh-score-recalc": {
        "task": "ekoh_score_recalc",
        "schedule": crontab(hour=2, minute=0),  # nightly
    },
    "vote-aggregate": {
        "task": "vote_aggregate",
        "schedule": timedelta(seconds=60),
    },
}

# ── Kafka bootstrap (optional) ─────────────────────────────────────
KAFKA_BOOTSTRAP_SERVERS = os.getenv("KAFKA_BOOTSTRAP_SERVERS", "localhost:9092")

# ── Fixture directory for load_isced command ───────────────────────
FIXTURE_DIRS = [
    Path(__file__).resolve().parent.parent
    / "modules"
    / "ekoh-smartvote"
    / "ekoh"
    / "fixtures"
]


===== END config/settings_addons.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/-models.py =====



===== END modules/ekoh-smartvote/ekoh/-models.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/admin.py =====

from django.contrib import admin

from konnaxion.ekoh.models.taxonomy import ExpertiseCategory
from konnaxion.ekoh.models.scores import UserExpertiseScore, UserEthicsScore
from konnaxion.ekoh.models.audit import ContextAnalysisLog, ScoreHistory
from konnaxion.ekoh.models.config import ScoreConfiguration
from konnaxion.ekoh.models.privacy import ConfidentialitySetting


@admin.register(ExpertiseCategory)
class CategoryAdmin(admin.ModelAdmin):
    list_display = ("code", "name", "depth", "parent")
    list_filter = ("depth",)
    search_fields = ("code", "name")


@admin.register(UserExpertiseScore)
class ExpertiseScoreAdmin(admin.ModelAdmin):
    list_display = ("user", "category", "weighted_score")
    list_filter = ("category",)
    search_fields = ("user__username", "category__code")


@admin.register(UserEthicsScore)
class EthicsAdmin(admin.ModelAdmin):
    list_display = ("user", "ethical_score")


@admin.register(ConfidentialitySetting)
class PrivacyAdmin(admin.ModelAdmin):
    list_display = ("user", "level")
    list_filter = ("level",)


@admin.register(ContextAnalysisLog)
class AnalysisLogAdmin(admin.ModelAdmin):
    list_display = ("entity_type", "entity_id", "created_at")
    readonly_fields = ("input_metadata", "adjustments_applied")
    list_filter = ("entity_type", "created_at")


@admin.register(ScoreConfiguration)
class ConfigAdmin(admin.ModelAdmin):
    list_display = ("weight_name", "field", "weight_value")
    list_filter = ("field",)
    search_fields = ("weight_name",)


===== END modules/ekoh-smartvote/ekoh/admin.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/admin_partition.py =====

"""
Admin interface to inspect month-based partitions in ekoh_smartvote schema.
"""

from django.contrib import admin
from django.db import connection


class PartitionInfo:
    """Dummy object representing one partition table."""
    def __init__(self, name):
        self.table_name = name


@admin.register(PartitionInfo)
class PartitionInfoAdmin(admin.ModelAdmin):
    list_display = ("table_name",)

    def get_queryset(self, request):
        with connection.cursor() as cur:
            cur.execute("""
                SELECT tablename FROM pg_tables
                WHERE schemaname = 'ekoh_smartvote'
                  AND tablename ~ '^(vote_|vote_ledger_|score_history_)';
            """)
            names = [row[0] for row in cur.fetchall()]
        return [PartitionInfo(name) for name in names]


===== END modules/ekoh-smartvote/ekoh/admin_partition.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/apps.py =====

"""
Ekoh Django-app configuration.

• Sets the default `search_path` so all raw SQL and migrations operate
  inside the `ekoh_smartvote` schema first, then fall back to `public`.
• Declares the app label `konnaxion.ekoh` so cross-module imports remain
  stable even if the module is moved to its own repo later.
"""

import logging
from django.apps import AppConfig
from django.db import connection

LOGGER = logging.getLogger(__name__)

EKOH_SCHEMA = "ekoh_smartvote"


class EkohConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "konnaxion.ekoh"
    verbose_name = "EkoH – Expertise & Ethics"

    def ready(self) -> None:  # noqa: D401  (simple present)
        """
        Ensure the custom schema exists and set the session search_path.

        Called once per Django process start-up.
        """
        with connection.cursor() as cur:
            # 1) Create the schema if it doesn't exist.
            cur.execute(
                f"CREATE SCHEMA IF NOT EXISTS {EKOH_SCHEMA};"
            )
            # 2) Apply search_path for the current connection.
            cur.execute(
                f"SET search_path TO {EKOH_SCHEMA}, public;"
            )
            LOGGER.debug("search_path set to %s,public", EKOH_SCHEMA)


===== END modules/ekoh-smartvote/ekoh/apps.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/urls.py =====

"""
URL router for the Ekoh app.
Import this in the project-level urls:

    path("api/v1/ekoh/", include("konnaxion.ekoh.urls"))
"""

from django.urls import path

from konnaxion.ekoh.views.profile import ProfileView

app_name = "ekoh"

urlpatterns = [
    path("profile/<int:uid>/", ProfileView.as_view(), name="profile"),
]


===== END modules/ekoh-smartvote/ekoh/urls.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/__init__.py =====



===== END modules/ekoh-smartvote/ekoh/__init__.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/management/commands/load_isced.py =====

"""
Django management command to load the ISCED-F taxonomy fixture
into the expertise_category table.
"""

import json
from pathlib import Path

from django.core.management.base import BaseCommand
from django.db import transaction

from konnaxion.ekoh.models.taxonomy import ExpertiseCategory


class Command(BaseCommand):
    help = "Load UNESCO ISCED-F 2013 taxonomy from fixtures/isced_f_2013.json"

    def handle(self, *args, **options):
        fixture_path = Path(__file__).resolve().parents[2] / "fixtures" / "isced_f_2013.json"
        if not fixture_path.exists():
            self.stderr.write(self.style.ERROR(f"Fixture not found: {fixture_path}"))
            return

        data = json.loads(fixture_path.read_text(encoding="utf-8"))

        self.stdout.write(f"Loading {len(data)} categories from {fixture_path}…")
        with transaction.atomic():
            # Clear existing table (idempotent)
            ExpertiseCategory.objects.all().delete()

            # Create in two passes: parents first, then children
            # Assuming fixture entries include 'parent_code'
            code_to_obj = {}
            # Pass 1: create root and broad domains (parent_code == None)
            for entry in data:
                if entry.get("parent_code") in (None, "", "null"):
                    obj = ExpertiseCategory.objects.create(
                        code=entry["code"],
                        name=entry["name"],
                        depth=entry.get("depth", 0),
                        path=entry["code"],
                    )
                    code_to_obj[entry["code"]] = obj

            # Pass 2: create children
            to_process = [e for e in data if e.get("parent_code")]
            while to_process:
                entry = to_process.pop(0)
                parent = code_to_obj.get(entry["parent_code"])
                if not parent:
                    # parent not yet created—requeue
                    to_process.append(entry)
                    continue
                path = f"{parent.path}.{entry['code']}"
                obj = ExpertiseCategory.objects.create(
                    code=entry["code"],
                    name=entry["name"],
                    parent=parent,
                    depth=entry.get("depth", parent.depth + 1),
                    path=path,
                )
                code_to_obj[entry["code"]] = obj

        self.stdout.write(self.style.SUCCESS("ISCED-F taxonomy loaded successfully."))


===== END modules/ekoh-smartvote/ekoh/management/commands/load_isced.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/models/audit.py =====

"""Context-analysis log & score history."""

from django.db import models

from .scores import UserExpertiseScore


class ContextAnalysisLog(models.Model):
    entity_type = models.CharField(max_length=64)
    entity_id = models.UUIDField()
    field = models.CharField(max_length=64, blank=True)
    input_metadata = models.JSONField(null=True, blank=True)
    adjustments_applied = models.JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "context_analysis_log"
        indexes = [models.Index(fields=["entity_type", "entity_id"])]


class ScoreHistory(models.Model):
    merit_score = models.ForeignKey(UserExpertiseScore, on_delete=models.CASCADE)
    old_value = models.DecimalField(max_digits=12, decimal_places=4)
    new_value = models.DecimalField(max_digits=12, decimal_places=4)
    change_reason = models.TextField(blank=True)
    changed_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "score_history"
        indexes = [models.Index(fields=["changed_at"])]


===== END modules/ekoh-smartvote/ekoh/models/audit.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/models/config.py =====

"""Runtime-tunable coefficients."""

from django.db import models


class ScoreConfiguration(models.Model):
    weight_name = models.CharField(max_length=64)
    weight_value = models.DecimalField(max_digits=6, decimal_places=3)
    field = models.CharField(max_length=64, blank=True)

    class Meta:
        db_table = "score_configuration"
        unique_together = ("weight_name", "field")

    def __str__(self) -> str:  # pragma: no cover
        return f"{self.weight_name}={self.weight_value}"


===== END modules/ekoh-smartvote/ekoh/models/config.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/models/privacy.py =====

"""User privacy / anonymity settings."""

from django.db import models
from django.conf import settings


class ConfidentialitySetting(models.Model):
    PUBLIC = "public"
    PSEUDONYM = "pseudonym"
    ANONYMOUS = "anonymous"

    LEVEL_CHOICES = [
        (PUBLIC, "Public"),
        (PSEUDONYM, "Pseudonym"),
        (ANONYMOUS, "Anonymous"),
    ]

    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE, primary_key=True
    )
    level = models.CharField(
        max_length=16,
        choices=LEVEL_CHOICES,
        default=PUBLIC,
    )

    class Meta:
        db_table = "confidentiality_setting"


===== END modules/ekoh-smartvote/ekoh/models/privacy.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/models/scores.py =====

"""Per-user merit and ethics scores."""

from django.db import models
from django.conf import settings

from .taxonomy import ExpertiseCategory


class UserExpertiseScore(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    category = models.ForeignKey(ExpertiseCategory, on_delete=models.CASCADE)
    raw_score = models.DecimalField(max_digits=12, decimal_places=4)
    weighted_score = models.DecimalField(max_digits=12, decimal_places=4)

    class Meta:
        db_table = "user_expertise_score"
        unique_together = ("user", "category")
        indexes = [
            models.Index(
                fields=["category", "-weighted_score"],
                name="idx_score_top",
                condition=models.Q(weighted_score__gt=0),
            ),
        ]


class UserEthicsScore(models.Model):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, primary_key=True, on_delete=models.CASCADE
    )
    ethical_score = models.DecimalField(max_digits=5, decimal_places=3)

    class Meta:
        db_table = "user_ethics_score"


===== END modules/ekoh-smartvote/ekoh/models/scores.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/models/taxonomy.py =====

"""Expertise hierarchy (UNESCO ISCED-F)."""

from django.db import models
from django.contrib.postgres.fields import LTreeField


class ExpertiseCategory(models.Model):
    """
    Hierarchical expertise domain.

    * `code` – the official ISCED-F code (e.g. "0511").
    * `path` – Postgres ltree (“01.04.11”) for fast descendant queries.
    """

    code = models.CharField(max_length=16, unique=True)
    name = models.CharField(max_length=128)
    parent = models.ForeignKey(
        "self",
        null=True,
        blank=True,
        on_delete=models.CASCADE,
        related_name="children",
    )
    depth = models.SmallIntegerField()
    path = LTreeField()

    class Meta:
        db_table = "expertise_category"
        indexes = [
            models.Index(fields=["depth", "code"], name="idx_cat_depth"),
            models.Index(fields=["path"], name="idx_cat_path", opclasses=["gist"]),
        ]

    def __str__(self) -> str:  # pragma: no cover
        return f"{self.code} • {self.name}"


===== END modules/ekoh-smartvote/ekoh/models/taxonomy.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/models/__init__.py =====

"""Expose public models for import convenience."""
from .taxonomy import ExpertiseCategory  # noqa: F401
from .scores import UserExpertiseScore, UserEthicsScore  # noqa: F401
from .config import ScoreConfiguration  # noqa: F401
from .privacy import ConfidentialitySetting  # noqa: F401
from .audit import ContextAnalysisLog, ScoreHistory  # noqa: F401


===== END modules/ekoh-smartvote/ekoh/models/__init__.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/serializers/profile.py =====

"""
Read-only profile serializer surfaced at GET /ekoh/profile/:uid
Combines:
  • basic user display name
  • confidentiality level
  • per-domain weighted expertise scores
  • global ethics multiplier
"""

from typing import Any

from django.contrib.auth import get_user_model
from rest_framework import serializers

from konnaxion.ekoh.models.scores import (
    UserExpertiseScore,
    UserEthicsScore,
)
from konnaxion.ekoh.models.privacy import ConfidentialitySetting

User = get_user_model()


class ExpertiseScoreNested(serializers.Serializer):
    domain_code = serializers.CharField()
    domain_name = serializers.CharField()
    weighted_score = serializers.DecimalField(max_digits=12, decimal_places=4)


class ProfileSerializer(serializers.Serializer):
    # top-level fields
    user_id = serializers.IntegerField(source="pk")
    display_name = serializers.CharField(source="get_full_name")
    confidentiality_level = serializers.SerializerMethodField()
    ethics_score = serializers.DecimalField(
        max_digits=5, decimal_places=3, source="ethics.ethical_score"
    )

    expertise = serializers.SerializerMethodField()

    # ------------------------------------------------------------------ #
    #  helper methods                                                    #
    # ------------------------------------------------------------------ #
    def get_confidentiality_level(self, user: User) -> str:
        setting = getattr(user, "confidentialitysetting", None)
        return setting.level if setting else ConfidentialitySetting.PUBLIC

    def get_expertise(self, user: User) -> list[dict[str, Any]]:
        qs = (
            UserExpertiseScore.objects.select_related("category")
            .filter(user_id=user.pk)
            .order_by("-weighted_score")[:20]  # top 20 for brevity
        )
        return [
            {
                "domain_code": row.category.code,
                "domain_name": row.category.name,
                "weighted_score": row.weighted_score,
            }
            for row in qs
        ]

    # ------------------------------------------------------------------ #
    #  override to optimise query count                                  #
    # ------------------------------------------------------------------ #
    @classmethod
    def setup_eager_loading(cls, queryset):
        """Fetch confidentiality & ethics in one go."""
        return queryset.select_related("confidentialitysetting", "ethics")


===== END modules/ekoh-smartvote/ekoh/serializers/profile.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/serializers/__init__.py =====

Commande ECHO dsactive.


===== END modules/ekoh-smartvote/ekoh/serializers/__init__.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/services/contextual_analysis.py =====

"""
Contextual-analysis stub.

Called by Celery task `contextual_analysis_batch` (future work)
to scan new publications, answers, or comments and adjust the
user’s domain scores.

For now it simply records a log entry so we can test the end-to-end flow.
"""

from __future__ import annotations

import logging
import uuid
from typing import Mapping, Any

from django.db import transaction

from konnaxion.ekoh.models.audit import ContextAnalysisLog
from konnaxion.ekoh.models.scores import UserExpertiseScore

LOGGER = logging.getLogger(__name__)


def analyse_entity(
    *,
    user_id: int,
    entity_type: str,
    entity_id: uuid.UUID,
    domain_code: str,
    input_metadata: Mapping[str, Any] | None = None,
) -> None:
    """
    Fake analysis:

    • +0.5 raw_score boost on the matching domain
    • Writes ContextAnalysisLog for explainability
    """
    with transaction.atomic():
        # upgrade or create a minimal score row
        score, _ = UserExpertiseScore.objects.get_or_create(
            user_id=user_id,
            category__code=domain_code,
            defaults={"raw_score": 0, "weighted_score": 0},
        )
        old = score.raw_score
        score.raw_score += 0.5
        score.save(update_fields=["raw_score"])

        ContextAnalysisLog.objects.create(
            entity_type=entity_type,
            entity_id=entity_id,
            field="raw_score",
            input_metadata=input_metadata or {},
            adjustments_applied={"+raw_score": 0.5},
        )

    LOGGER.debug(
        "Context analysis: user=%s %s %s %+0.5 raw (%.2f→%.2f)",
        user_id,
        entity_type,
        entity_id,
        old,
        score.raw_score,
    )


===== END modules/ekoh-smartvote/ekoh/services/contextual_analysis.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/services/multidimensional_scoring.py =====

"""
Multidimensional scoring engine.

Converts raw activity metrics into a weighted EkoH merit score
along three axes:

    • quality      (peer review, up-votes, moderator marks…)
    • expertise    (credentials, publications, citations…)
    • frequency    (participation cadence)

Final formula (from 03-technical_spec.md §2 .2 .1):

    S_u,d  =  Σ_i  ( R_i  ·  N_i,u,d )

        where:
          R_i  =  runtime weight  (RAW_WEIGHT_QUALITY, etc.)
          N_i  =  normalised metric on axis *i* for user *u* & domain *d*

Normalisation is performed as **percent-rank** over the *domain* cohort
(avoids cross-domain bias).
"""

from __future__ import annotations

import logging
from decimal import Decimal
from typing import Iterable, Mapping

from django.db.models import F, Window
from django.db.models.functions import PercentRank

from konnaxion.ekoh.models.config import ScoreConfiguration
from konnaxion.ekoh.models.scores import (
    UserExpertiseScore,
)
from konnaxion.ekoh.models.taxonomy import ExpertiseCategory

LOGGER = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# helper – fetch runtime weights (cached for 60 s with simple lru)            #
# --------------------------------------------------------------------------- #
from functools import lru_cache
from time import time


@lru_cache(maxsize=1)
def _weights_cache() -> Mapping[str, Decimal]:
    """Return RAW_WEIGHT coefficients as {name: Decimal}."""
    rows = (
        ScoreConfiguration.objects.filter(weight_name__startswith="RAW_WEIGHT_")
        .values_list("weight_name", "weight_value")
    )
    return {name: Decimal(value) for name, value in rows}


def get_raw_weights(force_refresh: bool = False) -> Mapping[str, Decimal]:
    if force_refresh:
        _weights_cache.cache_clear()
    return _weights_cache()


# --------------------------------------------------------------------------- #
# main API                                                                    #
# --------------------------------------------------------------------------- #
AXES = ("quality", "expertise", "frequency")


def compute_user_domain_score(
    user_id: int,
    domain: ExpertiseCategory,
    metrics: Mapping[str, Decimal],
    *,
    flush: bool = True,
) -> Decimal:
    """
    Compute weighted score **S_u,d** for one user in one domain.

    Parameters
    ----------
    user_id : int
        ID of auth_user
    domain : ExpertiseCategory
        Leaf or parent domain
    metrics : dict
        Raw axis metrics already gathered by callers:
          {"quality": 87, "expertise": 66, "frequency": 12}
    flush : bool
        Persist result into UserExpertiseScore table if True.

    Returns
    -------
    Decimal
        Weighted score between 0 and 100 (rounded to 4 decimals)
    """
    raw_weights = get_raw_weights()
    missing = [ax for ax in AXES if ax not in metrics]
    if missing:  # pragma: no cover
        raise ValueError(f"Missing metric(s): {', '.join(missing)}")

    # Percent-rank normalisation within domain cohort
    normalised = _percent_rank(metrics, domain)

    weighted_sum = Decimal("0")
    for axis in AXES:
        weighted_sum += raw_weights[f"RAW_WEIGHT_{axis.upper()}"] * normalised[axis]

    score = weighted_sum.quantize(Decimal("0.0001"))

    if flush:
        UserExpertiseScore.objects.update_or_create(
            user_id=user_id,
            category=domain,
            defaults={
                "raw_score": sum(metrics.values()),
                "weighted_score": score,
            },
        )
    return score


# --------------------------------------------------------------------------- #
# internal helpers                                                            #
# --------------------------------------------------------------------------- #
def _percent_rank(
    metric_map: Mapping[str, Decimal], domain: ExpertiseCategory
) -> Mapping[str, Decimal]:
    """
    Convert raw axis values to 0-1 scale using PercentRank over cohort.

    Cohort = users who have any score row in this *domain* OR its descendants.
    """
    # Gather cohort scores in one ORM query per axis
    cohort_qs = (
        UserExpertiseScore.objects.filter(category__path__descendant=domain.path)
        .values("user_id")
        .annotate(raw_axis=F("raw_score"))
    )

    norm: dict[str, Decimal] = {}
    for axis in AXES:
        ranked = (
            cohort_qs.annotate(
                pct=Window(expression=PercentRank(), order_by=F("raw_axis").asc())
            )
            .filter(raw_axis=metric_map[axis])
            .first()
        )
        norm[axis] = Decimal(ranked["pct"] if ranked else 0)
    return norm


===== END modules/ekoh-smartvote/ekoh/services/multidimensional_scoring.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/services/__init__.py =====

Commande ECHO dsactive.


===== END modules/ekoh-smartvote/ekoh/services/__init__.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/tasks/contextual.py =====

"""
Celery task: contextual_analysis_batch

Placeholder that will scan entities (publications, answers, etc.)
and call analyse_entity for each. For now, just logs invocation.
"""

import logging
from celery import shared_task

from konnaxion.ekoh.services.contextual_analysis import analyse_entity

LOGGER = logging.getLogger(__name__)


@shared_task(name="contextual_analysis_batch")
def contextual_analysis_batch():
    LOGGER.info("Contextual analysis batch started")
    # TODO: Replace below with real query of new entities
    # For now, simulate one call as proof-of-concept
    dummy_user_id = 1
    dummy_entity_id = None
    analyse_entity(
        user_id=dummy_user_id,
        entity_type="example",
        entity_id=dummy_entity_id,
        domain_code="0000",  # replace with real code
        input_metadata={"note": "stub run"},
    )
    LOGGER.info("Contextual analysis batch completed")


===== END modules/ekoh-smartvote/ekoh/tasks/contextual.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/tasks/recalc.py =====

"""
Celery task: ekoh_score_recalc

* Runs nightly (see tasks_schedule.md).
* Iterates through all users and relevant expertise domains.
* Calls `compute_user_domain_score` to update weighted scores in DB.
"""

from __future__ import annotations

import logging
from itertools import islice
from typing import Iterable, Iterator

from celery import shared_task
from django.contrib.auth import get_user_model
from django.db.models import QuerySet

from konnaxion.ekoh.models.taxonomy import ExpertiseCategory
from konnaxion.ekoh.services.multidimensional_scoring import (
    compute_user_domain_score,
)

LOGGER = logging.getLogger(__name__)
User = get_user_model()

CHUNK_SIZE = 1_000  # tune based on RAM


def chunked(iterable: Iterable[int], size: int) -> Iterator[list[int]]:
    """Yield lists of `size` items from iterable."""
    it = iter(iterable)
    while (chunk := list(islice(it, size))):
        yield chunk


def _collect_metrics(user_id: int, domain: ExpertiseCategory):
    """
    Placeholder metric collector.

    Replace with real aggregation of quality / expertise / frequency.
    For now just returns dummy 0s so task runs without error.
    """
    return {"quality": 0, "expertise": 0, "frequency": 0}


@shared_task(name="ekoh_score_recalc")
def recalc_all_scores() -> None:
    LOGGER.info("EkoH score rebuild started")
    domains: QuerySet[ExpertiseCategory] = ExpertiseCategory.objects.filter(depth__gte=1)

    for user_chunk in chunked(
        User.objects.values_list("id", flat=True).order_by("id"), CHUNK_SIZE
    ):
        for uid in user_chunk:
            for domain in domains:
                metrics = _collect_metrics(uid, domain)
                compute_user_domain_score(uid, domain, metrics, flush=True)
        LOGGER.debug("Processed %s users", len(user_chunk))

    LOGGER.info("EkoH score rebuild completed")


===== END modules/ekoh-smartvote/ekoh/tasks/recalc.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/tasks/__init__.py =====

Commande ECHO dsactive.


===== END modules/ekoh-smartvote/ekoh/tasks/__init__.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/views/profile.py =====

"""
GET /ekoh/profile/<uid>

Returns the public expertise & ethics profile for a single user.
"""

from django.shortcuts import get_object_or_404
from django.contrib.auth import get_user_model
from rest_framework.generics import RetrieveAPIView
from rest_framework.permissions import IsAuthenticatedOrReadOnly

from konnaxion.ekoh.serializers.profile import ProfileSerializer

User = get_user_model()


class ProfileView(RetrieveAPIView):
    """
    Public endpoint – no auth required if the target user’s
    confidentiality level is `public` or `pseudonym`.
    """

    serializer_class = ProfileSerializer
    permission_classes = [IsAuthenticatedOrReadOnly]
    lookup_url_kwarg = "uid"

    def get_queryset(self):
        """
        Optimise by pulling related privacy & ethics records
        in one DB round-trip.
        """
        qs = User.objects.all()
        return ProfileSerializer.setup_eager_loading(qs)

    def get_object(self):
        uid = self.kwargs.get(self.lookup_url_kwarg)
        return get_object_or_404(self.get_queryset(), pk=uid)


===== END modules/ekoh-smartvote/ekoh/views/profile.py =====


===== BEGIN modules/ekoh-smartvote/ekoh/views/__init__.py =====

Commande ECHO dsactive.


===== END modules/ekoh-smartvote/ekoh/views/__init__.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/admin.py =====

from django.contrib import admin

from konnaxion.smart_vote.models.core import (
    Vote,
    VoteModality,
    VoteResult,
    VoteLedger,
)


@admin.register(VoteModality)
class ModalityAdmin(admin.ModelAdmin):
    list_display = ("name",)


@admin.register(Vote)
class VoteAdmin(admin.ModelAdmin):
    list_display = ("id", "user", "target_type", "weighted_value", "created_at")
    list_filter = ("target_type", "modality")
    search_fields = ("user__username", "target_id")


@admin.register(VoteResult)
class VoteResultAdmin(admin.ModelAdmin):
    list_display = ("target_type", "target_id", "sum_weighted_value", "vote_count")


@admin.register(VoteLedger)
class LedgerAdmin(admin.ModelAdmin):
    list_display = ("ledger_id", "vote", "block_height", "logged_at")
    readonly_fields = ("sha256_hash",)


===== END modules/ekoh-smartvote/smart_vote/admin.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/apps.py =====

"""
Smart-Vote Django-app configuration.

• Shares the **same schema** (`ekoh_smartvote`) as the Ekoh app.
• Ensures the schema and required extensions exist
  (ltree & pgcrypto already installed by EkohConfig, but
  we guard idempotently in case this app is run standalone).
"""

import logging
from django.apps import AppConfig
from django.db import connection

LOGGER = logging.getLogger(__name__)
SCHEMA = "ekoh_smartvote"


class SmartVoteConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "konnaxion.smart_vote"
    verbose_name = "Smart-Vote – Weighted Balloting"

    def ready(self) -> None:  # noqa: D401  (simple present)
        """
        Ensure schema exists and search_path is set for this connection.
        """
        with connection.cursor() as cur:
            cur.execute(f"CREATE SCHEMA IF NOT EXISTS {SCHEMA};")
            cur.execute(f"SET search_path TO {SCHEMA}, public;")
            # Extensions are no-ops if already installed
            cur.execute("CREATE EXTENSION IF NOT EXISTS ltree;")
            cur.execute("CREATE EXTENSION IF NOT EXISTS pgcrypto;")
        LOGGER.debug("Smart-Vote search_path initialised (%s,public)", SCHEMA)


===== END modules/ekoh-smartvote/smart_vote/apps.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/models.py =====



===== END modules/ekoh-smartvote/smart_vote/models.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/urls.py =====

"""
Smart-Vote route entrypoint.

Add to project urls.py:

    path("api/v1/smart-vote/", include("konnaxion.smart_vote.urls"))
"""

from django.urls import path
from konnaxion.smart_vote.views.cast import CastBallotView

app_name = "smart_vote"

urlpatterns = [
    path("cast/", CastBallotView.as_view(), name="cast"),
]


===== END modules/ekoh-smartvote/smart_vote/urls.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/__init__.py =====



===== END modules/ekoh-smartvote/smart_vote/__init__.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/models/consultation.py =====

@echo off
REM =============================================================
REM  create_missing_ekoh_files.bat
REM  Creates EMPTY placeholder files still outstanding.
REM  No content, no comments—just stub files Git can track.
REM =============================================================

SETLOCAL
set MOD=modules\ekoh-smartvote

REM ---------- 1. Directories ----------
for %%D in (
    "%MOD%\smart_vote\models"
    "%MOD%\smart_vote\migrations"
    "%MOD%\ekoh\tasks"
    "%MOD%\ekoh"
    "%MOD%\ekoh\fixtures"
    ".github\workflows"
    "docs"
    "config"
) do if not exist "%%~D" md "%%~D"

REM ---------- 2. Empty files ----------
for %%F in (
    "%MOD%\smart_vote\models\consultation.py"
    "%MOD%\smart_vote\models\consultation_relevance.py"
    "%MOD%\smart_vote\migrations\0002_consultation.py"
    "%MOD%\ekoh\tasks\contextual.py"
    "%MOD%\ekoh\admin_partition.py"
    "config\settings_addons.py"
    "config\celery.py"
    "docs\openapi.yaml"
    ".github\workflows\secrets-example.yml"
    "%MOD%\ekoh\fixtures\isced_f_2013.json"
) do if not exist "%%~F" copy nul "%%~F" >nul

echo.
echo Empty placeholder files created.
ENDLOCAL


===== END modules/ekoh-smartvote/smart_vote/models/consultation.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/models/consultation_relevance.py =====



===== END modules/ekoh-smartvote/smart_vote/models/consultation_relevance.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/models/core.py =====

"""
Core Smart-Vote tables.

Partitioning ⬇︎
-------------
`vote`, `vote_ledger` are **monthly range-partitioned** on `created_at`
and `logged_at`.  Native Django ORM can’t declare child tables, so
partition DDL is emitted in the first migration.
"""

from __future__ import annotations

import uuid
from decimal import Decimal

from django.db import models
from django.conf import settings


# ------------------------------------------------------------------ #
# 1)  Vote modality lookup                                            #
# ------------------------------------------------------------------ #
class VoteModality(models.Model):
    """Approval, ranking, rating, preferential, budget_split …"""

    APPROVAL = "approval"
    RANKING = "ranking"
    RATING = "rating"
    PREFERENTIAL = "preferential"
    BUDGET = "budget_split"

    name = models.CharField(
        max_length=32,
        primary_key=True,
        choices=[
            (APPROVAL, "Approval"),
            (RANKING, "Ranking"),
            (RATING, "Rating 1-5"),
            (PREFERENTIAL, "Preferential"),
            (BUDGET, "Budget split"),
        ],
    )
    parameters = models.JSONField(blank=True, null=True)

    class Meta:
        db_table = "vote_modality"

    def __str__(self) -> str:  # pragma: no cover
        return self.name


# ------------------------------------------------------------------ #
# 2)  Raw vote (partitioned)                                          #
# ------------------------------------------------------------------ #
class Vote(models.Model):
    """
    One ballot cast by `user` on an arbitrary `target`.

    Partitioned **monthly** on `created_at`.
    """

    id = models.BigAutoField(primary_key=True)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    # generic FK → any model (“consultation”, “idea”, “policy” …)
    target_type = models.CharField(max_length=64)
    target_id = models.UUIDField(default=uuid.uuid4)

    modality = models.ForeignKey(VoteModality, on_delete=models.PROTECT)

    raw_value = models.DecimalField(max_digits=12, decimal_places=4)
    weighted_value = models.DecimalField(max_digits=12, decimal_places=4)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "vote"
        unique_together = ("user", "target_type", "target_id")
        indexes = [
            models.Index(fields=["target_type", "target_id"], name="idx_vote_target")
        ]

    # convenience
    def __str__(self) -> str:  # pragma: no cover
        return f"{self.user_id}→{self.target_id} = {self.weighted_value}"


# ------------------------------------------------------------------ #
# 3)  Aggregated result (1 row per target)                            #
# ------------------------------------------------------------------ #
class VoteResult(models.Model):
    target_type = models.CharField(max_length=64)
    target_id = models.UUIDField()
    sum_weighted_value = models.DecimalField(max_digits=20, decimal_places=4)
    vote_count = models.IntegerField()

    class Meta:
        db_table = "vote_result"
        unique_together = ("target_type", "target_id")

    def __str__(self):  # pragma: no cover
        return f"{self.target_id} ⟹ {self.sum_weighted_value}"


# ------------------------------------------------------------------ #
# 4)  Ledger                                                           #
# ------------------------------------------------------------------ #
class VoteLedger(models.Model):
    """
    Append-only log for on-chain anchoring.

    Partitioned monthly on `logged_at`.
    """

    ledger_id = models.BigAutoField(primary_key=True)
    vote = models.ForeignKey(Vote, on_delete=models.CASCADE)
    sha256_hash = models.BinaryField()  # 32-byte SHA-256
    block_height = models.BigIntegerField(null=True, blank=True)
    logged_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "vote_ledger"
        indexes = [models.Index(fields=["vote_id"], name="idx_ledger_vote")]

    def __str__(self):  # pragma: no cover
        return f"ledger {self.ledger_id} → vote {self.vote_id}"


===== END modules/ekoh-smartvote/smart_vote/models/core.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/serializers/ballot.py =====

"""
Ballot input / output schema.

POST body example
-----------------
{
  "consultation": "7077e77f-0a1e-4f8a-83b2-d12e2c68b4ec",
  "target_id":     "7077e77f-0a1e-4f8a-83b2-d12e2c68b4ec",   # same as consultation for single-question
  "modality":      "approval",
  "raw_value":     1
}
"""

from uuid import UUID
from decimal import Decimal

from rest_framework import serializers

from konnaxion.smart_vote.models.core import Vote, VoteModality
from konnaxion.smart_vote.services.weight_calculator import get_weight


class BallotSerializer(serializers.Serializer):
    consultation = serializers.UUIDField()
    target_id = serializers.UUIDField()
    modality = serializers.ChoiceField(choices=[m[0] for m in VoteModality._meta.get_field("name").choices])
    raw_value = serializers.DecimalField(max_digits=12, decimal_places=4)

    def validate(self, attrs):
        user = self.context["request"].user
        if Vote.objects.filter(
            user=user,
            target_type="consultation",
            target_id=attrs["target_id"],
        ).exists():
            raise serializers.ValidationError("You have already voted on this target.")
        return attrs

    def create(self, validated_data):
        user = self.context["request"].user
        weighted = get_weight(user.id, validated_data["consultation"])
        return Vote.objects.create(
            user=user,
            target_type="consultation",
            target_id=validated_data["target_id"],
            modality_id=validated_data["modality"],
            raw_value=validated_data["raw_value"],
            weighted_value=Decimal(validated_data["raw_value"]) * weighted,
        )

    # Response body
    id = serializers.IntegerField(read_only=True)
    weighted_value = serializers.DecimalField(max_digits=12, decimal_places=4, read_only=True)


===== END modules/ekoh-smartvote/smart_vote/serializers/ballot.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/serializers/__init__.py =====

Commande ECHO dsactive.


===== END modules/ekoh-smartvote/smart_vote/serializers/__init__.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/services/weight_calculator.py =====

"""
Weight-calculator — core of Smart-Vote.

Formula  (see 03-technical_spec.md §2.3):

    W_u,c  =  min(
                 Σ_d  ( R_c,d  ·  S_u,d )  ,  ethical_cap
             )  ×  ethics_multiplier

where
    •  R_c,d          = relevance weight for consultation *c* & domain *d*
    •  S_u,d          = user weighted expertise score for domain *d*
    •  ethics_multiplier  = 1 + (ethical_score – 1) * α
    •  ethical_cap    = EKOH_MULTIPLIER_CAP  (env / param)

This module exposes the single public function:

    get_weight(user_id: int, consultation_id: uuid) -> Decimal
"""

from __future__ import annotations

import logging
from decimal import Decimal
from functools import lru_cache
from typing import Dict

from django.db.models import Sum
from django.conf import settings

from konnaxion.ekoh.models.scores import UserExpertiseScore, UserEthicsScore
from konnaxion.ekoh.models.config import ScoreConfiguration
from konnaxion.smart_vote.models.core import VoteModality
from konnaxion.ekoh.models.taxonomy import ExpertiseCategory
from konnaxion.smart_vote.models.core import (
    Consultation,  # assumed imported or created
    ConsultationRelevance,
)

LOGGER = logging.getLogger(__name__)


# --------------------------------------------------------------------------- #
#  Runtime tunables                                                           #
# --------------------------------------------------------------------------- #
@lru_cache(maxsize=32)
def _fetch_param(name: str) -> Decimal:
    """Read a numeric param from score_configuration (cached)."""
    obj = ScoreConfiguration.objects.filter(weight_name=name).first()
    if obj is None:
        raise RuntimeError(f"Missing parameter {name}")
    return Decimal(obj.weight_value)


def ethical_cap() -> Decimal:
    return _fetch_param("EKOH_MULTIPLIER_CAP")


# --------------------------------------------------------------------------- #
#  Cached helpers                                                             #
# --------------------------------------------------------------------------- #
@lru_cache(maxsize=512)
def _relevance_vector(consultation_id) -> Dict[int, Decimal]:
    """Return {category_id: relevance_weight} for a consultation."""
    rows = ConsultationRelevance.objects.filter(
        consultation_id=consultation_id
    ).values_list("category_id", "weight")
    return {cid: Decimal(w) for cid, w in rows}


@lru_cache(maxsize=5_000)
def _expertise_vector(user_id: int) -> Dict[int, Decimal]:
    """Return {category_id: weighted_score} for a user."""
    rows = UserExpertiseScore.objects.filter(user_id=user_id).values_list(
        "category_id", "weighted_score"
    )
    return {cid: Decimal(s) for cid, s in rows}


def _ethics_multiplier(user_id: int) -> Decimal:
    row = UserEthicsScore.objects.filter(user_id=user_id).first()
    if not row:
        return Decimal("1.0")
    # α = 1 by default (linear); tweak if needed
    return Decimal(row.ethical_score)


# --------------------------------------------------------------------------- #
#  Public API                                                                 #
# --------------------------------------------------------------------------- #
def get_weight(user_id: int, consultation_id) -> Decimal:
    """
    Calculate voting weight for user on a given consultation.

    Steps
    -----
    1. Dot-product relevance vector with user expertise vector.
    2. Cap result by EKOH_MULTIPLIER_CAP.
    3. Multiply by ethics multiplier.
    """
    rel_vec = _relevance_vector(consultation_id)
    exp_vec = _expertise_vector(user_id)

    dot = sum(rel_vec.get(cid, 0) * exp_vec.get(cid, 0) for cid in rel_vec)

    capped = min(dot, ethical_cap())
    weight = (Decimal(capped) * _ethics_multiplier(user_id)).quantize(
        Decimal("0.0001")
    )

    LOGGER.debug(
        "Weight u=%s c=%s  dot=%s  capped=%s  ethics× => %s",
        user_id,
        consultation_id,
        dot,
        capped,
        weight,
    )
    return weight


===== END modules/ekoh-smartvote/smart_vote/services/weight_calculator.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/services/__init__.py =====

Commande ECHO dsactive.


===== END modules/ekoh-smartvote/smart_vote/services/__init__.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/tasks/aggregator.py =====

"""
Aggregator task:

1. Pulls Vote rows created since the last run (uses id > cursor).
2. Sums their weighted values per (target_type, target_id) combination.
3. UPSERTs into vote_result (sum_weighted_value, vote_count).

Runs every minute by default (see tasks_schedule.md).
"""

from __future__ import annotations

import logging
from collections import defaultdict
from decimal import Decimal

from celery import shared_task
from django.db import transaction, connection

from konnaxion.smart_vote.models.core import Vote, VoteResult

LOGGER = logging.getLogger(__name__)
CURSOR_KEY = "ekoh_smartvote.last_vote_id"


def _load_cursor() -> int:
    """Fetch last processed vote id from pg_settings (simple key-value)."""
    with connection.cursor() as cur:
        cur.execute(
            "SELECT current_setting(%s, true);",
            (CURSOR_KEY,),
        )
        row = cur.fetchone()
    return int(row[0]) if row and row[0] else 0


def _save_cursor(vote_id: int) -> None:
    with connection.cursor() as cur:
        cur.execute("SELECT set_config(%s, %s, true);", (CURSOR_KEY, str(vote_id)))


@shared_task(name="vote_aggregate")
def aggregate_votes(batch_size: int = 5_000) -> None:
    last_id = _load_cursor()
    LOGGER.debug("Vote aggregate start (cursor=%s)", last_id)

    qs = Vote.objects.filter(id__gt=last_id).order_by("id")[:batch_size]
    if not qs.exists():
        LOGGER.debug("No new votes")
        return

    # 1) group by target
    totals: dict[tuple[str, str], dict[str, Decimal | int]] = defaultdict(
        lambda: {"sum": Decimal(0), "count": 0}
    )

    highest_id = last_id
    for v in qs:
        key = (v.target_type, str(v.target_id))
        totals[key]["sum"] += v.weighted_value
        totals[key]["count"] += 1
        highest_id = max(highest_id, v.id)

    # 2) upsert
    with transaction.atomic():
        for (t_type, t_id), agg in totals.items():
            VoteResult.objects.update_or_create(
                target_type=t_type,
                target_id=t_id,
                defaults={
                    "sum_weighted_value": agg["sum"],
                    "vote_count": agg["count"],
                },
            )
        _save_cursor(highest_id)

    LOGGER.info("Aggregated %s votes up to id %s", len(qs), highest_id)


===== END modules/ekoh-smartvote/smart_vote/tasks/aggregator.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/tasks/__init__.py =====

"""
Celery discovers tasks in this package.
"""


===== END modules/ekoh-smartvote/smart_vote/tasks/__init__.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/views/cast.py =====

"""
POST /smart-vote/cast   → creates one Vote row
"""

from rest_framework.generics import CreateAPIView
from rest_framework.permissions import IsAuthenticated

from konnaxion.smart_vote.serializers.ballot import BallotSerializer


class CastBallotView(CreateAPIView):
    serializer_class = BallotSerializer
    permission_classes = [IsAuthenticated]


===== END modules/ekoh-smartvote/smart_vote/views/cast.py =====


===== BEGIN modules/ekoh-smartvote/smart_vote/views/__init__.py =====

Commande ECHO dsactive.


===== END modules/ekoh-smartvote/smart_vote/views/__init__.py =====
