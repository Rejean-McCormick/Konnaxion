===== TOC (83 fichiers) =====
0001  C:\MyCode\Konnaxionv14\backend\konnaxion\__init__.py
0002  C:\MyCode\Konnaxionv14\backend\konnaxion\conftest.py
0003  C:\MyCode\Konnaxionv14\backend\konnaxion\contrib\__init__.py
0004  C:\MyCode\Konnaxionv14\backend\konnaxion\contrib\sites\__init__.py
0005  C:\MyCode\Konnaxionv14\backend\konnaxion\ethikos\__init__.py
0006  C:\MyCode\Konnaxionv14\backend\konnaxion\ethikos\admin.py
0007  C:\MyCode\Konnaxionv14\backend\konnaxion\ethikos\api_views.py
0008  C:\MyCode\Konnaxionv14\backend\konnaxion\ethikos\apps.py
0009  C:\MyCode\Konnaxionv14\backend\konnaxion\ethikos\models.py
0010  C:\MyCode\Konnaxionv14\backend\konnaxion\ethikos\serializers.py
0011  C:\MyCode\Konnaxionv14\backend\konnaxion\ethikos\urls.py
0012  C:\MyCode\Konnaxionv14\backend\konnaxion\ethikos\views.py
0013  C:\MyCode\Konnaxionv14\backend\konnaxion\keenkonnect\__init__.py
0014  C:\MyCode\Konnaxionv14\backend\konnaxion\keenkonnect\admin.py
0015  C:\MyCode\Konnaxionv14\backend\konnaxion\keenkonnect\api_views.py
0016  C:\MyCode\Konnaxionv14\backend\konnaxion\keenkonnect\apps.py
0017  C:\MyCode\Konnaxionv14\backend\konnaxion\keenkonnect\models.py
0018  C:\MyCode\Konnaxionv14\backend\konnaxion\keenkonnect\serializers.py
0019  C:\MyCode\Konnaxionv14\backend\konnaxion\keenkonnect\views.py
0020  C:\MyCode\Konnaxionv14\backend\konnaxion\kollective_intelligence\__init__.py
0021  C:\MyCode\Konnaxionv14\backend\konnaxion\kollective_intelligence\admin.py
0022  C:\MyCode\Konnaxionv14\backend\konnaxion\kollective_intelligence\api_views.py
0023  C:\MyCode\Konnaxionv14\backend\konnaxion\kollective_intelligence\apps.py
0024  C:\MyCode\Konnaxionv14\backend\konnaxion\kollective_intelligence\models.py
0025  C:\MyCode\Konnaxionv14\backend\konnaxion\kollective_intelligence\serializers.py
0026  C:\MyCode\Konnaxionv14\backend\konnaxion\kollective_intelligence\views.py
0027  C:\MyCode\Konnaxionv14\backend\konnaxion\konnected\__init__.py
0028  C:\MyCode\Konnaxionv14\backend\konnaxion\konnected\admin.py
0029  C:\MyCode\Konnaxionv14\backend\konnaxion\konnected\api_views.py
0030  C:\MyCode\Konnaxionv14\backend\konnaxion\konnected\apps.py
0031  C:\MyCode\Konnaxionv14\backend\konnaxion\konnected\models.py
0032  C:\MyCode\Konnaxionv14\backend\konnaxion\konnected\serializers.py
0033  C:\MyCode\Konnaxionv14\backend\konnaxion\konnected\tasks.py
0034  C:\MyCode\Konnaxionv14\backend\konnaxion\konnected\views.py
0035  C:\MyCode\Konnaxionv14\backend\konnaxion\kreative\__init__.py
0036  C:\MyCode\Konnaxionv14\backend\konnaxion\kreative\admin.py
0037  C:\MyCode\Konnaxionv14\backend\konnaxion\kreative\api_views.py
0038  C:\MyCode\Konnaxionv14\backend\konnaxion\kreative\apps.py
0039  C:\MyCode\Konnaxionv14\backend\konnaxion\kreative\models.py
0040  C:\MyCode\Konnaxionv14\backend\konnaxion\kreative\serializers.py
0041  C:\MyCode\Konnaxionv14\backend\konnaxion\kreative\views.py
0042  C:\MyCode\Konnaxionv14\backend\konnaxion\moderation\api_views.py
0043  C:\MyCode\Konnaxionv14\backend\konnaxion\moderation\models.py
0044  C:\MyCode\Konnaxionv14\backend\konnaxion\moderation\serializers.py
0045  C:\MyCode\Konnaxionv14\backend\konnaxion\static\css\project.css
0046  C:\MyCode\Konnaxionv14\backend\konnaxion\static\fonts\.gitkeep
0047  C:\MyCode\Konnaxionv14\backend\konnaxion\static\js\project.js
0048  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\403.html
0049  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\403_csrf.html
0050  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\404.html
0051  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\500.html
0052  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\account\base_manage_password.html
0053  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\allauth\elements\alert.html
0054  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\allauth\elements\badge.html
0055  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\allauth\elements\button.html
0056  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\allauth\elements\field.html
0057  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\allauth\elements\fields.html
0058  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\allauth\elements\panel.html
0059  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\allauth\elements\table.html
0060  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\allauth\layouts\entrance.html
0061  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\allauth\layouts\manage.html
0062  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\base.html
0063  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\pages\about.html
0064  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\pages\home.html
0065  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\users\user_detail.html
0066  C:\MyCode\Konnaxionv14\backend\konnaxion\templates\users\user_form.html
0067  C:\MyCode\Konnaxionv14\backend\konnaxion\trust\models.py
0068  C:\MyCode\Konnaxionv14\backend\konnaxion\trust\serializers.py
0069  C:\MyCode\Konnaxionv14\backend\konnaxion\urls.py
0070  C:\MyCode\Konnaxionv14\backend\konnaxion\users\__init__.py
0071  C:\MyCode\Konnaxionv14\backend\konnaxion\users\adapters.py
0072  C:\MyCode\Konnaxionv14\backend\konnaxion\users\admin.py
0073  C:\MyCode\Konnaxionv14\backend\konnaxion\users\api\__init__.py
0074  C:\MyCode\Konnaxionv14\backend\konnaxion\users\api\serializers.py
0075  C:\MyCode\Konnaxionv14\backend\konnaxion\users\api\urls.py
0076  C:\MyCode\Konnaxionv14\backend\konnaxion\users\api\views.py
0077  C:\MyCode\Konnaxionv14\backend\konnaxion\users\apps.py
0078  C:\MyCode\Konnaxionv14\backend\konnaxion\users\context_processors.py
0079  C:\MyCode\Konnaxionv14\backend\konnaxion\users\forms.py
0080  C:\MyCode\Konnaxionv14\backend\konnaxion\users\models.py
0081  C:\MyCode\Konnaxionv14\backend\konnaxion\users\tasks.py
0082  C:\MyCode\Konnaxionv14\backend\konnaxion\users\urls.py
0083  C:\MyCode\Konnaxionv14\backend\konnaxion\users\views.py
===== END TOC =====


===== BEGIN konnaxion/__init__.py =====
__version__ = "0.1.0"
__version_info__ = tuple(
    int(num) if num.isdigit() else num
    for num in __version__.replace("-", ".", 1).split(".")
)

===== END konnaxion/__init__.py =====


===== BEGIN konnaxion/conftest.py =====
import pytest

from konnaxion.users.models import User
from konnaxion.users.tests.factories import UserFactory


@pytest.fixture(autouse=True)
def _media_storage(settings, tmpdir) -> None:
    settings.MEDIA_ROOT = tmpdir.strpath


@pytest.fixture
def user(db) -> User:
    return UserFactory()

===== END konnaxion/conftest.py =====


===== BEGIN konnaxion/contrib/__init__.py =====
"""
To understand why this file is here, please read:

https://cookiecutter-django.readthedocs.io/en/latest/5-help/faq.html#why-is-there-a-django-contrib-sites-directory-in-cookiecutter-django
"""

===== END konnaxion/contrib/__init__.py =====


===== BEGIN konnaxion/contrib/sites/__init__.py =====
"""
To understand why this file is here, please read:

https://cookiecutter-django.readthedocs.io/en/latest/5-help/faq.html#why-is-there-a-django-contrib-sites-directory-in-cookiecutter-django
"""

===== END konnaxion/contrib/sites/__init__.py =====


===== BEGIN konnaxion/ethikos/__init__.py =====

===== END konnaxion/ethikos/__init__.py =====


===== BEGIN konnaxion/ethikos/admin.py =====
# konnaxion/ethikos/admin.py
from __future__ import annotations
from typing import Sequence

from django.apps import apps
from django.contrib import admin
from django.utils.html import format_html
from django.utils.translation import gettext_lazy as _

from .models import (
    EthikosArgument,
    EthikosCategory,
    EthikosStance,
    EthikosTopic,
)

# ───────── Mix-in to show created/updated columns ─────────
class TimestampMixin(admin.ModelAdmin):
    date_hierarchy = "created_at"

    def _time_fields(self) -> set[str]:
        return {"created_at", "updated_at"} & {f.name for f in self.model._meta.get_fields()}

    def get_readonly_fields(self, request, obj=None) -> Sequence[str]:
        return (*super().get_readonly_fields(request, obj), *self._time_fields())

    def get_list_display(self, request):
        cols = list(super().get_list_display(request))
        for f in self._time_fields():
            if f not in cols:
                cols.append(f)
        return tuple(cols)

# ───────── Category ─────────
@admin.register(EthikosCategory)
class EthikosCategoryAdmin(admin.ModelAdmin):
    list_display = ("name", "description")
    search_fields = ("name",)
    list_per_page = 30

# ───────── Topic ─────────
@admin.register(EthikosTopic)
class EthikosTopicAdmin(TimestampMixin):
    list_display = (
        "title",
        "category",
        "expertise_category",
        "status_badge",
        "total_votes",
        "created_by",
        "last_activity",
    )
    list_filter = ("status", "category", "expertise_category")
    search_fields = ("title", "description")
    autocomplete_fields = ("category", "expertise_category", "created_by")
    list_select_related = ("category", "expertise_category", "created_by")
    ordering = ("-created_at",)

    @admin.display(description=_("status"), ordering="status")
    def status_badge(self, obj: EthikosTopic) -> str:
        colour = {
            EthikosTopic.OPEN: "green",
            EthikosTopic.CLOSED: "red",
            EthikosTopic.ARCHIVED: "grey",
        }.get(obj.status, "black")
        return format_html(
            '<span style="color:{};font-weight:600;">{}</span>',
            colour,
            obj.get_status_display(),
        )

# ───────── Stance ─────────
@admin.register(EthikosStance)
class EthikosStanceAdmin(admin.ModelAdmin):
    list_display = ("user", "topic", "value", "timestamp")
    list_filter = ("value",)
    search_fields = ("user__username", "topic__title")
    autocomplete_fields = ("user", "topic")
    ordering = ("-timestamp",)

# ───────── Argument ─────────
@admin.register(EthikosArgument)
class EthikosArgumentAdmin(TimestampMixin):
    list_display = ("short_content", "topic", "user", "side", "is_hidden")
    list_filter = ("side", "is_hidden")
    search_fields = ("content", "user__username", "topic__title")
    autocomplete_fields = ("topic", "user", "parent")
    list_select_related = ("topic", "user", "parent")

    @admin.display(description=_("content"))
    def short_content(self, obj: EthikosArgument) -> str:
        return (obj.content[:60] + "…") if len(obj.content) > 60 else obj.content

# ───────── Fallback auto-registration ─────────
cfg = apps.get_app_config("ethikos")
for mdl in cfg.get_models():
    if not admin.site.is_registered(mdl):
        admin.site.register(mdl)

===== END konnaxion/ethikos/admin.py =====


===== BEGIN konnaxion/ethikos/api_views.py =====
# backend/konnaxion/ethikos/api_views.py

from django.shortcuts import get_object_or_404
from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.exceptions import ValidationError
from rest_framework.response import Response

from .models import (
    EthikosCategory,
    EthikosTopic,
    EthikosStance,
    EthikosArgument,
)
from .serializers import (
    EthikosCategorySerializer,
    EthikosTopicSerializer,
    EthikosStanceSerializer,
    EthikosArgumentSerializer,
)


# ---- Permissions simples owner-or-read-only ---------------------------------
class IsOwnerOrReadOnly(permissions.BasePermission):
    """
    Lecture pour tous. Ecriture réservée au propriétaire.
    - Topic: champ 'created_by'
    - Stance/Argument: champ 'user'
    """

    def has_object_permission(self, request, view, obj):
        if request.method in permissions.SAFE_METHODS:
            return True
        owner_id = getattr(obj, "created_by_id", None) or getattr(obj, "user_id", None)
        return owner_id == getattr(request.user, "id", None)


# ---- Categories (lecture seule par défaut) ----------------------------------
class CategoryViewSet(viewsets.ReadOnlyModelViewSet):
    """
    Liste et détail des catégories de débats.
    """
    queryset = EthikosCategory.objects.all().order_by("name")
    serializer_class = EthikosCategorySerializer
    permission_classes = [permissions.AllowAny]


# ---- Topics -----------------------------------------------------------------
class TopicViewSet(viewsets.ModelViewSet):
    """
    CRUD pour les sujets de débat.
    Injecte 'created_by' et gère 'category' malgré le serializer read-only.
    """
    queryset = EthikosTopic.objects.select_related("created_by", "category")
    serializer_class = EthikosTopicSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly]

    def _resolve_category(self, request, required: bool) -> EthikosCategory | None:
        cat_id = request.data.get("category") or request.data.get("category_id")
        if not cat_id:
            if required:
                raise ValidationError({"category": "Requis"})
            return None
        return get_object_or_404(EthikosCategory, pk=cat_id)

    def perform_create(self, serializer):
        category = self._resolve_category(self.request, required=True)
        serializer.save(created_by=self.request.user, category=category)

    def perform_update(self, serializer):
        # category facultative en update
        category = self._resolve_category(self.request, required=False)
        if category is not None:
            serializer.save(category=category)
        else:
            serializer.save()

    def get_queryset(self):
        qs = super().get_queryset()
        cat = self.request.query_params.get("category")
        if cat:
            qs = qs.filter(category_id=cat)
        status_param = self.request.query_params.get("status")
        if status_param:
            qs = qs.filter(status=status_param)
        return qs

    @action(detail=True, methods=["get"], permission_classes=[permissions.AllowAny])
    def preview(self, request, pk=None):
        """
        Retourne un aperçu minimal du topic.
        Compatible avec un usage front de type .../topics/{id}/preview.
        """
        topic = self.get_object()
        desc = topic.description or ""
        preview_desc = desc if len(desc) <= 280 else (desc[:280] + "…")
        data = {
            "id": topic.id,
            "title": topic.title,
            "description": preview_desc,
            "category": topic.category.name if topic.category_id else None,
            "status": topic.status,
            "total_votes": topic.total_votes,
            "last_activity": topic.last_activity,
        }
        return Response(data, status=status.HTTP_200_OK)


# ---- Stances ----------------------------------------------------------------
class StanceViewSet(viewsets.ModelViewSet):
    """
    Crée/Met à jour la position d’un utilisateur sur un topic.
    - GET list: filtrable par ?topic=<id>
    - POST: upsert (update_or_create) pour respecter l'unicité (user, topic)
    """
    queryset = EthikosStance.objects.select_related("topic", "user")
    serializer_class = EthikosStanceSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly]

    def get_queryset(self):
        qs = super().get_queryset()
        topic_id = self.request.query_params.get("topic")
        if topic_id:
            qs = qs.filter(topic_id=topic_id)
        return qs

    def create(self, request, *args, **kwargs):
        topic_id = request.data.get("topic")
        value = request.data.get("value")
        if topic_id is None or value is None:
            raise ValidationError({"topic": "Requis", "value": "Requis"})
        # Upsert sur (user, topic) pour éviter les erreurs d'unicité
        stance, created = EthikosStance.objects.update_or_create(
            user=request.user,
            topic_id=topic_id,
            defaults={"value": value},
        )
        serializer = self.get_serializer(stance)
        code = status.HTTP_201_CREATED if created else status.HTTP_200_OK
        return Response(serializer.data, status=code)

    def perform_create(self, serializer):
        # Non utilisé car create() est surchargé, mais gardé par sécurité.
        serializer.save(user=self.request.user)


# ---- Arguments --------------------------------------------------------------
class ArgumentViewSet(viewsets.ModelViewSet):
    """
    Messages argumentés, threadés par 'parent' (pro/contra).
    - GET list: filtrable par ?topic=<id>
    - POST: fixe 'user' et accepte 'parent' même si le serializer le marque read-only.
    """
    queryset = EthikosArgument.objects.select_related("user", "topic", "parent")
    serializer_class = EthikosArgumentSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly]

    def get_queryset(self):
        qs = super().get_queryset()
        topic_id = self.request.query_params.get("topic")
        if topic_id:
            qs = qs.filter(topic_id=topic_id)
        return qs

    def perform_create(self, serializer):
        parent_id = self.request.data.get("parent")
        extra = {"user": self.request.user}
        if parent_id:
            parent = get_object_or_404(EthikosArgument, pk=parent_id)
            # Si 'topic' fourni et différent de celui du parent -> erreur
            topic_in = self.request.data.get("topic")
            if topic_in and int(topic_in) != parent.topic_id:
                raise ValidationError({"parent": "Le parent doit appartenir au même topic."})
            extra["parent"] = parent
        serializer.save(**extra)

===== END konnaxion/ethikos/api_views.py =====


===== BEGIN konnaxion/ethikos/apps.py =====
from django.apps import AppConfig


class EthikosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "konnaxion.ethikos"

===== END konnaxion/ethikos/apps.py =====


===== BEGIN konnaxion/ethikos/models.py =====
# konnaxion/ethikos/models.py
from django.conf import settings
from django.core.validators import MinValueValidator, MaxValueValidator
from django.db import models

# ───────────────────────────────────────────────────
STANCE_MIN, STANCE_MAX = -3, 3
# ───────────────────────────────────────────────────

class EthikosCategory(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)

    class Meta:
        ordering = ("name",)

    def __str__(self):
        return self.name


class EthikosTopic(models.Model):
    """One debate question."""
    OPEN, CLOSED, ARCHIVED = "open", "closed", "archived"
    STATUS_CHOICES = [
        (OPEN, "Open"),
        (CLOSED, "Closed"),
        (ARCHIVED, "Archived"),
    ]

    title = models.CharField(max_length=255)
    description = models.TextField()
    category = models.ForeignKey(
        EthikosCategory, on_delete=models.PROTECT, related_name="topics"
    )
    expertise_category = models.ForeignKey(
        "kollective_intelligence.ExpertiseCategory",
        null=True, blank=True, on_delete=models.SET_NULL,
    )
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="ethikos_topics",
    )

    status = models.CharField(
        max_length=8,              # fits “archived”
        choices=STATUS_CHOICES,
        default=OPEN,
    )
    total_votes = models.PositiveIntegerField(default=0)
    last_activity = models.DateTimeField(auto_now=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ("-created_at",)

    def __str__(self):
        return self.title


class EthikosStance(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="ethikos_stances",
    )
    topic = models.ForeignKey(
        EthikosTopic,
        on_delete=models.CASCADE,
        related_name="stances",
    )
    value = models.SmallIntegerField(
        validators=[
            MinValueValidator(STANCE_MIN),
            MaxValueValidator(STANCE_MAX),
        ]
    )
    timestamp = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("user", "topic")
        indexes = [models.Index(fields=("topic",)), models.Index(fields=("user",))]
        constraints = [
            models.CheckConstraint(
                name="stance_value_between_-3_and_3",
                condition=models.Q(value__gte=STANCE_MIN, value__lte=STANCE_MAX),
            ),
        ]

    def __str__(self):
        return f"{self.user} → {self.topic} = {self.value}"


class EthikosArgument(models.Model):
    PRO, CON = "pro", "con"
    SIDE_CHOICES = [(PRO, "Pro"), (CON, "Con")]

    topic = models.ForeignKey(
        EthikosTopic, on_delete=models.CASCADE, related_name="arguments"
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="ethikos_arguments",
    )
    content = models.TextField()
    parent = models.ForeignKey(
        "self",
        null=True, blank=True,
        on_delete=models.CASCADE,
        related_name="replies",
    )
    side = models.CharField(
        max_length=3, choices=SIDE_CHOICES, null=True, blank=True
    )
    is_hidden = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [models.Index(fields=("topic",)), models.Index(fields=("user",))]
        ordering = ("created_at",)

    def __str__(self):
        return f"{self.user} on {self.topic}"

===== END konnaxion/ethikos/models.py =====


===== BEGIN konnaxion/ethikos/serializers.py =====
# backend/konnaxion/ethikos/serializers.py

from rest_framework import serializers
from .models import (
    EthikosCategory,
    EthikosTopic,
    EthikosStance,
    EthikosArgument,
)

__all__ = [
    "EthikosCategorySerializer",
    "EthikosTopicSerializer",
    "EthikosStanceSerializer",
    "EthikosArgumentSerializer",
]


class EthikosCategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = EthikosCategory
        fields = "__all__"
        read_only_fields = ("id",)


class EthikosTopicSerializer(serializers.ModelSerializer):
    # Représentation en lecture seule (objet imbriqué)…
    category = EthikosCategorySerializer(read_only=True)
    created_by = serializers.StringRelatedField(read_only=True)
    # …et champ d’entrée write-only pour la création/mise à jour.
    category_id = serializers.PrimaryKeyRelatedField(
        queryset=EthikosCategory.objects.all(),
        source="category",
        write_only=True,
        required=True,
    )

    class Meta:
        model = EthikosTopic
        fields = (
            "id",
            "title",
            "description",
            "category",        # read-only nested
            "category_id",     # write-only PK
            "expertise_category",
            "status",
            "total_votes",
            "created_by",
            "last_activity",
            "created_at",
        )
        read_only_fields = (
            "id",
            "created_by",
            "last_activity",
            "created_at",
            "total_votes",     # maintenu côté serveur
        )


class EthikosStanceSerializer(serializers.ModelSerializer):
    user = serializers.StringRelatedField(read_only=True)

    class Meta:
        model = EthikosStance
        fields = (
            "id",
            "user",
            "topic",     # PK par défaut, utilisable en écriture
            "value",
            "timestamp",
        )
        read_only_fields = ("id", "user", "timestamp")


class EthikosArgumentSerializer(serializers.ModelSerializer):
    user = serializers.StringRelatedField(read_only=True)
    # pour la lecture: on expose l'id du parent
    parent = serializers.PrimaryKeyRelatedField(read_only=True)
    # pour l'écriture: on accepte parent_id
    parent_id = serializers.PrimaryKeyRelatedField(
        queryset=EthikosArgument.objects.all(),
        source="parent",
        write_only=True,
        required=False,
        allow_null=True,
    )

    class Meta:
        model = EthikosArgument
        fields = (
            "id",
            "topic",         # PK par défaut
            "user",
            "content",
            "parent",        # read-only id
            "parent_id",     # write-only id
            "side",
            "is_hidden",
            "created_at",
            "updated_at",
        )
        read_only_fields = ("id", "user", "created_at", "updated_at")

    def validate(self, attrs):
        """
        Empêche d'attacher une réponse à un parent d'un autre topic.
        """
        topic = attrs.get("topic") or getattr(self.instance, "topic", None)
        parent = attrs.get("parent")
        if parent is not None and topic is not None and parent.topic_id != topic.id:
            raise serializers.ValidationError(
                {"parent_id": "Le parent appartient à un autre topic."}
            )
        return attrs

===== END konnaxion/ethikos/serializers.py =====


===== BEGIN konnaxion/ethikos/urls.py =====
# backend/konnaxion/ethikos/urls.py

from rest_framework.routers import DefaultRouter
from .api_views import TopicViewSet, StanceViewSet, ArgumentViewSet

# Optionnel : n'activer "categories" que si le ViewSet existe réellement.
try:
    from .api_views import CategoryViewSet  # type: ignore
    _HAS_CATEGORY = True
except Exception:
    _HAS_CATEGORY = False

router = DefaultRouter()
router.register(r"topics", TopicViewSet, basename="ethikos-topic")
router.register(r"stances", StanceViewSet, basename="ethikos-stance")
router.register(r"arguments", ArgumentViewSet, basename="ethikos-argument")

if _HAS_CATEGORY:
    router.register(r"categories", CategoryViewSet, basename="ethikos-category")

urlpatterns = router.urls

===== END konnaxion/ethikos/urls.py =====


===== BEGIN konnaxion/ethikos/views.py =====

# Create your views here.
# konnaxion/ethikos/api_views.py

from rest_framework import viewsets, permissions, mixins
from .models import EthikosTopic, EthikosStance, EthikosArgument
from .serializers import (
    EthikosTopicSerializer, EthikosStanceSerializer, EthikosArgumentSerializer
)

class TopicViewSet(viewsets.ModelViewSet):
    queryset = EthikosTopic.objects.all()
    serializer_class = EthikosTopicSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)

class StanceViewSet(mixins.CreateModelMixin,
                    mixins.UpdateModelMixin,
                    mixins.RetrieveModelMixin,
                    mixins.ListModelMixin,
                    viewsets.GenericViewSet):
    queryset = EthikosStance.objects.all()
    serializer_class = EthikosStanceSerializer
    permission_classes = [permissions.IsAuthenticated]

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

    def get_queryset(self):
        # List stances for the current topic or user
        topic_id = self.request.query_params.get("topic")
        qs = super().get_queryset()
        if topic_id:
            qs = qs.filter(topic_id=topic_id)
        return qs

class ArgumentViewSet(viewsets.ModelViewSet):
    queryset = EthikosArgument.objects.all()
    serializer_class = EthikosArgumentSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

===== END konnaxion/ethikos/views.py =====


===== BEGIN konnaxion/keenkonnect/__init__.py =====

===== END konnaxion/keenkonnect/__init__.py =====


===== BEGIN konnaxion/keenkonnect/admin.py =====
# template for konnaxion/<app>/admin.py
from django.contrib import admin
from django.apps import apps

app_config = apps.get_app_config(__name__.split(".")[-2])  # resolves to the app name
for model in app_config.get_models():
    if not admin.site.is_registered(model):
        admin.site.register(model)

===== END konnaxion/keenkonnect/admin.py =====


===== BEGIN konnaxion/keenkonnect/api_views.py =====
from rest_framework import viewsets, permissions
from rest_framework.decorators import action
from rest_framework.response import Response

from .models import Project, ProjectResource, ProjectTask, ProjectMessage, ProjectTeam, ProjectRating, Tag
from .serializers import (
    ProjectSerializer,
    ProjectResourceSerializer,
    ProjectTaskSerializer,
    ProjectMessageSerializer,
    ProjectTeamSerializer,
    ProjectRatingSerializer,
    TagSerializer,
)

class ProjectViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Projects (collaborative projects workspace).
    Provides list, retrieve, create, update, delete.
    Only authenticated users can create/update; read is open to all.
    """
    queryset = Project.objects.select_related("creator").prefetch_related("tags").all()
    serializer_class = ProjectSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["status", "category", "creator_id", "creator"]  # allow filtering by status, category, creator

    def perform_create(self, serializer):
        # Set the project creator to the logged-in user
        serializer.save(creator=self.request.user)

class ProjectResourceViewSet(viewsets.ModelViewSet):
    """
    ViewSet for ProjectResource files/links attached to a project.
    Allows CRUD on project resources. 
    Only authenticated users can upload/edit; anyone can read (if project is accessible).
    """
    queryset = ProjectResource.objects.select_related("project", "uploaded_by").all()
    serializer_class = ProjectResourceSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["project", "file_type"]

    def perform_create(self, serializer):
        # Set uploader to current user
        serializer.save(uploaded_by=self.request.user)

class ProjectTaskViewSet(viewsets.ModelViewSet):
    """
    ViewSet for ProjectTask (tasks within a project).
    Allows managing tasks (CRUD) for projects.
    Only authenticated can modify; read is open.
    Supports filtering by project, status, assignee.
    """
    queryset = ProjectTask.objects.select_related("project", "assignee").all()
    serializer_class = ProjectTaskSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["project", "status", "assignee"]

    def perform_create(self, serializer):
        # On create, ensure task is associated with a project (project must be provided in request data).
        # We do not set assignee automatically; if provided and valid, it will be used.
        serializer.save()

class ProjectMessageViewSet(viewsets.ModelViewSet):
    """
    ViewSet for ProjectMessage (project chat messages).
    Allows sending and viewing messages in project discussion threads.
    Only authenticated users can create messages; read access is open to authenticated (or read-only public if desired).
    """
    queryset = ProjectMessage.objects.select_related("project", "author").order_by("created_at").all()
    serializer_class = ProjectMessageSerializer
    # Assuming project messages are internal, require login to read and write:
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["project", "author"]

    def perform_create(self, serializer):
        # Set message author to current user
        serializer.save(author=self.request.user)

class ProjectTeamViewSet(viewsets.ModelViewSet):
    """
    ViewSet for ProjectTeam (project team membership).
    Provides team membership list and management (add/remove members).
    Only authenticated can modify (e.g., add themselves or others to teams); read is open to view project teams.
    Filtering by project or user is supported.
    """
    queryset = ProjectTeam.objects.select_related("project", "user").all()
    serializer_class = ProjectTeamSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["project", "user", "role"]

    def perform_create(self, serializer):
        # If a user adds themselves to a project or an owner adds a team member.
        # We ensure the joined_at is set automatically; user and project must be provided in request data.
        serializer.save()

    @action(detail=False, methods=["get"], permission_classes=[permissions.IsAuthenticated], url_path="my-teams")
    def my_teams(self, request):
        """
        Custom endpoint to list the current user's team memberships.
        Returns all ProjectTeam entries where user is the current user.
        """
        memberships = ProjectTeam.objects.select_related("project").filter(user=request.user)
        serializer = self.get_serializer(memberships, many=True)
        return Response(serializer.data)

class ProjectRatingViewSet(viewsets.ModelViewSet):
    """
    ViewSet for ProjectRating (community ratings on projects).
    Users can upvote/downvote a project (value = +1 or -1).
    Each user can rate a project once (unique per project & user).
    Only authenticated users can create/modify ratings; read is open to see ratings.
    """
    queryset = ProjectRating.objects.select_related("project", "user").all()
    serializer_class = ProjectRatingSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["project", "user"]

    def perform_create(self, serializer):
        # Assign the current user as the rater
        serializer.save(user=self.request.user)

class TagViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Tag objects (tags/keywords for projects and tasks).
    Allows listing all tags and creating new tags.
    Typically used for categorizing projects and tasks.
    """
    queryset = Tag.objects.all().order_by("name")
    serializer_class = TagSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["name"]
    # Allow searching tags by name substring
    from rest_framework import filters
    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    search_fields = ["name"]

===== END konnaxion/keenkonnect/api_views.py =====


===== BEGIN konnaxion/keenkonnect/apps.py =====
from django.apps import AppConfig


class KeenkonnectConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "konnaxion.keenkonnect"

===== END konnaxion/keenkonnect/apps.py =====


===== BEGIN konnaxion/keenkonnect/models.py =====
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

class Project(models.Model):
    class Status(models.TextChoices):
        IDEA = "idea", _("Idea")
        INPROGRESS = "progress", _("In progress")
        COMPLETED = "completed", _("Completed")
        VALIDATED = "validated", _("Validated")

    title = models.CharField(max_length=200)
    description = models.TextField()
    category = models.CharField(max_length=100)
    creator = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.PROTECT,
        related_name="created_projects",
    )
    status = models.CharField(
        max_length=10, choices=Status.choices, default=Status.IDEA
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    tags = models.ManyToManyField("Tag", blank=True, related_name="projects")

    class Meta:
        ordering = ("-created_at",)
        indexes = [models.Index(fields=("status", "category"))]

    def __str__(self):
        return self.title

def project_file_path(instance, filename):
    return f"projects/{instance.project_id}/{filename}"

class ProjectResource(models.Model):
    class FileType(models.TextChoices):
        IMAGE = "image", _("Image")
        DOC = "document", _("Document")
        MODEL_3D = "3d_model", _("3D model")
        OTHER = "other", _("Other")

    project = models.ForeignKey(Project, on_delete=models.CASCADE, related_name="resources")
    title = models.CharField(max_length=200, blank=True)
    description = models.TextField(blank=True)
    file = models.FileField(upload_to=project_file_path, blank=True, null=True)
    external_url = models.URLField(blank=True)
    file_type = models.CharField(max_length=15, choices=FileType.choices)
    uploaded_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True)
    uploaded_at = models.DateTimeField(auto_now_add=True)
    version = models.PositiveSmallIntegerField(default=1)
    converted_path = models.FileField(upload_to=project_file_path, blank=True, null=True)

    class Meta:
        ordering = ("-uploaded_at",)

class ProjectMessage(models.Model):
    project = models.ForeignKey(Project, on_delete=models.CASCADE, related_name="messages")
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ("created_at",)
        indexes = [models.Index(fields=("project", "created_at"))]

class ProjectTask(models.Model):
    class TaskStatus(models.TextChoices):
        TODO = "todo", _("To do")
        IN_PROGRESS = "doing", _("In progress")
        DONE = "done", _("Done")

    project = models.ForeignKey(Project, on_delete=models.CASCADE, related_name="tasks")
    title = models.CharField(max_length=200)
    description = models.TextField(blank=True)
    status = models.CharField(max_length=10, choices=TaskStatus.choices, default=TaskStatus.TODO)
    assignee = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    due_date = models.DateField(blank=True, null=True)
    order = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ("order", "created_at")
        indexes = [models.Index(fields=("project", "status"))]

class ProjectTeam(models.Model):
    class Role(models.TextChoices):
        OWNER = "owner", _("Owner")
        COLLABORATOR = "collaborator", _("Collaborator")
        MENTOR = "mentor", _("Mentor")

    project = models.ForeignKey(Project, on_delete=models.CASCADE, related_name="team_memberships")
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    role = models.CharField(max_length=15, choices=Role.choices, default=Role.COLLABORATOR)
    joined_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("project", "user")
        indexes = [models.Index(fields=("project", "role"))]

class ProjectRating(models.Model):
    project = models.ForeignKey(Project, on_delete=models.CASCADE, related_name="ratings")
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    value = models.SmallIntegerField(choices=[(1, "+1"), (-1, "-1")])
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("project", "user")
        indexes = [models.Index(fields=("project",))]

class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True)

    def __str__(self):
        return self.name

===== END konnaxion/keenkonnect/models.py =====


===== BEGIN konnaxion/keenkonnect/serializers.py =====
from rest_framework import serializers
from .models import Project, ProjectResource, ProjectTask, ProjectMessage, ProjectTeam, ProjectRating, Tag

# Exported classes for import elsewhere
__all__ = [
    "ProjectSerializer",
    "ProjectResourceSerializer",
    "ProjectTaskSerializer",
    "ProjectMessageSerializer",
    "ProjectTeamSerializer",
    "ProjectRatingSerializer",
    "TagSerializer",
]

class ProjectSerializer(serializers.ModelSerializer):
    """Serializer for collaborative Project objects."""
    # Display creator username/string, read-only (set in view)
    creator = serializers.StringRelatedField(read_only=True)
    # We include tags as primary key list (many-to-many). They will appear as a list of tag IDs.
    # created_at and updated_at are auto timestamps, set read-only
    class Meta:
        model = Project
        fields = "__all__"
        read_only_fields = ("creator", "created_at", "updated_at")

class ProjectResourceSerializer(serializers.ModelSerializer):
    """Serializer for ProjectResource (documents/files linked to a project)."""
    # Show uploader as string, assign in view on create
    uploaded_by = serializers.StringRelatedField(read_only=True)
    class Meta:
        model = ProjectResource
        fields = "__all__"
        read_only_fields = ("id", "uploaded_by", "uploaded_at", "version", "converted_path")

class ProjectTaskSerializer(serializers.ModelSerializer):
    """Serializer for a ProjectTask (to-do or milestone in a project)."""
    # Show assignee username if present
    assignee = serializers.StringRelatedField(read_only=True)
    class Meta:
        model = ProjectTask
        fields = "__all__"
        read_only_fields = ("id", "created_at")  # creator implicitly the project owner, created_at auto

class ProjectMessageSerializer(serializers.ModelSerializer):
    """Serializer for a ProjectMessage (chat message in a project thread)."""
    # Show author username, assign in view
    author = serializers.StringRelatedField(read_only=True)
    class Meta:
        model = ProjectMessage
        fields = "__all__"
        read_only_fields = ("id", "author", "created_at")

class ProjectTeamSerializer(serializers.ModelSerializer):
    """Serializer for ProjectTeam (project membership with role)."""
    # Show user and project names for context
    user = serializers.StringRelatedField(read_only=True)
    project = serializers.StringRelatedField(read_only=True)
    class Meta:
        model = ProjectTeam
        fields = "__all__"
        read_only_fields = ("id", "joined_at")

class ProjectRatingSerializer(serializers.ModelSerializer):
    """Serializer for ProjectRating (user rating/upvote on a project)."""
    # Show rater username, assign in view
    user = serializers.StringRelatedField(read_only=True)
    class Meta:
        model = ProjectRating
        fields = "__all__"
        read_only_fields = ("id", "user", "created_at")

class TagSerializer(serializers.ModelSerializer):
    """Serializer for Tag (keyword) objects."""
    class Meta:
        model = Tag
        fields = "__all__"
        # All fields (id and name) are included; name is unique. No special read_only needed.

===== END konnaxion/keenkonnect/serializers.py =====


===== BEGIN konnaxion/keenkonnect/views.py =====
from django.shortcuts import render

# Create your views here.

===== END konnaxion/keenkonnect/views.py =====


===== BEGIN konnaxion/kollective_intelligence/__init__.py =====

===== END konnaxion/kollective_intelligence/__init__.py =====


===== BEGIN konnaxion/kollective_intelligence/admin.py =====
from django.contrib import admin
from .models import ExpertiseCategory

@admin.register(ExpertiseCategory)
class ExpertiseCategoryAdmin(admin.ModelAdmin):
    search_fields = ("name",)
    list_display = ("name",)
    list_per_page = 30

# Register any other models generically if not already registered
from django.apps import apps
app_config = apps.get_app_config(__name__.split(".")[-2])
for model in app_config.get_models():
    if not admin.site.is_registered(model):
        admin.site.register(model)

===== END konnaxion/kollective_intelligence/admin.py =====


===== BEGIN konnaxion/kollective_intelligence/api_views.py =====
# konnaxion/kollective_intelligence/api_views.py

from rest_framework import permissions, viewsets

from .models import Vote, VoteResult
from .serializers import VoteSerializer, VoteResultSerializer


__all__ = [
    "VoteViewSet",
    "VoteResultViewSet",
]


class VoteViewSet(viewsets.ModelViewSet):
    """
    Smart‑Vote endpoint for raw + weighted ballots.

    Mounted via `config/api_router.py` as:

        /api/kollective/votes/

    Behaviour:

    - GET /api/kollective/votes/
        List votes, optionally filtered by:
          * target_type
          * target_id
          * user (username)

    - POST /api/kollective/votes/
        Create a new vote. The authenticated user is always
        set as `user` on the Vote model, regardless of payload.

    The serializer exposes:

      id, user (string), target_type, target_id,
      raw_value, weighted_value, voted_at
    """

    serializer_class = VoteSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        """
        Apply simple filters based on query params so the UI
        can request votes for a particular poll/target.

        Supported query params:
          - target_type
          - target_id
          - user (matches related User.username)
        """
        qs = Vote.objects.select_related("user").all()

        params = self.request.query_params

        target_type = params.get("target_type")
        if target_type:
            qs = qs.filter(target_type=target_type)

        target_id = params.get("target_id")
        if target_id:
            try:
                qs = qs.filter(target_id=int(target_id))
            except (TypeError, ValueError):
                # Ignore invalid target_id; return unfiltered by id
                pass

        username = params.get("user")
        if username:
            qs = qs.filter(user__username=username)

        return qs.order_by("-voted_at")

    def perform_create(self, serializer):
        """
        On creation, always associate the vote with the
        currently authenticated user.
        """
        serializer.save(user=self.request.user)


class VoteResultViewSet(viewsets.ReadOnlyModelViewSet):
    """
    Read‑only access to aggregated vote results, if you choose
    to expose them via the same app.

    Typical usage (future/optional):

        GET /api/kollective/vote-results/?target_type=...&target_id=...

    Not currently wired in `config/api_router.py`, but available
    for easy registration later.
    """

    serializer_class = VoteResultSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        qs = VoteResult.objects.all()
        params = self.request.query_params

        target_type = params.get("target_type")
        if target_type:
            qs = qs.filter(target_type=target_type)

        target_id = params.get("target_id")
        if target_id:
            try:
                qs = qs.filter(target_id=int(target_id))
            except (TypeError, ValueError):
                pass

        return qs.order_by("target_type", "target_id")

===== END konnaxion/kollective_intelligence/api_views.py =====


===== BEGIN konnaxion/kollective_intelligence/apps.py =====
from django.apps import AppConfig


class KollectiveIntelligenceConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "konnaxion.kollective_intelligence"

===== END konnaxion/kollective_intelligence/apps.py =====


===== BEGIN konnaxion/kollective_intelligence/models.py =====

# kollective_intelligence/models.py
from django.conf import settings
from django.db import models
from django.utils import timezone


# ────────────────────────────────
# Ekoh domain
# ────────────────────────────────

class ExpertiseCategory(models.Model):
    """Catalog of knowledge domains.”"""
    name = models.CharField(max_length=120, unique=True)

    def __str__(self):
        return self.name


class UserExpertiseScore(models.Model):
    """Current domain-specific expertise weight per user.”"""
    user = models.ForeignKey(settings.AUTH_USER_MODEL,
                             on_delete=models.CASCADE,
                             related_name="expertise_scores")
    category = models.ForeignKey(ExpertiseCategory,
                                 on_delete=models.CASCADE,
                                 related_name="user_scores")
    raw_score = models.DecimalField(max_digits=7, decimal_places=3)
    weighted_score = models.DecimalField(max_digits=7, decimal_places=3)

    class Meta:
        unique_together = ("user", "category")
        indexes = [models.Index(fields=["category", "-weighted_score"])]

    def __str__(self):
        return f"{self.user} – {self.category}: {self.weighted_score}"


class UserEthicsScore(models.Model):
    """Ethical multiplier influencing all expertise weights.”"""
    user = models.OneToOneField(settings.AUTH_USER_MODEL,
                                on_delete=models.CASCADE,
                                primary_key=True)
    ethical_score = models.DecimalField(max_digits=5, decimal_places=2)

    def __str__(self):
        return f"{self.user}: {self.ethical_score}"


class ScoreConfiguration(models.Model):
    """Stores named weight configurations (global or field-specific).”"""
    weight_name = models.CharField(max_length=64)
    weight_value = models.DecimalField(max_digits=6, decimal_places=3)
    field = models.CharField(max_length=64, blank=True, null=True)

    class Meta:
        unique_together = ("weight_name", "field")


class ContextAnalysisLog(models.Model):
    """Logs every AI adjustment applied to scores.”"""
    entity_type = models.CharField(max_length=40)
    entity_id = models.PositiveBigIntegerField()
    field = models.CharField(max_length=64)
    input_metadata = models.JSONField()
    adjustments_applied = models.JSONField()
    logged_at = models.DateTimeField(default=timezone.now)


class ConfidentialitySetting(models.Model):
    """Per-user anonymity preferences.”"""
    PUBLIC = "public"
    PSEUDONYM = "pseudonym"
    ANONYMOUS = "anonymous"
    LEVEL_CHOICES = [
        (PUBLIC, "Public"),
        (PSEUDONYM, "Pseudonym"),
        (ANONYMOUS, "Anonymous"),
    ]

    user = models.OneToOneField(settings.AUTH_USER_MODEL,
                                on_delete=models.CASCADE,
                                primary_key=True)
    level = models.CharField(max_length=10, choices=LEVEL_CHOICES,
                             default=PUBLIC)


class ScoreHistory(models.Model):
    """Keeps an audit trail of every score change.”"""
    merit_score = models.ForeignKey(UserExpertiseScore,
                                    on_delete=models.CASCADE,
                                    related_name="history")
    old_value = models.DecimalField(max_digits=7, decimal_places=3)
    new_value = models.DecimalField(max_digits=7, decimal_places=3)
    change_reason = models.CharField(max_length=255)
    changed_at = models.DateTimeField(default=timezone.now)


# ────────────────────────────────
# Smart Vote domain
# ────────────────────────────────

class Vote(models.Model):
    """Stores each raw and weighted vote.”"""
    user = models.ForeignKey(settings.AUTH_USER_MODEL,
                             on_delete=models.CASCADE,
                             related_name="votes")
    target_type = models.CharField(max_length=40)
    target_id = models.PositiveBigIntegerField()
    raw_value = models.DecimalField(max_digits=6, decimal_places=3)
    weighted_value = models.DecimalField(max_digits=6, decimal_places=3)
    voted_at = models.DateTimeField(default=timezone.now)

    class Meta:
        unique_together = ("user", "target_type", "target_id")


class VoteModality(models.Model):
    """Parameters for approval / ranking / rating, etc.”"""
    name = models.CharField(max_length=40, unique=True)
    parameters = models.JSONField()


class EmergingExpert(models.Model):
    """Flags fast-rising contributors.”"""
    user = models.ForeignKey(settings.AUTH_USER_MODEL,
                             on_delete=models.CASCADE,
                             related_name="emerging_expert_flags")
    detection_date = models.DateField(default=timezone.now)
    score_delta = models.DecimalField(max_digits=7, decimal_places=3)


class VoteResult(models.Model):
    """Aggregated weighted totals per target.”"""
    target_type = models.CharField(max_length=40)
    target_id = models.PositiveBigIntegerField()
    sum_weighted_value = models.DecimalField(max_digits=12, decimal_places=3)
    vote_count = models.PositiveIntegerField()

    class Meta:
        unique_together = ("target_type", "target_id")


class IntegrationMapping(models.Model):
    """Links Smart Vote to other modules / domain objects.”"""
    module_name = models.CharField(max_length=40)
    context_type = models.CharField(max_length=40)
    mapping_details = models.JSONField()

===== END konnaxion/kollective_intelligence/models.py =====


===== BEGIN konnaxion/kollective_intelligence/serializers.py =====
# konnaxion/kollective_intelligence/serializers.py
from rest_framework import serializers

from .models import (
    ExpertiseCategory,
    UserExpertiseScore,
    UserEthicsScore,
    ScoreConfiguration,
    ContextAnalysisLog,
    ConfidentialitySetting,
    ScoreHistory,
    Vote,
    VoteModality,
    EmergingExpert,
    VoteResult,
    IntegrationMapping,
)

__all__ = [
    "ExpertiseCategorySerializer",
    "UserExpertiseScoreSerializer",
    "UserEthicsScoreSerializer",
    "ScoreConfigurationSerializer",
    "ContextAnalysisLogSerializer",
    "ConfidentialitySettingSerializer",
    "ScoreHistorySerializer",
    "VoteSerializer",
    "VoteResultSerializer",
    "VoteModalitySerializer",
    "EmergingExpertSerializer",
    "IntegrationMappingSerializer",
]


# ────────────────────────────────
# Ekoh / reputation domain
# ────────────────────────────────


class ExpertiseCategorySerializer(serializers.ModelSerializer):
    """
    Simple catalogue of knowledge / expertise domains.
    """

    class Meta:
        model = ExpertiseCategory
        fields = "__all__"
        read_only_fields = ("id",)


class UserExpertiseScoreSerializer(serializers.ModelSerializer):
    """
    Current domain‑specific expertise weight per user.

    The `user` and `category` relations are exposed read‑only for display,
    while `category_id` is used for writes. The view is expected to inject
    the authenticated user on create/update.
    """

    user = serializers.StringRelatedField(read_only=True)
    category = ExpertiseCategorySerializer(read_only=True)
    category_id = serializers.PrimaryKeyRelatedField(
        source="category",
        queryset=ExpertiseCategory.objects.all(),
        write_only=True,
        required=True,
    )

    class Meta:
        model = UserExpertiseScore
        fields = (
            "id",
            "user",
            "category",
            "category_id",
            "raw_score",
            "weighted_score",
        )
        read_only_fields = ("id", "user")


class UserEthicsScoreSerializer(serializers.ModelSerializer):
    """
    Ethical multiplier influencing all expertise weights.
    """

    user = serializers.StringRelatedField(read_only=True)

    class Meta:
        model = UserEthicsScore
        fields = "__all__"
        read_only_fields = ("user",)


class ScoreConfigurationSerializer(serializers.ModelSerializer):
    """
    Named weight configuration (global or field‑specific).
    """

    class Meta:
        model = ScoreConfiguration
        fields = "__all__"
        read_only_fields = ("id",)


class ContextAnalysisLogSerializer(serializers.ModelSerializer):
    """
    Audit log of AI/context adjustments applied to scores.

    Exposed as read‑only; entries are intended to be created server‑side.
    """

    class Meta:
        model = ContextAnalysisLog
        fields = "__all__"
        read_only_fields = (
            "id",
            "entity_type",
            "entity_id",
            "field",
            "input_metadata",
            "adjustments_applied",
            "logged_at",
        )


class ConfidentialitySettingSerializer(serializers.ModelSerializer):
    """
    Per‑user anonymity / visibility preferences.
    """

    user = serializers.StringRelatedField(read_only=True)

    class Meta:
        model = ConfidentialitySetting
        fields = "__all__"
        read_only_fields = ("user",)


class ScoreHistorySerializer(serializers.ModelSerializer):
    """
    Immutable audit trail of expertise score changes.
    """

    merit_score = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = ScoreHistory
        fields = "__all__"
        read_only_fields = (
            "id",
            "merit_score",
            "old_value",
            "new_value",
            "change_reason",
            "changed_at",
        )


# ────────────────────────────────
# Smart Vote domain
# ────────────────────────────────


class VoteSerializer(serializers.ModelSerializer):
    """
    Serializer for Vote (individual vote record with raw and weighted values).
    """

    user = serializers.StringRelatedField(read_only=True)

    class Meta:
        model = Vote
        fields = "__all__"
        read_only_fields = ("id", "user", "voted_at")


class VoteResultSerializer(serializers.ModelSerializer):
    """
    Serializer for VoteResult (aggregated vote totals for a target object).

    Read‑only – these results are typically computed by background jobs
    or database queries, not created directly via the public API.
    """

    class Meta:
        model = VoteResult
        fields = "__all__"
        read_only_fields = ("id",)


class VoteModalitySerializer(serializers.ModelSerializer):
    """
    Serializer for VoteModality (definition of a voting mode and its parameters).
    """

    class Meta:
        model = VoteModality
        fields = "__all__"
        read_only_fields = ("id",)


class EmergingExpertSerializer(serializers.ModelSerializer):
    """
    Flags fast‑rising contributors in a given period.
    """

    user = serializers.StringRelatedField(read_only=True)

    class Meta:
        model = EmergingExpert
        fields = "__all__"
        read_only_fields = ("id", "user")


class IntegrationMappingSerializer(serializers.ModelSerializer):
    """
    Links Smart Vote / Ekoh context to other modules' objects.
    """

    class Meta:
        model = IntegrationMapping
        fields = "__all__"
        read_only_fields = ("id",)

===== END konnaxion/kollective_intelligence/serializers.py =====


===== BEGIN konnaxion/kollective_intelligence/views.py =====
from django.shortcuts import render

# Create your views here.

===== END konnaxion/kollective_intelligence/views.py =====


===== BEGIN konnaxion/konnected/__init__.py =====

===== END konnaxion/konnected/__init__.py =====


===== BEGIN konnaxion/konnected/admin.py =====
# backend/konnaxion/konnected/admin.py
from __future__ import annotations

from typing import Sequence

from django.apps import apps
from django.contrib import admin

from .models import (
    CertificationPath,
    CoCreationContribution,
    CoCreationProject,
    Evaluation,
    ForumPost,
    ForumTopic,
    InteropMapping,
    KnowledgeRecommendation,
    KnowledgeResource,
    LearningProgress,
    PeerValidation,
    Portfolio,
)


# ───────── Generic timestamp mixin (created_at / updated_at) ─────────
class TimestampMixin(admin.ModelAdmin):
    """
    Common admin behaviour for TimeStampedModel-based models:
    - expose created_at / updated_at as read-only
    - add them to list_display
    """
    date_hierarchy = "created_at"

    def _time_fields(self) -> set[str]:
        return {"created_at", "updated_at"} & {
            f.name for f in self.model._meta.get_fields()
        }

    def get_readonly_fields(self, request, obj=None) -> Sequence[str]:  # type: ignore[override]
        return (*super().get_readonly_fields(request, obj), *self._time_fields())

    def get_list_display(self, request):  # type: ignore[override]
        cols = list(super().get_list_display(request))
        for f in self._time_fields():
            if f not in cols:
                cols.append(f)
        return tuple(cols)


# ───────── CertifiKation sub-module ─────────
@admin.register(CertificationPath)
class CertificationPathAdmin(TimestampMixin):
    list_display = ("name", "description")
    search_fields = ("name", "description")
    ordering = ("name",)


@admin.register(Evaluation)
class EvaluationAdmin(TimestampMixin):
    list_display = ("user", "path", "raw_score", "created_at")
    list_filter = ("path",)
    search_fields = (
        "user__username",
        "path__name",
    )
    autocomplete_fields = ("user", "path")
    list_select_related = ("user", "path")
    ordering = ("-created_at",)


@admin.register(PeerValidation)
class PeerValidationAdmin(TimestampMixin):
    list_display = ("evaluation", "peer", "decision", "created_at")
    list_filter = ("decision",)
    search_fields = (
        "peer__username",
        "evaluation__id",
        "evaluation__path__name",
    )
    autocomplete_fields = ("evaluation", "peer")
    list_select_related = ("evaluation", "peer")


@admin.register(Portfolio)
class PortfolioAdmin(TimestampMixin):
    list_display = ("title", "user", "items_count", "created_at")
    search_fields = ("title", "user__username")
    autocomplete_fields = ("user",)
    filter_horizontal = ("items",)

    def items_count(self, obj: Portfolio) -> int:
        return obj.items.count()

    items_count.short_description = "Items"  # type: ignore[attr-defined]


@admin.register(InteropMapping)
class InteropMappingAdmin(TimestampMixin):
    list_display = ("local_certification", "external_system", "external_id")
    search_fields = (
        "external_system",
        "external_id",
        "local_certification__name",
    )
    autocomplete_fields = ("local_certification",)
    list_select_related = ("local_certification",)


# ───────── Knowledge sub-module ─────────
@admin.register(KnowledgeResource)
class KnowledgeResourceAdmin(TimestampMixin):
    list_display = ("title", "type", "url", "author", "created_at")
    list_filter = ("type",)
    search_fields = ("title", "url", "author__username")
    autocomplete_fields = ("author",)
    list_select_related = ("author",)


@admin.register(KnowledgeRecommendation)
class KnowledgeRecommendationAdmin(TimestampMixin):
    list_display = ("user", "resource", "recommended_at", "created_at")
    search_fields = ("user__username", "resource__title")
    autocomplete_fields = ("user", "resource")
    list_select_related = ("user", "resource")


@admin.register(LearningProgress)
class LearningProgressAdmin(TimestampMixin):
    list_display = ("user", "resource", "progress_percent", "created_at")
    search_fields = ("user__username", "resource__title")
    autocomplete_fields = ("user", "resource")
    list_select_related = ("user", "resource")


# ───────── Co‑Creation sub-module ─────────
@admin.register(CoCreationProject)
class CoCreationProjectAdmin(TimestampMixin):
    list_display = ("title", "status", "created_at")
    list_filter = ("status",)
    search_fields = ("title",)


@admin.register(CoCreationContribution)
class CoCreationContributionAdmin(TimestampMixin):
    list_display = ("project", "user", "short_content", "created_at")
    search_fields = ("content", "user__username", "project__title")
    autocomplete_fields = ("project", "user")
    list_select_related = ("project", "user")

    def short_content(self, obj: CoCreationContribution) -> str:
        text = obj.content or ""
        return (text[:60] + "…") if len(text) > 60 else text

    short_content.short_description = "Content"  # type: ignore[attr-defined]


# ───────── Forum sub-module ─────────
@admin.register(ForumTopic)
class ForumTopicAdmin(TimestampMixin):
    list_display = ("title", "category", "creator", "created_at")
    list_filter = ("category",)
    search_fields = ("title", "category", "creator__username")
    autocomplete_fields = ("creator",)
    list_select_related = ("creator",)


@admin.register(ForumPost)
class ForumPostAdmin(TimestampMixin):
    list_display = ("topic", "author", "short_content", "created_at")
    search_fields = ("content", "topic__title", "author__username")
    autocomplete_fields = ("topic", "author")
    list_select_related = ("topic", "author")

    def short_content(self, obj: ForumPost) -> str:
        text = obj.content or ""
        return (text[:60] + "…") if len(text) > 60 else text

    short_content.short_description = "Content"  # type: ignore[attr-defined]


# ───────── Fallback auto-registration ─────────
# Ensure any future models in this app still appear in the admin.
cfg = apps.get_app_config("konnected")
for mdl in cfg.get_models():
    if not admin.site.is_registered(mdl):
        admin.site.register(mdl)

===== END konnaxion/konnected/admin.py =====


===== BEGIN konnaxion/konnected/api_views.py =====
# konnaxion/konnected/api_views.py
from datetime import timedelta

from django.conf import settings
from django.utils import timezone
from rest_framework import permissions, status, viewsets
from rest_framework.decorators import action
from rest_framework.response import Response

from .models import (
    CertificationPath,
    Evaluation,
    KnowledgeResource,
    PeerValidation,
    Portfolio,
)
from .serializers import (
    CertificationPathSerializer,
    EvaluationSerializer,
    ExamAttemptSerializer,
    KnowledgeResourceSerializer,
    PeerValidationSerializer,
    PortfolioSerializer,
)

# ---------------------------------------------------------------------------
# Global parameters – aligned with v14 Global Parameter Reference
# ---------------------------------------------------------------------------

CERT_PASS_PERCENT: int = getattr(settings, "CERT_PASS_PERCENT", 80)
QUIZ_RETRY_COOLDOWN_MIN: int = getattr(settings, "QUIZ_RETRY_COOLDOWN_MIN", 30)


def _generate_synthetic_exam_sessions(now=None):
    """
    Helper for generating a small synthetic exam schedule.

    v14 does not yet define a persistent ExamSession model; both the
    CertificationPathViewSet.sessions action and the Evaluation
    registration logic use this helper so that the schedule is
    consistent across endpoints.

    Returns a list of dicts with:
        id, start_at, end_at, timezone, modality, location,
        capacity, seats_remaining, registration_deadline.
    """
    if now is None:
        now = timezone.now()

    base_start = now + timedelta(days=3)
    sessions = []
    for index in range(3):
        start = base_start + timedelta(days=7 * index)
        end = start + timedelta(hours=2)
        sessions.append(
            {
                "id": index + 1,
                "start_at": start.isoformat(),
                "end_at": end.isoformat(),
                "timezone": "UTC",
                "modality": "online",
                "location": "Remote proctored",
                "capacity": 25,
                "seats_remaining": 25,
                "registration_deadline": (start - timedelta(days=1)).isoformat(),
            }
        )
    return sessions


class KnowledgeResourceViewSet(viewsets.ModelViewSet):
    """
    CRUD endpoints for KonnectED knowledge-library items
    (video, document, course, other).

    The model follows v14 spec:
        id, title, type, url, author, created_at, updated_at
    """
    queryset = KnowledgeResource.objects.select_related("author")
    serializer_class = KnowledgeResourceSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def perform_create(self, serializer):
        # Record the authenticated user as the author
        serializer.save(author=self.request.user)


# ---------------------------------------------------------------------------
#  CertifiKation – Certification paths + exam attempts
# ---------------------------------------------------------------------------


class CertificationPathViewSet(viewsets.ModelViewSet):
    """
    CRUD endpoints for certification / learning paths.

    Base routes (mounted under /api/):

        GET  /konnected/certifications/paths/
        POST /konnected/certifications/paths/
        GET  /konnected/certifications/paths/{id}/
        ...

    Extra actions (for Exam Registration and Exam Preparation pages):

        GET /konnected/certifications/paths/{id}/eligibility/
        GET /konnected/certifications/paths/{id}/sessions/
        GET /konnected/certifications/paths/{id}/preparation-plan/
    """
    queryset = CertificationPath.objects.all().order_by("name")
    serializer_class = CertificationPathSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    @action(
        detail=True,
        methods=["get"],
        url_path="eligibility",
        permission_classes=[permissions.IsAuthenticated],
    )
    def eligibility(self, request, pk=None):
        """
        Returns a simple eligibility view for this certification path.

        Response shape matches ExamEligibility in the frontend:
            { "already_passed": bool, "cooldown_remaining_minutes": number }
        """
        path = self.get_object()
        user = request.user

        evaluations = (
            Evaluation.objects.filter(user=user, path=path)
            .order_by("-created_at")
        )

        already_passed = False
        cooldown_remaining = 0

        last_eval = evaluations.first()
        if last_eval is not None:
            score = last_eval.raw_score
            metadata = last_eval.metadata or {}
            pass_threshold = metadata.get("pass_percent", CERT_PASS_PERCENT)

            if score is not None and score >= pass_threshold:
                already_passed = True
            else:
                # Respect retry cooldown from the last attempt
                delta_minutes = (timezone.now() - last_eval.created_at).total_seconds() / 60.0
                if delta_minutes < QUIZ_RETRY_COOLDOWN_MIN:
                    cooldown_remaining = int(
                        max(0, round(QUIZ_RETRY_COOLDOWN_MIN - delta_minutes))
                    )

        return Response(
            {
                "already_passed": already_passed,
                "cooldown_remaining_minutes": cooldown_remaining,
            }
        )

    @action(
        detail=True,
        methods=["get"],
        url_path="preparation-plan",
        permission_classes=[permissions.IsAuthenticated],
    )
    def preparation_plan(self, request, pk=None):
        """
        Returns a lightweight exam preparation snapshot for this path.

        Response shape matches ExamPreparationResponse used by the
        Exam Preparation page in the frontend. For v14 this endpoint
        focuses on summarising exam attempts and cooldowns; study
        modules and focus areas are returned as empty lists until
        richer learning-path models are introduced.
        """
        path = self.get_object()
        user = request.user

        evaluations = (
            Evaluation.objects.filter(user=user, path=path)
            .order_by("-created_at")
        )
        last_eval = evaluations.first()

        if last_eval is not None:
            metadata = last_eval.metadata or {}

            score_percent = metadata.get("score_percent")
            if score_percent is None and last_eval.raw_score is not None:
                score_percent = float(last_eval.raw_score)

            pass_percent = metadata.get("pass_percent", CERT_PASS_PERCENT)

            last_result = None
            if score_percent is not None:
                last_result = "pass" if score_percent >= pass_percent else "fail"

            attempts_used = evaluations.count()
            attempts_allowed = metadata.get("attempts_allowed")

            cooldown_delta = timedelta(minutes=QUIZ_RETRY_COOLDOWN_MIN)
            cooldown_ends_at_dt = last_eval.created_at + cooldown_delta
            now = timezone.now()
            is_cooldown_active = now < cooldown_ends_at_dt
            cooldown_ends_at = (
                cooldown_ends_at_dt.isoformat() if is_cooldown_active else None
            )

            # When evaluation registrations come from the Exam Registration page,
            # we store an ISO target_date in metadata based on the chosen session.
            target_date = metadata.get("target_date")

            exam_payload = {
                "targetDate": target_date,
                "recommendedStudyHours": metadata.get("recommended_study_hours"),
                "lastScorePercent": score_percent,
                "lastResult": last_result,
                "lastAttemptAt": last_eval.created_at.isoformat(),
                "attemptsUsed": attempts_used,
                "attemptsAllowed": attempts_allowed,
                "isCooldownActive": is_cooldown_active,
                "cooldownEndsAt": cooldown_ends_at,
                "passPercent": pass_percent,
                "retryCooldownMinutes": QUIZ_RETRY_COOLDOWN_MIN,
            }
        else:
            # No attempts yet – still return exam metadata so the UI can
            # show thresholds and cooldown policy.
            exam_payload = {
                "targetDate": None,
                "recommendedStudyHours": None,
                "lastScorePercent": None,
                "lastResult": None,
                "lastAttemptAt": None,
                "attemptsUsed": 0,
                "attemptsAllowed": None,
                "isCooldownActive": False,
                "cooldownEndsAt": None,
                "passPercent": CERT_PASS_PERCENT,
                "retryCooldownMinutes": QUIZ_RETRY_COOLDOWN_MIN,
            }

        payload = {
            "path": {
                "id": path.pk,
                "name": path.name,
                "description": path.description,
            },
            # Study modules and focus areas are intentionally empty for now.
            # A future learning-path model can populate these without
            # changing the endpoint contract.
            "exam": exam_payload,
            "overallProgressPercent": None,
            "modules": [],
            "focusAreas": [],
        }
        return Response(payload)

    @action(
        detail=True,
        methods=["get"],
        url_path="sessions",
        permission_classes=[permissions.IsAuthenticated],
    )
    def sessions(self, request, pk=None):
        """
        Returns upcoming exam sessions for this certification path.

        v14 does not yet define a persistent ExamSession model, so this
        implementation returns a small synthetic schedule based on the
        current time. You can replace this with real DB-backed sessions
        later without changing the endpoint contract.
        """
        sessions = _generate_synthetic_exam_sessions()
        return Response(sessions)


class EvaluationViewSet(viewsets.ModelViewSet):
    """
    Stores exam / assessment attempts for certification paths.

    Base routes (mounted under /api/):

        GET  /konnected/certifications/evaluations/
        POST /konnected/certifications/evaluations/
        GET  /konnected/certifications/evaluations/{id}/
        ...

    The queryset is always scoped to the authenticated user.
    """
    serializer_class = EvaluationSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return Evaluation.objects.none()
        return (
            Evaluation.objects.filter(user=user)
            .select_related("path", "user")
            .order_by("-created_at")
        )

    def create(self, request, *args, **kwargs):
        """
        Custom create to map the Exam Registration payload into the model.

        The frontend (Exam Registration page) typically POSTs:

            {
              "path_id":        number,
              "session_id":     number,
              "full_name":      string,
              "agreed_terms":   boolean
            }

        We map:
            - user  ← request.user
            - path  ← CertificationPath(path_id)
            - raw_score ← 0.0 (exam not taken yet)
            - metadata ← remaining booking details
        """
        user = request.user
        data = request.data

        path_id = data.get("path_id")
        if not path_id:
            return Response(
                {"detail": "path_id is required."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        try:
            path = CertificationPath.objects.get(pk=path_id)
        except CertificationPath.DoesNotExist:
            return Response(
                {"detail": "Unknown certification path."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        session_id = data.get("session_id")
        target_date = None

        # Best-effort mapping of the chosen synthetic session to a target date.
        if session_id is not None:
            try:
                session_id_int = int(session_id)
            except (TypeError, ValueError):
                session_id_int = None

            if session_id_int is not None:
                for session in _generate_synthetic_exam_sessions():
                    if session["id"] == session_id_int:
                        target_date = session["start_at"]
                        break

        metadata = {
            "session_id": session_id,
            "full_name": data.get("full_name"),
            "agreed_terms": data.get("agreed_terms"),
            # Reasonable defaults that the dashboard and preparation page
            # can later read/override.
            "delivery_mode": "online",
            "proctored": True,
            "status": "scheduled",
        }

        if target_date is not None:
            metadata["target_date"] = target_date

        evaluation = Evaluation.objects.create(
            user=user,
            path=path,
            raw_score=0.0,
            metadata=metadata,
        )

        serializer = self.get_serializer(evaluation)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)


class PeerValidationViewSet(viewsets.ModelViewSet):
    """
    API for peer mentors to record validation decisions on evaluations.
    """
    serializer_class = PeerValidationSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return PeerValidation.objects.none()
        if user.is_staff:
            return PeerValidation.objects.all().select_related("evaluation", "peer")
        return PeerValidation.objects.filter(peer=user).select_related("evaluation", "peer")

    def perform_create(self, serializer):
        serializer.save(peer=self.request.user)


class PortfolioViewSet(viewsets.ModelViewSet):
    """
    CRUD endpoints for user skill portfolios (collections of KnowledgeResources).
    """
    serializer_class = PortfolioSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return Portfolio.objects.none()
        return Portfolio.objects.filter(user=user).prefetch_related("items")

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class ExamAttemptViewSet(viewsets.ViewSet):
    """
    Read-only endpoints backing the Exam Dashboard UI.

    This ViewSet does not map to a single model; instead it aggregates
    Evaluation + PeerValidation (and, optionally, certificates/portfolio)
    into ExamAttemptSerializer records.

    Mounted under /api/ as:

        GET /konnected/certifications/exam-attempts/
        GET /konnected/certifications/exam-attempts/me/
        GET /konnected/certifications/exam-attempts/{id}/
        POST /konnected/certifications/exam-attempts/{id}/appeal/
        POST /konnected/certifications/exam-attempts/{id}/retry/
    """
    permission_classes = [permissions.IsAuthenticated]

    def _build_attempt(self, evaluation: Evaluation, attempt_number: int) -> dict:
        metadata = evaluation.metadata or {}
        path = evaluation.path

        score_percent = metadata.get("score_percent")
        if score_percent is None and evaluation.raw_score is not None:
            score_percent = float(evaluation.raw_score)

        max_score = metadata.get("max_score")
        delivery_mode = metadata.get("delivery_mode", "online")
        proctored = bool(metadata.get("proctored", False))

        # Use per-evaluation pass threshold if present
        pass_threshold = metadata.get("pass_percent", CERT_PASS_PERCENT)

        status_value = metadata.get("status")
        if not status_value:
            # Derive a simple status when none is explicitly stored
            if score_percent is None or score_percent == 0:
                status_value = "scheduled"
            elif score_percent >= pass_threshold:
                status_value = "passed"
            else:
                status_value = "failed"

        peer_required = bool(metadata.get("peer_validation_required", False))

        peer_status = None
        if peer_required:
            peer_qs = PeerValidation.objects.filter(evaluation=evaluation)
            decisions = {pv.decision for pv in peer_qs}
            if "approved" in decisions:
                peer_status = "approved"
            elif "rejected" in decisions:
                peer_status = "rejected"
            elif decisions:
                peer_status = "pending"
            else:
                peer_status = "pending"

        appeal_status = metadata.get("appeal_status", "none")

        cooldown_delta = timedelta(minutes=QUIZ_RETRY_COOLDOWN_MIN)
        next_retry_at = evaluation.created_at + cooldown_delta
        now = timezone.now()
        can_retry = status_value != "passed" and now >= next_retry_at

        certificate_id = metadata.get("certificate_id")
        certificate_url = metadata.get("certificate_url")
        portfolio_item_id = metadata.get("portfolio_item_id")
        portfolio_url = metadata.get("portfolio_url")

        return {
            "id": str(evaluation.pk),
            "certificationPathId": str(path.pk),
            "certificationPathName": path.name,
            "attemptNumber": attempt_number,
            "takenAt": evaluation.created_at,
            "deliveryMode": delivery_mode,
            "proctored": proctored,
            "scorePercent": score_percent,
            "maxScore": max_score,
            "status": status_value,
            "peerValidationRequired": peer_required,
            "peerValidationStatus": peer_status,
            "appealStatus": appeal_status,
            "certificateId": certificate_id,
            "certificateUrl": certificate_url,
            "portfolioItemId": portfolio_item_id,
            "portfolioUrl": portfolio_url,
            "canRetry": can_retry,
            # Only expose a concrete nextRetryAt while cooldown is active
            "nextRetryAt": None if can_retry else next_retry_at,
        }

    def list(self, request):
        """
        Alias for `me()` – global listing of attempts for the current user.
        """
        return self.me(request)

    @action(detail=False, methods=["get"], url_path="me")
    def me(self, request):
        """
        Returns all exam attempts for the authenticated user across paths.

        Response shape matches the ExamDashboard `ExamAttemptsResponse`:
            { "attempts": ExamAttempt[] }
        """
        user = request.user
        evaluations = (
            Evaluation.objects.filter(user=user)
            .select_related("path")
            .order_by("path_id", "created_at", "pk")
        )

        attempts_payload = []
        attempt_counter_by_path: dict[int, int] = {}

        for evaluation in evaluations:
            path_id = evaluation.path_id
            attempt_counter_by_path[path_id] = attempt_counter_by_path.get(path_id, 0) + 1
            attempt_number = attempt_counter_by_path[path_id]
            attempts_payload.append(self._build_attempt(evaluation, attempt_number))

        serializer = ExamAttemptSerializer(attempts_payload, many=True)
        return Response({"attempts": serializer.data})

    def retrieve(self, request, pk=None):
        """
        Detailed view of a single exam attempt belonging to the current user.
        """
        user = request.user
        try:
            evaluation = (
                Evaluation.objects.select_related("path")
                .get(pk=pk, user=user)
            )
        except Evaluation.DoesNotExist:
            return Response(status=status.HTTP_404_NOT_FOUND)

        # Compute attempt number within this path
        ordered = (
            Evaluation.objects.filter(user=user, path=evaluation.path)
            .order_by("created_at", "pk")
        )
        attempt_number = 1
        for idx, ev in enumerate(ordered, start=1):
            if ev.pk == evaluation.pk:
                attempt_number = idx
                break

        payload = self._build_attempt(evaluation, attempt_number)
        serializer = ExamAttemptSerializer(payload)
        return Response(serializer.data)

    @action(detail=True, methods=["post"], url_path="appeal")
    def appeal(self, request, pk=None):
        """
        Lightweight stub for opening an appeal on an evaluation.

        For v14 we simply mark the evaluation's metadata and return
        the updated attempt. A richer workflow (notifications, tasks)
        can be layered on top later.
        """
        try:
            evaluation = Evaluation.objects.get(pk=pk, user=request.user)
        except Evaluation.DoesNotExist:
            return Response(status=status.HTTP_404_NOT_FOUND)

        metadata = evaluation.metadata or {}
        metadata["appeal_status"] = "open"
        evaluation.metadata = metadata
        evaluation.save(update_fields=["metadata", "updated_at"])

        return self.retrieve(request, pk=pk)

    @action(detail=True, methods=["post"], url_path="retry")
    def retry(self, request, pk=None):
        """
        Helper that creates a new scheduled Evaluation for the same path,
        subject to the configured cooldown.

        This is used by the Exam Dashboard "Retry" action.
        """
        try:
            source_eval = (
                Evaluation.objects.select_related("path")
                .get(pk=pk, user=request.user)
            )
        except Evaluation.DoesNotExist:
            return Response(status=status.HTTP_404_NOT_FOUND)

        metadata = source_eval.metadata or {}

        # Compute score_percent and pass threshold to determine if the exam is already passed
        score_percent = metadata.get("score_percent")
        if score_percent is None and source_eval.raw_score is not None:
            score_percent = float(source_eval.raw_score)
        pass_threshold = metadata.get("pass_percent", CERT_PASS_PERCENT)

        if score_percent is not None and score_percent >= pass_threshold:
            return Response(
                {"detail": "You cannot retry an exam that has already been passed."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        cooldown_delta = timedelta(minutes=QUIZ_RETRY_COOLDOWN_MIN)
        if timezone.now() < source_eval.created_at + cooldown_delta:
            return Response(
                {"detail": "Retry cooldown is still active for this exam."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        base_metadata = metadata
        new_metadata = {
            **base_metadata,
            "status": "scheduled",
            "is_retry": True,
        }

        new_eval = Evaluation.objects.create(
            user=request.user,
            path=source_eval.path,
            raw_score=0.0,
            metadata=new_metadata,
        )

        # Compute attempt number for the newly created evaluation
        ordered = (
            Evaluation.objects.filter(user=request.user, path=source_eval.path)
            .order_by("created_at", "pk")
        )
        attempt_number = 1
        for idx, ev in enumerate(ordered, start=1):
            if ev.pk == new_eval.pk:
                attempt_number = idx
                break

        payload = self._build_attempt(new_eval, attempt_number)
        serializer = ExamAttemptSerializer(payload)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

===== END konnaxion/konnected/api_views.py =====


===== BEGIN konnaxion/konnected/apps.py =====
from django.apps import AppConfig


class KonnectedConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "konnaxion.konnected"

===== END konnaxion/konnected/apps.py =====


===== BEGIN konnaxion/konnected/models.py =====
# backend/konnaxion/konnected/models.py
from django.conf import settings
from django.db import models


class TimeStampedModel(models.Model):
    """Adds created_at / updated_at to every table."""
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


# ──────────────────────────────
#  CertifiKation sub-module
# ──────────────────────────────
class CertificationPath(TimeStampedModel):
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)

    def __str__(self) -> str:
        return self.name


class Evaluation(TimeStampedModel):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    path = models.ForeignKey(CertificationPath, on_delete=models.CASCADE)
    raw_score = models.FloatField()
    metadata = models.JSONField()

    def __str__(self) -> str:
        return f"{self.user} – {self.path} ({self.raw_score})"


class PeerValidation(TimeStampedModel):
    class Decision(models.TextChoices):
        APPROVED = "approved", "Approved"
        REJECTED = "rejected", "Rejected"

    evaluation = models.ForeignKey(Evaluation, on_delete=models.CASCADE)
    peer = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    decision = models.CharField(max_length=8, choices=Decision.choices)

    def __str__(self) -> str:
        return f"{self.peer} → {self.evaluation} [{self.decision}]"


class Portfolio(TimeStampedModel):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    items = models.ManyToManyField(
        "KnowledgeResource",
        blank=True,
        related_name="portfolios",
    )

    def __str__(self) -> str:
        return self.title


class InteropMapping(TimeStampedModel):
    local_certification = models.ForeignKey(CertificationPath, on_delete=models.CASCADE)
    external_system = models.CharField(max_length=120)
    external_id = models.CharField(max_length=255)

    def __str__(self) -> str:
        return f"{self.external_system}:{self.external_id}"


# ──────────────────────────────
#  Knowledge sub-module
# ──────────────────────────────
class KnowledgeResource(TimeStampedModel):
    class ResourceType(models.TextChoices):
        VIDEO = "video", "Video"
        DOC = "doc", "Document"
        COURSE = "course", "Course"
        OTHER = "other", "Other"

    title = models.CharField(max_length=255)
    type = models.CharField(max_length=10, choices=ResourceType.choices)
    url = models.URLField()
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
    )

    def __str__(self) -> str:
        return self.title


class KnowledgeRecommendation(TimeStampedModel):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    resource = models.ForeignKey(KnowledgeResource, on_delete=models.CASCADE)
    recommended_at = models.DateTimeField()

    def __str__(self) -> str:
        return f"{self.user} ⇢ {self.resource}"


class LearningProgress(TimeStampedModel):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    resource = models.ForeignKey(KnowledgeResource, on_delete=models.CASCADE)
    progress_percent = models.DecimalField(max_digits=5, decimal_places=2)

    class Meta:
        unique_together = ("user", "resource")  # each user/resource pair only once

    def __str__(self) -> str:
        return f"{self.user} – {self.resource} ({self.progress_percent}%)"


# ──────────────────────────────
#  Offline content packaging
# ──────────────────────────────
class OfflinePackage(TimeStampedModel):
    """
    Represents an offline bundle of KonnectED resources.

    Backing model for the Offline Content page:
      app/konnected/learning-library/offline-content/page.tsx

    Fields map to the OfflinePackage type used by the frontend.
    """

    class Status(models.TextChoices):
        SCHEDULED = "scheduled", "Scheduled"
        BUILDING = "building", "Building"
        READY = "ready", "Ready"
        FAILED = "failed", "Failed"

    class TargetDeviceType(models.TextChoices):
        LAPTOP = "laptop", "Laptop / desktop"
        TABLET = "tablet", "Tablet"
        USB = "usb", "USB / external media"
        OTHER = "other", "Other / mixed devices"

    # Human-facing metadata
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)

    # Lifecycle and build state
    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.SCHEDULED,
    )
    item_count = models.PositiveIntegerField(
        default=0,
        help_text="Number of resources included in the last built bundle.",
    )
    total_size_mb = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        default=0,
        help_text="Approximate total bundle size in megabytes.",
    )
    last_built_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="When this package was last fully built.",
    )

    target_device_type = models.CharField(
        max_length=16,
        choices=TargetDeviceType.choices,
        blank=True,
        help_text="Intended primary device type, if any.",
    )
    auto_sync = models.BooleanField(
        default=False,
        help_text="If true, include in scheduled offline build jobs.",
    )
    build_progress_percent = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="Current build progress (0–100).",
    )
    last_error_message = models.TextField(
        blank=True,
        help_text="Last build error, if the package is in a failed state.",
    )

    # Selection filters / constraints (mirror CreateOfflinePackagePayload)
    max_size_mb = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="Optional upper bound for package size in MB.",
    )
    include_types = models.JSONField(
        null=True,
        blank=True,
        help_text="Optional list of content types to include (article, video, lesson, quiz, dataset).",
    )
    subject_filter = models.CharField(
        max_length=255,
        blank=True,
        help_text="Optional subject/topic filter applied when resolving resources.",
    )
    level_filter = models.CharField(
        max_length=255,
        blank=True,
        help_text="Optional difficulty/level filter.",
    )
    language_filter = models.CharField(
        max_length=32,
        blank=True,
        help_text="Optional language filter (e.g. 'en', 'fr').",
    )

    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="offline_packages",
        help_text="User who created this offline package definition.",
    )

    def __str__(self) -> str:
        return self.name


# ──────────────────────────────
#  Co-Creation sub-module
# ──────────────────────────────
class CoCreationProject(TimeStampedModel):
    class Status(models.TextChoices):
        DRAFT = "draft", "Draft"
        ACTIVE = "active", "Active"
        ARCHIVED = "archived", "Archived"

    title = models.CharField(max_length=255)
    status = models.CharField(
        max_length=8,
        choices=Status.choices,
        default=Status.DRAFT,
    )

    def __str__(self) -> str:
        return self.title


class CoCreationContribution(TimeStampedModel):
    project = models.ForeignKey(CoCreationProject, on_delete=models.CASCADE)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    content = models.TextField()

    def __str__(self) -> str:
        return f"{self.user} → {self.project}"


# ──────────────────────────────
#  Forum sub-module
# ──────────────────────────────
class ForumTopic(TimeStampedModel):
    title = models.CharField(max_length=255)
    category = models.CharField(max_length=120)
    creator = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self) -> str:
        return self.title


class ForumPost(TimeStampedModel):
    topic = models.ForeignKey(
        ForumTopic,
        on_delete=models.CASCADE,
        related_name="posts",
    )
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    content = models.TextField()

    def __str__(self) -> str:
        return f"{self.author} @ {self.topic}"

===== END konnaxion/konnected/models.py =====


===== BEGIN konnaxion/konnected/serializers.py =====
# konnaxion/konnected/serializers.py
from rest_framework import serializers

from .models import (
    CertificationPath,
    Evaluation,
    PeerValidation,
    Portfolio,
    KnowledgeResource,
)

__all__ = [
    "KnowledgeResourceSerializer",
    "CertificationPathSerializer",
    "EvaluationSerializer",
    "PeerValidationSerializer",
    "PortfolioSerializer",
    "ExamAttemptSerializer",
]


class KnowledgeResourceSerializer(serializers.ModelSerializer):
    """
    Serialises library items (video, doc, course…) defined by the
    KnowledgeResource model in v14.
    """

    author = serializers.StringRelatedField(read_only=True)

    class Meta:
        model = KnowledgeResource
        fields = "__all__"


class CertificationPathSerializer(serializers.ModelSerializer):
    """
    Minimal representation of a certification / learning path.

    v14 only stores basic metadata in the database (name, description…).
    Any extra fields used by the frontend (level, tags, KPIs) can be
    added later either as DB columns or via a CMS / enrichment layer.
    """

    class Meta:
        model = CertificationPath
        fields = "__all__"


class EvaluationSerializer(serializers.ModelSerializer):
    """
    Stores a single evaluation / exam attempt for a user on a path.

    The JSON `metadata` field is intentionally flexible and can contain:
        - delivery_mode, proctored, status
        - session_id, full_name, agreed_terms
        - score_percent, max_score
        - appeal_status, peer_validation_required, etc.
    """

    user = serializers.StringRelatedField(read_only=True)
    path = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = Evaluation
        fields = "__all__"
        read_only_fields = ("id", "user", "path", "created_at", "updated_at")


class PeerValidationSerializer(serializers.ModelSerializer):
    """
    Peer mentor validation on a given evaluation.
    """

    peer = serializers.StringRelatedField(read_only=True)
    evaluation = serializers.PrimaryKeyRelatedField(queryset=Evaluation.objects.all())

    class Meta:
        model = PeerValidation
        fields = "__all__"
        read_only_fields = ("id", "peer", "created_at", "updated_at")


class PortfolioSerializer(serializers.ModelSerializer):
    """
    User skill portfolio – curated collection of KnowledgeResources.
    """

    user = serializers.StringRelatedField(read_only=True)
    items = serializers.PrimaryKeyRelatedField(
        queryset=KnowledgeResource.objects.all(),
        many=True,
        required=False,
    )

    class Meta:
        model = Portfolio
        fields = "__all__"
        read_only_fields = ("id", "user", "created_at", "updated_at")


class ExamAttemptSerializer(serializers.Serializer):
    """
    Read-only projection used by the Exam Dashboard UI.

    This is *not* backed by a dedicated model; it aggregates data coming
    from Evaluation (+ PeerValidation, Portfolio / certificates) into a
    single flattened record.

    It matches the shape used in:
      app/konnected/certifications/exam-dashboard-results/page.tsx
    """

    id = serializers.CharField()
    certificationPathId = serializers.CharField()
    certificationPathName = serializers.CharField()
    attemptNumber = serializers.IntegerField()
    takenAt = serializers.DateTimeField()

    deliveryMode = serializers.CharField()
    proctored = serializers.BooleanField()

    scorePercent = serializers.FloatField(allow_null=True)
    maxScore = serializers.FloatField(allow_null=True, required=False)

    status = serializers.CharField()
    peerValidationRequired = serializers.BooleanField()
    peerValidationStatus = serializers.CharField(
        allow_null=True,
        required=False,
    )
    appealStatus = serializers.CharField(
        allow_null=True,
        required=False,
    )

    certificateId = serializers.CharField(
        allow_null=True,
        allow_blank=True,
        required=False,
    )
    certificateUrl = serializers.CharField(
        allow_null=True,
        allow_blank=True,
        required=False,
    )
    portfolioItemId = serializers.CharField(
        allow_null=True,
        allow_blank=True,
        required=False,
    )
    portfolioUrl = serializers.CharField(
        allow_null=True,
        allow_blank=True,
        required=False,
    )

    canRetry = serializers.BooleanField()
    nextRetryAt = serializers.DateTimeField(
        allow_null=True,
        required=False,
    )

===== END konnaxion/konnected/serializers.py =====


===== BEGIN konnaxion/konnected/tasks.py =====
# konnaxion/konnected/tasks.py
from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import Iterable, Sequence

from celery import shared_task
from django.conf import settings
from django.utils import timezone

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Optional imports – keep this module importable even before all models exist.
# ---------------------------------------------------------------------------

try:
    from .models import KnowledgeResource  # type: ignore[attr-defined]
except Exception:  # pragma: no cover - defensive import for early migrations
    KnowledgeResource = None  # type: ignore[assignment]

try:
    from .models import OfflinePackage  # type: ignore[attr-defined]
except Exception:  # pragma: no cover - model may not exist yet
    OfflinePackage = None  # type: ignore[assignment]


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _offline_root() -> Path:
    """
    Resolve the directory where offline exports/manifests are written.

    By default this is <MEDIA_ROOT>/offline_packages.
    """
    media_root = Path(getattr(settings, "MEDIA_ROOT", "."))
    base = media_root / "offline_packages"
    base.mkdir(parents=True, exist_ok=True)
    return base


def _serialize_resource(resource: object) -> dict:
    """
    Minimal serialisation of a KnowledgeResource for inclusion in offline bundles.

    The shape is intentionally simple and stable; the frontend's offline viewer
    can evolve independently as long as these core keys remain available.
    """
    created_at = getattr(resource, "created_at", None)
    updated_at = getattr(resource, "updated_at", None)

    return {
        "id": getattr(resource, "pk", None),
        "title": getattr(resource, "title", None),
        "type": getattr(resource, "type", None),
        "url": getattr(resource, "url", None),
        "author_id": getattr(resource, "author_id", None),
        "created_at": created_at.isoformat() if hasattr(created_at, "isoformat") else None,
        "updated_at": updated_at.isoformat() if hasattr(updated_at, "isoformat") else None,
    }


def _estimate_resource_size_mb(resource: object) -> float:
    """
    Best-effort size estimation for a resource, in megabytes.

    We look for a few commonly-used attributes; if none is present,
    we fall back to 0.0 to avoid over-counting.
    """
    candidates = (
        getattr(resource, "size_mb", None),
        getattr(resource, "sizeMb", None),
        getattr(resource, "bundle_size_mb", None),
        getattr(resource, "bundleSizeMb", None),
    )
    for value in candidates:
        if value is None:
            continue
        try:
            return float(value)
        except (TypeError, ValueError):
            continue
    return 0.0


def _safe_slug(value: str, fallback: str) -> str:
    """
    Very small, dependency-free slugifier for filenames.
    """
    value = (value or "").strip() or fallback
    slug_chars: list[str] = []
    for ch in value:
        slug_chars.append(ch.lower() if ch.isalnum() else "-")
    slug = "".join(slug_chars).strip("-")
    return slug or fallback


def _ensure_offline_package_model():
    """
    Return the OfflinePackage model or raise a clear error if it is missing.
    """
    if OfflinePackage is None:
        msg = (
            "OfflinePackage model is not available. "
            "Define the model in konnaxion.konnected.models and run migrations "
            "before using offline package tasks."
        )
        raise RuntimeError(msg)
    return OfflinePackage


def _select_resources_for_package(package: object) -> Iterable[object]:
    """
    Return an iterable of KnowledgeResource objects to include in a package.

    Selection is intentionally conservative so it remains safe while the schema
    evolves:

    - If KnowledgeResource is not available, returns an empty list.
    - Otherwise, starts from all resources ordered by id.
    - Optionally applies filters based on fields present on the OfflinePackage:
        * include_types / includeTypes  -> KnowledgeResource.type
        * subject_filter                -> KnowledgeResource.subject (if present)
        * level_filter                  -> KnowledgeResource.level (if present)
        * language_filter               -> KnowledgeResource.language (if present)

    Any filter whose corresponding field does not yet exist on the model is
    silently ignored.
    """
    if KnowledgeResource is None:
        return []

    qs = KnowledgeResource.objects.all().order_by("id")  # type: ignore[union-attr]

    # ---- Type filter -------------------------------------------------------
    include_types = getattr(package, "include_types", None) or getattr(
        package,
        "includeTypes",
        None,
    )
    if include_types:
        if isinstance(include_types, str):
            include_types_list = [t.strip() for t in include_types.split(",") if t.strip()]
        else:
            include_types_list = list(include_types)
        if include_types_list:
            try:
                qs = qs.filter(type__in=include_types_list)
            except Exception:
                # If the filter fails for any reason, fall back to the unfiltered qs.
                pass

    # ---- Subject / level / language filters (optional) --------------------
    # Only apply where both the package and model expose matching attributes.
    filters: dict[str, str] = {}
    for field, pkg_attr in (
        ("subject", "subject_filter"),
        ("level", "level_filter"),
        ("language", "language_filter"),
    ):
        value = getattr(package, pkg_attr, None)
        if value in (None, ""):
            continue
        if hasattr(KnowledgeResource, field):  # type: ignore[arg-type]
            filters[field] = value

    if filters:
        try:
            qs = qs.filter(**filters)
        except Exception:
            # Ignore filter errors and return the broader queryset.
            pass

    return qs


def _enforce_size_limit(resources: Sequence[object], max_size_mb: float | None) -> list[object]:
    """
    Apply an approximate max-size constraint to the given resources.

    If max_size_mb is None or <= 0, the input sequence is returned as a list.
    Otherwise, resources are accumulated until the size limit would be exceeded.
    """
    if max_size_mb is None or max_size_mb <= 0:
        return list(resources)

    selected: list[object] = []
    total = 0.0

    for res in resources:
        size = _estimate_resource_size_mb(res)
        # Always include at least the first resource, even if it exceeds the limit.
        if selected and total + size > max_size_mb:
            break
        selected.append(res)
        total += size

    return selected


def _write_package_manifest(package: object, resources: Sequence[object]) -> Path:
    """
    Write a JSON manifest for an OfflinePackage and return the file path.

    The manifest currently includes:
    - package metadata (id, name, filters)
    - generation timestamp
    - a list of serialised KnowledgeResource items
    """
    base_dir = _offline_root()
    package_id = getattr(package, "pk", "unknown")
    name = getattr(package, "name", "") or f"package-{package_id}"
    slug = _safe_slug(name, f"package-{package_id}")
    timestamp = timezone.now().strftime("%Y%m%d-%H%M%S")
    filename = f"offline_pkg_{slug}_{timestamp}.json"
    path = base_dir / filename

    package_meta = {
        "id": package_id,
        "name": getattr(package, "name", None),
        "description": getattr(package, "description", None),
        "target_device_type": getattr(package, "target_device_type", None)
        or getattr(package, "targetDeviceType", None),
        "max_size_mb": getattr(package, "max_size_mb", None)
        or getattr(package, "maxSizeMb", None),
        "include_types": list(
            getattr(package, "include_types", None)
            or getattr(package, "includeTypes", None)
            or [],
        ),
        "subject_filter": getattr(package, "subject_filter", None),
        "level_filter": getattr(package, "level_filter", None),
        "language_filter": getattr(package, "language_filter", None),
    }

    manifest = {
        "package": package_meta,
        "generated_at": timezone.now().isoformat(),
        "items": [_serialize_resource(res) for res in resources],
    }

    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        json.dump(manifest, f, ensure_ascii=False, indent=2)

    return path


def _update_package_resources(package: object, resources: Sequence[object]) -> None:
    """
    Attach the selected resources to the package via a ManyToMany relation, if present.

    Expected future schema: OfflinePackage.resources -> KnowledgeResource.m2m.
    If the relation does not exist yet, this is a no-op.
    """
    rel = getattr(package, "resources", None)
    if rel is None:
        # M2M relation not defined yet – nothing to do.
        return

    try:
        rel.set(resources)
    except Exception:
        logger.exception(
            "Failed to update resources for OfflinePackage #%s",
            getattr(package, "pk", "?"),
        )


def _set_package_status(
    package: object,
    *,
    status: str | None = None,
    progress: float | None = None,
    error: str | None = None,
    item_count: int | None = None,
    total_size_mb: float | None = None,
    last_built_at=None,
    bundle_path: Path | str | None = None,
) -> None:
    """
    Update common OfflinePackage fields in a defensive way.

    This helper deliberately avoids `update_fields` so it stays safe even if the
    exact field set changes; unknown attributes simply become transient and are
    ignored by the ORM.
    """
    if status is not None:
        setattr(package, "status", status)

    if progress is not None:
        setattr(package, "build_progress_percent", float(progress))

    if error is not None:
        setattr(package, "last_error_message", error)
    elif error is None and getattr(package, "last_error_message", None):
        # Clear stale errors on success.
        setattr(package, "last_error_message", None)

    if item_count is not None:
        setattr(package, "item_count", int(item_count))

    if total_size_mb is not None:
        setattr(package, "total_size_mb", float(total_size_mb))

    if last_built_at is not None:
        setattr(package, "last_built_at", last_built_at)

    if bundle_path is not None:
        setattr(package, "bundle_path", str(bundle_path))

    try:
        package.save()  # type: ignore[call-arg]
    except Exception:
        logger.exception(
            "Failed to save OfflinePackage #%s",
            getattr(package, "pk", "?"),
        )


# ---------------------------------------------------------------------------
# Celery tasks
# ---------------------------------------------------------------------------


@shared_task()
def export_knowledge_resources_for_offline() -> str:
    """
    Generate a JSON dump of all KnowledgeResource rows for offline use.

    The resulting file is written into <MEDIA_ROOT>/offline_packages and the
    absolute filesystem path is returned as the task result.
    """
    if KnowledgeResource is None:
        msg = "KnowledgeResource model not available; cannot export offline data."
        logger.warning(msg)
        return ""

    base_dir = _offline_root()
    timestamp = timezone.now().strftime("%Y%m%d-%H%M%S")
    out_path = base_dir / f"knowledge_resources_{timestamp}.json"

    items: list[dict] = []
    # Use iterator() to avoid loading everything into memory at once.
    qs = KnowledgeResource.objects.all().order_by("id")  # type: ignore[union-attr]
    for res in qs.iterator():
        items.append(_serialize_resource(res))

    payload = {
        "generated_at": timezone.now().isoformat(),
        "count": len(items),
        "items": items,
    }

    with out_path.open("w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)

    logger.info("Exported %s knowledge resources to %s", len(items), out_path)
    return str(out_path)


@shared_task()
def build_offline_package(package_id: int | str) -> dict:
    """
    Build or rebuild a single OfflinePackage.

    This task:
    - Resolves candidate KnowledgeResource rows according to the package filters.
    - Applies an optional maxSizeMb constraint.
    - Writes a JSON manifest for the bundle under <MEDIA_ROOT>/offline_packages.
    - Updates the package's status / counts / size metrics.

    The return value is a small summary dict suitable for logging or debugging.
    """
    model = _ensure_offline_package_model()

    try:
        package = model.objects.get(pk=package_id)  # type: ignore[attr-defined]
    except model.DoesNotExist:  # type: ignore[attr-defined]
        logger.error("OfflinePackage #%s does not exist; skipping build.", package_id)
        return {"id": package_id, "status": "missing"}

    logger.info(
        "Starting build for OfflinePackage #%s (%s)",
        getattr(package, "pk", None),
        getattr(package, "name", ""),
    )

    # Mark as building before doing any heavy work.
    _set_package_status(package, status="building", progress=0.0, error=None)

    if KnowledgeResource is None:
        error = "KnowledgeResource model not available; cannot build offline package."
        logger.error(error)
        _set_package_status(package, status="failed", progress=0.0, error=error)
        return {
            "id": getattr(package, "pk", package_id),
            "status": "failed",
            "error": error,
        }

    try:
        # Resolve candidate resources and optional max size.
        qs = _select_resources_for_package(package)
        max_size_raw = getattr(package, "max_size_mb", None) or getattr(
            package,
            "maxSizeMb",
            None,
        )
        try:
            max_size_value: float | None
            max_size_value = float(max_size_raw) if max_size_raw is not None else None
        except (TypeError, ValueError):
            max_size_value = None

        # Evaluate queryset and enforce size constraint (if any).
        resources = list(qs)
        resources = _enforce_size_limit(resources, max_size_value)

        total_size_mb = sum(_estimate_resource_size_mb(r) for r in resources)
        manifest_path = _write_package_manifest(package, resources)
        _update_package_resources(package, resources)

        now = timezone.now()
        _set_package_status(
            package,
            status="ready",
            progress=100.0,
            error=None,
            item_count=len(resources),
            total_size_mb=total_size_mb,
            last_built_at=now,
            bundle_path=manifest_path,
        )

        logger.info(
            "OfflinePackage #%s built successfully: %s items, %.2f MB (manifest: %s)",
            getattr(package, "pk", None),
            len(resources),
            total_size_mb,
            manifest_path,
        )

        return {
            "id": getattr(package, "pk", package_id),
            "status": getattr(package, "status", None),
            "item_count": len(resources),
            "total_size_mb": total_size_mb,
            "manifest_path": str(manifest_path),
        }

    except Exception as exc:  # pragma: no cover - defensive logging
        error = f"{exc.__class__.__name__}: {exc}"
        logger.exception(
            "Failed to build OfflinePackage #%s",
            getattr(package, "pk", package_id),
        )
        _set_package_status(
            package,
            status="failed",
            progress=0.0,
            error=error,
        )
        return {
            "id": getattr(package, "pk", package_id),
            "status": "failed",
            "error": error,
        }


@shared_task()
def build_offline_packages_for_auto_sync() -> int:
    """
    Enqueue builds for all OfflinePackage objects enrolled in automatic sync.

    This task is intended to be scheduled by Celery beat according to the
    OFFLINE_PACKAGE_CRON setting (see Global Parameter Reference).
    """
    model = OfflinePackage
    if model is None:
        logger.warning(
            "OfflinePackage model not available; auto-sync task has nothing to do.",
        )
        return 0

    qs = model.objects.all()  # type: ignore[union-attr]
    # Prefer packages explicitly opted into automatic sync.
    try:
        qs = qs.filter(auto_sync=True)
    except Exception:
        # If the field does not exist yet, fall back to all packages.
        pass

    # Avoid scheduling duplicate work for packages already building.
    try:
        qs = qs.exclude(status="building")
    except Exception:
        # If there is no status field, just proceed with the base queryset.
        pass

    count = 0
    for pkg in qs.iterator():
        build_offline_package.delay(pkg.pk)
        count += 1

    logger.info("Scheduled builds for %s auto-sync offline packages.", count)
    return count

===== END konnaxion/konnected/tasks.py =====


===== BEGIN konnaxion/konnected/views.py =====
from django.shortcuts import render

# Create your views here.

===== END konnaxion/konnected/views.py =====


===== BEGIN konnaxion/kreative/__init__.py =====

===== END konnaxion/kreative/__init__.py =====


===== BEGIN konnaxion/kreative/admin.py =====
# template for konnaxion/<app>/admin.py
from django.contrib import admin
from django.apps import apps

app_config = apps.get_app_config(__name__.split(".")[-2])  # resolves to the app name
for model in app_config.get_models():
    if not admin.site.is_registered(model):
        admin.site.register(model)

===== END konnaxion/kreative/admin.py =====


===== BEGIN konnaxion/kreative/api_views.py =====
from rest_framework import viewsets, permissions
from .models import KreativeArtwork, Gallery, CollabSession, TraditionEntry, Tag
from .serializers import (
    KreativeArtworkSerializer, GallerySerializer,
    CollabSessionSerializer, TraditionEntrySerializer, TagSerializer
)

class KreativeArtworkViewSet(viewsets.ModelViewSet):
    """
    ViewSet for KreativeArtwork (creative artworks uploaded by users).
    Users must be authenticated to list or create artworks (art content is members-only).
    """
    queryset = KreativeArtwork.objects.select_related("artist").prefetch_related("tags").all()
    serializer_class = KreativeArtworkSerializer
    permission_classes = [permissions.IsAuthenticated]  # Only logged-in users can view or upload artworks
    filterset_fields = ["artist", "media_type", "year"]

    def perform_create(self, serializer):
        # Set the artist (uploader) to current user
        serializer.save(artist=self.request.user)

class GalleryViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Gallery (collections of artworks).
    Galleries can be viewed by anyone; only authenticated users can create (curate) galleries.
    """
    queryset = Gallery.objects.select_related("created_by").prefetch_related("artworks").all()
    serializer_class = GallerySerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["created_by", "theme"]

    def perform_create(self, serializer):
        # Set the curator/creator of the gallery to current user
        serializer.save(created_by=self.request.user)

class CollabSessionViewSet(viewsets.ModelViewSet):
    """
    ViewSet for CollabSession (live collaboration sessions for artists).
    Allows listing ongoing or past sessions and starting new sessions.
    Auth required to create a session; reading sessions is allowed to all (to discover sessions).
    """
    queryset = CollabSession.objects.select_related("host", "final_artwork").all()
    serializer_class = CollabSessionSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["session_type", "host", "ended_at"]

    def perform_create(self, serializer):
        # Set the session host to the current user
        serializer.save(host=self.request.user)

class TraditionEntryViewSet(viewsets.ModelViewSet):
    """
    ViewSet for TraditionEntry (submissions of cultural traditions for preservation).
    Anyone can view approved tradition entries; authenticated users can submit new entries.
    """
    queryset = TraditionEntry.objects.select_related("submitted_by", "approved_by").all()
    serializer_class = TraditionEntrySerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["approved", "region", "submitted_by"]

    def perform_create(self, serializer):
        # Set the submitter to current user
        serializer.save(submitted_by=self.request.user)
        # Note: Approval fields are read-only. Approval is handled by admins separately.

class KreativeTagViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Tag in Kreative app (tags for artworks).
    Allows listing and creating tags for categorizing artworks.
    """
    queryset = Tag.objects.all().order_by("name")
    serializer_class = TagSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filterset_fields = ["name"]
    from rest_framework import filters
    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    search_fields = ["name"]

===== END konnaxion/kreative/api_views.py =====


===== BEGIN konnaxion/kreative/apps.py =====
from django.apps import AppConfig


class KreativeConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "konnaxion.kreative"

===== END konnaxion/kreative/apps.py =====


===== BEGIN konnaxion/kreative/models.py =====
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

# -- Simple reusable tag --
class Tag(models.Model):
    """
    Simple tagging table that can be reused by other apps.
    """
    name = models.CharField(max_length=64, unique=True)

    class Meta:
        verbose_name = _("Tag")
        verbose_name_plural = _("Tags")

    def __str__(self):
        return self.name

# -- Artwork and curation --
class KreativeArtwork(models.Model):
    """
    A single piece of art uploaded by a user.
    """
    class MediaType(models.TextChoices):
        IMAGE = "image", _("Image")
        VIDEO = "video", _("Video")
        AUDIO = "audio", _("Audio")
        OTHER = "other", _("Other")

    artist = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="artworks",
    )
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    media_file = models.FileField(upload_to="kreative/artworks/")
    media_type = models.CharField(
        max_length=10, choices=MediaType.choices, default=MediaType.IMAGE
    )
    year = models.PositiveIntegerField(null=True, blank=True)
    medium = models.CharField(max_length=120, blank=True)
    style = models.CharField(max_length=120, blank=True)
    tags = models.ManyToManyField(Tag, through="ArtworkTag", blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = _("Artwork")
        verbose_name_plural = _("Artworks")
        ordering = ["-created_at"]

    def __str__(self):
        return self.title

class ArtworkTag(models.Model):
    """
    Through-table for artwork <-> tag, for ManyToMany.
    """
    artwork = models.ForeignKey(KreativeArtwork, on_delete=models.CASCADE)
    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)

    class Meta:
        unique_together = ("artwork", "tag")

# -- Gallery and ordering --
class Gallery(models.Model):
    """
    A curated set of artworks.
    """
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="galleries_created",
    )
    theme = models.CharField(max_length=120, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    artworks = models.ManyToManyField(
        KreativeArtwork, through="GalleryArtwork", related_name="galleries"
    )

    class Meta:
        verbose_name = _("Gallery")
        verbose_name_plural = _("Galleries")
        ordering = ["-created_at"]

    def __str__(self):
        return self.title

class GalleryArtwork(models.Model):
    """
    Through-table giving order inside a gallery.
    """
    gallery = models.ForeignKey(Gallery, on_delete=models.CASCADE)
    artwork = models.ForeignKey(KreativeArtwork, on_delete=models.CASCADE)
    order = models.PositiveIntegerField(default=0)

    class Meta:
        unique_together = ("gallery", "artwork")
        ordering = ["order"]

# -- Co-creation room --
class CollabSession(models.Model):
    """
    Real-time co-creation room (painting, music, etc.).
    """
    SESSION_TYPES = [
        ("painting", _("Painting")),
        ("music", _("Music")),
        ("mixed", _("Mixed Media")),
    ]

    name = models.CharField(max_length=255)
    host = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="collab_sessions_hosted",
    )
    session_type = models.CharField(max_length=20, choices=SESSION_TYPES)
    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)
    final_artwork = models.ForeignKey(
        KreativeArtwork,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="created_in_sessions",
    )

    class Meta:
        verbose_name = _("Collaboration Session")
        verbose_name_plural = _("Collaboration Sessions")
        ordering = ["-started_at"]

# -- Cultural heritage/tradition entry --
class TraditionEntry(models.Model):
    """
    Cultural-heritage submission for Konservation archive.
    """
    REGION_MAX_LENGTH = 120

    title = models.CharField(max_length=255)
    description = models.TextField()
    region = models.CharField(max_length=REGION_MAX_LENGTH)  # could be ref-table later
    media_file = models.FileField(upload_to="kreative/traditions/")
    submitted_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="tradition_entries",
    )
    submitted_at = models.DateTimeField(auto_now_add=True)
    approved = models.BooleanField(default=False)
    approved_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="tradition_entries_approved",
    )
    approved_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        verbose_name = _("Tradition Entry")
        verbose_name_plural = _("Tradition Entries")
        ordering = ["-submitted_at"]

    def __str__(self):
        return self.title

# -- NEW: VirtualExhibition, DigitalArchive, ArchiveDocument, AICatalogueEntry, CulturalPartner --
class VirtualExhibition(models.Model):
    """
    Online curated show.
    """
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = _("Virtual Exhibition")
        verbose_name_plural = _("Virtual Exhibitions")

    def __str__(self):
        return self.name

class DigitalArchive(models.Model):
    """
    Stored artwork master entry (collection/archive).
    """
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    url = models.URLField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = _("Digital Archive")
        verbose_name_plural = _("Digital Archives")

    def __str__(self):
        return self.title

class ArchiveDocument(models.Model):
    """
    Documents linked to archives (e.g., image, PDF, scan).
    """
    archive = models.ForeignKey(DigitalArchive, on_delete=models.CASCADE, related_name="documents")
    document_type = models.CharField(max_length=64)
    url = models.URLField()
    metadata = models.JSONField(blank=True, default=dict)

    class Meta:
        verbose_name = _("Archive Document")
        verbose_name_plural = _("Archive Documents")

class AICatalogueEntry(models.Model):
    """
    AI-generated tags/classification for an archive document.
    """
    archive_document = models.ForeignKey(ArchiveDocument, on_delete=models.CASCADE, related_name="ai_entries")
    tags = models.JSONField(blank=True, default=list)
    classification = models.CharField(max_length=120, blank=True)

    class Meta:
        verbose_name = _("AI Catalogue Entry")
        verbose_name_plural = _("AI Catalogue Entries")

class CulturalPartner(models.Model):
    """
    Museum/heritage sources or partners.
    """
    name = models.CharField(max_length=255)
    type = models.CharField(max_length=64)
    contact_info = models.JSONField(blank=True, default=dict)

    class Meta:
        verbose_name = _("Cultural Partner")
        verbose_name_plural = _("Cultural Partners")

    def __str__(self):
        return self.name

===== END konnaxion/kreative/models.py =====


===== BEGIN konnaxion/kreative/serializers.py =====
from rest_framework import serializers
from .models import KreativeArtwork, Gallery, CollabSession, TraditionEntry, Tag

__all__ = [
    "KreativeArtworkSerializer",
    "GallerySerializer",
    "CollabSessionSerializer",
    "TraditionEntrySerializer",
    "TagSerializer",
]

class TagSerializer(serializers.ModelSerializer):
    """Serializer for Tag (artwork/tagging keyword)."""
    class Meta:
        model = Tag
        fields = "__all__"

class KreativeArtworkSerializer(serializers.ModelSerializer):
    """Serializer for KreativeArtwork (a creative artwork uploaded by a user)."""
    artist = serializers.StringRelatedField(read_only=True)
    # Embed tag details read-only: list tags with id and name
    tags = TagSerializer(many=True, read_only=True)
    class Meta:
        model = KreativeArtwork
        fields = "__all__"
        read_only_fields = ("id", "artist", "created_at")

class GallerySerializer(serializers.ModelSerializer):
    """Serializer for Gallery (a curated collection of artworks)."""
    created_by = serializers.StringRelatedField(read_only=True)
    # List artworks in the gallery with their details (read-only for output).
    artworks = KreativeArtworkSerializer(many=True, read_only=True)
    class Meta:
        model = Gallery
        fields = "__all__"
        read_only_fields = ("id", "created_by", "created_at")

class CollabSessionSerializer(serializers.ModelSerializer):
    """Serializer for CollabSession (real-time collaboration session for creatives)."""
    host = serializers.StringRelatedField(read_only=True)
    final_artwork = serializers.PrimaryKeyRelatedField(queryset=KreativeArtwork.objects.all(), allow_null=True, required=False)
    class Meta:
        model = CollabSession
        fields = "__all__"
        read_only_fields = ("id", "host", "started_at", "ended_at")

class TraditionEntrySerializer(serializers.ModelSerializer):
    """Serializer for TraditionEntry (cultural heritage submission for preservation)."""
    submitted_by = serializers.StringRelatedField(read_only=True)
    approved_by = serializers.StringRelatedField(read_only=True)
    class Meta:
        model = TraditionEntry
        fields = "__all__"
        read_only_fields = ("id", "submitted_by", "submitted_at", "approved", "approved_by", "approved_at")

===== END konnaxion/kreative/serializers.py =====


===== BEGIN konnaxion/kreative/views.py =====
from django.shortcuts import render

# Create your views here.

===== END konnaxion/kreative/views.py =====


===== BEGIN konnaxion/moderation/api_views.py =====
# backend/konnaxion/moderation/api_views.py
"""REST API for moderation and audit-log admin endpoints.

This module exposes three endpoints (to be wired in ``config/urls.py``):

    GET  /admin/moderation
    POST /admin/moderation/<id>
    GET  /admin/audit/logs

They are consumed by:

  - services/admin.fetchModerationQueue
  - services/admin.actOnReport
  - services/audit.fetchAuditLogs
  - the Ethikos / KonnectED admin moderation & audit UIs.
"""

from __future__ import annotations

from typing import Any

from django.db.models import Q
from django.shortcuts import get_object_or_404
from django.utils import timezone
from rest_framework import generics, permissions, status
from rest_framework import serializers as drf_serializers
from rest_framework.exceptions import ValidationError
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response
from rest_framework.views import APIView

from .models import AuditLogEntry, ModerationReport
from .serializers import ModerationReportSerializer


class IsModerationAdmin(permissions.BasePermission):
    """
    Permission class for moderation and audit endpoints.

    Default behaviour:
      - requires an authenticated user
      - and user.is_staff or user.is_superuser

    If you later introduce a dedicated "moderator" role or group,
    you can extend ``has_permission`` accordingly (e.g. check groups).
    """

    def has_permission(self, request, view) -> bool:  # type: ignore[override]
        user = request.user
        if not user or not user.is_authenticated:
            return False
        # Keep it simple and predictable: staff/superusers only by default
        return bool(getattr(user, "is_staff", False) or getattr(user, "is_superuser", False))


class ModerationQueueView(generics.ListAPIView):
    """
    GET /admin/moderation

    Returns the global moderation queue used by several frontends.

    Response shape is intentionally simple and stable::

        {
            "items": [
                {
                    "id": "...",
                    "content": "...",
                    "reporter": "...",
                    "type": "Spam" | "Harassment" | "Misinformation",
                    "status": "Pending" | "Resolved" | "Escalated",
                    ...  # optional richer fields
                },
                ...
            ]
        }

    The serializer can expose additional fields (targetType, targetId,
    severity, timestamps, etc.). Frontends are defensive and will
    gracefully consume whatever superset you provide.
    """

    serializer_class = ModerationReportSerializer
    permission_classes = [IsModerationAdmin]
    pagination_class = None  # return full queue, not paginated

    def get_queryset(self):
        qs = ModerationReport.objects.all()

        # Optional status filter: /admin/moderation?status=Pending
        status_param = self.request.query_params.get("status")
        if status_param and any(f.name == "status" for f in ModerationReport._meta.fields):
            qs = qs.filter(status=status_param)

        # Prefer created_at ordering if the field exists
        if any(f.name == "created_at" for f in ModerationReport._meta.fields):
            qs = qs.order_by("-created_at")
        else:
            qs = qs.order_by("-pk")

        return qs

    def list(self, request, *args, **kwargs) -> Response:  # type: ignore[override]
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        # Wrap into {items: [...]} to match services/admin.ModerationPayload
        return Response({"items": serializer.data})


class ModerationDecisionView(APIView):
    """
    POST /admin/moderation/<id>

    Body::

        { "remove": true | false }

    Semantics:
      - remove = true  → content should be removed/hidden, report resolved
      - remove = false → content is approved/kept, report resolved

    Frontends do not rely on a particular response body; a 2xx with
    empty content is sufficient. This view returns HTTP 204 on success.
    """

    permission_classes = [IsModerationAdmin]

    def post(self, request, pk: int, *args: Any, **kwargs: Any) -> Response:
        report = get_object_or_404(ModerationReport, pk=pk)

        if "remove" not in request.data:
            raise ValidationError({"remove": "This field is required."})

        remove = bool(request.data.get("remove"))

        # Always mark as resolved in the moderation queue.
        # Prefer a typed constant on the model if it exists.
        if hasattr(report, "status"):
            resolved_value = getattr(report, "STATUS_RESOLVED", None)
            if resolved_value is None:
                # Fallback to simple string value if no constant defined
                resolved_value = "Resolved"
            setattr(report, "status", resolved_value)

        # Optional bookkeeping fields on the model, if they exist.
        now = timezone.now()

        if hasattr(report, "last_action_at"):
            setattr(report, "last_action_at", now)

        if hasattr(report, "resolved_at"):
            setattr(report, "resolved_at", now)

        if hasattr(report, "resolved_by") and getattr(request.user, "is_authenticated", False):
            # type: ignore[assignment]
            setattr(report, "resolved_by", request.user)

        # If the domain model exposes a helper method to apply the decision
        # to the underlying target object, call it defensively.
        apply_fn = getattr(report, "apply_decision", None)
        if callable(apply_fn):
            # Recommended signature on the model::
            #   def apply_decision(self, *, remove: bool, actor: User | None) -> None: ...
            apply_fn(remove=remove, actor=request.user if request.user.is_authenticated else None)

        # Finally persist changes on the report itself.
        report.save()

        return Response(status=status.HTTP_204_NO_CONTENT)


# ---------------------------------------------------------------------------
# Audit-log API
# ---------------------------------------------------------------------------


class AuditLogEntrySerializer(drf_serializers.ModelSerializer):
    """
    Serializer aligned with services/audit.ts::LogRow.

    The only difference is that ``entityId`` is backed by the ``entity_id``
    model field.
    """

    entityId = drf_serializers.CharField(
        source="entity_id",
        required=False,
        allow_blank=True,
    )

    class Meta:
        model = AuditLogEntry
        fields = (
            "id",
            "ts",
            "actor",
            "action",
            "target",
            "severity",
            "entity",
            "entityId",
            "ip",
            "status",
            "meta",
        )
        read_only_fields = fields


class AuditLogPagination(PageNumberPagination):
    """
    Page-number pagination matching the admin audit UI contract.

    Query params:

      - ``page``     – 1‑based page index
      - ``pageSize`` – number of items per page (max 200)
    """

    page_query_param = "page"
    page_size_query_param = "pageSize"
    page_size = 20
    max_page_size = 200

    def get_paginated_response(self, data):
        assert self.request is not None  # for type checkers
        return Response(
            {
                "items": data,
                "page": self.page.number,
                "pageSize": self.get_page_size(self.request),
                "total": self.page.paginator.count,
            }
        )


class AuditLogListView(generics.ListAPIView):
    """
    GET /admin/audit/logs

    Paginated, filterable audit log stream used by the admin UI.

    Supported query params:

        page      – 1-based page index (default: 1)
        pageSize  – page size (default: 20, max: 200)
        q         – free-text search across actor, action, target, entity
        severity  – 'info' | 'warn' | 'critical'
        sort      – one of 'ts', '-ts', 'actor', '-actor',
                    'action', '-action', 'severity', '-severity',
                    'status', '-status'

    Response shape::

        {
            "items": [...],
            "page": <int>,
            "pageSize": <int>,
            "total": <int>
        }
    """

    serializer_class = AuditLogEntrySerializer
    permission_classes = [IsModerationAdmin]
    pagination_class = AuditLogPagination

    def get_queryset(self):
        qs = AuditLogEntry.objects.all()
        params = self.request.query_params

        severity = params.get("severity")
        if severity:
            qs = qs.filter(severity=severity)

        q = params.get("q")
        if q:
            qs = qs.filter(
                Q(actor__icontains=q)
                | Q(action__icontains=q)
                | Q(target__icontains=q)
                | Q(entity__icontains=q)
            )

        sort = params.get("sort") or "-ts"
        allowed_sorts = {
            "ts",
            "-ts",
            "actor",
            "-actor",
            "action",
            "-action",
            "severity",
            "-severity",
            "status",
            "-status",
        }
        if sort not in allowed_sorts:
            sort = "-ts"

        # Secondary order for deterministic pagination
        return qs.order_by(sort, "-id")

===== END konnaxion/moderation/api_views.py =====


===== BEGIN konnaxion/moderation/models.py =====
# backend/konnaxion/moderation/models.py
from __future__ import annotations

from typing import Any

from django.conf import settings
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.utils.translation import gettext_lazy as _


# ---------------------------------------------------------------------------
#  Enumerations
# ---------------------------------------------------------------------------


class ModerationTargetType(models.TextChoices):
    TOPIC = "topic", _("Topic")
    POST = "post", _("Post / argument")
    USER = "user", _("User")
    OTHER = "other", _("Other")


class ModerationStatus(models.TextChoices):
    # Values match what the Ethikos admin UI expects from the API
    PENDING = "Pending", _("Pending")
    RESOLVED = "Resolved", _("Resolved")
    ESCALATED = "Escalated", _("Escalated")


class ModerationSeverity(models.TextChoices):
    LOW = "low", _("Low")
    MEDIUM = "medium", _("Medium")
    HIGH = "high", _("High")


class ModerationReason(models.TextChoices):
    # Values match admin.services.Report["type"]
    SPAM = "Spam", _("Spam")
    HARASSMENT = "Harassment", _("Harassment")
    MISINFORMATION = "Misinformation", _("Misinformation")
    OTHER = "Other", _("Other")


class ModerationActionType(models.TextChoices):
    APPROVE = "approve", _("Approve content")
    REMOVE = "remove", _("Remove content")
    ESCALATE = "escalate", _("Escalate / flag")
    IGNORE = "ignore", _("Ignore / keep pending")


class AuditSeverity(models.TextChoices):
    # Matches services/audit.LogRow["severity"]
    INFO = "info", _("Info")
    WARN = "warn", _("Warning")
    CRITICAL = "critical", _("Critical")


class AuditStatus(models.TextChoices):
    # Matches services/audit.LogRow["status"]
    OK = "ok", _("OK")
    WARN = "warn", _("Warning")
    ERROR = "error", _("Error")


# ---------------------------------------------------------------------------
#  Moderation models
# ---------------------------------------------------------------------------


class ModerationCase(models.Model):
    """
    Canonical moderation queue entry, independent from the source system.

    This aggregates one or more user reports for the same target object.
    It is what you typically expose to `/admin/moderation` and adapt into
    the Ethikos moderation queue shape on the API layer.
    """

    # Optional generic relation to the moderated object (topic, argument, user, etc.)
    target_content_type = models.ForeignKey(
        ContentType,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="moderation_cases",
    )
    target_object_id = models.CharField(
        max_length=64,
        blank=True,
        help_text=_("Primary key of the moderated object, stored as text."),
    )
    target_object = GenericForeignKey("target_content_type", "target_object_id")

    # High-level identifiers expected by the frontend adapters
    target_type = models.CharField(
        max_length=16,
        choices=ModerationTargetType.choices,
        default=ModerationTargetType.POST,
        help_text=_("UI-level category of the moderated target (topic, post, user, …)."),
    )
    target_id = models.CharField(
        max_length=64,
        blank=True,
        help_text=_("External identifier exposed to frontends (argumentId, topicId, userId, …)."),
    )
    context_title = models.CharField(
        max_length=255,
        blank=True,
        help_text=_("Debate / consultation context, e.g. topic title."),
    )
    content_preview = models.TextField(
        blank=True,
        help_text=_("Short snapshot of the offending content for quick review."),
    )

    # Offender metadata
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="moderation_cases_authored",
    )
    author_name = models.CharField(
        max_length=255,
        blank=True,
        help_text=_("Cached author label for admin views."),
    )

    # Queue state
    status = models.CharField(
        max_length=16,
        choices=ModerationStatus.choices,
        default=ModerationStatus.PENDING,
        db_index=True,
    )
    severity = models.CharField(
        max_length=8,
        choices=ModerationSeverity.choices,
        default=ModerationSeverity.MEDIUM,
        db_index=True,
    )
    report_count = models.PositiveIntegerField(
        default=0,
        help_text=_("Denormalized number of merged user reports for this case."),
    )

    # Governance metadata
    source = models.CharField(
        max_length=64,
        blank=True,
        help_text=_("Originating app or module (e.g. 'ethikos', 'keenkonnect')."),
    )
    created_at = models.DateTimeField(auto_now_add=True)
    last_action_at = models.DateTimeField(auto_now=True)

    last_moderated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="moderation_cases_moderated",
    )

    class Meta:
        ordering = ("-created_at",)
        indexes = [
            models.Index(fields=("status", "severity")),
            models.Index(fields=("target_type", "target_id")),
            models.Index(fields=("created_at",)),
        ]
        verbose_name = _("Moderation case")
        verbose_name_plural = _("Moderation cases")

    def __str__(self) -> str:
        snippet = (self.content_preview[:40] + "…") if self.content_preview else f"#{self.pk}"
        ctx = self.context_title or snippet
        return f"[{self.status}] {ctx}"

    def recalculate_report_count(self, *, commit: bool = True) -> int:
        """
        Recompute `report_count` from the related ModerationReport rows.
        Call this from admin actions or signals if you change reports in bulk.
        """
        count = self.reports.count()
        self.report_count = count
        if commit:
            self.save(update_fields=["report_count"])
        return count


class ModerationReport(models.Model):
    """
    Individual user report that feeds a ModerationCase.

    This is the canonical storage for `/report` endpoints from any module
    (Ethikos debates, consultations, project messages, …).
    """

    case = models.ForeignKey(
        ModerationCase,
        on_delete=models.CASCADE,
        related_name="reports",
    )

    reporter = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="moderation_reports",
    )
    reporter_name = models.CharField(
        max_length=255,
        blank=True,
        help_text=_("Cached reporter label for admin views."),
    )

    type = models.CharField(
        max_length=32,
        choices=ModerationReason.choices,
        default=ModerationReason.SPAM,
        help_text=_("Primary moderation reason label."),
    )
    message = models.TextField(
        blank=True,
        help_text=_("Optional free-text notes supplied by the reporter."),
    )

    meta = models.JSONField(
        blank=True,
        default=dict,
        help_text=_("Arbitrary JSON payload with source-specific details."),
    )
    ip_address = models.GenericIPAddressField(
        null=True,
        blank=True,
        help_text=_("Source IP address of the reporter, if tracked."),
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ("-created_at",)
        indexes = [
            models.Index(fields=("type",)),
            models.Index(fields=("created_at",)),
        ]
        verbose_name = _("Moderation report")
        verbose_name_plural = _("Moderation reports")

    def __str__(self) -> str:
        return f"{self.get_type_display()} on case #{self.case_id}"


class ModerationAction(models.Model):
    """
    Moderator decision attached to a ModerationCase.

    You can use this to drive the queue (approve/remove/escalate) and
    optionally link it to an AuditLogEntry for full traceability.
    """

    case = models.ForeignKey(
        ModerationCase,
        on_delete=models.CASCADE,
        related_name="actions",
    )
    moderator = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="moderation_actions",
    )
    action = models.CharField(
        max_length=16,
        choices=ModerationActionType.choices,
    )
    notes = models.TextField(
        blank=True,
        help_text=_("Optional internal notes from the moderator."),
    )
    created_at = models.DateTimeField(auto_now_add=True)

    audit_entry = models.ForeignKey(
        "AuditLogEntry",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="moderation_actions",
        help_text=_("Optional link to the audit log entry for this decision."),
    )

    class Meta:
        ordering = ("-created_at",)
        verbose_name = _("Moderation action")
        verbose_name_plural = _("Moderation actions")

    def __str__(self) -> str:
        return f"{self.get_action_display()} on case #{self.case_id}"


# ---------------------------------------------------------------------------
#  Audit log model
# ---------------------------------------------------------------------------


class AuditLogEntry(models.Model):
    """
    Canonical audit log entry used by Ethikos admin and other apps.

    It is intentionally aligned with `services/audit.ts`'s `LogRow`:
      - `id`       → primary key
      - `ts`       → timestamp
      - `actor`    → denormalised actor label
      - `action`   → logical action identifier
      - `target`   → human-readable context
      - `severity` → 'info' | 'warn' | 'critical'
      - `entity`   → machine entity type (topic, argument, user, …)
      - `entityId` → comes from `entity_id` here
      - `ip`       → source IP
      - `status`   → 'ok' | 'warn' | 'error'
      - `meta`     → JSON blob
    """

    ts = models.DateTimeField(
        auto_now_add=True,
        db_index=True,
        help_text=_("Timestamp when the event occurred."),
    )

    # Optional structured link to the actor
    actor_user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="audit_entries",
        help_text=_("Optional link to the user that triggered the event."),
    )
    actor = models.CharField(
        max_length=255,
        blank=True,
        help_text=_("Denormalized actor label exposed in the API."),
    )

    action = models.CharField(
        max_length=128,
        help_text=_("Logical action identifier, e.g. 'UPDATE_TOPIC'."),
    )
    target = models.CharField(
        max_length=255,
        blank=True,
        help_text=_("Human-readable target used in the admin UI."),
    )

    entity = models.CharField(
        max_length=64,
        blank=True,
        help_text=_("Machine-oriented entity type, e.g. 'topic', 'argument', 'user'."),
    )
    entity_id = models.CharField(
        max_length=64,
        blank=True,
        help_text=_("Primary key of the entity in the source system, stored as text."),
    )

    # Optional generic FK to the underlying object
    entity_content_type = models.ForeignKey(
        ContentType,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="audit_entries",
    )
    entity_object_id = models.CharField(
        max_length=64,
        blank=True,
    )
    entity_object = GenericForeignKey("entity_content_type", "entity_object_id")

    severity = models.CharField(
        max_length=10,
        choices=AuditSeverity.choices,
        default=AuditSeverity.INFO,
        db_index=True,
    )
    status = models.CharField(
        max_length=10,
        choices=AuditStatus.choices,
        default=AuditStatus.OK,
        db_index=True,
    )
    ip = models.GenericIPAddressField(
        null=True,
        blank=True,
        help_text=_("Source IP address, if available."),
    )
    meta = models.JSONField(
        blank=True,
        default=dict,
        help_text=_("Free-form JSON payload with extra context for the event."),
    )

    class Meta:
        ordering = ("-ts",)
        indexes = [
            models.Index(fields=("ts",)),
            models.Index(fields=("severity",)),
            models.Index(fields=("status",)),
            models.Index(fields=("entity", "entity_id")),
        ]
        verbose_name = _("Audit log entry")
        verbose_name_plural = _("Audit log entries")

    def __str__(self) -> str:
        return f"{self.ts.isoformat()} {self.action}"

    def save(self, *args: Any, **kwargs: Any) -> None:
        """
        Ensure `actor` is filled when a structured `actor_user` exists.
        """
        if self.actor_user and not self.actor:
            # Prefer get_username() when available
            get_username = getattr(self.actor_user, "get_username", None)
            self.actor = get_username() if callable(get_username) else str(self.actor_user)
        super().save(*args, **kwargs)

    @classmethod
    def log(
        cls,
        *,
        actor_user: Any | None = None,
        actor: str | None = None,
        action: str,
        target: str | None = None,
        entity: str | None = None,
        entity_id: str | int | None = None,
        severity: AuditSeverity | str = AuditSeverity.INFO,
        status: AuditStatus | str = AuditStatus.OK,
        ip: str | None = None,
        meta: dict[str, Any] | None = None,
    ) -> "AuditLogEntry":
        """
        Convenience helper to create an audit entry from application code.

        Example::

            AuditLogEntry.log(
                actor_user=request.user,
                action="UPDATE_TOPIC",
                target=topic.title,
                entity="topic",
                entity_id=topic.pk,
                severity=AuditSeverity.INFO,
                status=AuditStatus.OK,
                meta={"topic_id": topic.pk},
            )
        """
        if entity_id is not None and not isinstance(entity_id, str):
            entity_id = str(entity_id)

        entry = cls(
            actor_user=actor_user,
            actor=actor or "",
            action=action,
            target=target or "",
            entity=entity or "",
            entity_id=entity_id or "",
            severity=severity,
            status=status,
            ip=ip,
            meta=meta or {},
        )
        entry.save()
        return entry

===== END konnaxion/moderation/models.py =====


===== BEGIN konnaxion/moderation/serializers.py =====
# backend/konnaxion/moderation/serializers.py

from __future__ import annotations

from rest_framework import serializers

from .models import AuditLogEntry, ModerationReport


__all__ = [
    "ModerationReportSerializer",
    "ModerationActionSerializer",
    "AuditLogEntrySerializer",
]


class ModerationReportSerializer(serializers.ModelSerializer):
    """
    Serializer used by the admin moderation UIs.

    It exposes both:
      - the original minimal moderation shape used by services/admin.Report
        (id, content, reporter, type, status)
      - richer fields consumed by the newer Ethikos/KonnectED moderation pages.

    The underlying DB model is ModerationReport, but many queue-related
    fields are denormalised on the related ModerationCase and exposed here
    via `source="case.*"`.
    """

    # ------------------------------------------------------------------
    # Legacy Admin UI shape (services/admin.Report)
    # ------------------------------------------------------------------

    # Short preview of the offending content, taken from the ModerationCase.
    content = serializers.CharField(
        source="case.content_preview",
        read_only=True,
    )

    # Primary moderation reason; matches ModerationReason values
    # ("Spam", "Harassment", "Misinformation", …).
    type = serializers.CharField()

    # Queue-level state and severity from the ModerationCase.
    status = serializers.CharField(source="case.status", read_only=True)
    severity = serializers.CharField(source="case.severity", read_only=True)

    # Human-readable relations
    reporter = serializers.StringRelatedField(read_only=True)
    author = serializers.StringRelatedField(source="case.author", read_only=True)

    # High-level identifiers from the ModerationCase
    target_type = serializers.CharField(source="case.target_type", read_only=True)
    target_id = serializers.CharField(source="case.target_id", read_only=True)

    created_at = serializers.DateTimeField(source="case.created_at", read_only=True)
    # Backwards-compatible alias: some code expects `updated_at`; we map it
    # to the last moderation action timestamp on the case.
    updated_at = serializers.DateTimeField(source="case.last_action_at", read_only=True)

    # ------------------------------------------------------------------
    # CamelCase aliases for Ethikos / KonnectED adapters
    # ------------------------------------------------------------------

    targetType = serializers.CharField(source="case.target_type", read_only=True)
    targetId = serializers.CharField(source="case.target_id", read_only=True)

    createdAt = serializers.DateTimeField(source="case.created_at", read_only=True)
    lastActionAt = serializers.DateTimeField(source="case.last_action_at", read_only=True)

    reporterName = serializers.SerializerMethodField()
    authorName = serializers.SerializerMethodField()

    # Some adapters look at `reason` while others use `type`.
    # Expose both; they are the same logical field.
    reason = serializers.CharField(source="type", read_only=True)

    # Reporter free-text message / notes (stored on ModerationReport)
    reporterMessage = serializers.CharField(
        source="message",
        allow_blank=True,
        required=False,
    )

    # Denormalised number of merged reports for this case
    reportCount = serializers.IntegerField(
        source="case.report_count",
        read_only=True,
        default=1,
    )

    class Meta:
        model = ModerationReport
        fields = (
            # Core moderation payload expected by services/admin.Report
            "id",
            "content",
            "reporter",
            "type",
            "status",
            # Extended queue metadata
            "reason",
            "severity",
            "message",
            "author",
            "target_type",
            "target_id",
            "created_at",
            "updated_at",
            # Aliases / enriched fields for richer UIs
            "targetType",
            "targetId",
            "createdAt",
            "lastActionAt",
            "reporterName",
            "authorName",
            "reporterMessage",
            "reportCount",
        )
        read_only_fields = (
            "id",
            "status",
            "severity",
            "reporter",
            "author",
            "target_type",
            "target_id",
            "created_at",
            "updated_at",
            "targetType",
            "targetId",
            "createdAt",
            "lastActionAt",
            "reportCount",
        )

    # ------------------------------------------------------------------
    # Name helpers
    # ------------------------------------------------------------------

    def get_reporterName(self, obj: ModerationReport) -> str:
        """
        Prefer the cached reporter_name if present,
        otherwise derive from the related User.
        """
        if getattr(obj, "reporter_name", ""):
            return obj.reporter_name

        user = getattr(obj, "reporter", None)
        if user is None:
            return ""

        name = getattr(user, "name", None)
        if name:
            return name

        get_username = getattr(user, "get_username", None)
        if callable(get_username):
            return get_username() or str(user)

        return str(user)

    def get_authorName(self, obj: ModerationReport) -> str:
        """
        Prefer the cached author_name on the ModerationCase if present,
        otherwise derive from the related author User.
        """
        case = getattr(obj, "case", None)
        if case is None:
            return ""

        if getattr(case, "author_name", ""):
            return case.author_name

        user = getattr(case, "author", None)
        if user is None:
            return ""

        name = getattr(user, "name", None)
        if name:
            return name

        get_username = getattr(user, "get_username", None)
        if callable(get_username):
            return get_username() or str(user)

        return str(user)


class ModerationActionSerializer(serializers.Serializer):
    """
    Payload used by POST admin/moderation/{id}/ from the frontend.

    Field:
        remove: if true, the offending content is removed and the report is
                marked as resolved; if false, the content is approved and
                the report is simply resolved.
    """

    remove = serializers.BooleanField()


class AuditLogEntrySerializer(serializers.ModelSerializer):
    """
    Serializer for the canonical audit-log row shape consumed by
    services/audit.ts (LogRow).
    """

    # Frontend expects `entityId`; the model stores `entity_id`.
    entityId = serializers.CharField(source="entity_id", read_only=True)

    class Meta:
        model = AuditLogEntry
        fields = (
            "id",
            "ts",
            "actor",
            "action",
            "target",
            "severity",
            "entity",
            "entityId",
            "ip",
            "status",
            "meta",
        )
        read_only_fields = fields

===== END konnaxion/moderation/serializers.py =====


===== BEGIN konnaxion/static/css/project.css =====
/* These styles are generated from project.scss. */

.alert-debug {
  color: black;
  background-color: white;
  border-color: #d6e9c6;
}

.alert-error {
  color: #b94a48;
  background-color: #f2dede;
  border-color: #eed3d7;
}

===== END konnaxion/static/css/project.css =====


===== BEGIN konnaxion/static/fonts/.gitkeep =====

===== END konnaxion/static/fonts/.gitkeep =====


===== BEGIN konnaxion/static/js/project.js =====
/* Project specific Javascript goes here. */

===== END konnaxion/static/js/project.js =====


===== BEGIN konnaxion/templates/403.html =====
{% extends "base.html" %}

{% block title %}Forbidden (403){% endblock title %}
{% block content %}
  <h1>Forbidden (403)</h1>
  <p>
    {% if exception %}
      {{ exception }}
    {% else %}
      You're not allowed to access this page.
    {% endif %}
  </p>
{% endblock content %}

===== END konnaxion/templates/403.html =====


===== BEGIN konnaxion/templates/403_csrf.html =====
{% extends "base.html" %}

{% block title %}Forbidden (403){% endblock title %}
{% block content %}
  <h1>Forbidden (403)</h1>
  <p>
    {% if exception %}
      {{ exception }}
    {% else %}
      You're not allowed to access this page.
    {% endif %}
  </p>
{% endblock content %}

===== END konnaxion/templates/403_csrf.html =====


===== BEGIN konnaxion/templates/404.html =====
{% extends "base.html" %}

{% block title %}Page not found{% endblock title %}
{% block content %}
  <h1>Page not found</h1>
  <p>
    {% if exception %}
      {{ exception }}
    {% else %}
      This is not the page you were looking for.
    {% endif %}
  </p>
{% endblock content %}

===== END konnaxion/templates/404.html =====


===== BEGIN konnaxion/templates/500.html =====
{% extends "base.html" %}

{% block title %}Server Error{% endblock title %}
{% block content %}
  <h1>Ooops!!! 500</h1>
  <h3>Looks like something went wrong!</h3>
  <p>
    We track these errors automatically, but if the problem persists feel free to contact us. In the meantime, try refreshing.
  </p>
{% endblock content %}

===== END konnaxion/templates/500.html =====


===== BEGIN konnaxion/templates/account/base_manage_password.html =====
{% extends "account/base_manage.html" %}

{% block main %}
  <div class="card">
    <div class="card-body">
      {% block content %}
      {% endblock content %}
    </div>
  </div>
{% endblock main %}


===== END konnaxion/templates/account/base_manage_password.html =====


===== BEGIN konnaxion/templates/allauth/elements/alert.html =====
{% load i18n %}
{% load allauth %}

<div class="alert alert-error">
  {% slot message %}
{% endslot %}
</div>

===== END konnaxion/templates/allauth/elements/alert.html =====


===== BEGIN konnaxion/templates/allauth/elements/badge.html =====
{% load allauth %}

<span class="badge {% if 'success' in attrs.tags %}bg-success{% endif %} {% if 'warning' in attrs.tags %}bg-warning{% endif %} {% if 'secondary' in attrs.tags %}bg-secondary{% endif %} {% if 'danger' in attrs.tags %}bg-danger{% endif %} {% if 'primary' in attrs.tags %}bg-primary{% endif %}">
  {% slot %}
{% endslot %}
</span>

===== END konnaxion/templates/allauth/elements/badge.html =====


===== BEGIN konnaxion/templates/allauth/elements/button.html =====
{% load allauth %}

{% comment %} djlint:off {% endcomment %}
<{% if attrs.href %}a href="{{ attrs.href }}"{% else %}button{% endif %}
                      {% if attrs.form %}form="{{ attrs.form }}"{% endif %}
                      {% if attrs.id %}id="{{ attrs.id }}"{% endif %}
                      {% if attrs.name %}name="{{ attrs.name }}"{% endif %}
                      {% if attrs.type %}type="{{ attrs.type }}"{% endif %}
                      class="btn
{% if 'success' in attrs.tags %}btn-success
{% elif 'warning' in attrs.tags %}btn-warning
{% elif 'secondary' in attrs.tags %}btn-secondary
{% elif 'danger' in attrs.tags %}btn-danger
{% elif 'primary' in attrs.tags %}btn-primary
{% else %}btn-primary
{% endif %}"
>
  {% slot %}
  {% endslot %}
  </{% if attrs.href %}a{% else %}button{% endif %}>

===== END konnaxion/templates/allauth/elements/button.html =====


===== BEGIN konnaxion/templates/allauth/elements/field.html =====
{% load allauth %}
{% load crispy_forms_tags %}

{% if attrs.type == "textarea" %}
  <div class="row mb-3">
    <div class="col-sm-10">
      <label for="{{ attrs.id }}">
        {% slot label %}
      {% endslot %}
    </label>
  </div>
  <textarea {% if attrs.required %}required{% endif %}
            {% if attrs.rows %}rows="{{ attrs.rows }}"{% endif %}
            {% if attrs.disabled %}disabled{% endif %}
            {% if attrs.readonly %}readonly{% endif %}
            {% if attrs.checked %}checked{% endif %}
            {% if attrs.name %}name="{{ attrs.name }}"{% endif %}
            {% if attrs.id %}id="{{ attrs.id }}"{% endif %}
            {% if attrs.placeholder %}placeholder="{{ attrs.placeholder }}"{% endif %}
            class="form-control">{% slot value %}{% endslot %}</textarea>
</div>
{% elif attrs.type == "radio" %}
<div class="row mb-3">
  <div class="col-sm-10">
    <div class="form-check">
      <input {% if attrs.required %}required{% endif %}
             {% if attrs.disabled %}disabled{% endif %}
             {% if attrs.readonly %}readonly{% endif %}
             {% if attrs.checked %}checked{% endif %}
             {% if attrs.name %}name="{{ attrs.name }}"{% endif %}
             {% if attrs.id %}id="{{ attrs.id }}"{% endif %}
             {% if attrs.placeholder %}placeholder="{{ attrs.placeholder }}"{% endif %}
             {% if attrs.autocomplete %}autocomplete="{{ attrs.autocomplete }}"{% endif %}
             value="{{ attrs.value|default_if_none:"" }}"
             type="{{ attrs.type }}" />
      <label class="form-check-label" for="{{ attrs.id }}">
        {% slot label %}
      {% endslot %}
    </label>
  </div>
</div>
</div>
{% else %}
<div class="col-sm-10">
  <label for="{{ attrs.id }}">
    {% slot label %}
  {% endslot %}
</label>
</div>
<div class="col-sm-10">
  <input {% if attrs.required %}required{% endif %}
         {% if attrs.disabled %}disabled{% endif %}
         {% if attrs.readonly %}readonly{% endif %}
         {% if attrs.checked %}checked{% endif %}
         {% if attrs.name %}name="{{ attrs.name }}"{% endif %}
         {% if attrs.id %}id="{{ attrs.id }}"{% endif %}
         {% if attrs.placeholder %}placeholder="{{ attrs.placeholder }}"{% endif %}
         {% if attrs.autocomplete %}autocomplete="{{ attrs.autocomplete }}"{% endif %}
         value="{{ attrs.value|default_if_none:"" }}"
         type="{{ attrs.type }}"
         class="form-control" />
</div>
{% endif %}
{% if slots.help_text %}
  <div class="form-text">{% slot help_text %}{% endslot %}</div>
{% endif %}

===== END konnaxion/templates/allauth/elements/field.html =====


===== BEGIN konnaxion/templates/allauth/elements/fields.html =====
{% load crispy_forms_tags %}

{{ attrs.form|crispy }}

===== END konnaxion/templates/allauth/elements/fields.html =====


===== BEGIN konnaxion/templates/allauth/elements/panel.html =====
{% load allauth %}

<section>
  <div class="card mb-4">
    <div class="card-body">
      <h2 class="card-title">
        {% slot title %}
      {% endslot %}
    </h2>
    {% slot body %}
  {% endslot %}
  {% if slots.actions %}
    <ul>
      {% for action in slots.actions %}<li>{{ action }}</li>{% endfor %}
    </ul>
  {% endif %}
</div>
</div>
</section>

===== END konnaxion/templates/allauth/elements/panel.html =====


===== BEGIN konnaxion/templates/allauth/elements/table.html =====
{% load allauth %}

<table class="table">
  {% slot %}
{% endslot %}
</table>

===== END konnaxion/templates/allauth/elements/table.html =====


===== BEGIN konnaxion/templates/allauth/layouts/entrance.html =====
{% extends "base.html" %}
{% load i18n %}
{% block bodyclass %}bg-light{% endblock bodyclass %}

{% block css %}{{ block.super }}{% endblock css %}
{% block title %}
  {% block head_title %}
    {% trans "Sign In" %}
  {% endblock head_title %}
{% endblock title %}
{% block body %}
  <div class="d-flex justify-content-center h-100 py-4">
    <div class="col-md-4 py-4 my-4 px-4">
      {% if messages %}
        {% for message in messages %}
          <div class="alert alert-dismissible {% if message.tags %}alert-{{ message.tags }}{% endif %}">
            {{ message }}
            <button type="button"
                    class="btn-close"
                    data-bs-dismiss="alert"
                    aria-label="Close"></button>
          </div>
        {% endfor %}
      {% endif %}
      {% block content %}
      {% endblock content %}
      {% block extra_body %}
      {% endblock extra_body %}
    </div>
  </div>
{% endblock body %}

===== END konnaxion/templates/allauth/layouts/entrance.html =====


===== BEGIN konnaxion/templates/allauth/layouts/manage.html =====
{% extends "base.html" %}

{% block main %}
  {% block content %}
  {% endblock content %}
{% endblock main %}

===== END konnaxion/templates/allauth/layouts/manage.html =====


===== BEGIN konnaxion/templates/base.html =====

{% load static i18n %}<!DOCTYPE html>
{% get_current_language as LANGUAGE_CODE %}
<html lang="{{ LANGUAGE_CODE }}">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>
      {% block title %}
      Konnaxion
    {% endblock title %}
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description"
        content="Our Project" />
  <meta name="author"
        content="Rejean McCormick" />
  <link rel="icon" href="{% static 'images/favicons/favicon.ico' %}" />
  {% block css %}
    <!-- Latest compiled and minified Bootstrap CSS -->
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.2.3/css/bootstrap.min.css"
          integrity="sha512-SbiR/eusphKoMVVXysTKG/7VseWii+Y3FdHrt0EpKgpToZeemhqHeZeLWLhJutz/2ut2Vw1uQEj2MbRF+TVBUA=="
          crossorigin="anonymous"
          referrerpolicy="no-referrer" />
<!-- Your stuff: Third-party CSS libraries go here -->
<!-- This file stores project-specific CSS -->

  
  <link href="{% static 'css/project.css' %}" rel="stylesheet" />


{% endblock css %}
<!-- Le javascript
    ================================================== -->
{# Placed at the top of the document so pages load faster with defer #}
{% block javascript %}


<!-- Bootstrap JS -->
<script defer
        src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.2.3/js/bootstrap.min.js"
        integrity="sha512-1/RvZTcCDEUjY/CypiMz+iqqtaoQfAITmNSJY17Myp4Ms5mdxPS5UV7iOfdZoxcGhzFbOm6sntTKJppjvuhg4g=="
        crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
<!-- Your stuff: Third-party javascript libraries go here -->


<!-- place project specific Javascript in this file -->

  
  <script defer src="{% static 'js/project.js' %}"></script>


{% endblock javascript %}
</head>
<body class="{% block bodyclass %}{% endblock bodyclass %}">
  {% block body %}
  <div class="mb-1">
    <nav class="navbar navbar-expand-md navbar-light bg-light">
      <div class="container-fluid">
        <button class="navbar-toggler navbar-toggler-right"
                type="button"
                data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent"
                aria-expanded="false"
                aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <a class="navbar-brand" href="{% url 'home' %}">Konnaxion</a>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item active">
              <a class="nav-link" href="{% url 'home' %}">Home <span class="visually-hidden">(current)</span></a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="{% url 'about' %}">About</a>
            </li>
            {% if request.user.is_authenticated %}
              <li class="nav-item">
                <a class="nav-link"
                   href="{% url 'users:detail' request.user.username %}">{% translate "My Profile" %}</a>
              </li>
              <li class="nav-item">
                {# URL provided by django-allauth/account/urls.py #}
                <a class="nav-link" href="{% url 'account_logout' %}">{% translate "Sign Out" %}</a>
              </li>
            {% else %}
              {% if ACCOUNT_ALLOW_REGISTRATION %}
                <li class="nav-item">
                  {# URL provided by django-allauth/account/urls.py #}
                  <a id="sign-up-link" class="nav-link" href="{% url 'account_signup' %}">{% translate "Sign Up" %}</a>
                </li>
              {% endif %}
              <li class="nav-item">
                {# URL provided by django-allauth/account/urls.py #}
                <a id="log-in-link" class="nav-link" href="{% url 'account_login' %}">{% translate "Sign In" %}</a>
              </li>
            {% endif %}
          </ul>
        </div>
      </div>
    </nav>
  </div>
  <div class="container">
    {% if messages %}
      {% for message in messages %}
        <div class="alert alert-dismissible {% if message.tags %}alert-{{ message.tags }}{% endif %}">
          {{ message }}
          <button type="button"
                  class="btn-close"
                  data-bs-dismiss="alert"
                  aria-label="Close"></button>
        </div>
      {% endfor %}
    {% endif %}
    {% block main %}
      {% block content %}
        <p>Use this document as a way to quick start any new project.</p>
      {% endblock content %}
    {% endblock main %}

  </div>
  {% endblock body %}
  <!-- /container -->
  {% block modal %}
  {% endblock modal %}
  {% block inline_javascript %}
    {% comment %}
    Script tags with only code, no src (defer by default). To run
    with a "defer" so that you run inline code:
    <script>
      window.addEventListener('DOMContentLoaded', () => {
        /* Run whatever you want */
      });
    </script>
    {% endcomment %}
  {% endblock inline_javascript %}
</body>
</html>

===== END konnaxion/templates/base.html =====


===== BEGIN konnaxion/templates/pages/about.html =====
{% extends "base.html" %}



===== END konnaxion/templates/pages/about.html =====


===== BEGIN konnaxion/templates/pages/home.html =====
{% extends "base.html" %}



===== END konnaxion/templates/pages/home.html =====


===== BEGIN konnaxion/templates/users/user_detail.html =====
{% extends "base.html" %}

{% load static %}

{% block title %}
  User: 
  
    {{ object.username }}
  
  
{% endblock title %}
{% block content %}
  <div class="container">
    <div class="row">
      <div class="col-sm-12">
        <h2>
        
        
          {{ object.username }}
        
      </h2>
      {% if object.name %}
        <p>{{ object.name }}</p>
      {% endif %}
    </div>
  </div>
  {% if object == request.user %}
    <!-- Action buttons -->
    <div class="row">
      <div class="col-sm-12">
        <a class="btn btn-primary" href="{% url 'users:update' %}" role="button">My Info</a>
        <a class="btn btn-primary"
           href="{% url 'account_email' %}"
           role="button">E-Mail</a>
        <a class="btn btn-primary"
           href="{% url 'mfa_index' %}"
           role="button">MFA</a>
        <!-- Your Stuff: Custom user template urls -->
      </div>
    </div>
    <!-- End Action buttons -->
  {% endif %}
</div>
{% endblock content %}

===== END konnaxion/templates/users/user_detail.html =====


===== BEGIN konnaxion/templates/users/user_form.html =====
{% extends "base.html" %}

{% load crispy_forms_tags %}

{% block title %}


  {{ user.username }}


{% endblock title %}
{% block content %}
  <h1>
  
  
    {{ user.username }}
  
  
</h1>
<form class="form-horizontal"
      method="post"
      action="{% url 'users:update' %}">
  {% csrf_token %}
  {{ form|crispy }}
  <div class="control-group">
    <div class="controls">
      <button type="submit" class="btn btn-primary">Update</button>
    </div>
  </div>
</form>
{% endblock content %}

===== END konnaxion/templates/users/user_form.html =====


===== BEGIN konnaxion/trust/models.py =====
# konnaxion/trust/models.py
from __future__ import annotations

from django.conf import settings
from django.db import models

__all__ = ["Credential"]


class Credential(models.Model):
    """
    Real‑world credential uploaded by a user for the Trust module.

    This model backs:
      - The Trust credentials UI (Ethikos > Trust > Credentials).
      - The `CredentialSerializer` in `konnaxion/trust/serializers.py`.
    """

    class Status(models.TextChoices):
        # Values and labels are kept identical so the API can safely expose
        # "Pending" | "Verified" | "Rejected" to the frontend.
        PENDING = "Pending", "Pending"
        VERIFIED = "Verified", "Verified"
        REJECTED = "Rejected", "Rejected"

    # Owner of the credential
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="trust_credentials",
        help_text="User who submitted this credential.",
    )

    # Basic metadata
    title = models.CharField(
        max_length=255,
        help_text="Short title, e.g. 'MSc Climate Policy'.",
    )
    issuer = models.CharField(
        max_length=255,
        blank=True,
        help_text="Issuing institution or body.",
    )
    issued_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="When the credential was issued (if known).",
    )

    # Uploaded document (PDF / JPG / PNG, etc.)
    file = models.FileField(
        upload_to="trust/credentials/%Y/%m/%d",
        blank=True,
        null=True,
        help_text="Binary document attached to this credential.",
    )

    # Review state + notes (managed by stewards/admins)
    status = models.CharField(
        max_length=16,
        choices=Status.choices,
        default=Status.PENDING,
        help_text="Review status in the trust workflow.",
    )
    notes = models.TextField(
        blank=True,
        help_text="Optional reviewer notes shown read‑only in the UI.",
    )

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ("-created_at",)
        indexes = [
            models.Index(fields=("user", "status")),
        ]

    def __str__(self) -> str:
        return f"{self.title} ({self.user})"

    # ------------------------------------------------------------------
    # Compatibility alias for serializers
    # ------------------------------------------------------------------
    @property
    def document(self):
        """
        Alias to the underlying `file` field.

        `konnaxion/trust/serializers.py` looks for a `document` attribute
        when building the public URL; exposing this property keeps that
        serializer working without duplicating the storage field.
        """
        return self.file

===== END konnaxion/trust/models.py =====


===== BEGIN konnaxion/trust/serializers.py =====
# backend/konnaxion/trust/serializers.py

from __future__ import annotations

from typing import Optional

from rest_framework import serializers

from .models import Credential

__all__ = ["CredentialSerializer"]


class CredentialSerializer(serializers.ModelSerializer):
    """
    Serializer for user-submitted real‑world credentials used in the Trust module.

    It matches the `Credential` / `CredentialRow` shape used on the frontend:
      - services/trust.ts  → interface Credential
      - app/ethikos/trust/credentials/page.tsx → type CredentialRow
    """

    # Frontend expects `issuedAt` (camelCase), mapped to model field `issued_at`.
    issuedAt = serializers.DateTimeField(
        source="issued_at",
        required=False,
        allow_null=True,
        format=None,  # ISO 8601
    )

    # Upload field: the raw file coming from the client, mapped to the model's
    # FileField (assumed to be named `document`).
    # This is write‑only and is not exposed in responses.
    file = serializers.FileField(
        write_only=True,
        required=True,
        source="document",
    )

    # Public URL to the stored document (built from FileField).
    url = serializers.SerializerMethodField()

    # Human-readable review status ("Verified" | "Pending" | "Rejected").
    status = serializers.SerializerMethodField()

    # Optional reviewer notes; exposed read-only to the end-user.
    notes = serializers.CharField(
        read_only=True,
        allow_blank=True,
        allow_null=True,
    )

    class Meta:
        model = Credential
        fields = (
            "id",
            "title",
            "issuer",
            "issuedAt",
            "url",
            "status",
            "notes",
            "file",  # write-only input for uploads
        )
        read_only_fields = (
            "id",
            "url",
            "status",
            "notes",
        )
        extra_kwargs = {
            "title": {"required": False, "allow_blank": True},
            "issuer": {"required": False, "allow_blank": True},
        }

    # ------------------------------------------------------------------
    # Creation
    # ------------------------------------------------------------------

    def create(self, validated_data: dict) -> Credential:
        """
        Create a new Credential attached to the current user.

        Behaviour:
        - `file` (document) is required.
        - `title` defaults to a cleaned-up version of the filename if omitted.
        - `issuer` is optional, defaults to empty string.
        - `issued_at` is optional and may be null.
        - `status` is initialised as a "pending" value.
        - `notes` is set to a default review message.
        """
        request = self.context.get("request")
        user = getattr(request, "user", None)

        if user is None or not getattr(user, "is_authenticated", False):
            raise serializers.ValidationError(
                {"non_field_errors": ["Authentication required to upload credentials."]}
            )

        # Because `file` is declared with source="document",
        # the validated key here is "document".
        document = validated_data.pop("document", None)
        if document is None:
            raise serializers.ValidationError({"file": ["This field is required."]})

        title: Optional[str] = validated_data.get("title") or None
        issuer: str = (validated_data.get("issuer") or "").strip()
        issued_at = validated_data.get("issued_at")

        # Derive title from filename if not provided
        if not title and getattr(document, "name", None):
            fname = document.name
            base = fname.rsplit(".", 1)[0]
            base = base.replace("_", " ").replace("-", " ").strip()
            title = base or "Untitled credential"

        # Resolve an appropriate "pending" status value.
        status_value = None
        status_enum = getattr(Credential, "Status", None)
        if status_enum is not None and hasattr(status_enum, "PENDING"):
            status_value = status_enum.PENDING
        elif hasattr(Credential, "STATUS_PENDING"):
            status_value = getattr(Credential, "STATUS_PENDING")
        else:
            # Fallback string; the display label will be normalised by get_status()
            status_value = "pending"

        default_notes = getattr(
            Credential,
            "DEFAULT_PENDING_NOTES",
            "Awaiting manual verification",
        )

        credential = Credential.objects.create(
            user=user,
            title=title or "Untitled credential",
            issuer=issuer,
            issued_at=issued_at,
            document=document,
            status=status_value,
            notes=default_notes,
        )
        return credential

    # ------------------------------------------------------------------
    # Computed fields
    # ------------------------------------------------------------------

    def get_url(self, obj: Credential) -> Optional[str]:
        """
        Returns an absolute URL to the uploaded document, if available.

        Prefers a FileField named `document`, but will also fall back to `file`
        if present on the model.
        """
        file_field = getattr(obj, "document", None) or getattr(obj, "file", None)
        if not file_field:
            return None

        try:
            relative_url = file_field.url
        except Exception:
            # File may not exist in storage yet
            return None

        request = self.context.get("request")
        if request is not None:
            return request.build_absolute_uri(relative_url)
        return relative_url

    def get_status(self, obj: Credential) -> Optional[str]:
        """
        Returns a human‑friendly review status string for the UI.

        If the model defines `get_status_display()` (e.g. via Django `choices`),
        that label is used; otherwise, the raw value is title‑cased.
        """
        display = getattr(obj, "get_status_display", None)
        if callable(display):
            return display()

        raw = getattr(obj, "status", None)
        if isinstance(raw, str):
            return raw.replace("_", " ").title()
        return raw

===== END konnaxion/trust/serializers.py =====


===== BEGIN konnaxion/urls.py =====
# konnaxion/urls.py

from django.urls import path, include

urlpatterns = [
    # ...
    path("api/ethikos/", include("konnaxion.ethikos.urls")),
    # ...
]

===== END konnaxion/urls.py =====


===== BEGIN konnaxion/users/__init__.py =====

===== END konnaxion/users/__init__.py =====


===== BEGIN konnaxion/users/adapters.py =====
from __future__ import annotations

import typing

from allauth.account.adapter import DefaultAccountAdapter
from allauth.socialaccount.adapter import DefaultSocialAccountAdapter
from django.conf import settings

if typing.TYPE_CHECKING:
    from allauth.socialaccount.models import SocialLogin
    from django.http import HttpRequest

    from konnaxion.users.models import User


class AccountAdapter(DefaultAccountAdapter):
    def is_open_for_signup(self, request: HttpRequest) -> bool:
        return getattr(settings, "ACCOUNT_ALLOW_REGISTRATION", True)


class SocialAccountAdapter(DefaultSocialAccountAdapter):
    def is_open_for_signup(
        self,
        request: HttpRequest,
        sociallogin: SocialLogin,
    ) -> bool:
        return getattr(settings, "ACCOUNT_ALLOW_REGISTRATION", True)

    def populate_user(
        self,
        request: HttpRequest,
        sociallogin: SocialLogin,
        data: dict[str, typing.Any],
    ) -> User:
        """
        Populates user information from social provider info.

        See: https://docs.allauth.org/en/latest/socialaccount/advanced.html#creating-and-populating-user-instances
        """
        user = super().populate_user(request, sociallogin, data)
        if not user.name:
            if name := data.get("name"):
                user.name = name
            elif first_name := data.get("first_name"):
                user.name = first_name
                if last_name := data.get("last_name"):
                    user.name += f" {last_name}"
        return user

===== END konnaxion/users/adapters.py =====


===== BEGIN konnaxion/users/admin.py =====
# konnaxion/users/admin.py
from allauth.account.decorators import secure_admin_login
from django.conf import settings
from django.contrib import admin
from django.contrib.auth import admin as auth_admin
from django.utils.html import format_html
from django.utils.translation import gettext_lazy as _

from .forms import UserAdminChangeForm, UserAdminCreationForm
from .models import User

if getattr(settings, "DJANGO_ADMIN_FORCE_ALLAUTH", False):
    # Force the `admin` sign-in process to go through django‑allauth.
    admin.autodiscover()
    admin.site.login = secure_admin_login(admin.site.login)  # type: ignore[method-assign]


@admin.register(User)
class UserAdmin(auth_admin.UserAdmin):
    form = UserAdminChangeForm
    add_form = UserAdminCreationForm

    # ---- Avatar helpers (safe even if no avatar field exists yet) ----
    def _avatar_url(self, obj: User) -> str:
        """
        Resolve the best available avatar URL for this user:
        - If a file field exists (avatar_file / avatar / profile_image / image), use its .url.
        - Else if an explicit avatar_url attribute or property exists, use it.
        - Else fall back to the default image in MEDIA: /kreative/artworks/default_profile.png.
        """
        # 1) Common file-field names we may add later
        for fname in ("avatar_file", "avatar", "profile_image", "image"):
            f = getattr(obj, fname, None)
            if f:
                url = getattr(f, "url", None) or str(f)
                if url:
                    return url

        # 2) Optional computed/explicit URL
        candidate = getattr(obj, "avatar_url", None)
        if callable(candidate):
            try:
                candidate = candidate()
            except Exception:
                candidate = None
        if isinstance(candidate, str) and candidate:
            return candidate

        # 3) Default placeholder in MEDIA
        media_url = getattr(settings, "MEDIA_URL", "/media/")
        return f"{media_url.rstrip('/')}/kreative/artworks/default_profile.png"

    @admin.display(description=_("Avatar"))
    def thumbnail(self, obj: User) -> str:
        url = self._avatar_url(obj)
        return format_html(
            '<img src="{}" alt="avatar" style="height:32px;width:32px;'
            "border-radius:50%;object-fit:cover;vertical-align:middle;\"/>",
            url,
        )

    @admin.display(description=_("Preview"))
    def avatar_preview(self, obj: User) -> str:
        url = self._avatar_url(obj)
        return format_html(
            '<img src="{}" alt="avatar preview" style="height:96px;width:96px;'
            'border-radius:50%;object-fit:cover;border:1px solid #e5e5e5;"/>',
            url,
        )

    # ---- Admin layout ----
    fieldsets = (
        (None, {"fields": ("username", "password")}),
        (_("Personal info"), {"fields": ("name", "email")}),
        (_("Profile image"), {"fields": ("avatar_preview",)}),  # read‑only preview
        (
            _("Permissions"),
            {
                "fields": (
                    "is_active",
                    "is_staff",
                    "is_superuser",
                    "groups",
                    "user_permissions",
                ),
            },
        ),
        (_("Important dates"), {"fields": ("last_login", "date_joined")}),
    )
    readonly_fields = ("avatar_preview",)

    list_display = ["thumbnail", "username", "name", "email", "is_staff", "is_superuser"]
    list_filter = ["is_staff", "is_superuser", "is_active", "groups"]
    search_fields = ["username", "name", "email"]
    ordering = ["username"]

===== END konnaxion/users/admin.py =====


===== BEGIN konnaxion/users/api/__init__.py =====

===== END konnaxion/users/api/__init__.py =====


===== BEGIN konnaxion/users/api/serializers.py =====
# backend/konnaxion/users/api/serializers.py

from __future__ import annotations

from urllib.parse import urlparse

from django.conf import settings
from rest_framework import serializers

from konnaxion.users.models import User


# Optional project-level override in settings.py:
# DEFAULT_AVATAR_PATH = "kreative/artworks/default_profile.png"
DEFAULT_AVATAR_PATH = getattr(
    settings, "DEFAULT_AVATAR_PATH", "kreative/artworks/default_profile.png"
)


def _is_absolute(url: str) -> bool:
    try:
        p = urlparse(url)
        return p.scheme in ("http", "https")
    except Exception:
        return False


def _join_media_url(path: str) -> str:
    """
    Join MEDIA_URL and a relative media path into a single URL string.
    Works whether MEDIA_URL is absolute (e.g. https://cdn/...) or relative (/media/).
    """
    base = (settings.MEDIA_URL or "/media/").rstrip("/")
    rel = path.lstrip("/")
    return f"{base}/{rel}"


class UserSerializer(serializers.ModelSerializer[User]):
    # Exposed to the frontend: absolute URL for the user's avatar (or default)
    avatar_url = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = ["username", "name", "url", "avatar_url"]
        extra_kwargs = {
            "url": {"view_name": "api:user-detail", "lookup_field": "username"},
        }

    def get_avatar_url(self, obj: User) -> str:
        """
        Rules:
        - If the User model has an ImageField `avatar` with a URL, use it.
          (If storage returns an absolute URL, return as-is.)
        - Else fall back to DEFAULT_AVATAR_PATH under MEDIA_URL.
        - If `request` is available, return an absolute URL for relative paths.
        """
        request = self.context.get("request")

        # Prefer a real uploaded avatar if present
        avatar = getattr(obj, "avatar", None)
        if avatar is not None and getattr(avatar, "url", None):
            url = avatar.url  # may already be absolute (e.g. S3)
            if _is_absolute(url):
                return url
            return request.build_absolute_uri(url) if request else url

        # Fallback: default image under MEDIA_URL
        fallback_rel = _join_media_url(DEFAULT_AVATAR_PATH)
        if _is_absolute(fallback_rel):
            # MEDIA_URL might be absolute (CDN)
            return fallback_rel
        return request.build_absolute_uri(fallback_rel) if request else fallback_rel

===== END konnaxion/users/api/serializers.py =====


===== BEGIN konnaxion/users/api/urls.py =====
# backend/konnaxion/users/api/urls.py
from rest_framework.routers import DefaultRouter
from .views import UserViewSet

app_name = "users_api"  # distinct namespace to avoid clashing with central "api"
router = DefaultRouter()
router.register(r"", UserViewSet, basename="user")

urlpatterns = router.urls

===== END konnaxion/users/api/urls.py =====


===== BEGIN konnaxion/users/api/views.py =====
from rest_framework import status, permissions
from rest_framework.decorators import action
from rest_framework.mixins import ListModelMixin, RetrieveModelMixin, UpdateModelMixin
from rest_framework.response import Response
from rest_framework.viewsets import GenericViewSet

from konnaxion.users.models import User
from .serializers import UserSerializer


class UserViewSet(RetrieveModelMixin, ListModelMixin, UpdateModelMixin, GenericViewSet):
    """
    /api/users/           → list (current user only)
    /api/users/{username}/ → retrieve
    /api/users/me/        → current user (explicit)
    """
    serializer_class = UserSerializer
    queryset = User.objects.all()
    lookup_field = "username"
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        """
        Limit list queries to the authenticated user.
        """
        user = self.request.user
        if not getattr(user, "is_authenticated", False):
            return User.objects.none()
        return self.queryset.filter(id=user.id)

    @action(detail=False, methods=["get"], url_path="me", url_name="me")
    def me(self, request):
        """
        Return the authenticated user's own record using the same serializer,
        so fields like `avatar_url` can build an absolute URL from `request`.
        """
        serializer = self.get_serializer(request.user, context={"request": request})
        return Response(serializer.data, status=status.HTTP_200_OK)

===== END konnaxion/users/api/views.py =====


===== BEGIN konnaxion/users/apps.py =====
import contextlib

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class UsersConfig(AppConfig):
    name = "konnaxion.users"
    verbose_name = _("Users")

    def ready(self):
        with contextlib.suppress(ImportError):
            import konnaxion.users.signals  # noqa: F401

===== END konnaxion/users/apps.py =====


===== BEGIN konnaxion/users/context_processors.py =====
from django.conf import settings


def allauth_settings(request):
    """Expose some settings from django-allauth in templates."""
    return {
        "ACCOUNT_ALLOW_REGISTRATION": settings.ACCOUNT_ALLOW_REGISTRATION,
    }

===== END konnaxion/users/context_processors.py =====


===== BEGIN konnaxion/users/forms.py =====
from allauth.account.forms import SignupForm
from allauth.socialaccount.forms import SignupForm as SocialSignupForm
from django.contrib.auth import forms as admin_forms
from django.utils.translation import gettext_lazy as _

from .models import User


class UserAdminChangeForm(admin_forms.UserChangeForm):
    class Meta(admin_forms.UserChangeForm.Meta):  # type: ignore[name-defined]
        model = User


class UserAdminCreationForm(admin_forms.AdminUserCreationForm):
    """
    Form for User Creation in the Admin Area.
    To change user signup, see UserSignupForm and UserSocialSignupForm.
    """

    class Meta(admin_forms.UserCreationForm.Meta):  # type: ignore[name-defined]
        model = User
        error_messages = {
            "username": {"unique": _("This username has already been taken.")},
        }


class UserSignupForm(SignupForm):
    """
    Form that will be rendered on a user sign up section/screen.
    Default fields will be added automatically.
    Check UserSocialSignupForm for accounts created from social.
    """


class UserSocialSignupForm(SocialSignupForm):
    """
    Renders the form when user has signed up using social accounts.
    Default fields will be added automatically.
    See UserSignupForm otherwise.
    """

===== END konnaxion/users/forms.py =====


===== BEGIN konnaxion/users/models.py =====
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.db.models import CharField
from django.urls import reverse
from django.utils.translation import gettext_lazy as _


class User(AbstractUser):
    """
    Default custom user model for Konnaxion.
    If adding fields that need to be filled at user signup,
    check forms.SignupForm and forms.SocialSignupForms accordingly.
    """

    # First and last name do not cover name patterns around the globe
    name = CharField(_("Name of User"), blank=True, max_length=255)
    first_name = None  # type: ignore[assignment]
    last_name = None  # type: ignore[assignment]

    # Chosen artwork used as this user's profile picture
    profile_artwork = models.ForeignKey(
        "kreative.KreativeArtwork",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="users_using_as_profile",
    )

    def get_absolute_url(self) -> str:
        """Get URL for user's detail view.

        Returns:
            str: URL for user detail.

        """
        return reverse("users:detail", kwargs={"username": self.username})

===== END konnaxion/users/models.py =====


===== BEGIN konnaxion/users/tasks.py =====
from celery import shared_task

from .models import User


@shared_task()
def get_users_count():
    """A pointless Celery task to demonstrate usage."""
    return User.objects.count()

===== END konnaxion/users/tasks.py =====


===== BEGIN konnaxion/users/urls.py =====
from django.urls import path

from .views import user_detail_view
from .views import user_redirect_view
from .views import user_update_view

app_name = "users"
urlpatterns = [
    path("~redirect/", view=user_redirect_view, name="redirect"),
    path("~update/", view=user_update_view, name="update"),
    path("<str:username>/", view=user_detail_view, name="detail"),
]

===== END konnaxion/users/urls.py =====


===== BEGIN konnaxion/users/views.py =====
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.messages.views import SuccessMessageMixin
from django.db.models import QuerySet
from django.urls import reverse
from django.utils.translation import gettext_lazy as _
from django.views.generic import DetailView
from django.views.generic import RedirectView
from django.views.generic import UpdateView

from konnaxion.users.models import User


class UserDetailView(LoginRequiredMixin, DetailView):
    model = User
    slug_field = "username"
    slug_url_kwarg = "username"


user_detail_view = UserDetailView.as_view()


class UserUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = User
    fields = ["name"]
    success_message = _("Information successfully updated")

    def get_success_url(self) -> str:
        assert self.request.user.is_authenticated  # type guard
        return self.request.user.get_absolute_url()

    def get_object(self, queryset: QuerySet | None=None) -> User:
        assert self.request.user.is_authenticated  # type guard
        return self.request.user


user_update_view = UserUpdateView.as_view()


class UserRedirectView(LoginRequiredMixin, RedirectView):
    permanent = False

    def get_redirect_url(self) -> str:
        return reverse("users:detail", kwargs={"username": self.request.user.username})


user_redirect_view = UserRedirectView.as_view()

===== END konnaxion/users/views.py =====

