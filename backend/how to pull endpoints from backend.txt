Use the same dev stack, then hit the schema endpoint with auth.

**1) Start the backend**

```bash
# from the backend/ folder
docker compose -f docker-compose.local.yml up -d
# check it came up on :8000
docker compose -f docker-compose.local.yml ps
docker logs -f konnaxion_local_django   # optional
```

Port 8000 is published by the `django` service and the app entrypoint is `/start`.  

**2) Authenticate (required by defaults)**
By default, all API views, including the schema view, require authentication. Swagger UI is admin‑only. 
Create a superuser and get a token:

```bash
# create an admin user
docker compose -f docker-compose.local.yml exec django python manage.py createsuperuser

# get a DRF token
curl -s -X POST http://localhost:8000/api/auth-token/ \
  -H "Content-Type: application/json" \
  -d '{"username":"<your_user>","password":"<your_pass>"}'
# → {"token":"<TOKEN>"}
```

The `auth-token` endpoint is mounted at `/api/auth-token/`. 

**3) Pull the current OpenAPI JSON**

```bash
TOKEN=<paste token>
curl -s "http://localhost:8000/api/schema/?format=json" \
  -H "Authorization: Token $TOKEN" \
  -o schema.json
```

The schema view lives at `/api/schema/` and is wired in `config/urls.py`. The schema includes only `/api/...` routes due to `SCHEMA_PATH_PREFIX="/api/"`.  

**4) List the endpoints quickly (optional)**

```bash
# requires jq
jq -r '.paths | keys[]' schema.json | sort
```

**Notes**

* You can also view Swagger UI at `http://localhost:8000/api/docs/` after logging in as an admin; anonymous users get 403 by design.  
* The API router mounts under `/api/` and registers modules like users and ethiKos; that’s what the schema will expose. 
* If you prefer running without Docker, `manage.py` defaults to `config.settings.local`; run `python manage.py runserver 0.0.0.0:8000` with a working Postgres/Redis in your env. 

This sequence reproduces your “pull current endpoints” check against `http://localhost:8000/api/schema/?format=json` exactly as the project is configured.
